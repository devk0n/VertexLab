# 0 "/home/devkon/CLionProjects/VertexLab/main.cpp"
# 1 "/home/devkon/CLionProjects/VertexLab/cmake-build-debug//"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 0 "<command-line>" 2
# 1 "/home/devkon/CLionProjects/VertexLab/main.cpp"
# 1 "/usr/include/GL/glew.h" 1 3 4
# 224 "/usr/include/GL/glew.h" 3 4
# 1 "/usr/include/c++/14.2.1/cstddef" 1 3 4
# 42 "/usr/include/c++/14.2.1/cstddef" 3 4
       
# 43 "/usr/include/c++/14.2.1/cstddef" 3






# 1 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 1 3
# 33 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 3
       
# 34 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 3
# 308 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 3

# 308 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 3
namespace std
{
  typedef long unsigned int size_t;
  typedef long int ptrdiff_t;


  typedef decltype(nullptr) nullptr_t;


#pragma GCC visibility push(default)


  extern "C++" __attribute__ ((__noreturn__, __always_inline__))
  inline void __terminate() noexcept
  {
    void terminate() noexcept __attribute__ ((__noreturn__,__cold__));
    terminate();
  }
#pragma GCC visibility pop
}
# 341 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 3
namespace std
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
namespace __gnu_cxx
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
# 534 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 3
namespace std
{
#pragma GCC visibility push(default)




  __attribute__((__always_inline__))
  constexpr inline bool
  __is_constant_evaluated() noexcept
  {





    return __builtin_is_constant_evaluated();



  }
#pragma GCC visibility pop
}
# 573 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 3
namespace std
{
#pragma GCC visibility push(default)

  extern "C++" __attribute__ ((__noreturn__))
  void
  __glibcxx_assert_fail
    (const char* __file, int __line, const char* __function,
     const char* __condition)
  noexcept;
#pragma GCC visibility pop
}
# 601 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 3
namespace std
{
  __attribute__((__always_inline__,__visibility__("default")))
  inline void
  __glibcxx_assert_fail()
  { }
}
# 680 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 3
# 1 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/os_defines.h" 1 3
# 39 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/os_defines.h" 3
# 1 "/usr/include/features.h" 1 3 4
# 402 "/usr/include/features.h" 3 4
# 1 "/usr/include/features-time64.h" 1 3 4
# 20 "/usr/include/features-time64.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 21 "/usr/include/features-time64.h" 2 3 4
# 1 "/usr/include/bits/timesize.h" 1 3 4
# 19 "/usr/include/bits/timesize.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 20 "/usr/include/bits/timesize.h" 2 3 4
# 22 "/usr/include/features-time64.h" 2 3 4
# 403 "/usr/include/features.h" 2 3 4
# 511 "/usr/include/features.h" 3 4
# 1 "/usr/include/sys/cdefs.h" 1 3 4
# 730 "/usr/include/sys/cdefs.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 731 "/usr/include/sys/cdefs.h" 2 3 4
# 1 "/usr/include/bits/long-double.h" 1 3 4
# 732 "/usr/include/sys/cdefs.h" 2 3 4
# 512 "/usr/include/features.h" 2 3 4
# 535 "/usr/include/features.h" 3 4
# 1 "/usr/include/gnu/stubs.h" 1 3 4
# 10 "/usr/include/gnu/stubs.h" 3 4
# 1 "/usr/include/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/gnu/stubs.h" 2 3 4
# 536 "/usr/include/features.h" 2 3 4
# 40 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/os_defines.h" 2 3
# 681 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 2 3


# 1 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/cpu_defines.h" 1 3
# 684 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 2 3
# 825 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 3
namespace __gnu_cxx
{
  typedef __decltype(0.0bf16) __bfloat16_t;
}
# 887 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 3
# 1 "/usr/include/c++/14.2.1/pstl/pstl_config.h" 1 3
# 888 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/c++config.h" 2 3
# 50 "/usr/include/c++/14.2.1/cstddef" 2 3
# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/stddef.h" 1 3 4
# 145 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 214 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 425 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
# 436 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/stddef.h" 3 4
} max_align_t;






  typedef decltype(nullptr) nullptr_t;
# 51 "/usr/include/c++/14.2.1/cstddef" 2 3


# 1 "/usr/include/c++/14.2.1/bits/version.h" 1 3
# 47 "/usr/include/c++/14.2.1/bits/version.h" 3
       
# 48 "/usr/include/c++/14.2.1/bits/version.h" 3
# 54 "/usr/include/c++/14.2.1/cstddef" 2 3

extern "C++"
{

namespace std
{

  using ::max_align_t;
}



namespace std
{


  enum class byte : unsigned char {};

  template<typename _IntegerType> struct __byte_operand { };
  template<> struct __byte_operand<bool> { using __type = byte; };
  template<> struct __byte_operand<char> { using __type = byte; };
  template<> struct __byte_operand<signed char> { using __type = byte; };
  template<> struct __byte_operand<unsigned char> { using __type = byte; };
  template<> struct __byte_operand<wchar_t> { using __type = byte; };

  template<> struct __byte_operand<char8_t> { using __type = byte; };

  template<> struct __byte_operand<char16_t> { using __type = byte; };
  template<> struct __byte_operand<char32_t> { using __type = byte; };
  template<> struct __byte_operand<short> { using __type = byte; };
  template<> struct __byte_operand<unsigned short> { using __type = byte; };
  template<> struct __byte_operand<int> { using __type = byte; };
  template<> struct __byte_operand<unsigned int> { using __type = byte; };
  template<> struct __byte_operand<long> { using __type = byte; };
  template<> struct __byte_operand<unsigned long> { using __type = byte; };
  template<> struct __byte_operand<long long> { using __type = byte; };
  template<> struct __byte_operand<unsigned long long> { using __type = byte; };

  template<> struct __byte_operand<__int128>
  { using __type = byte; };
  template<> struct __byte_operand<unsigned __int128>
  { using __type = byte; };
# 109 "/usr/include/c++/14.2.1/cstddef" 3
  template<typename _IntegerType>
    struct __byte_operand<const _IntegerType>
    : __byte_operand<_IntegerType> { };
  template<typename _IntegerType>
    struct __byte_operand<volatile _IntegerType>
    : __byte_operand<_IntegerType> { };
  template<typename _IntegerType>
    struct __byte_operand<const volatile _IntegerType>
    : __byte_operand<_IntegerType> { };

  template<typename _IntegerType>
    using __byte_op_t = typename __byte_operand<_IntegerType>::__type;

  template<typename _IntegerType>
    [[__gnu__::__always_inline__]]
    constexpr __byte_op_t<_IntegerType>
    operator<<(byte __b, _IntegerType __shift) noexcept
    { return (byte)(unsigned char)((unsigned)__b << __shift); }

  template<typename _IntegerType>
    [[__gnu__::__always_inline__]]
    constexpr __byte_op_t<_IntegerType>
    operator>>(byte __b, _IntegerType __shift) noexcept
    { return (byte)(unsigned char)((unsigned)__b >> __shift); }

  [[__gnu__::__always_inline__]]
  constexpr byte
  operator|(byte __l, byte __r) noexcept
  { return (byte)(unsigned char)((unsigned)__l | (unsigned)__r); }

  [[__gnu__::__always_inline__]]
  constexpr byte
  operator&(byte __l, byte __r) noexcept
  { return (byte)(unsigned char)((unsigned)__l & (unsigned)__r); }

  [[__gnu__::__always_inline__]]
  constexpr byte
  operator^(byte __l, byte __r) noexcept
  { return (byte)(unsigned char)((unsigned)__l ^ (unsigned)__r); }

  [[__gnu__::__always_inline__]]
  constexpr byte
  operator~(byte __b) noexcept
  { return (byte)(unsigned char)~(unsigned)__b; }

  template<typename _IntegerType>
    [[__gnu__::__always_inline__]]
    constexpr __byte_op_t<_IntegerType>&
    operator<<=(byte& __b, _IntegerType __shift) noexcept
    { return __b = __b << __shift; }

  template<typename _IntegerType>
    [[__gnu__::__always_inline__]]
    constexpr __byte_op_t<_IntegerType>&
    operator>>=(byte& __b, _IntegerType __shift) noexcept
    { return __b = __b >> __shift; }

  [[__gnu__::__always_inline__]]
  constexpr byte&
  operator|=(byte& __l, byte __r) noexcept
  { return __l = __l | __r; }

  [[__gnu__::__always_inline__]]
  constexpr byte&
  operator&=(byte& __l, byte __r) noexcept
  { return __l = __l & __r; }

  [[__gnu__::__always_inline__]]
  constexpr byte&
  operator^=(byte& __l, byte __r) noexcept
  { return __l = __l ^ __r; }

  template<typename _IntegerType>
    [[nodiscard,__gnu__::__always_inline__]]
    constexpr _IntegerType
    to_integer(__byte_op_t<_IntegerType> __b) noexcept
    { return _IntegerType(__b); }


}

}
# 225 "/usr/include/GL/glew.h" 2 3 4
# 1 "/usr/include/c++/14.2.1/cstdint" 1 3 4
# 32 "/usr/include/c++/14.2.1/cstdint" 3 4
       
# 33 "/usr/include/c++/14.2.1/cstdint" 3
# 45 "/usr/include/c++/14.2.1/cstdint" 3
# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/stdint.h" 1 3 4
# 9 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/stdint.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/bits/types.h" 1 3 4
# 27 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 28 "/usr/include/bits/types.h" 2 3 4
# 1 "/usr/include/bits/timesize.h" 1 3 4
# 19 "/usr/include/bits/timesize.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 20 "/usr/include/bits/timesize.h" 2 3 4
# 29 "/usr/include/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;






typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;



typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 141 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/typesizes.h" 1 3 4
# 142 "/usr/include/bits/types.h" 2 3 4
# 1 "/usr/include/bits/time64.h" 1 3 4
# 143 "/usr/include/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;
typedef long int __suseconds64_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 28 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/bits/wchar.h" 1 3 4
# 29 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 30 "/usr/include/stdint.h" 2 3 4




# 1 "/usr/include/bits/stdint-intn.h" 1 3 4
# 24 "/usr/include/bits/stdint-intn.h" 3 4
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
# 35 "/usr/include/stdint.h" 2 3 4


# 1 "/usr/include/bits/stdint-uintn.h" 1 3 4
# 24 "/usr/include/bits/stdint-uintn.h" 3 4
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
# 38 "/usr/include/stdint.h" 2 3 4



# 1 "/usr/include/bits/stdint-least.h" 1 3 4
# 25 "/usr/include/bits/stdint-least.h" 3 4
typedef __int_least8_t int_least8_t;
typedef __int_least16_t int_least16_t;
typedef __int_least32_t int_least32_t;
typedef __int_least64_t int_least64_t;


typedef __uint_least8_t uint_least8_t;
typedef __uint_least16_t uint_least16_t;
typedef __uint_least32_t uint_least32_t;
typedef __uint_least64_t uint_least64_t;
# 42 "/usr/include/stdint.h" 2 3 4





typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 60 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 76 "/usr/include/stdint.h" 3 4
typedef long int intptr_t;


typedef unsigned long int uintptr_t;
# 90 "/usr/include/stdint.h" 3 4
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
# 10 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/stdint.h" 2 3 4
# 46 "/usr/include/c++/14.2.1/cstdint" 2 3


namespace std
{

  using ::int8_t;
  using ::int16_t;
  using ::int32_t;
  using ::int64_t;

  using ::int_fast8_t;
  using ::int_fast16_t;
  using ::int_fast32_t;
  using ::int_fast64_t;

  using ::int_least8_t;
  using ::int_least16_t;
  using ::int_least32_t;
  using ::int_least64_t;

  using ::intmax_t;
  using ::intptr_t;

  using ::uint8_t;
  using ::uint16_t;
  using ::uint32_t;
  using ::uint64_t;

  using ::uint_fast8_t;
  using ::uint_fast16_t;
  using ::uint_fast32_t;
  using ::uint_fast64_t;

  using ::uint_least8_t;
  using ::uint_least16_t;
  using ::uint_least32_t;
  using ::uint_least64_t;

  using ::uintmax_t;
  using ::uintptr_t;
# 142 "/usr/include/c++/14.2.1/cstdint" 3
}
# 226 "/usr/include/GL/glew.h" 2 3 4
# 282 "/usr/include/GL/glew.h" 3 4
extern "C" {







typedef unsigned int GLenum;
typedef unsigned int GLbitfield;
typedef unsigned int GLuint;
typedef int GLint;
typedef int GLsizei;
typedef unsigned char GLboolean;
typedef signed char GLbyte;
typedef short GLshort;
typedef unsigned char GLubyte;
typedef unsigned short GLushort;
typedef unsigned long GLulong;
typedef float GLfloat;
typedef float GLclampf;
typedef double GLdouble;
typedef double GLclampd;
typedef void GLvoid;
# 316 "/usr/include/GL/glew.h" 3 4
typedef int64_t GLint64EXT;
typedef uint64_t GLuint64EXT;

typedef GLint64EXT GLint64;
typedef GLuint64EXT GLuint64;
typedef struct __GLsync *GLsync;

typedef char GLchar;

typedef void *GLeglImageOES;
# 862 "/usr/include/GL/glew.h" 3 4
extern void glAccum (GLenum op, GLfloat value);
extern void glAlphaFunc (GLenum func, GLclampf ref);
extern GLboolean glAreTexturesResident (GLsizei n, const GLuint *textures, GLboolean *residences);
extern void glArrayElement (GLint i);
extern void glBegin (GLenum mode);
extern void glBindTexture (GLenum target, GLuint texture);
extern void glBitmap (GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap);
extern void glBlendFunc (GLenum sfactor, GLenum dfactor);
extern void glCallList (GLuint list);
extern void glCallLists (GLsizei n, GLenum type, const void *lists);
extern void glClear (GLbitfield mask);
extern void glClearAccum (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
extern void glClearColor (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
extern void glClearDepth (GLclampd depth);
extern void glClearIndex (GLfloat c);
extern void glClearStencil (GLint s);
extern void glClipPlane (GLenum plane, const GLdouble *equation);
extern void glColor3b (GLbyte red, GLbyte green, GLbyte blue);
extern void glColor3bv (const GLbyte *v);
extern void glColor3d (GLdouble red, GLdouble green, GLdouble blue);
extern void glColor3dv (const GLdouble *v);
extern void glColor3f (GLfloat red, GLfloat green, GLfloat blue);
extern void glColor3fv (const GLfloat *v);
extern void glColor3i (GLint red, GLint green, GLint blue);
extern void glColor3iv (const GLint *v);
extern void glColor3s (GLshort red, GLshort green, GLshort blue);
extern void glColor3sv (const GLshort *v);
extern void glColor3ub (GLubyte red, GLubyte green, GLubyte blue);
extern void glColor3ubv (const GLubyte *v);
extern void glColor3ui (GLuint red, GLuint green, GLuint blue);
extern void glColor3uiv (const GLuint *v);
extern void glColor3us (GLushort red, GLushort green, GLushort blue);
extern void glColor3usv (const GLushort *v);
extern void glColor4b (GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha);
extern void glColor4bv (const GLbyte *v);
extern void glColor4d (GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha);
extern void glColor4dv (const GLdouble *v);
extern void glColor4f (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
extern void glColor4fv (const GLfloat *v);
extern void glColor4i (GLint red, GLint green, GLint blue, GLint alpha);
extern void glColor4iv (const GLint *v);
extern void glColor4s (GLshort red, GLshort green, GLshort blue, GLshort alpha);
extern void glColor4sv (const GLshort *v);
extern void glColor4ub (GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha);
extern void glColor4ubv (const GLubyte *v);
extern void glColor4ui (GLuint red, GLuint green, GLuint blue, GLuint alpha);
extern void glColor4uiv (const GLuint *v);
extern void glColor4us (GLushort red, GLushort green, GLushort blue, GLushort alpha);
extern void glColor4usv (const GLushort *v);
extern void glColorMask (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
extern void glColorMaterial (GLenum face, GLenum mode);
extern void glColorPointer (GLint size, GLenum type, GLsizei stride, const void *pointer);
extern void glCopyPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum type);
extern void glCopyTexImage1D (GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLint border);
extern void glCopyTexImage2D (GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
extern void glCopyTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
extern void glCopyTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
extern void glCullFace (GLenum mode);
extern void glDeleteLists (GLuint list, GLsizei range);
extern void glDeleteTextures (GLsizei n, const GLuint *textures);
extern void glDepthFunc (GLenum func);
extern void glDepthMask (GLboolean flag);
extern void glDepthRange (GLclampd zNear, GLclampd zFar);
extern void glDisable (GLenum cap);
extern void glDisableClientState (GLenum array);
extern void glDrawArrays (GLenum mode, GLint first, GLsizei count);
extern void glDrawBuffer (GLenum mode);
extern void glDrawElements (GLenum mode, GLsizei count, GLenum type, const void *indices);
extern void glDrawPixels (GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
extern void glEdgeFlag (GLboolean flag);
extern void glEdgeFlagPointer (GLsizei stride, const void *pointer);
extern void glEdgeFlagv (const GLboolean *flag);
extern void glEnable (GLenum cap);
extern void glEnableClientState (GLenum array);
extern void glEnd (void);
extern void glEndList (void);
extern void glEvalCoord1d (GLdouble u);
extern void glEvalCoord1dv (const GLdouble *u);
extern void glEvalCoord1f (GLfloat u);
extern void glEvalCoord1fv (const GLfloat *u);
extern void glEvalCoord2d (GLdouble u, GLdouble v);
extern void glEvalCoord2dv (const GLdouble *u);
extern void glEvalCoord2f (GLfloat u, GLfloat v);
extern void glEvalCoord2fv (const GLfloat *u);
extern void glEvalMesh1 (GLenum mode, GLint i1, GLint i2);
extern void glEvalMesh2 (GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2);
extern void glEvalPoint1 (GLint i);
extern void glEvalPoint2 (GLint i, GLint j);
extern void glFeedbackBuffer (GLsizei size, GLenum type, GLfloat *buffer);
extern void glFinish (void);
extern void glFlush (void);
extern void glFogf (GLenum pname, GLfloat param);
extern void glFogfv (GLenum pname, const GLfloat *params);
extern void glFogi (GLenum pname, GLint param);
extern void glFogiv (GLenum pname, const GLint *params);
extern void glFrontFace (GLenum mode);
extern void glFrustum (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
extern GLuint glGenLists (GLsizei range);
extern void glGenTextures (GLsizei n, GLuint *textures);
extern void glGetBooleanv (GLenum pname, GLboolean *params);
extern void glGetClipPlane (GLenum plane, GLdouble *equation);
extern void glGetDoublev (GLenum pname, GLdouble *params);
extern GLenum glGetError (void);
extern void glGetFloatv (GLenum pname, GLfloat *params);
extern void glGetIntegerv (GLenum pname, GLint *params);
extern void glGetLightfv (GLenum light, GLenum pname, GLfloat *params);
extern void glGetLightiv (GLenum light, GLenum pname, GLint *params);
extern void glGetMapdv (GLenum target, GLenum query, GLdouble *v);
extern void glGetMapfv (GLenum target, GLenum query, GLfloat *v);
extern void glGetMapiv (GLenum target, GLenum query, GLint *v);
extern void glGetMaterialfv (GLenum face, GLenum pname, GLfloat *params);
extern void glGetMaterialiv (GLenum face, GLenum pname, GLint *params);
extern void glGetPixelMapfv (GLenum map, GLfloat *values);
extern void glGetPixelMapuiv (GLenum map, GLuint *values);
extern void glGetPixelMapusv (GLenum map, GLushort *values);
extern void glGetPointerv (GLenum pname, void* *params);
extern void glGetPolygonStipple (GLubyte *mask);
extern const GLubyte * glGetString (GLenum name);
extern void glGetTexEnvfv (GLenum target, GLenum pname, GLfloat *params);
extern void glGetTexEnviv (GLenum target, GLenum pname, GLint *params);
extern void glGetTexGendv (GLenum coord, GLenum pname, GLdouble *params);
extern void glGetTexGenfv (GLenum coord, GLenum pname, GLfloat *params);
extern void glGetTexGeniv (GLenum coord, GLenum pname, GLint *params);
extern void glGetTexImage (GLenum target, GLint level, GLenum format, GLenum type, void *pixels);
extern void glGetTexLevelParameterfv (GLenum target, GLint level, GLenum pname, GLfloat *params);
extern void glGetTexLevelParameteriv (GLenum target, GLint level, GLenum pname, GLint *params);
extern void glGetTexParameterfv (GLenum target, GLenum pname, GLfloat *params);
extern void glGetTexParameteriv (GLenum target, GLenum pname, GLint *params);
extern void glHint (GLenum target, GLenum mode);
extern void glIndexMask (GLuint mask);
extern void glIndexPointer (GLenum type, GLsizei stride, const void *pointer);
extern void glIndexd (GLdouble c);
extern void glIndexdv (const GLdouble *c);
extern void glIndexf (GLfloat c);
extern void glIndexfv (const GLfloat *c);
extern void glIndexi (GLint c);
extern void glIndexiv (const GLint *c);
extern void glIndexs (GLshort c);
extern void glIndexsv (const GLshort *c);
extern void glIndexub (GLubyte c);
extern void glIndexubv (const GLubyte *c);
extern void glInitNames (void);
extern void glInterleavedArrays (GLenum format, GLsizei stride, const void *pointer);
extern GLboolean glIsEnabled (GLenum cap);
extern GLboolean glIsList (GLuint list);
extern GLboolean glIsTexture (GLuint texture);
extern void glLightModelf (GLenum pname, GLfloat param);
extern void glLightModelfv (GLenum pname, const GLfloat *params);
extern void glLightModeli (GLenum pname, GLint param);
extern void glLightModeliv (GLenum pname, const GLint *params);
extern void glLightf (GLenum light, GLenum pname, GLfloat param);
extern void glLightfv (GLenum light, GLenum pname, const GLfloat *params);
extern void glLighti (GLenum light, GLenum pname, GLint param);
extern void glLightiv (GLenum light, GLenum pname, const GLint *params);
extern void glLineStipple (GLint factor, GLushort pattern);
extern void glLineWidth (GLfloat width);
extern void glListBase (GLuint base);
extern void glLoadIdentity (void);
extern void glLoadMatrixd (const GLdouble *m);
extern void glLoadMatrixf (const GLfloat *m);
extern void glLoadName (GLuint name);
extern void glLogicOp (GLenum opcode);
extern void glMap1d (GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points);
extern void glMap1f (GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points);
extern void glMap2d (GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points);
extern void glMap2f (GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points);
extern void glMapGrid1d (GLint un, GLdouble u1, GLdouble u2);
extern void glMapGrid1f (GLint un, GLfloat u1, GLfloat u2);
extern void glMapGrid2d (GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2);
extern void glMapGrid2f (GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2);
extern void glMaterialf (GLenum face, GLenum pname, GLfloat param);
extern void glMaterialfv (GLenum face, GLenum pname, const GLfloat *params);
extern void glMateriali (GLenum face, GLenum pname, GLint param);
extern void glMaterialiv (GLenum face, GLenum pname, const GLint *params);
extern void glMatrixMode (GLenum mode);
extern void glMultMatrixd (const GLdouble *m);
extern void glMultMatrixf (const GLfloat *m);
extern void glNewList (GLuint list, GLenum mode);
extern void glNormal3b (GLbyte nx, GLbyte ny, GLbyte nz);
extern void glNormal3bv (const GLbyte *v);
extern void glNormal3d (GLdouble nx, GLdouble ny, GLdouble nz);
extern void glNormal3dv (const GLdouble *v);
extern void glNormal3f (GLfloat nx, GLfloat ny, GLfloat nz);
extern void glNormal3fv (const GLfloat *v);
extern void glNormal3i (GLint nx, GLint ny, GLint nz);
extern void glNormal3iv (const GLint *v);
extern void glNormal3s (GLshort nx, GLshort ny, GLshort nz);
extern void glNormal3sv (const GLshort *v);
extern void glNormalPointer (GLenum type, GLsizei stride, const void *pointer);
extern void glOrtho (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
extern void glPassThrough (GLfloat token);
extern void glPixelMapfv (GLenum map, GLsizei mapsize, const GLfloat *values);
extern void glPixelMapuiv (GLenum map, GLsizei mapsize, const GLuint *values);
extern void glPixelMapusv (GLenum map, GLsizei mapsize, const GLushort *values);
extern void glPixelStoref (GLenum pname, GLfloat param);
extern void glPixelStorei (GLenum pname, GLint param);
extern void glPixelTransferf (GLenum pname, GLfloat param);
extern void glPixelTransferi (GLenum pname, GLint param);
extern void glPixelZoom (GLfloat xfactor, GLfloat yfactor);
extern void glPointSize (GLfloat size);
extern void glPolygonMode (GLenum face, GLenum mode);
extern void glPolygonOffset (GLfloat factor, GLfloat units);
extern void glPolygonStipple (const GLubyte *mask);
extern void glPopAttrib (void);
extern void glPopClientAttrib (void);
extern void glPopMatrix (void);
extern void glPopName (void);
extern void glPrioritizeTextures (GLsizei n, const GLuint *textures, const GLclampf *priorities);
extern void glPushAttrib (GLbitfield mask);
extern void glPushClientAttrib (GLbitfield mask);
extern void glPushMatrix (void);
extern void glPushName (GLuint name);
extern void glRasterPos2d (GLdouble x, GLdouble y);
extern void glRasterPos2dv (const GLdouble *v);
extern void glRasterPos2f (GLfloat x, GLfloat y);
extern void glRasterPos2fv (const GLfloat *v);
extern void glRasterPos2i (GLint x, GLint y);
extern void glRasterPos2iv (const GLint *v);
extern void glRasterPos2s (GLshort x, GLshort y);
extern void glRasterPos2sv (const GLshort *v);
extern void glRasterPos3d (GLdouble x, GLdouble y, GLdouble z);
extern void glRasterPos3dv (const GLdouble *v);
extern void glRasterPos3f (GLfloat x, GLfloat y, GLfloat z);
extern void glRasterPos3fv (const GLfloat *v);
extern void glRasterPos3i (GLint x, GLint y, GLint z);
extern void glRasterPos3iv (const GLint *v);
extern void glRasterPos3s (GLshort x, GLshort y, GLshort z);
extern void glRasterPos3sv (const GLshort *v);
extern void glRasterPos4d (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern void glRasterPos4dv (const GLdouble *v);
extern void glRasterPos4f (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern void glRasterPos4fv (const GLfloat *v);
extern void glRasterPos4i (GLint x, GLint y, GLint z, GLint w);
extern void glRasterPos4iv (const GLint *v);
extern void glRasterPos4s (GLshort x, GLshort y, GLshort z, GLshort w);
extern void glRasterPos4sv (const GLshort *v);
extern void glReadBuffer (GLenum mode);
extern void glReadPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void *pixels);
extern void glRectd (GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2);
extern void glRectdv (const GLdouble *v1, const GLdouble *v2);
extern void glRectf (GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2);
extern void glRectfv (const GLfloat *v1, const GLfloat *v2);
extern void glRecti (GLint x1, GLint y1, GLint x2, GLint y2);
extern void glRectiv (const GLint *v1, const GLint *v2);
extern void glRects (GLshort x1, GLshort y1, GLshort x2, GLshort y2);
extern void glRectsv (const GLshort *v1, const GLshort *v2);
extern GLint glRenderMode (GLenum mode);
extern void glRotated (GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
extern void glRotatef (GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
extern void glScaled (GLdouble x, GLdouble y, GLdouble z);
extern void glScalef (GLfloat x, GLfloat y, GLfloat z);
extern void glScissor (GLint x, GLint y, GLsizei width, GLsizei height);
extern void glSelectBuffer (GLsizei size, GLuint *buffer);
extern void glShadeModel (GLenum mode);
extern void glStencilFunc (GLenum func, GLint ref, GLuint mask);
extern void glStencilMask (GLuint mask);
extern void glStencilOp (GLenum fail, GLenum zfail, GLenum zpass);
extern void glTexCoord1d (GLdouble s);
extern void glTexCoord1dv (const GLdouble *v);
extern void glTexCoord1f (GLfloat s);
extern void glTexCoord1fv (const GLfloat *v);
extern void glTexCoord1i (GLint s);
extern void glTexCoord1iv (const GLint *v);
extern void glTexCoord1s (GLshort s);
extern void glTexCoord1sv (const GLshort *v);
extern void glTexCoord2d (GLdouble s, GLdouble t);
extern void glTexCoord2dv (const GLdouble *v);
extern void glTexCoord2f (GLfloat s, GLfloat t);
extern void glTexCoord2fv (const GLfloat *v);
extern void glTexCoord2i (GLint s, GLint t);
extern void glTexCoord2iv (const GLint *v);
extern void glTexCoord2s (GLshort s, GLshort t);
extern void glTexCoord2sv (const GLshort *v);
extern void glTexCoord3d (GLdouble s, GLdouble t, GLdouble r);
extern void glTexCoord3dv (const GLdouble *v);
extern void glTexCoord3f (GLfloat s, GLfloat t, GLfloat r);
extern void glTexCoord3fv (const GLfloat *v);
extern void glTexCoord3i (GLint s, GLint t, GLint r);
extern void glTexCoord3iv (const GLint *v);
extern void glTexCoord3s (GLshort s, GLshort t, GLshort r);
extern void glTexCoord3sv (const GLshort *v);
extern void glTexCoord4d (GLdouble s, GLdouble t, GLdouble r, GLdouble q);
extern void glTexCoord4dv (const GLdouble *v);
extern void glTexCoord4f (GLfloat s, GLfloat t, GLfloat r, GLfloat q);
extern void glTexCoord4fv (const GLfloat *v);
extern void glTexCoord4i (GLint s, GLint t, GLint r, GLint q);
extern void glTexCoord4iv (const GLint *v);
extern void glTexCoord4s (GLshort s, GLshort t, GLshort r, GLshort q);
extern void glTexCoord4sv (const GLshort *v);
extern void glTexCoordPointer (GLint size, GLenum type, GLsizei stride, const void *pointer);
extern void glTexEnvf (GLenum target, GLenum pname, GLfloat param);
extern void glTexEnvfv (GLenum target, GLenum pname, const GLfloat *params);
extern void glTexEnvi (GLenum target, GLenum pname, GLint param);
extern void glTexEnviv (GLenum target, GLenum pname, const GLint *params);
extern void glTexGend (GLenum coord, GLenum pname, GLdouble param);
extern void glTexGendv (GLenum coord, GLenum pname, const GLdouble *params);
extern void glTexGenf (GLenum coord, GLenum pname, GLfloat param);
extern void glTexGenfv (GLenum coord, GLenum pname, const GLfloat *params);
extern void glTexGeni (GLenum coord, GLenum pname, GLint param);
extern void glTexGeniv (GLenum coord, GLenum pname, const GLint *params);
extern void glTexImage1D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void *pixels);
extern void glTexImage2D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels);
extern void glTexParameterf (GLenum target, GLenum pname, GLfloat param);
extern void glTexParameterfv (GLenum target, GLenum pname, const GLfloat *params);
extern void glTexParameteri (GLenum target, GLenum pname, GLint param);
extern void glTexParameteriv (GLenum target, GLenum pname, const GLint *params);
extern void glTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels);
extern void glTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
extern void glTranslated (GLdouble x, GLdouble y, GLdouble z);
extern void glTranslatef (GLfloat x, GLfloat y, GLfloat z);
extern void glVertex2d (GLdouble x, GLdouble y);
extern void glVertex2dv (const GLdouble *v);
extern void glVertex2f (GLfloat x, GLfloat y);
extern void glVertex2fv (const GLfloat *v);
extern void glVertex2i (GLint x, GLint y);
extern void glVertex2iv (const GLint *v);
extern void glVertex2s (GLshort x, GLshort y);
extern void glVertex2sv (const GLshort *v);
extern void glVertex3d (GLdouble x, GLdouble y, GLdouble z);
extern void glVertex3dv (const GLdouble *v);
extern void glVertex3f (GLfloat x, GLfloat y, GLfloat z);
extern void glVertex3fv (const GLfloat *v);
extern void glVertex3i (GLint x, GLint y, GLint z);
extern void glVertex3iv (const GLint *v);
extern void glVertex3s (GLshort x, GLshort y, GLshort z);
extern void glVertex3sv (const GLshort *v);
extern void glVertex4d (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern void glVertex4dv (const GLdouble *v);
extern void glVertex4f (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern void glVertex4fv (const GLfloat *v);
extern void glVertex4i (GLint x, GLint y, GLint z, GLint w);
extern void glVertex4iv (const GLint *v);
extern void glVertex4s (GLshort x, GLshort y, GLshort z, GLshort w);
extern void glVertex4sv (const GLshort *v);
extern void glVertexPointer (GLint size, GLenum type, GLsizei stride, const void *pointer);
extern void glViewport (GLint x, GLint y, GLsizei width, GLsizei height);
# 1219 "/usr/include/GL/glew.h" 3 4
# 1 "/usr/include/GL/glu.h" 1 3 4
# 34 "/usr/include/GL/glu.h" 3 4
# 1 "/usr/include/GL/gl.h" 1 3 4
# 35 "/usr/include/GL/glu.h" 2 3 4
# 61 "/usr/include/GL/glu.h" 3 4
extern "C" {
# 266 "/usr/include/GL/glu.h" 3 4
class GLUnurbs;
class GLUquadric;
class GLUtesselator;






typedef GLUnurbs GLUnurbsObj;
typedef GLUquadric GLUquadricObj;
typedef GLUtesselator GLUtesselatorObj;
typedef GLUtesselator GLUtriangulatorObj;




typedef void ( * _GLUfuncptr)(void);

extern void gluBeginCurve (GLUnurbs* nurb);
extern void gluBeginPolygon (GLUtesselator* tess);
extern void gluBeginSurface (GLUnurbs* nurb);
extern void gluBeginTrim (GLUnurbs* nurb);
extern GLint gluBuild1DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
extern GLint gluBuild1DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, const void *data);
extern GLint gluBuild2DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
extern GLint gluBuild2DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *data);
extern GLint gluBuild3DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data);
extern GLint gluBuild3DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data);
extern GLboolean gluCheckExtension (const GLubyte *extName, const GLubyte *extString);
extern void gluCylinder (GLUquadric* quad, GLdouble base, GLdouble top, GLdouble height, GLint slices, GLint stacks);
extern void gluDeleteNurbsRenderer (GLUnurbs* nurb);
extern void gluDeleteQuadric (GLUquadric* quad);
extern void gluDeleteTess (GLUtesselator* tess);
extern void gluDisk (GLUquadric* quad, GLdouble inner, GLdouble outer, GLint slices, GLint loops);
extern void gluEndCurve (GLUnurbs* nurb);
extern void gluEndPolygon (GLUtesselator* tess);
extern void gluEndSurface (GLUnurbs* nurb);
extern void gluEndTrim (GLUnurbs* nurb);
extern const GLubyte * gluErrorString (GLenum error);
extern void gluGetNurbsProperty (GLUnurbs* nurb, GLenum property, GLfloat* data);
extern const GLubyte * gluGetString (GLenum name);
extern void gluGetTessProperty (GLUtesselator* tess, GLenum which, GLdouble* data);
extern void gluLoadSamplingMatrices (GLUnurbs* nurb, const GLfloat *model, const GLfloat *perspective, const GLint *view);
extern void gluLookAt (GLdouble eyeX, GLdouble eyeY, GLdouble eyeZ, GLdouble centerX, GLdouble centerY, GLdouble centerZ, GLdouble upX, GLdouble upY, GLdouble upZ);
extern GLUnurbs* gluNewNurbsRenderer (void);
extern GLUquadric* gluNewQuadric (void);
extern GLUtesselator* gluNewTess (void);
extern void gluNextContour (GLUtesselator* tess, GLenum type);
extern void gluNurbsCallback (GLUnurbs* nurb, GLenum which, _GLUfuncptr CallBackFunc);
extern void gluNurbsCallbackData (GLUnurbs* nurb, GLvoid* userData);
extern void gluNurbsCallbackDataEXT (GLUnurbs* nurb, GLvoid* userData);
extern void gluNurbsCurve (GLUnurbs* nurb, GLint knotCount, GLfloat *knots, GLint stride, GLfloat *control, GLint order, GLenum type);
extern void gluNurbsProperty (GLUnurbs* nurb, GLenum property, GLfloat value);
extern void gluNurbsSurface (GLUnurbs* nurb, GLint sKnotCount, GLfloat* sKnots, GLint tKnotCount, GLfloat* tKnots, GLint sStride, GLint tStride, GLfloat* control, GLint sOrder, GLint tOrder, GLenum type);
extern void gluOrtho2D (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top);
extern void gluPartialDisk (GLUquadric* quad, GLdouble inner, GLdouble outer, GLint slices, GLint loops, GLdouble start, GLdouble sweep);
extern void gluPerspective (GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar);
extern void gluPickMatrix (GLdouble x, GLdouble y, GLdouble delX, GLdouble delY, GLint *viewport);
extern GLint gluProject (GLdouble objX, GLdouble objY, GLdouble objZ, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble* winX, GLdouble* winY, GLdouble* winZ);
extern void gluPwlCurve (GLUnurbs* nurb, GLint count, GLfloat* data, GLint stride, GLenum type);
extern void gluQuadricCallback (GLUquadric* quad, GLenum which, _GLUfuncptr CallBackFunc);
extern void gluQuadricDrawStyle (GLUquadric* quad, GLenum draw);
extern void gluQuadricNormals (GLUquadric* quad, GLenum normal);
extern void gluQuadricOrientation (GLUquadric* quad, GLenum orientation);
extern void gluQuadricTexture (GLUquadric* quad, GLboolean texture);
extern GLint gluScaleImage (GLenum format, GLsizei wIn, GLsizei hIn, GLenum typeIn, const void *dataIn, GLsizei wOut, GLsizei hOut, GLenum typeOut, GLvoid* dataOut);
extern void gluSphere (GLUquadric* quad, GLdouble radius, GLint slices, GLint stacks);
extern void gluTessBeginContour (GLUtesselator* tess);
extern void gluTessBeginPolygon (GLUtesselator* tess, GLvoid* data);
extern void gluTessCallback (GLUtesselator* tess, GLenum which, _GLUfuncptr CallBackFunc);
extern void gluTessEndContour (GLUtesselator* tess);
extern void gluTessEndPolygon (GLUtesselator* tess);
extern void gluTessNormal (GLUtesselator* tess, GLdouble valueX, GLdouble valueY, GLdouble valueZ);
extern void gluTessProperty (GLUtesselator* tess, GLenum which, GLdouble data);
extern void gluTessVertex (GLUtesselator* tess, GLdouble *location, GLvoid* data);
extern GLint gluUnProject (GLdouble winX, GLdouble winY, GLdouble winZ, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble* objX, GLdouble* objY, GLdouble* objZ);
extern GLint gluUnProject4 (GLdouble winX, GLdouble winY, GLdouble winZ, GLdouble clipW, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble nearVal, GLdouble farVal, GLdouble* objX, GLdouble* objY, GLdouble* objZ, GLdouble* objW);


}
# 1220 "/usr/include/GL/glew.h" 2 3 4
# 1269 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCOPYTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLDRAWRANGEELEMENTSPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices);
typedef void ( * PFNGLTEXIMAGE3DPROC) (GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
# 1394 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLACTIVETEXTUREPROC) (GLenum texture);
typedef void ( * PFNGLCLIENTACTIVETEXTUREPROC) (GLenum texture);
typedef void ( * PFNGLCOMPRESSEDTEXIMAGE1DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXIMAGE2DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXIMAGE3DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
typedef void ( * PFNGLGETCOMPRESSEDTEXIMAGEPROC) (GLenum target, GLint lod, void *img);
typedef void ( * PFNGLLOADTRANSPOSEMATRIXDPROC) (const GLdouble m[16]);
typedef void ( * PFNGLLOADTRANSPOSEMATRIXFPROC) (const GLfloat m[16]);
typedef void ( * PFNGLMULTTRANSPOSEMATRIXDPROC) (const GLdouble m[16]);
typedef void ( * PFNGLMULTTRANSPOSEMATRIXFPROC) (const GLfloat m[16]);
typedef void ( * PFNGLMULTITEXCOORD1DPROC) (GLenum target, GLdouble s);
typedef void ( * PFNGLMULTITEXCOORD1DVPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD1FPROC) (GLenum target, GLfloat s);
typedef void ( * PFNGLMULTITEXCOORD1FVPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD1IPROC) (GLenum target, GLint s);
typedef void ( * PFNGLMULTITEXCOORD1IVPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD1SPROC) (GLenum target, GLshort s);
typedef void ( * PFNGLMULTITEXCOORD1SVPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLMULTITEXCOORD2DPROC) (GLenum target, GLdouble s, GLdouble t);
typedef void ( * PFNGLMULTITEXCOORD2DVPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD2FPROC) (GLenum target, GLfloat s, GLfloat t);
typedef void ( * PFNGLMULTITEXCOORD2FVPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD2IPROC) (GLenum target, GLint s, GLint t);
typedef void ( * PFNGLMULTITEXCOORD2IVPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD2SPROC) (GLenum target, GLshort s, GLshort t);
typedef void ( * PFNGLMULTITEXCOORD2SVPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLMULTITEXCOORD3DPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r);
typedef void ( * PFNGLMULTITEXCOORD3DVPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD3FPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r);
typedef void ( * PFNGLMULTITEXCOORD3FVPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD3IPROC) (GLenum target, GLint s, GLint t, GLint r);
typedef void ( * PFNGLMULTITEXCOORD3IVPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD3SPROC) (GLenum target, GLshort s, GLshort t, GLshort r);
typedef void ( * PFNGLMULTITEXCOORD3SVPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLMULTITEXCOORD4DPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
typedef void ( * PFNGLMULTITEXCOORD4DVPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD4FPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
typedef void ( * PFNGLMULTITEXCOORD4FVPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD4IPROC) (GLenum target, GLint s, GLint t, GLint r, GLint q);
typedef void ( * PFNGLMULTITEXCOORD4IVPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD4SPROC) (GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
typedef void ( * PFNGLMULTITEXCOORD4SVPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLSAMPLECOVERAGEPROC) (GLclampf value, GLboolean invert);
# 1537 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBLENDCOLORPROC) (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
typedef void ( * PFNGLBLENDEQUATIONPROC) (GLenum mode);
typedef void ( * PFNGLBLENDFUNCSEPARATEPROC) (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
typedef void ( * PFNGLFOGCOORDPOINTERPROC) (GLenum type, GLsizei stride, const void *pointer);
typedef void ( * PFNGLFOGCOORDDPROC) (GLdouble coord);
typedef void ( * PFNGLFOGCOORDDVPROC) (const GLdouble *coord);
typedef void ( * PFNGLFOGCOORDFPROC) (GLfloat coord);
typedef void ( * PFNGLFOGCOORDFVPROC) (const GLfloat *coord);
typedef void ( * PFNGLMULTIDRAWARRAYSPROC) (GLenum mode, const GLint *first, const GLsizei *count, GLsizei drawcount);
typedef void ( * PFNGLMULTIDRAWELEMENTSPROC) (GLenum mode, const GLsizei *count, GLenum type, const void *const* indices, GLsizei drawcount);
typedef void ( * PFNGLPOINTPARAMETERFPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLPOINTPARAMETERFVPROC) (GLenum pname, const GLfloat *params);
typedef void ( * PFNGLPOINTPARAMETERIPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLPOINTPARAMETERIVPROC) (GLenum pname, const GLint *params);
typedef void ( * PFNGLSECONDARYCOLOR3BPROC) (GLbyte red, GLbyte green, GLbyte blue);
typedef void ( * PFNGLSECONDARYCOLOR3BVPROC) (const GLbyte *v);
typedef void ( * PFNGLSECONDARYCOLOR3DPROC) (GLdouble red, GLdouble green, GLdouble blue);
typedef void ( * PFNGLSECONDARYCOLOR3DVPROC) (const GLdouble *v);
typedef void ( * PFNGLSECONDARYCOLOR3FPROC) (GLfloat red, GLfloat green, GLfloat blue);
typedef void ( * PFNGLSECONDARYCOLOR3FVPROC) (const GLfloat *v);
typedef void ( * PFNGLSECONDARYCOLOR3IPROC) (GLint red, GLint green, GLint blue);
typedef void ( * PFNGLSECONDARYCOLOR3IVPROC) (const GLint *v);
typedef void ( * PFNGLSECONDARYCOLOR3SPROC) (GLshort red, GLshort green, GLshort blue);
typedef void ( * PFNGLSECONDARYCOLOR3SVPROC) (const GLshort *v);
typedef void ( * PFNGLSECONDARYCOLOR3UBPROC) (GLubyte red, GLubyte green, GLubyte blue);
typedef void ( * PFNGLSECONDARYCOLOR3UBVPROC) (const GLubyte *v);
typedef void ( * PFNGLSECONDARYCOLOR3UIPROC) (GLuint red, GLuint green, GLuint blue);
typedef void ( * PFNGLSECONDARYCOLOR3UIVPROC) (const GLuint *v);
typedef void ( * PFNGLSECONDARYCOLOR3USPROC) (GLushort red, GLushort green, GLushort blue);
typedef void ( * PFNGLSECONDARYCOLOR3USVPROC) (const GLushort *v);
typedef void ( * PFNGLSECONDARYCOLORPOINTERPROC) (GLint size, GLenum type, GLsizei stride, const void *pointer);
typedef void ( * PFNGLWINDOWPOS2DPROC) (GLdouble x, GLdouble y);
typedef void ( * PFNGLWINDOWPOS2DVPROC) (const GLdouble *p);
typedef void ( * PFNGLWINDOWPOS2FPROC) (GLfloat x, GLfloat y);
typedef void ( * PFNGLWINDOWPOS2FVPROC) (const GLfloat *p);
typedef void ( * PFNGLWINDOWPOS2IPROC) (GLint x, GLint y);
typedef void ( * PFNGLWINDOWPOS2IVPROC) (const GLint *p);
typedef void ( * PFNGLWINDOWPOS2SPROC) (GLshort x, GLshort y);
typedef void ( * PFNGLWINDOWPOS2SVPROC) (const GLshort *p);
typedef void ( * PFNGLWINDOWPOS3DPROC) (GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLWINDOWPOS3DVPROC) (const GLdouble *p);
typedef void ( * PFNGLWINDOWPOS3FPROC) (GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLWINDOWPOS3FVPROC) (const GLfloat *p);
typedef void ( * PFNGLWINDOWPOS3IPROC) (GLint x, GLint y, GLint z);
typedef void ( * PFNGLWINDOWPOS3IVPROC) (const GLint *p);
typedef void ( * PFNGLWINDOWPOS3SPROC) (GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLWINDOWPOS3SVPROC) (const GLshort *p);
# 1693 "/usr/include/GL/glew.h" 3 4
typedef ptrdiff_t GLintptr;
typedef ptrdiff_t GLsizeiptr;

typedef void ( * PFNGLBEGINQUERYPROC) (GLenum target, GLuint id);
typedef void ( * PFNGLBINDBUFFERPROC) (GLenum target, GLuint buffer);
typedef void ( * PFNGLBUFFERDATAPROC) (GLenum target, GLsizeiptr size, const void* data, GLenum usage);
typedef void ( * PFNGLBUFFERSUBDATAPROC) (GLenum target, GLintptr offset, GLsizeiptr size, const void* data);
typedef void ( * PFNGLDELETEBUFFERSPROC) (GLsizei n, const GLuint* buffers);
typedef void ( * PFNGLDELETEQUERIESPROC) (GLsizei n, const GLuint* ids);
typedef void ( * PFNGLENDQUERYPROC) (GLenum target);
typedef void ( * PFNGLGENBUFFERSPROC) (GLsizei n, GLuint* buffers);
typedef void ( * PFNGLGENQUERIESPROC) (GLsizei n, GLuint* ids);
typedef void ( * PFNGLGETBUFFERPARAMETERIVPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETBUFFERPOINTERVPROC) (GLenum target, GLenum pname, void** params);
typedef void ( * PFNGLGETBUFFERSUBDATAPROC) (GLenum target, GLintptr offset, GLsizeiptr size, void* data);
typedef void ( * PFNGLGETQUERYOBJECTIVPROC) (GLuint id, GLenum pname, GLint* params);
typedef void ( * PFNGLGETQUERYOBJECTUIVPROC) (GLuint id, GLenum pname, GLuint* params);
typedef void ( * PFNGLGETQUERYIVPROC) (GLenum target, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISBUFFERPROC) (GLuint buffer);
typedef GLboolean ( * PFNGLISQUERYPROC) (GLuint id);
typedef void* ( * PFNGLMAPBUFFERPROC) (GLenum target, GLenum access);
typedef GLboolean ( * PFNGLUNMAPBUFFERPROC) (GLenum target);
# 1830 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLATTACHSHADERPROC) (GLuint program, GLuint shader);
typedef void ( * PFNGLBINDATTRIBLOCATIONPROC) (GLuint program, GLuint index, const GLchar* name);
typedef void ( * PFNGLBLENDEQUATIONSEPARATEPROC) (GLenum modeRGB, GLenum modeAlpha);
typedef void ( * PFNGLCOMPILESHADERPROC) (GLuint shader);
typedef GLuint ( * PFNGLCREATEPROGRAMPROC) (void);
typedef GLuint ( * PFNGLCREATESHADERPROC) (GLenum type);
typedef void ( * PFNGLDELETEPROGRAMPROC) (GLuint program);
typedef void ( * PFNGLDELETESHADERPROC) (GLuint shader);
typedef void ( * PFNGLDETACHSHADERPROC) (GLuint program, GLuint shader);
typedef void ( * PFNGLDISABLEVERTEXATTRIBARRAYPROC) (GLuint index);
typedef void ( * PFNGLDRAWBUFFERSPROC) (GLsizei n, const GLenum* bufs);
typedef void ( * PFNGLENABLEVERTEXATTRIBARRAYPROC) (GLuint index);
typedef void ( * PFNGLGETACTIVEATTRIBPROC) (GLuint program, GLuint index, GLsizei maxLength, GLsizei* length, GLint* size, GLenum* type, GLchar* name);
typedef void ( * PFNGLGETACTIVEUNIFORMPROC) (GLuint program, GLuint index, GLsizei maxLength, GLsizei* length, GLint* size, GLenum* type, GLchar* name);
typedef void ( * PFNGLGETATTACHEDSHADERSPROC) (GLuint program, GLsizei maxCount, GLsizei* count, GLuint* shaders);
typedef GLint ( * PFNGLGETATTRIBLOCATIONPROC) (GLuint program, const GLchar* name);
typedef void ( * PFNGLGETPROGRAMINFOLOGPROC) (GLuint program, GLsizei bufSize, GLsizei* length, GLchar* infoLog);
typedef void ( * PFNGLGETPROGRAMIVPROC) (GLuint program, GLenum pname, GLint* param);
typedef void ( * PFNGLGETSHADERINFOLOGPROC) (GLuint shader, GLsizei bufSize, GLsizei* length, GLchar* infoLog);
typedef void ( * PFNGLGETSHADERSOURCEPROC) (GLuint obj, GLsizei maxLength, GLsizei* length, GLchar* source);
typedef void ( * PFNGLGETSHADERIVPROC) (GLuint shader, GLenum pname, GLint* param);
typedef GLint ( * PFNGLGETUNIFORMLOCATIONPROC) (GLuint program, const GLchar* name);
typedef void ( * PFNGLGETUNIFORMFVPROC) (GLuint program, GLint location, GLfloat* params);
typedef void ( * PFNGLGETUNIFORMIVPROC) (GLuint program, GLint location, GLint* params);
typedef void ( * PFNGLGETVERTEXATTRIBPOINTERVPROC) (GLuint index, GLenum pname, void** pointer);
typedef void ( * PFNGLGETVERTEXATTRIBDVPROC) (GLuint index, GLenum pname, GLdouble* params);
typedef void ( * PFNGLGETVERTEXATTRIBFVPROC) (GLuint index, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETVERTEXATTRIBIVPROC) (GLuint index, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISPROGRAMPROC) (GLuint program);
typedef GLboolean ( * PFNGLISSHADERPROC) (GLuint shader);
typedef void ( * PFNGLLINKPROGRAMPROC) (GLuint program);
typedef void ( * PFNGLSHADERSOURCEPROC) (GLuint shader, GLsizei count, const GLchar *const* string, const GLint* length);
typedef void ( * PFNGLSTENCILFUNCSEPARATEPROC) (GLenum face, GLenum func, GLint ref, GLuint mask);
typedef void ( * PFNGLSTENCILMASKSEPARATEPROC) (GLenum face, GLuint mask);
typedef void ( * PFNGLSTENCILOPSEPARATEPROC) (GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
typedef void ( * PFNGLUNIFORM1FPROC) (GLint location, GLfloat v0);
typedef void ( * PFNGLUNIFORM1FVPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLUNIFORM1IPROC) (GLint location, GLint v0);
typedef void ( * PFNGLUNIFORM1IVPROC) (GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLUNIFORM2FPROC) (GLint location, GLfloat v0, GLfloat v1);
typedef void ( * PFNGLUNIFORM2FVPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLUNIFORM2IPROC) (GLint location, GLint v0, GLint v1);
typedef void ( * PFNGLUNIFORM2IVPROC) (GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLUNIFORM3FPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void ( * PFNGLUNIFORM3FVPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLUNIFORM3IPROC) (GLint location, GLint v0, GLint v1, GLint v2);
typedef void ( * PFNGLUNIFORM3IVPROC) (GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLUNIFORM4FPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void ( * PFNGLUNIFORM4FVPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLUNIFORM4IPROC) (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void ( * PFNGLUNIFORM4IVPROC) (GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLUNIFORMMATRIX2FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLUNIFORMMATRIX3FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLUNIFORMMATRIX4FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLUSEPROGRAMPROC) (GLuint program);
typedef void ( * PFNGLVALIDATEPROGRAMPROC) (GLuint program);
typedef void ( * PFNGLVERTEXATTRIB1DPROC) (GLuint index, GLdouble x);
typedef void ( * PFNGLVERTEXATTRIB1DVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB1FPROC) (GLuint index, GLfloat x);
typedef void ( * PFNGLVERTEXATTRIB1FVPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB1SPROC) (GLuint index, GLshort x);
typedef void ( * PFNGLVERTEXATTRIB1SVPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB2DPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void ( * PFNGLVERTEXATTRIB2DVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB2FPROC) (GLuint index, GLfloat x, GLfloat y);
typedef void ( * PFNGLVERTEXATTRIB2FVPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB2SPROC) (GLuint index, GLshort x, GLshort y);
typedef void ( * PFNGLVERTEXATTRIB2SVPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB3DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLVERTEXATTRIB3DVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB3FPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLVERTEXATTRIB3FVPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB3SPROC) (GLuint index, GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLVERTEXATTRIB3SVPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB4NBVPROC) (GLuint index, const GLbyte* v);
typedef void ( * PFNGLVERTEXATTRIB4NIVPROC) (GLuint index, const GLint* v);
typedef void ( * PFNGLVERTEXATTRIB4NSVPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB4NUBPROC) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
typedef void ( * PFNGLVERTEXATTRIB4NUBVPROC) (GLuint index, const GLubyte* v);
typedef void ( * PFNGLVERTEXATTRIB4NUIVPROC) (GLuint index, const GLuint* v);
typedef void ( * PFNGLVERTEXATTRIB4NUSVPROC) (GLuint index, const GLushort* v);
typedef void ( * PFNGLVERTEXATTRIB4BVPROC) (GLuint index, const GLbyte* v);
typedef void ( * PFNGLVERTEXATTRIB4DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLVERTEXATTRIB4DVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB4FPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLVERTEXATTRIB4FVPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB4IVPROC) (GLuint index, const GLint* v);
typedef void ( * PFNGLVERTEXATTRIB4SPROC) (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void ( * PFNGLVERTEXATTRIB4SVPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB4UBVPROC) (GLuint index, const GLubyte* v);
typedef void ( * PFNGLVERTEXATTRIB4UIVPROC) (GLuint index, const GLuint* v);
typedef void ( * PFNGLVERTEXATTRIB4USVPROC) (GLuint index, const GLushort* v);
typedef void ( * PFNGLVERTEXATTRIBPOINTERPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void* pointer);
# 2051 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLUNIFORMMATRIX2X3FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLUNIFORMMATRIX2X4FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLUNIFORMMATRIX3X2FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLUNIFORMMATRIX3X4FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLUNIFORMMATRIX4X2FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLUNIFORMMATRIX4X3FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
# 2180 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBEGINCONDITIONALRENDERPROC) (GLuint id, GLenum mode);
typedef void ( * PFNGLBEGINTRANSFORMFEEDBACKPROC) (GLenum primitiveMode);
typedef void ( * PFNGLBINDFRAGDATALOCATIONPROC) (GLuint program, GLuint colorNumber, const GLchar* name);
typedef void ( * PFNGLCLAMPCOLORPROC) (GLenum target, GLenum clamp);
typedef void ( * PFNGLCLEARBUFFERFIPROC) (GLenum buffer, GLint drawBuffer, GLfloat depth, GLint stencil);
typedef void ( * PFNGLCLEARBUFFERFVPROC) (GLenum buffer, GLint drawBuffer, const GLfloat* value);
typedef void ( * PFNGLCLEARBUFFERIVPROC) (GLenum buffer, GLint drawBuffer, const GLint* value);
typedef void ( * PFNGLCLEARBUFFERUIVPROC) (GLenum buffer, GLint drawBuffer, const GLuint* value);
typedef void ( * PFNGLCOLORMASKIPROC) (GLuint buf, GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
typedef void ( * PFNGLDISABLEIPROC) (GLenum cap, GLuint index);
typedef void ( * PFNGLENABLEIPROC) (GLenum cap, GLuint index);
typedef void ( * PFNGLENDCONDITIONALRENDERPROC) (void);
typedef void ( * PFNGLENDTRANSFORMFEEDBACKPROC) (void);
typedef void ( * PFNGLGETBOOLEANI_VPROC) (GLenum pname, GLuint index, GLboolean* data);
typedef GLint ( * PFNGLGETFRAGDATALOCATIONPROC) (GLuint program, const GLchar* name);
typedef const GLubyte* ( * PFNGLGETSTRINGIPROC) (GLenum name, GLuint index);
typedef void ( * PFNGLGETTEXPARAMETERIIVPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETTEXPARAMETERIUIVPROC) (GLenum target, GLenum pname, GLuint* params);
typedef void ( * PFNGLGETTRANSFORMFEEDBACKVARYINGPROC) (GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, GLchar * name);
typedef void ( * PFNGLGETUNIFORMUIVPROC) (GLuint program, GLint location, GLuint* params);
typedef void ( * PFNGLGETVERTEXATTRIBIIVPROC) (GLuint index, GLenum pname, GLint* params);
typedef void ( * PFNGLGETVERTEXATTRIBIUIVPROC) (GLuint index, GLenum pname, GLuint* params);
typedef GLboolean ( * PFNGLISENABLEDIPROC) (GLenum cap, GLuint index);
typedef void ( * PFNGLTEXPARAMETERIIVPROC) (GLenum target, GLenum pname, const GLint* params);
typedef void ( * PFNGLTEXPARAMETERIUIVPROC) (GLenum target, GLenum pname, const GLuint* params);
typedef void ( * PFNGLTRANSFORMFEEDBACKVARYINGSPROC) (GLuint program, GLsizei count, const GLchar *const* varyings, GLenum bufferMode);
typedef void ( * PFNGLUNIFORM1UIPROC) (GLint location, GLuint v0);
typedef void ( * PFNGLUNIFORM1UIVPROC) (GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLUNIFORM2UIPROC) (GLint location, GLuint v0, GLuint v1);
typedef void ( * PFNGLUNIFORM2UIVPROC) (GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLUNIFORM3UIPROC) (GLint location, GLuint v0, GLuint v1, GLuint v2);
typedef void ( * PFNGLUNIFORM3UIVPROC) (GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLUNIFORM4UIPROC) (GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void ( * PFNGLUNIFORM4UIVPROC) (GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLVERTEXATTRIBI1IPROC) (GLuint index, GLint v0);
typedef void ( * PFNGLVERTEXATTRIBI1IVPROC) (GLuint index, const GLint* v0);
typedef void ( * PFNGLVERTEXATTRIBI1UIPROC) (GLuint index, GLuint v0);
typedef void ( * PFNGLVERTEXATTRIBI1UIVPROC) (GLuint index, const GLuint* v0);
typedef void ( * PFNGLVERTEXATTRIBI2IPROC) (GLuint index, GLint v0, GLint v1);
typedef void ( * PFNGLVERTEXATTRIBI2IVPROC) (GLuint index, const GLint* v0);
typedef void ( * PFNGLVERTEXATTRIBI2UIPROC) (GLuint index, GLuint v0, GLuint v1);
typedef void ( * PFNGLVERTEXATTRIBI2UIVPROC) (GLuint index, const GLuint* v0);
typedef void ( * PFNGLVERTEXATTRIBI3IPROC) (GLuint index, GLint v0, GLint v1, GLint v2);
typedef void ( * PFNGLVERTEXATTRIBI3IVPROC) (GLuint index, const GLint* v0);
typedef void ( * PFNGLVERTEXATTRIBI3UIPROC) (GLuint index, GLuint v0, GLuint v1, GLuint v2);
typedef void ( * PFNGLVERTEXATTRIBI3UIVPROC) (GLuint index, const GLuint* v0);
typedef void ( * PFNGLVERTEXATTRIBI4BVPROC) (GLuint index, const GLbyte* v0);
typedef void ( * PFNGLVERTEXATTRIBI4IPROC) (GLuint index, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void ( * PFNGLVERTEXATTRIBI4IVPROC) (GLuint index, const GLint* v0);
typedef void ( * PFNGLVERTEXATTRIBI4SVPROC) (GLuint index, const GLshort* v0);
typedef void ( * PFNGLVERTEXATTRIBI4UBVPROC) (GLuint index, const GLubyte* v0);
typedef void ( * PFNGLVERTEXATTRIBI4UIPROC) (GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void ( * PFNGLVERTEXATTRIBI4UIVPROC) (GLuint index, const GLuint* v0);
typedef void ( * PFNGLVERTEXATTRIBI4USVPROC) (GLuint index, const GLushort* v0);
typedef void ( * PFNGLVERTEXATTRIBIPOINTERPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const void*pointer);
# 2336 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDRAWARRAYSINSTANCEDPROC) (GLenum mode, GLint first, GLsizei count, GLsizei primcount);
typedef void ( * PFNGLDRAWELEMENTSINSTANCEDPROC) (GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei primcount);
typedef void ( * PFNGLPRIMITIVERESTARTINDEXPROC) (GLuint buffer);
typedef void ( * PFNGLTEXBUFFERPROC) (GLenum target, GLenum internalFormat, GLuint buffer);
# 2378 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLFRAMEBUFFERTEXTUREPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level);
typedef void ( * PFNGLGETBUFFERPARAMETERI64VPROC) (GLenum target, GLenum value, GLint64 * data);
typedef void ( * PFNGLGETINTEGER64I_VPROC) (GLenum pname, GLuint index, GLint64 * data);
# 2398 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLVERTEXATTRIBDIVISORPROC) (GLuint index, GLuint divisor);
# 2424 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBLENDEQUATIONSEPARATEIPROC) (GLuint buf, GLenum modeRGB, GLenum modeAlpha);
typedef void ( * PFNGLBLENDEQUATIONIPROC) (GLuint buf, GLenum mode);
typedef void ( * PFNGLBLENDFUNCSEPARATEIPROC) (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
typedef void ( * PFNGLBLENDFUNCIPROC) (GLuint buf, GLenum src, GLenum dst);
typedef void ( * PFNGLMINSAMPLESHADINGPROC) (GLclampf value);
# 2499 "/usr/include/GL/glew.h" 3 4
typedef GLenum ( * PFNGLGETGRAPHICSRESETSTATUSPROC) (void);
typedef void ( * PFNGLGETNCOMPRESSEDTEXIMAGEPROC) (GLenum target, GLint lod, GLsizei bufSize, GLvoid *pixels);
typedef void ( * PFNGLGETNTEXIMAGEPROC) (GLenum tex, GLint level, GLenum format, GLenum type, GLsizei bufSize, GLvoid *pixels);
typedef void ( * PFNGLGETNUNIFORMDVPROC) (GLuint program, GLint location, GLsizei bufSize, GLdouble *params);
# 2541 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLMULTIDRAWARRAYSINDIRECTCOUNTPROC) (GLenum mode, const GLvoid *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
typedef void ( * PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTPROC) (GLenum mode, GLenum type, const GLvoid *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
typedef void ( * PFNGLSPECIALIZESHADERPROC) (GLuint shader, const GLchar *pEntryPoint, GLuint numSpecializationConstants, const GLuint *pConstantIndex, const GLuint *pConstantValue);
# 2572 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLTBUFFERMASK3DFXPROC) (GLuint mask);
# 2658 "/usr/include/GL/glew.h" 3 4
typedef void ( *GLDEBUGPROCAMD)(GLuint id, GLenum category, GLenum severity, GLsizei length, const GLchar* message, void* userParam);

typedef void ( * PFNGLDEBUGMESSAGECALLBACKAMDPROC) (GLDEBUGPROCAMD callback, void *userParam);
typedef void ( * PFNGLDEBUGMESSAGEENABLEAMDPROC) (GLenum category, GLenum severity, GLsizei count, const GLuint* ids, GLboolean enabled);
typedef void ( * PFNGLDEBUGMESSAGEINSERTAMDPROC) (GLenum category, GLenum severity, GLuint id, GLsizei length, const GLchar* buf);
typedef GLuint ( * PFNGLGETDEBUGMESSAGELOGAMDPROC) (GLuint count, GLsizei bufsize, GLenum* categories, GLuint* severities, GLuint* ids, GLsizei* lengths, GLchar* message);
# 2691 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBLENDEQUATIONINDEXEDAMDPROC) (GLuint buf, GLenum mode);
typedef void ( * PFNGLBLENDEQUATIONSEPARATEINDEXEDAMDPROC) (GLuint buf, GLenum modeRGB, GLenum modeAlpha);
typedef void ( * PFNGLBLENDFUNCINDEXEDAMDPROC) (GLuint buf, GLenum src, GLenum dst);
typedef void ( * PFNGLBLENDFUNCSEPARATEINDEXEDAMDPROC) (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
# 2717 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEADVANCEDAMDPROC) (GLuint renderbuffer, GLsizei samples, GLsizei storageSamples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLRENDERBUFFERSTORAGEMULTISAMPLEADVANCEDAMDPROC) (GLenum target, GLsizei samples, GLsizei storageSamples, GLenum internalformat, GLsizei width, GLsizei height);
# 2737 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLFRAMEBUFFERSAMPLEPOSITIONSFVAMDPROC) (GLenum target, GLuint numsamples, GLuint pixelindex, const GLfloat* values);
typedef void ( * PFNGLGETFRAMEBUFFERPARAMETERFVAMDPROC) (GLenum target, GLenum pname, GLuint numsamples, GLuint pixelindex, GLsizei size, GLfloat* values);
typedef void ( * PFNGLGETNAMEDFRAMEBUFFERPARAMETERFVAMDPROC) (GLuint framebuffer, GLenum pname, GLuint numsamples, GLuint pixelindex, GLsizei size, GLfloat* values);
typedef void ( * PFNGLNAMEDFRAMEBUFFERSAMPLEPOSITIONSFVAMDPROC) (GLuint framebuffer, GLuint numsamples, GLuint pixelindex, const GLfloat* values);
# 2855 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLVERTEXATTRIBPARAMETERIAMDPROC) (GLuint index, GLenum pname, GLint param);
# 2868 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLMULTIDRAWARRAYSINDIRECTAMDPROC) (GLenum mode, const void *indirect, GLsizei primcount, GLsizei stride);
typedef void ( * PFNGLMULTIDRAWELEMENTSINDIRECTAMDPROC) (GLenum mode, GLenum type, const void *indirect, GLsizei primcount, GLsizei stride);
# 2889 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDELETENAMESAMDPROC) (GLenum identifier, GLuint num, const GLuint* names);
typedef void ( * PFNGLGENNAMESAMDPROC) (GLenum identifier, GLuint num, GLuint* names);
typedef GLboolean ( * PFNGLISNAMEAMDPROC) (GLenum identifier, GLuint name);
# 2913 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLQUERYOBJECTPARAMETERUIAMDPROC) (GLenum target, GLuint id, GLenum pname, GLuint param);
# 2934 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBEGINPERFMONITORAMDPROC) (GLuint monitor);
typedef void ( * PFNGLDELETEPERFMONITORSAMDPROC) (GLsizei n, GLuint* monitors);
typedef void ( * PFNGLENDPERFMONITORAMDPROC) (GLuint monitor);
typedef void ( * PFNGLGENPERFMONITORSAMDPROC) (GLsizei n, GLuint* monitors);
typedef void ( * PFNGLGETPERFMONITORCOUNTERDATAAMDPROC) (GLuint monitor, GLenum pname, GLsizei dataSize, GLuint* data, GLint *bytesWritten);
typedef void ( * PFNGLGETPERFMONITORCOUNTERINFOAMDPROC) (GLuint group, GLuint counter, GLenum pname, void *data);
typedef void ( * PFNGLGETPERFMONITORCOUNTERSTRINGAMDPROC) (GLuint group, GLuint counter, GLsizei bufSize, GLsizei* length, GLchar *counterString);
typedef void ( * PFNGLGETPERFMONITORCOUNTERSAMDPROC) (GLuint group, GLint* numCounters, GLint *maxActiveCounters, GLsizei countersSize, GLuint *counters);
typedef void ( * PFNGLGETPERFMONITORGROUPSTRINGAMDPROC) (GLuint group, GLsizei bufSize, GLsizei* length, GLchar *groupString);
typedef void ( * PFNGLGETPERFMONITORGROUPSAMDPROC) (GLint* numGroups, GLsizei groupsSize, GLuint *groups);
typedef void ( * PFNGLSELECTPERFMONITORCOUNTERSAMDPROC) (GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint* counterList);
# 3004 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLSETMULTISAMPLEFVAMDPROC) (GLenum pname, GLuint index, const GLfloat* val);
# 3101 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLTEXSTORAGESPARSEAMDPROC) (GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags);
typedef void ( * PFNGLTEXTURESTORAGESPARSEAMDPROC) (GLuint texture, GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags);
# 3121 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLSTENCILOPVALUEAMDPROC) (GLenum face, GLuint value);
# 3189 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLTESSELLATIONFACTORAMDPROC) (GLfloat factor);
typedef void ( * PFNGLTESSELLATIONMODEAMDPROC) (GLenum mode);
# 3236 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBLITFRAMEBUFFERANGLEPROC) (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
# 3253 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLRENDERBUFFERSTORAGEMULTISAMPLEANGLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
# 3268 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDRAWARRAYSINSTANCEDANGLEPROC) (GLenum mode, GLint first, GLsizei count, GLsizei primcount);
typedef void ( * PFNGLDRAWELEMENTSINSTANCEDANGLEPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount);
typedef void ( * PFNGLVERTEXATTRIBDIVISORANGLEPROC) (GLuint index, GLuint divisor);
# 3368 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBEGINQUERYANGLEPROC) (GLenum target, GLuint id);
typedef void ( * PFNGLDELETEQUERIESANGLEPROC) (GLsizei n, const GLuint* ids);
typedef void ( * PFNGLENDQUERYANGLEPROC) (GLenum target);
typedef void ( * PFNGLGENQUERIESANGLEPROC) (GLsizei n, GLuint* ids);
typedef void ( * PFNGLGETQUERYOBJECTI64VANGLEPROC) (GLuint id, GLenum pname, GLint64* params);
typedef void ( * PFNGLGETQUERYOBJECTIVANGLEPROC) (GLuint id, GLenum pname, GLint* params);
typedef void ( * PFNGLGETQUERYOBJECTUI64VANGLEPROC) (GLuint id, GLenum pname, GLuint64* params);
typedef void ( * PFNGLGETQUERYOBJECTUIVANGLEPROC) (GLuint id, GLenum pname, GLuint* params);
typedef void ( * PFNGLGETQUERYIVANGLEPROC) (GLenum target, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISQUERYANGLEPROC) (GLuint id);
typedef void ( * PFNGLQUERYCOUNTERANGLEPROC) (GLuint id, GLenum target);
# 3403 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETTRANSLATEDSHADERSOURCEANGLEPROC) (GLuint shader, GLsizei bufsize, GLsizei* length, GLchar* source);
# 3466 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCOPYTEXTURELEVELSAPPLEPROC) (GLuint destinationTexture, GLuint sourceTexture, GLint sourceBaseLevel, GLsizei sourceLevelCount);
# 3483 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDRAWELEMENTARRAYAPPLEPROC) (GLenum mode, GLint first, GLsizei count);
typedef void ( * PFNGLDRAWRANGEELEMENTARRAYAPPLEPROC) (GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count);
typedef void ( * PFNGLELEMENTPOINTERAPPLEPROC) (GLenum type, const void *pointer);
typedef void ( * PFNGLMULTIDRAWELEMENTARRAYAPPLEPROC) (GLenum mode, const GLint* first, const GLsizei *count, GLsizei primcount);
typedef void ( * PFNGLMULTIDRAWRANGEELEMENTARRAYAPPLEPROC) (GLenum mode, GLuint start, GLuint end, const GLint* first, const GLsizei *count, GLsizei primcount);
# 3507 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDELETEFENCESAPPLEPROC) (GLsizei n, const GLuint* fences);
typedef void ( * PFNGLFINISHFENCEAPPLEPROC) (GLuint fence);
typedef void ( * PFNGLFINISHOBJECTAPPLEPROC) (GLenum object, GLint name);
typedef void ( * PFNGLGENFENCESAPPLEPROC) (GLsizei n, GLuint* fences);
typedef GLboolean ( * PFNGLISFENCEAPPLEPROC) (GLuint fence);
typedef void ( * PFNGLSETFENCEAPPLEPROC) (GLuint fence);
typedef GLboolean ( * PFNGLTESTFENCEAPPLEPROC) (GLuint fence);
typedef GLboolean ( * PFNGLTESTOBJECTAPPLEPROC) (GLenum object, GLuint name);
# 3561 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBUFFERPARAMETERIAPPLEPROC) (GLenum target, GLenum pname, GLint param);
typedef void ( * PFNGLFLUSHMAPPEDBUFFERRANGEAPPLEPROC) (GLenum target, GLintptr offset, GLsizeiptr size);
# 3584 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLRENDERBUFFERSTORAGEMULTISAMPLEAPPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLRESOLVEMULTISAMPLEFRAMEBUFFERAPPLEPROC) (void);
# 3606 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETOBJECTPARAMETERIVAPPLEPROC) (GLenum objectType, GLuint name, GLenum pname, GLint* params);
typedef GLenum ( * PFNGLOBJECTPURGEABLEAPPLEPROC) (GLenum objectType, GLuint name, GLenum option);
typedef GLenum ( * PFNGLOBJECTUNPURGEABLEAPPLEPROC) (GLenum objectType, GLuint name, GLenum option);
# 3688 "/usr/include/GL/glew.h" 3 4
typedef GLenum ( * PFNGLCLIENTWAITSYNCAPPLEPROC) (GLsync GLsync, GLbitfield flags, GLuint64 timeout);
typedef void ( * PFNGLDELETESYNCAPPLEPROC) (GLsync GLsync);
typedef GLsync ( * PFNGLFENCESYNCAPPLEPROC) (GLenum condition, GLbitfield flags);
typedef void ( * PFNGLGETINTEGER64VAPPLEPROC) (GLenum pname, GLint64* params);
typedef void ( * PFNGLGETSYNCIVAPPLEPROC) (GLsync GLsync, GLenum pname, GLsizei bufSize, GLsizei* length, GLint *values);
typedef GLboolean ( * PFNGLISSYNCAPPLEPROC) (GLsync GLsync);
typedef void ( * PFNGLWAITSYNCAPPLEPROC) (GLsync GLsync, GLbitfield flags, GLuint64 timeout);
# 3766 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETTEXPARAMETERPOINTERVAPPLEPROC) (GLenum target, GLenum pname, void **params);
typedef void ( * PFNGLTEXTURERANGEAPPLEPROC) (GLenum target, GLsizei length, void *pointer);
# 3794 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBINDVERTEXARRAYAPPLEPROC) (GLuint array);
typedef void ( * PFNGLDELETEVERTEXARRAYSAPPLEPROC) (GLsizei n, const GLuint* arrays);
typedef void ( * PFNGLGENVERTEXARRAYSAPPLEPROC) (GLsizei n, const GLuint* arrays);
typedef GLboolean ( * PFNGLISVERTEXARRAYAPPLEPROC) (GLuint array);
# 3822 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLFLUSHVERTEXARRAYRANGEAPPLEPROC) (GLsizei length, void *pointer);
typedef void ( * PFNGLVERTEXARRAYPARAMETERIAPPLEPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLVERTEXARRAYRANGEAPPLEPROC) (GLsizei length, void *pointer);
# 3850 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDISABLEVERTEXATTRIBAPPLEPROC) (GLuint index, GLenum pname);
typedef void ( * PFNGLENABLEVERTEXATTRIBAPPLEPROC) (GLuint index, GLenum pname);
typedef GLboolean ( * PFNGLISVERTEXATTRIBENABLEDAPPLEPROC) (GLuint index, GLenum pname);
typedef void ( * PFNGLMAPVERTEXATTRIB1DAPPLEPROC) (GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble* points);
typedef void ( * PFNGLMAPVERTEXATTRIB1FAPPLEPROC) (GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat* points);
typedef void ( * PFNGLMAPVERTEXATTRIB2DAPPLEPROC) (GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble* points);
typedef void ( * PFNGLMAPVERTEXATTRIB2FAPPLEPROC) (GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat* points);
# 3903 "/usr/include/GL/glew.h" 3 4
typedef int GLfixed;

typedef void ( * PFNGLCLEARDEPTHFPROC) (GLclampf d);
typedef void ( * PFNGLDEPTHRANGEFPROC) (GLclampf n, GLclampf f);
typedef void ( * PFNGLGETSHADERPRECISIONFORMATPROC) (GLenum shadertype, GLenum precisiontype, GLint* range, GLint *precision);
typedef void ( * PFNGLRELEASESHADERCOMPILERPROC) (void);
typedef void ( * PFNGLSHADERBINARYPROC) (GLsizei count, const GLuint* shaders, GLenum binaryformat, const void*binary, GLsizei length);
# 3926 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLMEMORYBARRIERBYREGIONPROC) (GLbitfield barriers);
# 3943 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLPRIMITIVEBOUNDINGBOXARBPROC) (GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW);
# 3989 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC) (GLenum mode, GLint first, GLsizei count, GLsizei primcount, GLuint baseinstance);
typedef void ( * PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount, GLuint baseinstance);
typedef void ( * PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount, GLint basevertex, GLuint baseinstance);
# 4008 "/usr/include/GL/glew.h" 3 4
typedef GLuint64 ( * PFNGLGETIMAGEHANDLEARBPROC) (GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format);
typedef GLuint64 ( * PFNGLGETTEXTUREHANDLEARBPROC) (GLuint texture);
typedef GLuint64 ( * PFNGLGETTEXTURESAMPLERHANDLEARBPROC) (GLuint texture, GLuint sampler);
typedef void ( * PFNGLGETVERTEXATTRIBLUI64VARBPROC) (GLuint index, GLenum pname, GLuint64EXT* params);
typedef GLboolean ( * PFNGLISIMAGEHANDLERESIDENTARBPROC) (GLuint64 handle);
typedef GLboolean ( * PFNGLISTEXTUREHANDLERESIDENTARBPROC) (GLuint64 handle);
typedef void ( * PFNGLMAKEIMAGEHANDLENONRESIDENTARBPROC) (GLuint64 handle);
typedef void ( * PFNGLMAKEIMAGEHANDLERESIDENTARBPROC) (GLuint64 handle, GLenum access);
typedef void ( * PFNGLMAKETEXTUREHANDLENONRESIDENTARBPROC) (GLuint64 handle);
typedef void ( * PFNGLMAKETEXTUREHANDLERESIDENTARBPROC) (GLuint64 handle);
typedef void ( * PFNGLPROGRAMUNIFORMHANDLEUI64ARBPROC) (GLuint program, GLint location, GLuint64 value);
typedef void ( * PFNGLPROGRAMUNIFORMHANDLEUI64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLuint64* values);
typedef void ( * PFNGLUNIFORMHANDLEUI64ARBPROC) (GLint location, GLuint64 value);
typedef void ( * PFNGLUNIFORMHANDLEUI64VARBPROC) (GLint location, GLsizei count, const GLuint64* value);
typedef void ( * PFNGLVERTEXATTRIBL1UI64ARBPROC) (GLuint index, GLuint64EXT x);
typedef void ( * PFNGLVERTEXATTRIBL1UI64VARBPROC) (GLuint index, const GLuint64EXT* v);
# 4056 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBINDFRAGDATALOCATIONINDEXEDPROC) (GLuint program, GLuint colorNumber, GLuint index, const GLchar * name);
typedef GLint ( * PFNGLGETFRAGDATAINDEXPROC) (GLuint program, const GLchar * name);
# 4081 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBUFFERSTORAGEPROC) (GLenum target, GLsizeiptr size, const void *data, GLbitfield flags);
# 4097 "/usr/include/GL/glew.h" 3 4
typedef struct _cl_context *cl_context;
typedef struct _cl_event *cl_event;

typedef GLsync ( * PFNGLCREATESYNCFROMCLEVENTARBPROC) (cl_context context, cl_event event, GLbitfield flags);
# 4113 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCLEARBUFFERDATAPROC) (GLenum target, GLenum internalformat, GLenum format, GLenum type, const void *data);
typedef void ( * PFNGLCLEARBUFFERSUBDATAPROC) (GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data);
typedef void ( * PFNGLCLEARNAMEDBUFFERDATAEXTPROC) (GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void *data);
typedef void ( * PFNGLCLEARNAMEDBUFFERSUBDATAEXTPROC) (GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data);
# 4134 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCLEARTEXIMAGEPROC) (GLuint texture, GLint level, GLenum format, GLenum type, const void *data);
typedef void ( * PFNGLCLEARTEXSUBIMAGEPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data);
# 4156 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCLIPCONTROLPROC) (GLenum origin, GLenum depth);
# 4175 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCLAMPCOLORARBPROC) (GLenum target, GLenum clamp);
# 4234 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDISPATCHCOMPUTEPROC) (GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z);
typedef void ( * PFNGLDISPATCHCOMPUTEINDIRECTPROC) (GLintptr indirect);
# 4254 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDISPATCHCOMPUTEGROUPSIZEARBPROC) (GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z, GLuint group_size_x, GLuint group_size_y, GLuint group_size_z);
# 4293 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCOPYBUFFERSUBDATAPROC) (GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size);
# 4306 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCOPYIMAGESUBDATAPROC) (GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);
# 4354 "/usr/include/GL/glew.h" 3 4
typedef void ( *GLDEBUGPROCARB)(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* message, const void* userParam);

typedef void ( * PFNGLDEBUGMESSAGECALLBACKARBPROC) (GLDEBUGPROCARB callback, const void *userParam);
typedef void ( * PFNGLDEBUGMESSAGECONTROLARBPROC) (GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint* ids, GLboolean enabled);
typedef void ( * PFNGLDEBUGMESSAGEINSERTARBPROC) (GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* buf);
typedef GLuint ( * PFNGLGETDEBUGMESSAGELOGARBPROC) (GLuint count, GLsizei bufSize, GLenum* sources, GLenum* types, GLuint* ids, GLenum* severities, GLsizei* lengths, GLchar* messageLog);
# 4426 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBINDTEXTUREUNITPROC) (GLuint unit, GLuint texture);
typedef void ( * PFNGLBLITNAMEDFRAMEBUFFERPROC) (GLuint readFramebuffer, GLuint drawFramebuffer, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
typedef GLenum ( * PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC) (GLuint framebuffer, GLenum target);
typedef void ( * PFNGLCLEARNAMEDBUFFERDATAPROC) (GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void *data);
typedef void ( * PFNGLCLEARNAMEDBUFFERSUBDATAPROC) (GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data);
typedef void ( * PFNGLCLEARNAMEDFRAMEBUFFERFIPROC) (GLuint framebuffer, GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil);
typedef void ( * PFNGLCLEARNAMEDFRAMEBUFFERFVPROC) (GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLfloat* value);
typedef void ( * PFNGLCLEARNAMEDFRAMEBUFFERIVPROC) (GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLint* value);
typedef void ( * PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC) (GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLuint* value);
typedef void ( * PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC) (GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOPYNAMEDBUFFERSUBDATAPROC) (GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
typedef void ( * PFNGLCOPYTEXTURESUBIMAGE1DPROC) (GLuint texture, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCOPYTEXTURESUBIMAGE2DPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLCOPYTEXTURESUBIMAGE3DPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLCREATEBUFFERSPROC) (GLsizei n, GLuint* buffers);
typedef void ( * PFNGLCREATEFRAMEBUFFERSPROC) (GLsizei n, GLuint* framebuffers);
typedef void ( * PFNGLCREATEPROGRAMPIPELINESPROC) (GLsizei n, GLuint* pipelines);
typedef void ( * PFNGLCREATEQUERIESPROC) (GLenum target, GLsizei n, GLuint* ids);
typedef void ( * PFNGLCREATERENDERBUFFERSPROC) (GLsizei n, GLuint* renderbuffers);
typedef void ( * PFNGLCREATESAMPLERSPROC) (GLsizei n, GLuint* samplers);
typedef void ( * PFNGLCREATETEXTURESPROC) (GLenum target, GLsizei n, GLuint* textures);
typedef void ( * PFNGLCREATETRANSFORMFEEDBACKSPROC) (GLsizei n, GLuint* ids);
typedef void ( * PFNGLCREATEVERTEXARRAYSPROC) (GLsizei n, GLuint* arrays);
typedef void ( * PFNGLDISABLEVERTEXARRAYATTRIBPROC) (GLuint vaobj, GLuint index);
typedef void ( * PFNGLENABLEVERTEXARRAYATTRIBPROC) (GLuint vaobj, GLuint index);
typedef void ( * PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC) (GLuint buffer, GLintptr offset, GLsizeiptr length);
typedef void ( * PFNGLGENERATETEXTUREMIPMAPPROC) (GLuint texture);
typedef void ( * PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC) (GLuint texture, GLint level, GLsizei bufSize, void *pixels);
typedef void ( * PFNGLGETNAMEDBUFFERPARAMETERI64VPROC) (GLuint buffer, GLenum pname, GLint64* params);
typedef void ( * PFNGLGETNAMEDBUFFERPARAMETERIVPROC) (GLuint buffer, GLenum pname, GLint* params);
typedef void ( * PFNGLGETNAMEDBUFFERPOINTERVPROC) (GLuint buffer, GLenum pname, void** params);
typedef void ( * PFNGLGETNAMEDBUFFERSUBDATAPROC) (GLuint buffer, GLintptr offset, GLsizeiptr size, void *data);
typedef void ( * PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC) (GLuint framebuffer, GLenum attachment, GLenum pname, GLint* params);
typedef void ( * PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC) (GLuint framebuffer, GLenum pname, GLint* param);
typedef void ( * PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC) (GLuint renderbuffer, GLenum pname, GLint* params);
typedef void ( * PFNGLGETQUERYBUFFEROBJECTI64VPROC) (GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
typedef void ( * PFNGLGETQUERYBUFFEROBJECTIVPROC) (GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
typedef void ( * PFNGLGETQUERYBUFFEROBJECTUI64VPROC) (GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
typedef void ( * PFNGLGETQUERYBUFFEROBJECTUIVPROC) (GLuint id, GLuint buffer, GLenum pname, GLintptr offset);
typedef void ( * PFNGLGETTEXTUREIMAGEPROC) (GLuint texture, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *pixels);
typedef void ( * PFNGLGETTEXTURELEVELPARAMETERFVPROC) (GLuint texture, GLint level, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETTEXTURELEVELPARAMETERIVPROC) (GLuint texture, GLint level, GLenum pname, GLint* params);
typedef void ( * PFNGLGETTEXTUREPARAMETERIIVPROC) (GLuint texture, GLenum pname, GLint* params);
typedef void ( * PFNGLGETTEXTUREPARAMETERIUIVPROC) (GLuint texture, GLenum pname, GLuint* params);
typedef void ( * PFNGLGETTEXTUREPARAMETERFVPROC) (GLuint texture, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETTEXTUREPARAMETERIVPROC) (GLuint texture, GLenum pname, GLint* params);
typedef void ( * PFNGLGETTRANSFORMFEEDBACKI64_VPROC) (GLuint xfb, GLenum pname, GLuint index, GLint64* param);
typedef void ( * PFNGLGETTRANSFORMFEEDBACKI_VPROC) (GLuint xfb, GLenum pname, GLuint index, GLint* param);
typedef void ( * PFNGLGETTRANSFORMFEEDBACKIVPROC) (GLuint xfb, GLenum pname, GLint* param);
typedef void ( * PFNGLGETVERTEXARRAYINDEXED64IVPROC) (GLuint vaobj, GLuint index, GLenum pname, GLint64* param);
typedef void ( * PFNGLGETVERTEXARRAYINDEXEDIVPROC) (GLuint vaobj, GLuint index, GLenum pname, GLint* param);
typedef void ( * PFNGLGETVERTEXARRAYIVPROC) (GLuint vaobj, GLenum pname, GLint* param);
typedef void ( * PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC) (GLuint framebuffer, GLsizei numAttachments, const GLenum* attachments);
typedef void ( * PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC) (GLuint framebuffer, GLsizei numAttachments, const GLenum* attachments, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void * ( * PFNGLMAPNAMEDBUFFERPROC) (GLuint buffer, GLenum access);
typedef void * ( * PFNGLMAPNAMEDBUFFERRANGEPROC) (GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access);
typedef void ( * PFNGLNAMEDBUFFERDATAPROC) (GLuint buffer, GLsizeiptr size, const void *data, GLenum usage);
typedef void ( * PFNGLNAMEDBUFFERSTORAGEPROC) (GLuint buffer, GLsizeiptr size, const void *data, GLbitfield flags);
typedef void ( * PFNGLNAMEDBUFFERSUBDATAPROC) (GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data);
typedef void ( * PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC) (GLuint framebuffer, GLenum mode);
typedef void ( * PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC) (GLuint framebuffer, GLsizei n, const GLenum* bufs);
typedef void ( * PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC) (GLuint framebuffer, GLenum pname, GLint param);
typedef void ( * PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC) (GLuint framebuffer, GLenum mode);
typedef void ( * PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC) (GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTUREPROC) (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level);
typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC) (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer);
typedef void ( * PFNGLNAMEDRENDERBUFFERSTORAGEPROC) (GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC) (GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLTEXTUREBUFFERPROC) (GLuint texture, GLenum internalformat, GLuint buffer);
typedef void ( * PFNGLTEXTUREBUFFERRANGEPROC) (GLuint texture, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void ( * PFNGLTEXTUREPARAMETERIIVPROC) (GLuint texture, GLenum pname, const GLint* params);
typedef void ( * PFNGLTEXTUREPARAMETERIUIVPROC) (GLuint texture, GLenum pname, const GLuint* params);
typedef void ( * PFNGLTEXTUREPARAMETERFPROC) (GLuint texture, GLenum pname, GLfloat param);
typedef void ( * PFNGLTEXTUREPARAMETERFVPROC) (GLuint texture, GLenum pname, const GLfloat* param);
typedef void ( * PFNGLTEXTUREPARAMETERIPROC) (GLuint texture, GLenum pname, GLint param);
typedef void ( * PFNGLTEXTUREPARAMETERIVPROC) (GLuint texture, GLenum pname, const GLint* param);
typedef void ( * PFNGLTEXTURESTORAGE1DPROC) (GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width);
typedef void ( * PFNGLTEXTURESTORAGE2DPROC) (GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC) (GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
typedef void ( * PFNGLTEXTURESTORAGE3DPROC) (GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
typedef void ( * PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC) (GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
typedef void ( * PFNGLTEXTURESUBIMAGE1DPROC) (GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLTEXTURESUBIMAGE2DPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLTEXTURESUBIMAGE3DPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC) (GLuint xfb, GLuint index, GLuint buffer);
typedef void ( * PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC) (GLuint xfb, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef GLboolean ( * PFNGLUNMAPNAMEDBUFFERPROC) (GLuint buffer);
typedef void ( * PFNGLVERTEXARRAYATTRIBBINDINGPROC) (GLuint vaobj, GLuint attribindex, GLuint bindingindex);
typedef void ( * PFNGLVERTEXARRAYATTRIBFORMATPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
typedef void ( * PFNGLVERTEXARRAYATTRIBIFORMATPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void ( * PFNGLVERTEXARRAYATTRIBLFORMATPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void ( * PFNGLVERTEXARRAYBINDINGDIVISORPROC) (GLuint vaobj, GLuint bindingindex, GLuint divisor);
typedef void ( * PFNGLVERTEXARRAYELEMENTBUFFERPROC) (GLuint vaobj, GLuint buffer);
typedef void ( * PFNGLVERTEXARRAYVERTEXBUFFERPROC) (GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
typedef void ( * PFNGLVERTEXARRAYVERTEXBUFFERSPROC) (GLuint vaobj, GLuint first, GLsizei count, const GLuint* buffers, const GLintptr *offsets, const GLsizei *strides);
# 4649 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDRAWBUFFERSARBPROC) (GLsizei n, const GLenum* bufs);
# 4662 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBLENDEQUATIONSEPARATEIARBPROC) (GLuint buf, GLenum modeRGB, GLenum modeAlpha);
typedef void ( * PFNGLBLENDEQUATIONIARBPROC) (GLuint buf, GLenum mode);
typedef void ( * PFNGLBLENDFUNCSEPARATEIARBPROC) (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
typedef void ( * PFNGLBLENDFUNCIARBPROC) (GLuint buf, GLenum src, GLenum dst);
# 4681 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDRAWELEMENTSBASEVERTEXPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLint basevertex);
typedef void ( * PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLint basevertex);
typedef void ( * PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices, GLint basevertex);
typedef void ( * PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC) (GLenum mode, const GLsizei* count, GLenum type, const void*const *indices, GLsizei drawcount, const GLint *basevertex);
# 4703 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDRAWARRAYSINDIRECTPROC) (GLenum mode, const void *indirect);
typedef void ( * PFNGLDRAWELEMENTSINDIRECTPROC) (GLenum mode, GLenum type, const void *indirect);
# 4844 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLFRAMEBUFFERPARAMETERIPROC) (GLenum target, GLenum pname, GLint param);
typedef void ( * PFNGLGETFRAMEBUFFERPARAMETERIVPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVEXTPROC) (GLuint framebuffer, GLenum pname, GLint* params);
typedef void ( * PFNGLNAMEDFRAMEBUFFERPARAMETERIEXTPROC) (GLuint framebuffer, GLenum pname, GLint param);
# 4938 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBINDFRAMEBUFFERPROC) (GLenum target, GLuint framebuffer);
typedef void ( * PFNGLBINDRENDERBUFFERPROC) (GLenum target, GLuint renderbuffer);
typedef void ( * PFNGLBLITFRAMEBUFFERPROC) (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
typedef GLenum ( * PFNGLCHECKFRAMEBUFFERSTATUSPROC) (GLenum target);
typedef void ( * PFNGLDELETEFRAMEBUFFERSPROC) (GLsizei n, const GLuint* framebuffers);
typedef void ( * PFNGLDELETERENDERBUFFERSPROC) (GLsizei n, const GLuint* renderbuffers);
typedef void ( * PFNGLFRAMEBUFFERRENDERBUFFERPROC) (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void ( * PFNGLFRAMEBUFFERTEXTURE1DPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void ( * PFNGLFRAMEBUFFERTEXTURE2DPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void ( * PFNGLFRAMEBUFFERTEXTURE3DPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint layer);
typedef void ( * PFNGLFRAMEBUFFERTEXTURELAYERPROC) (GLenum target,GLenum attachment, GLuint texture,GLint level,GLint layer);
typedef void ( * PFNGLGENFRAMEBUFFERSPROC) (GLsizei n, GLuint* framebuffers);
typedef void ( * PFNGLGENRENDERBUFFERSPROC) (GLsizei n, GLuint* renderbuffers);
typedef void ( * PFNGLGENERATEMIPMAPPROC) (GLenum target);
typedef void ( * PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC) (GLenum target, GLenum attachment, GLenum pname, GLint* params);
typedef void ( * PFNGLGETRENDERBUFFERPARAMETERIVPROC) (GLenum target, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISFRAMEBUFFERPROC) (GLuint framebuffer);
typedef GLboolean ( * PFNGLISRENDERBUFFERPROC) (GLuint renderbuffer);
typedef void ( * PFNGLRENDERBUFFERSTORAGEPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
# 5020 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLFRAMEBUFFERTEXTUREARBPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level);
typedef void ( * PFNGLFRAMEBUFFERTEXTUREFACEARBPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);
typedef void ( * PFNGLFRAMEBUFFERTEXTURELAYERARBPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
typedef void ( * PFNGLPROGRAMPARAMETERIARBPROC) (GLuint program, GLenum pname, GLint value);
# 5044 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETPROGRAMBINARYPROC) (GLuint program, GLsizei bufSize, GLsizei* length, GLenum *binaryFormat, void*binary);
typedef void ( * PFNGLPROGRAMBINARYPROC) (GLuint program, GLenum binaryFormat, const void *binary, GLsizei length);
typedef void ( * PFNGLPROGRAMPARAMETERIPROC) (GLuint program, GLenum pname, GLint value);
# 5061 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei bufSize, void *pixels);
typedef void ( * PFNGLGETTEXTURESUBIMAGEPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLsizei bufSize, void *pixels);
# 5079 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLSPECIALIZESHADERARBPROC) (GLuint shader, const GLchar* pEntryPoint, GLuint numSpecializationConstants, const GLuint* pConstantIndex, const GLuint* pConstantValue);
# 5121 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETUNIFORMDVPROC) (GLuint program, GLint location, GLdouble* params);
typedef void ( * PFNGLUNIFORM1DPROC) (GLint location, GLdouble x);
typedef void ( * PFNGLUNIFORM1DVPROC) (GLint location, GLsizei count, const GLdouble* value);
typedef void ( * PFNGLUNIFORM2DPROC) (GLint location, GLdouble x, GLdouble y);
typedef void ( * PFNGLUNIFORM2DVPROC) (GLint location, GLsizei count, const GLdouble* value);
typedef void ( * PFNGLUNIFORM3DPROC) (GLint location, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLUNIFORM3DVPROC) (GLint location, GLsizei count, const GLdouble* value);
typedef void ( * PFNGLUNIFORM4DPROC) (GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLUNIFORM4DVPROC) (GLint location, GLsizei count, const GLdouble* value);
typedef void ( * PFNGLUNIFORMMATRIX2DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLUNIFORMMATRIX2X3DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLUNIFORMMATRIX2X4DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLUNIFORMMATRIX3DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLUNIFORMMATRIX3X2DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLUNIFORMMATRIX3X4DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLUNIFORMMATRIX4DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLUNIFORMMATRIX4X2DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLUNIFORMMATRIX4X3DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
# 5177 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETUNIFORMI64VARBPROC) (GLuint program, GLint location, GLint64* params);
typedef void ( * PFNGLGETUNIFORMUI64VARBPROC) (GLuint program, GLint location, GLuint64* params);
typedef void ( * PFNGLGETNUNIFORMI64VARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLint64* params);
typedef void ( * PFNGLGETNUNIFORMUI64VARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLuint64* params);
typedef void ( * PFNGLPROGRAMUNIFORM1I64ARBPROC) (GLuint program, GLint location, GLint64 x);
typedef void ( * PFNGLPROGRAMUNIFORM1I64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLint64* value);
typedef void ( * PFNGLPROGRAMUNIFORM1UI64ARBPROC) (GLuint program, GLint location, GLuint64 x);
typedef void ( * PFNGLPROGRAMUNIFORM1UI64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLuint64* value);
typedef void ( * PFNGLPROGRAMUNIFORM2I64ARBPROC) (GLuint program, GLint location, GLint64 x, GLint64 y);
typedef void ( * PFNGLPROGRAMUNIFORM2I64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLint64* value);
typedef void ( * PFNGLPROGRAMUNIFORM2UI64ARBPROC) (GLuint program, GLint location, GLuint64 x, GLuint64 y);
typedef void ( * PFNGLPROGRAMUNIFORM2UI64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLuint64* value);
typedef void ( * PFNGLPROGRAMUNIFORM3I64ARBPROC) (GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z);
typedef void ( * PFNGLPROGRAMUNIFORM3I64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLint64* value);
typedef void ( * PFNGLPROGRAMUNIFORM3UI64ARBPROC) (GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z);
typedef void ( * PFNGLPROGRAMUNIFORM3UI64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLuint64* value);
typedef void ( * PFNGLPROGRAMUNIFORM4I64ARBPROC) (GLuint program, GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w);
typedef void ( * PFNGLPROGRAMUNIFORM4I64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLint64* value);
typedef void ( * PFNGLPROGRAMUNIFORM4UI64ARBPROC) (GLuint program, GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w);
typedef void ( * PFNGLPROGRAMUNIFORM4UI64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLuint64* value);
typedef void ( * PFNGLUNIFORM1I64ARBPROC) (GLint location, GLint64 x);
typedef void ( * PFNGLUNIFORM1I64VARBPROC) (GLint location, GLsizei count, const GLint64* value);
typedef void ( * PFNGLUNIFORM1UI64ARBPROC) (GLint location, GLuint64 x);
typedef void ( * PFNGLUNIFORM1UI64VARBPROC) (GLint location, GLsizei count, const GLuint64* value);
typedef void ( * PFNGLUNIFORM2I64ARBPROC) (GLint location, GLint64 x, GLint64 y);
typedef void ( * PFNGLUNIFORM2I64VARBPROC) (GLint location, GLsizei count, const GLint64* value);
typedef void ( * PFNGLUNIFORM2UI64ARBPROC) (GLint location, GLuint64 x, GLuint64 y);
typedef void ( * PFNGLUNIFORM2UI64VARBPROC) (GLint location, GLsizei count, const GLuint64* value);
typedef void ( * PFNGLUNIFORM3I64ARBPROC) (GLint location, GLint64 x, GLint64 y, GLint64 z);
typedef void ( * PFNGLUNIFORM3I64VARBPROC) (GLint location, GLsizei count, const GLint64* value);
typedef void ( * PFNGLUNIFORM3UI64ARBPROC) (GLint location, GLuint64 x, GLuint64 y, GLuint64 z);
typedef void ( * PFNGLUNIFORM3UI64VARBPROC) (GLint location, GLsizei count, const GLuint64* value);
typedef void ( * PFNGLUNIFORM4I64ARBPROC) (GLint location, GLint64 x, GLint64 y, GLint64 z, GLint64 w);
typedef void ( * PFNGLUNIFORM4I64VARBPROC) (GLint location, GLsizei count, const GLint64* value);
typedef void ( * PFNGLUNIFORM4UI64ARBPROC) (GLint location, GLuint64 x, GLuint64 y, GLuint64 z, GLuint64 w);
typedef void ( * PFNGLUNIFORM4UI64VARBPROC) (GLint location, GLsizei count, const GLuint64* value);
# 5360 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCOLORSUBTABLEPROC) (GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void *data);
typedef void ( * PFNGLCOLORTABLEPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *table);
typedef void ( * PFNGLCOLORTABLEPARAMETERFVPROC) (GLenum target, GLenum pname, const GLfloat *params);
typedef void ( * PFNGLCOLORTABLEPARAMETERIVPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void ( * PFNGLCONVOLUTIONFILTER1DPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *image);
typedef void ( * PFNGLCONVOLUTIONFILTER2DPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *image);
typedef void ( * PFNGLCONVOLUTIONPARAMETERFPROC) (GLenum target, GLenum pname, GLfloat params);
typedef void ( * PFNGLCONVOLUTIONPARAMETERFVPROC) (GLenum target, GLenum pname, const GLfloat *params);
typedef void ( * PFNGLCONVOLUTIONPARAMETERIPROC) (GLenum target, GLenum pname, GLint params);
typedef void ( * PFNGLCONVOLUTIONPARAMETERIVPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void ( * PFNGLCOPYCOLORSUBTABLEPROC) (GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCOPYCOLORTABLEPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCOPYCONVOLUTIONFILTER1DPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCOPYCONVOLUTIONFILTER2DPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLGETCOLORTABLEPROC) (GLenum target, GLenum format, GLenum type, void *table);
typedef void ( * PFNGLGETCOLORTABLEPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETCOLORTABLEPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETCONVOLUTIONFILTERPROC) (GLenum target, GLenum format, GLenum type, void *image);
typedef void ( * PFNGLGETCONVOLUTIONPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETCONVOLUTIONPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETHISTOGRAMPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, void *values);
typedef void ( * PFNGLGETHISTOGRAMPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETHISTOGRAMPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETMINMAXPROC) (GLenum target, GLboolean reset, GLenum format, GLenum types, void *values);
typedef void ( * PFNGLGETMINMAXPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETMINMAXPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETSEPARABLEFILTERPROC) (GLenum target, GLenum format, GLenum type, void *row, void *column, void *span);
typedef void ( * PFNGLHISTOGRAMPROC) (GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
typedef void ( * PFNGLMINMAXPROC) (GLenum target, GLenum internalformat, GLboolean sink);
typedef void ( * PFNGLRESETHISTOGRAMPROC) (GLenum target);
typedef void ( * PFNGLRESETMINMAXPROC) (GLenum target);
typedef void ( * PFNGLSEPARABLEFILTER2DPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *row, const void *column);
# 5438 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLMULTIDRAWARRAYSINDIRECTCOUNTARBPROC) (GLenum mode, const void *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
typedef void ( * PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTARBPROC) (GLenum mode, GLenum type, const void *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
# 5455 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDRAWARRAYSINSTANCEDARBPROC) (GLenum mode, GLint first, GLsizei count, GLsizei primcount);
typedef void ( * PFNGLDRAWELEMENTSINSTANCEDARBPROC) (GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei primcount);
typedef void ( * PFNGLVERTEXATTRIBDIVISORARBPROC) (GLuint index, GLuint divisor);
# 5474 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETINTERNALFORMATIVPROC) (GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint* params);
# 5587 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETINTERNALFORMATI64VPROC) (GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint64* params);
# 5600 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLINVALIDATEBUFFERDATAPROC) (GLuint buffer);
typedef void ( * PFNGLINVALIDATEBUFFERSUBDATAPROC) (GLuint buffer, GLintptr offset, GLsizeiptr length);
typedef void ( * PFNGLINVALIDATEFRAMEBUFFERPROC) (GLenum target, GLsizei numAttachments, const GLenum* attachments);
typedef void ( * PFNGLINVALIDATESUBFRAMEBUFFERPROC) (GLenum target, GLsizei numAttachments, const GLenum* attachments, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLINVALIDATETEXIMAGEPROC) (GLuint texture, GLint level);
typedef void ( * PFNGLINVALIDATETEXSUBIMAGEPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth);
# 5641 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLFLUSHMAPPEDBUFFERRANGEPROC) (GLenum target, GLintptr offset, GLsizeiptr length);
typedef void * ( * PFNGLMAPBUFFERRANGEPROC) (GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);
# 5667 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCURRENTPALETTEMATRIXARBPROC) (GLint index);
typedef void ( * PFNGLMATRIXINDEXPOINTERARBPROC) (GLint size, GLenum type, GLsizei stride, void *pointer);
typedef void ( * PFNGLMATRIXINDEXUBVARBPROC) (GLint size, GLubyte *indices);
typedef void ( * PFNGLMATRIXINDEXUIVARBPROC) (GLint size, GLuint *indices);
typedef void ( * PFNGLMATRIXINDEXUSVARBPROC) (GLint size, GLushort *indices);
# 5688 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBINDBUFFERSBASEPROC) (GLenum target, GLuint first, GLsizei count, const GLuint* buffers);
typedef void ( * PFNGLBINDBUFFERSRANGEPROC) (GLenum target, GLuint first, GLsizei count, const GLuint* buffers, const GLintptr *offsets, const GLsizeiptr *sizes);
typedef void ( * PFNGLBINDIMAGETEXTURESPROC) (GLuint first, GLsizei count, const GLuint* textures);
typedef void ( * PFNGLBINDSAMPLERSPROC) (GLuint first, GLsizei count, const GLuint* samplers);
typedef void ( * PFNGLBINDTEXTURESPROC) (GLuint first, GLsizei count, const GLuint* textures);
typedef void ( * PFNGLBINDVERTEXBUFFERSPROC) (GLuint first, GLsizei count, const GLuint* buffers, const GLintptr *offsets, const GLsizei *strides);
# 5711 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLMULTIDRAWARRAYSINDIRECTPROC) (GLenum mode, const void *indirect, GLsizei primcount, GLsizei stride);
typedef void ( * PFNGLMULTIDRAWELEMENTSINDIRECTPROC) (GLenum mode, GLenum type, const void *indirect, GLsizei primcount, GLsizei stride);
# 5736 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLSAMPLECOVERAGEARBPROC) (GLclampf value, GLboolean invert);
# 5785 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLACTIVETEXTUREARBPROC) (GLenum texture);
typedef void ( * PFNGLCLIENTACTIVETEXTUREARBPROC) (GLenum texture);
typedef void ( * PFNGLMULTITEXCOORD1DARBPROC) (GLenum target, GLdouble s);
typedef void ( * PFNGLMULTITEXCOORD1DVARBPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD1FARBPROC) (GLenum target, GLfloat s);
typedef void ( * PFNGLMULTITEXCOORD1FVARBPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD1IARBPROC) (GLenum target, GLint s);
typedef void ( * PFNGLMULTITEXCOORD1IVARBPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD1SARBPROC) (GLenum target, GLshort s);
typedef void ( * PFNGLMULTITEXCOORD1SVARBPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLMULTITEXCOORD2DARBPROC) (GLenum target, GLdouble s, GLdouble t);
typedef void ( * PFNGLMULTITEXCOORD2DVARBPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD2FARBPROC) (GLenum target, GLfloat s, GLfloat t);
typedef void ( * PFNGLMULTITEXCOORD2FVARBPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD2IARBPROC) (GLenum target, GLint s, GLint t);
typedef void ( * PFNGLMULTITEXCOORD2IVARBPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD2SARBPROC) (GLenum target, GLshort s, GLshort t);
typedef void ( * PFNGLMULTITEXCOORD2SVARBPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLMULTITEXCOORD3DARBPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r);
typedef void ( * PFNGLMULTITEXCOORD3DVARBPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD3FARBPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r);
typedef void ( * PFNGLMULTITEXCOORD3FVARBPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD3IARBPROC) (GLenum target, GLint s, GLint t, GLint r);
typedef void ( * PFNGLMULTITEXCOORD3IVARBPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD3SARBPROC) (GLenum target, GLshort s, GLshort t, GLshort r);
typedef void ( * PFNGLMULTITEXCOORD3SVARBPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLMULTITEXCOORD4DARBPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
typedef void ( * PFNGLMULTITEXCOORD4DVARBPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD4FARBPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
typedef void ( * PFNGLMULTITEXCOORD4FVARBPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD4IARBPROC) (GLenum target, GLint s, GLint t, GLint r, GLint q);
typedef void ( * PFNGLMULTITEXCOORD4IVARBPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD4SARBPROC) (GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
typedef void ( * PFNGLMULTITEXCOORD4SVARBPROC) (GLenum target, const GLshort *v);
# 5870 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBEGINQUERYARBPROC) (GLenum target, GLuint id);
typedef void ( * PFNGLDELETEQUERIESARBPROC) (GLsizei n, const GLuint* ids);
typedef void ( * PFNGLENDQUERYARBPROC) (GLenum target);
typedef void ( * PFNGLGENQUERIESARBPROC) (GLsizei n, GLuint* ids);
typedef void ( * PFNGLGETQUERYOBJECTIVARBPROC) (GLuint id, GLenum pname, GLint* params);
typedef void ( * PFNGLGETQUERYOBJECTUIVARBPROC) (GLuint id, GLenum pname, GLuint* params);
typedef void ( * PFNGLGETQUERYIVARBPROC) (GLenum target, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISQUERYARBPROC) (GLuint id);
# 5911 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLMAXSHADERCOMPILERTHREADSARBPROC) (GLuint count);
# 5964 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLPOINTPARAMETERFARBPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLPOINTPARAMETERFVARBPROC) (GLenum pname, const GLfloat* params);
# 5993 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLPOLYGONOFFSETCLAMPPROC) (GLfloat factor, GLfloat units, GLfloat clamp);
# 6063 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETPROGRAMINTERFACEIVPROC) (GLuint program, GLenum programInterface, GLenum pname, GLint* params);
typedef GLuint ( * PFNGLGETPROGRAMRESOURCEINDEXPROC) (GLuint program, GLenum programInterface, const GLchar* name);
typedef GLint ( * PFNGLGETPROGRAMRESOURCELOCATIONPROC) (GLuint program, GLenum programInterface, const GLchar* name);
typedef GLint ( * PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC) (GLuint program, GLenum programInterface, const GLchar* name);
typedef void ( * PFNGLGETPROGRAMRESOURCENAMEPROC) (GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei* length, GLchar *name);
typedef void ( * PFNGLGETPROGRAMRESOURCEIVPROC) (GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum* props, GLsizei bufSize, GLsizei *length, GLint *params);
# 6091 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLPROVOKINGVERTEXPROC) (GLenum mode);
# 6135 "/usr/include/GL/glew.h" 3 4
typedef GLenum ( * PFNGLGETGRAPHICSRESETSTATUSARBPROC) (void);
typedef void ( * PFNGLGETNCOLORTABLEARBPROC) (GLenum target, GLenum format, GLenum type, GLsizei bufSize, void* table);
typedef void ( * PFNGLGETNCOMPRESSEDTEXIMAGEARBPROC) (GLenum target, GLint lod, GLsizei bufSize, void* img);
typedef void ( * PFNGLGETNCONVOLUTIONFILTERARBPROC) (GLenum target, GLenum format, GLenum type, GLsizei bufSize, void* image);
typedef void ( * PFNGLGETNHISTOGRAMARBPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void* values);
typedef void ( * PFNGLGETNMAPDVARBPROC) (GLenum target, GLenum query, GLsizei bufSize, GLdouble* v);
typedef void ( * PFNGLGETNMAPFVARBPROC) (GLenum target, GLenum query, GLsizei bufSize, GLfloat* v);
typedef void ( * PFNGLGETNMAPIVARBPROC) (GLenum target, GLenum query, GLsizei bufSize, GLint* v);
typedef void ( * PFNGLGETNMINMAXARBPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void* values);
typedef void ( * PFNGLGETNPIXELMAPFVARBPROC) (GLenum map, GLsizei bufSize, GLfloat* values);
typedef void ( * PFNGLGETNPIXELMAPUIVARBPROC) (GLenum map, GLsizei bufSize, GLuint* values);
typedef void ( * PFNGLGETNPIXELMAPUSVARBPROC) (GLenum map, GLsizei bufSize, GLushort* values);
typedef void ( * PFNGLGETNPOLYGONSTIPPLEARBPROC) (GLsizei bufSize, GLubyte* pattern);
typedef void ( * PFNGLGETNSEPARABLEFILTERARBPROC) (GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, void* row, GLsizei columnBufSize, void*column, void*span);
typedef void ( * PFNGLGETNTEXIMAGEARBPROC) (GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void* img);
typedef void ( * PFNGLGETNUNIFORMDVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLdouble* params);
typedef void ( * PFNGLGETNUNIFORMFVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLfloat* params);
typedef void ( * PFNGLGETNUNIFORMIVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLint* params);
typedef void ( * PFNGLGETNUNIFORMUIVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLuint* params);
typedef void ( * PFNGLREADNPIXELSARBPROC) (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void* data);
# 6213 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLFRAMEBUFFERSAMPLELOCATIONSFVARBPROC) (GLenum target, GLuint start, GLsizei count, const GLfloat* v);
typedef void ( * PFNGLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVARBPROC) (GLuint framebuffer, GLuint start, GLsizei count, const GLfloat* v);
# 6231 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLMINSAMPLESHADINGARBPROC) (GLclampf value);
# 6246 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBINDSAMPLERPROC) (GLuint unit, GLuint sampler);
typedef void ( * PFNGLDELETESAMPLERSPROC) (GLsizei count, const GLuint * samplers);
typedef void ( * PFNGLGENSAMPLERSPROC) (GLsizei count, GLuint* samplers);
typedef void ( * PFNGLGETSAMPLERPARAMETERIIVPROC) (GLuint sampler, GLenum pname, GLint* params);
typedef void ( * PFNGLGETSAMPLERPARAMETERIUIVPROC) (GLuint sampler, GLenum pname, GLuint* params);
typedef void ( * PFNGLGETSAMPLERPARAMETERFVPROC) (GLuint sampler, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETSAMPLERPARAMETERIVPROC) (GLuint sampler, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISSAMPLERPROC) (GLuint sampler);
typedef void ( * PFNGLSAMPLERPARAMETERIIVPROC) (GLuint sampler, GLenum pname, const GLint* params);
typedef void ( * PFNGLSAMPLERPARAMETERIUIVPROC) (GLuint sampler, GLenum pname, const GLuint* params);
typedef void ( * PFNGLSAMPLERPARAMETERFPROC) (GLuint sampler, GLenum pname, GLfloat param);
typedef void ( * PFNGLSAMPLERPARAMETERFVPROC) (GLuint sampler, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLSAMPLERPARAMETERIPROC) (GLuint sampler, GLenum pname, GLint param);
typedef void ( * PFNGLSAMPLERPARAMETERIVPROC) (GLuint sampler, GLenum pname, const GLint* params);
# 6317 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLACTIVESHADERPROGRAMPROC) (GLuint pipeline, GLuint program);
typedef void ( * PFNGLBINDPROGRAMPIPELINEPROC) (GLuint pipeline);
typedef GLuint ( * PFNGLCREATESHADERPROGRAMVPROC) (GLenum type, GLsizei count, const GLchar * const * strings);
typedef void ( * PFNGLDELETEPROGRAMPIPELINESPROC) (GLsizei n, const GLuint* pipelines);
typedef void ( * PFNGLGENPROGRAMPIPELINESPROC) (GLsizei n, GLuint* pipelines);
typedef void ( * PFNGLGETPROGRAMPIPELINEINFOLOGPROC) (GLuint pipeline, GLsizei bufSize, GLsizei* length, GLchar *infoLog);
typedef void ( * PFNGLGETPROGRAMPIPELINEIVPROC) (GLuint pipeline, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISPROGRAMPIPELINEPROC) (GLuint pipeline);
typedef void ( * PFNGLPROGRAMUNIFORM1DPROC) (GLuint program, GLint location, GLdouble x);
typedef void ( * PFNGLPROGRAMUNIFORM1DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORM1FPROC) (GLuint program, GLint location, GLfloat x);
typedef void ( * PFNGLPROGRAMUNIFORM1FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORM1IPROC) (GLuint program, GLint location, GLint x);
typedef void ( * PFNGLPROGRAMUNIFORM1IVPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLPROGRAMUNIFORM1UIPROC) (GLuint program, GLint location, GLuint x);
typedef void ( * PFNGLPROGRAMUNIFORM1UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLPROGRAMUNIFORM2DPROC) (GLuint program, GLint location, GLdouble x, GLdouble y);
typedef void ( * PFNGLPROGRAMUNIFORM2DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORM2FPROC) (GLuint program, GLint location, GLfloat x, GLfloat y);
typedef void ( * PFNGLPROGRAMUNIFORM2FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORM2IPROC) (GLuint program, GLint location, GLint x, GLint y);
typedef void ( * PFNGLPROGRAMUNIFORM2IVPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLPROGRAMUNIFORM2UIPROC) (GLuint program, GLint location, GLuint x, GLuint y);
typedef void ( * PFNGLPROGRAMUNIFORM2UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLPROGRAMUNIFORM3DPROC) (GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLPROGRAMUNIFORM3DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORM3FPROC) (GLuint program, GLint location, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLPROGRAMUNIFORM3FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORM3IPROC) (GLuint program, GLint location, GLint x, GLint y, GLint z);
typedef void ( * PFNGLPROGRAMUNIFORM3IVPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLPROGRAMUNIFORM3UIPROC) (GLuint program, GLint location, GLuint x, GLuint y, GLuint z);
typedef void ( * PFNGLPROGRAMUNIFORM3UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLPROGRAMUNIFORM4DPROC) (GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLPROGRAMUNIFORM4DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORM4FPROC) (GLuint program, GLint location, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLPROGRAMUNIFORM4FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORM4IPROC) (GLuint program, GLint location, GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLPROGRAMUNIFORM4IVPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLPROGRAMUNIFORM4UIPROC) (GLuint program, GLint location, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void ( * PFNGLPROGRAMUNIFORM4UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLUSEPROGRAMSTAGESPROC) (GLuint pipeline, GLbitfield stages, GLuint program);
typedef void ( * PFNGLVALIDATEPROGRAMPIPELINEPROC) (GLuint pipeline);
# 6487 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC) (GLuint program, GLuint bufferIndex, GLenum pname, GLint* params);
# 6610 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBINDIMAGETEXTUREPROC) (GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format);
typedef void ( * PFNGLMEMORYBARRIERPROC) (GLbitfield barriers);
# 6669 "/usr/include/GL/glew.h" 3 4
typedef char GLcharARB;
typedef unsigned int GLhandleARB;

typedef void ( * PFNGLATTACHOBJECTARBPROC) (GLhandleARB containerObj, GLhandleARB obj);
typedef void ( * PFNGLCOMPILESHADERARBPROC) (GLhandleARB shaderObj);
typedef GLhandleARB ( * PFNGLCREATEPROGRAMOBJECTARBPROC) (void);
typedef GLhandleARB ( * PFNGLCREATESHADEROBJECTARBPROC) (GLenum shaderType);
typedef void ( * PFNGLDELETEOBJECTARBPROC) (GLhandleARB obj);
typedef void ( * PFNGLDETACHOBJECTARBPROC) (GLhandleARB containerObj, GLhandleARB attachedObj);
typedef void ( * PFNGLGETACTIVEUNIFORMARBPROC) (GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei* length, GLint *size, GLenum *type, GLcharARB *name);
typedef void ( * PFNGLGETATTACHEDOBJECTSARBPROC) (GLhandleARB containerObj, GLsizei maxCount, GLsizei* count, GLhandleARB *obj);
typedef GLhandleARB ( * PFNGLGETHANDLEARBPROC) (GLenum pname);
typedef void ( * PFNGLGETINFOLOGARBPROC) (GLhandleARB obj, GLsizei maxLength, GLsizei* length, GLcharARB *infoLog);
typedef void ( * PFNGLGETOBJECTPARAMETERFVARBPROC) (GLhandleARB obj, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETOBJECTPARAMETERIVARBPROC) (GLhandleARB obj, GLenum pname, GLint* params);
typedef void ( * PFNGLGETSHADERSOURCEARBPROC) (GLhandleARB obj, GLsizei maxLength, GLsizei* length, GLcharARB *source);
typedef GLint ( * PFNGLGETUNIFORMLOCATIONARBPROC) (GLhandleARB programObj, const GLcharARB* name);
typedef void ( * PFNGLGETUNIFORMFVARBPROC) (GLhandleARB programObj, GLint location, GLfloat* params);
typedef void ( * PFNGLGETUNIFORMIVARBPROC) (GLhandleARB programObj, GLint location, GLint* params);
typedef void ( * PFNGLLINKPROGRAMARBPROC) (GLhandleARB programObj);
typedef void ( * PFNGLSHADERSOURCEARBPROC) (GLhandleARB shaderObj, GLsizei count, const GLcharARB ** string, const GLint *length);
typedef void ( * PFNGLUNIFORM1FARBPROC) (GLint location, GLfloat v0);
typedef void ( * PFNGLUNIFORM1FVARBPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLUNIFORM1IARBPROC) (GLint location, GLint v0);
typedef void ( * PFNGLUNIFORM1IVARBPROC) (GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLUNIFORM2FARBPROC) (GLint location, GLfloat v0, GLfloat v1);
typedef void ( * PFNGLUNIFORM2FVARBPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLUNIFORM2IARBPROC) (GLint location, GLint v0, GLint v1);
typedef void ( * PFNGLUNIFORM2IVARBPROC) (GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLUNIFORM3FARBPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void ( * PFNGLUNIFORM3FVARBPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLUNIFORM3IARBPROC) (GLint location, GLint v0, GLint v1, GLint v2);
typedef void ( * PFNGLUNIFORM3IVARBPROC) (GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLUNIFORM4FARBPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void ( * PFNGLUNIFORM4FVARBPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLUNIFORM4IARBPROC) (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void ( * PFNGLUNIFORM4IVARBPROC) (GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLUNIFORMMATRIX2FVARBPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLUNIFORMMATRIX3FVARBPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLUNIFORMMATRIX4FVARBPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLUSEPROGRAMOBJECTARBPROC) (GLhandleARB programObj);
typedef void ( * PFNGLVALIDATEPROGRAMARBPROC) (GLhandleARB programObj);
# 6796 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLSHADERSTORAGEBLOCKBINDINGPROC) (GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding);
# 6819 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETACTIVESUBROUTINENAMEPROC) (GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei* length, GLchar *name);
typedef void ( * PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC) (GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei* length, GLchar *name);
typedef void ( * PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC) (GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint* values);
typedef void ( * PFNGLGETPROGRAMSTAGEIVPROC) (GLuint program, GLenum shadertype, GLenum pname, GLint* values);
typedef GLuint ( * PFNGLGETSUBROUTINEINDEXPROC) (GLuint program, GLenum shadertype, const GLchar* name);
typedef GLint ( * PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC) (GLuint program, GLenum shadertype, const GLchar* name);
typedef void ( * PFNGLGETUNIFORMSUBROUTINEUIVPROC) (GLenum shadertype, GLint location, GLuint* params);
typedef void ( * PFNGLUNIFORMSUBROUTINESUIVPROC) (GLenum shadertype, GLsizei count, const GLuint* indices);
# 6897 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCOMPILESHADERINCLUDEARBPROC) (GLuint shader, GLsizei count, const GLchar* const *path, const GLint *length);
typedef void ( * PFNGLDELETENAMEDSTRINGARBPROC) (GLint namelen, const GLchar* name);
typedef void ( * PFNGLGETNAMEDSTRINGARBPROC) (GLint namelen, const GLchar* name, GLsizei bufSize, GLint *stringlen, GLchar *string);
typedef void ( * PFNGLGETNAMEDSTRINGIVARBPROC) (GLint namelen, const GLchar* name, GLenum pname, GLint *params);
typedef GLboolean ( * PFNGLISNAMEDSTRINGARBPROC) (GLint namelen, const GLchar* name);
typedef void ( * PFNGLNAMEDSTRINGARBPROC) (GLenum type, GLint namelen, const GLchar* name, GLint stringlen, const GLchar *string);
# 6956 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBUFFERPAGECOMMITMENTARBPROC) (GLenum target, GLintptr offset, GLsizeiptr size, GLboolean commit);
# 6981 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLTEXPAGECOMMITMENTARBPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit);
# 7051 "/usr/include/GL/glew.h" 3 4
typedef GLenum ( * PFNGLCLIENTWAITSYNCPROC) (GLsync GLsync,GLbitfield flags,GLuint64 timeout);
typedef void ( * PFNGLDELETESYNCPROC) (GLsync GLsync);
typedef GLsync ( * PFNGLFENCESYNCPROC) (GLenum condition,GLbitfield flags);
typedef void ( * PFNGLGETINTEGER64VPROC) (GLenum pname, GLint64* params);
typedef void ( * PFNGLGETSYNCIVPROC) (GLsync GLsync,GLenum pname,GLsizei bufSize,GLsizei* length, GLint *values);
typedef GLboolean ( * PFNGLISSYNCPROC) (GLsync GLsync);
typedef void ( * PFNGLWAITSYNCPROC) (GLsync GLsync,GLbitfield flags,GLuint64 timeout);
# 7109 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLPATCHPARAMETERFVPROC) (GLenum pname, const GLfloat* values);
typedef void ( * PFNGLPATCHPARAMETERIPROC) (GLenum pname, GLint value);
# 7124 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLTEXTUREBARRIERPROC) (void);
# 7154 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLTEXBUFFERARBPROC) (GLenum target, GLenum internalformat, GLuint buffer);
# 7180 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLTEXBUFFERRANGEPROC) (GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void ( * PFNGLTEXTUREBUFFERRANGEEXTPROC) (GLuint texture, GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
# 7207 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCOMPRESSEDTEXIMAGE1DARBPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXIMAGE2DARBPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXIMAGE3DARBPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE1DARBPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE2DARBPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE3DARBPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
typedef void ( * PFNGLGETCOMPRESSEDTEXIMAGEARBPROC) (GLenum target, GLint lod, void *img);
# 7472 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETMULTISAMPLEFVPROC) (GLenum pname, GLuint index, GLfloat* val);
typedef void ( * PFNGLSAMPLEMASKIPROC) (GLuint index, GLbitfield mask);
typedef void ( * PFNGLTEXIMAGE2DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
typedef void ( * PFNGLTEXIMAGE3DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
# 7593 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLTEXSTORAGE1DPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
typedef void ( * PFNGLTEXSTORAGE2DPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLTEXSTORAGE3DPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
# 7610 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLTEXSTORAGE2DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
typedef void ( * PFNGLTEXSTORAGE3DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
typedef void ( * PFNGLTEXTURESTORAGE2DMULTISAMPLEEXTPROC) (GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
typedef void ( * PFNGLTEXTURESTORAGE3DMULTISAMPLEEXTPROC) (GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
# 7650 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLTEXTUREVIEWPROC) (GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers);
# 7666 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETQUERYOBJECTI64VPROC) (GLuint id, GLenum pname, GLint64* params);
typedef void ( * PFNGLGETQUERYOBJECTUI64VPROC) (GLuint id, GLenum pname, GLuint64* params);
typedef void ( * PFNGLQUERYCOUNTERPROC) (GLuint id, GLenum target);
# 7688 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBINDTRANSFORMFEEDBACKPROC) (GLenum target, GLuint id);
typedef void ( * PFNGLDELETETRANSFORMFEEDBACKSPROC) (GLsizei n, const GLuint* ids);
typedef void ( * PFNGLDRAWTRANSFORMFEEDBACKPROC) (GLenum mode, GLuint id);
typedef void ( * PFNGLGENTRANSFORMFEEDBACKSPROC) (GLsizei n, GLuint* ids);
typedef GLboolean ( * PFNGLISTRANSFORMFEEDBACKPROC) (GLuint id);
typedef void ( * PFNGLPAUSETRANSFORMFEEDBACKPROC) (void);
typedef void ( * PFNGLRESUMETRANSFORMFEEDBACKPROC) (void);
# 7716 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBEGINQUERYINDEXEDPROC) (GLenum target, GLuint index, GLuint id);
typedef void ( * PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC) (GLenum mode, GLuint id, GLuint stream);
typedef void ( * PFNGLENDQUERYINDEXEDPROC) (GLenum target, GLuint index);
typedef void ( * PFNGLGETQUERYINDEXEDIVPROC) (GLenum target, GLuint index, GLenum pname, GLint* params);
# 7735 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC) (GLenum mode, GLuint id, GLsizei primcount);
typedef void ( * PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC) (GLenum mode, GLuint id, GLuint stream, GLsizei primcount);
# 7767 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLLOADTRANSPOSEMATRIXDARBPROC) (GLdouble m[16]);
typedef void ( * PFNGLLOADTRANSPOSEMATRIXFARBPROC) (GLfloat m[16]);
typedef void ( * PFNGLMULTTRANSPOSEMATRIXDARBPROC) (GLdouble m[16]);
typedef void ( * PFNGLMULTTRANSPOSEMATRIXFARBPROC) (GLfloat m[16]);
# 7820 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBINDBUFFERBASEPROC) (GLenum target, GLuint index, GLuint buffer);
typedef void ( * PFNGLBINDBUFFERRANGEPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void ( * PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC) (GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei* length, GLchar* uniformBlockName);
typedef void ( * PFNGLGETACTIVEUNIFORMBLOCKIVPROC) (GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint* params);
typedef void ( * PFNGLGETACTIVEUNIFORMNAMEPROC) (GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei* length, GLchar* uniformName);
typedef void ( * PFNGLGETACTIVEUNIFORMSIVPROC) (GLuint program, GLsizei uniformCount, const GLuint* uniformIndices, GLenum pname, GLint* params);
typedef void ( * PFNGLGETINTEGERI_VPROC) (GLenum target, GLuint index, GLint* data);
typedef GLuint ( * PFNGLGETUNIFORMBLOCKINDEXPROC) (GLuint program, const GLchar* uniformBlockName);
typedef void ( * PFNGLGETUNIFORMINDICESPROC) (GLuint program, GLsizei uniformCount, const GLchar* const * uniformNames, GLuint* uniformIndices);
typedef void ( * PFNGLUNIFORMBLOCKBINDINGPROC) (GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);
# 7864 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBINDVERTEXARRAYPROC) (GLuint array);
typedef void ( * PFNGLDELETEVERTEXARRAYSPROC) (GLsizei n, const GLuint* arrays);
typedef void ( * PFNGLGENVERTEXARRAYSPROC) (GLsizei n, GLuint* arrays);
typedef GLboolean ( * PFNGLISVERTEXARRAYPROC) (GLuint array);
# 7883 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETVERTEXATTRIBLDVPROC) (GLuint index, GLenum pname, GLdouble* params);
typedef void ( * PFNGLVERTEXATTRIBL1DPROC) (GLuint index, GLdouble x);
typedef void ( * PFNGLVERTEXATTRIBL1DVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBL2DPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void ( * PFNGLVERTEXATTRIBL2DVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBL3DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLVERTEXATTRIBL3DVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBL4DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLVERTEXATTRIBL4DVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBLPOINTERPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const void* pointer);
# 7923 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBINDVERTEXBUFFERPROC) (GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
typedef void ( * PFNGLVERTEXARRAYBINDVERTEXBUFFEREXTPROC) (GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
typedef void ( * PFNGLVERTEXARRAYVERTEXATTRIBBINDINGEXTPROC) (GLuint vaobj, GLuint attribindex, GLuint bindingindex);
typedef void ( * PFNGLVERTEXARRAYVERTEXATTRIBFORMATEXTPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
typedef void ( * PFNGLVERTEXARRAYVERTEXATTRIBIFORMATEXTPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void ( * PFNGLVERTEXARRAYVERTEXATTRIBLFORMATEXTPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void ( * PFNGLVERTEXARRAYVERTEXBINDINGDIVISOREXTPROC) (GLuint vaobj, GLuint bindingindex, GLuint divisor);
typedef void ( * PFNGLVERTEXATTRIBBINDINGPROC) (GLuint attribindex, GLuint bindingindex);
typedef void ( * PFNGLVERTEXATTRIBFORMATPROC) (GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
typedef void ( * PFNGLVERTEXATTRIBIFORMATPROC) (GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void ( * PFNGLVERTEXATTRIBLFORMATPROC) (GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void ( * PFNGLVERTEXBINDINGDIVISORPROC) (GLuint bindingindex, GLuint divisor);
# 8001 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLVERTEXBLENDARBPROC) (GLint count);
typedef void ( * PFNGLWEIGHTPOINTERARBPROC) (GLint size, GLenum type, GLsizei stride, void *pointer);
typedef void ( * PFNGLWEIGHTBVARBPROC) (GLint size, GLbyte *weights);
typedef void ( * PFNGLWEIGHTDVARBPROC) (GLint size, GLdouble *weights);
typedef void ( * PFNGLWEIGHTFVARBPROC) (GLint size, GLfloat *weights);
typedef void ( * PFNGLWEIGHTIVARBPROC) (GLint size, GLint *weights);
typedef void ( * PFNGLWEIGHTSVARBPROC) (GLint size, GLshort *weights);
typedef void ( * PFNGLWEIGHTUBVARBPROC) (GLint size, GLubyte *weights);
typedef void ( * PFNGLWEIGHTUIVARBPROC) (GLint size, GLuint *weights);
typedef void ( * PFNGLWEIGHTUSVARBPROC) (GLint size, GLushort *weights);
# 8064 "/usr/include/GL/glew.h" 3 4
typedef ptrdiff_t GLintptrARB;
typedef ptrdiff_t GLsizeiptrARB;

typedef void ( * PFNGLBINDBUFFERARBPROC) (GLenum target, GLuint buffer);
typedef void ( * PFNGLBUFFERDATAARBPROC) (GLenum target, GLsizeiptrARB size, const void *data, GLenum usage);
typedef void ( * PFNGLBUFFERSUBDATAARBPROC) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, const void *data);
typedef void ( * PFNGLDELETEBUFFERSARBPROC) (GLsizei n, const GLuint* buffers);
typedef void ( * PFNGLGENBUFFERSARBPROC) (GLsizei n, GLuint* buffers);
typedef void ( * PFNGLGETBUFFERPARAMETERIVARBPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETBUFFERPOINTERVARBPROC) (GLenum target, GLenum pname, void** params);
typedef void ( * PFNGLGETBUFFERSUBDATAARBPROC) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, void *data);
typedef GLboolean ( * PFNGLISBUFFERARBPROC) (GLuint buffer);
typedef void * ( * PFNGLMAPBUFFERARBPROC) (GLenum target, GLenum access);
typedef GLboolean ( * PFNGLUNMAPBUFFERARBPROC) (GLenum target);
# 8180 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBINDPROGRAMARBPROC) (GLenum target, GLuint program);
typedef void ( * PFNGLDELETEPROGRAMSARBPROC) (GLsizei n, const GLuint* programs);
typedef void ( * PFNGLDISABLEVERTEXATTRIBARRAYARBPROC) (GLuint index);
typedef void ( * PFNGLENABLEVERTEXATTRIBARRAYARBPROC) (GLuint index);
typedef void ( * PFNGLGENPROGRAMSARBPROC) (GLsizei n, GLuint* programs);
typedef void ( * PFNGLGETPROGRAMENVPARAMETERDVARBPROC) (GLenum target, GLuint index, GLdouble* params);
typedef void ( * PFNGLGETPROGRAMENVPARAMETERFVARBPROC) (GLenum target, GLuint index, GLfloat* params);
typedef void ( * PFNGLGETPROGRAMLOCALPARAMETERDVARBPROC) (GLenum target, GLuint index, GLdouble* params);
typedef void ( * PFNGLGETPROGRAMLOCALPARAMETERFVARBPROC) (GLenum target, GLuint index, GLfloat* params);
typedef void ( * PFNGLGETPROGRAMSTRINGARBPROC) (GLenum target, GLenum pname, void *string);
typedef void ( * PFNGLGETPROGRAMIVARBPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETVERTEXATTRIBPOINTERVARBPROC) (GLuint index, GLenum pname, void** pointer);
typedef void ( * PFNGLGETVERTEXATTRIBDVARBPROC) (GLuint index, GLenum pname, GLdouble* params);
typedef void ( * PFNGLGETVERTEXATTRIBFVARBPROC) (GLuint index, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETVERTEXATTRIBIVARBPROC) (GLuint index, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISPROGRAMARBPROC) (GLuint program);
typedef void ( * PFNGLPROGRAMENVPARAMETER4DARBPROC) (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLPROGRAMENVPARAMETER4DVARBPROC) (GLenum target, GLuint index, const GLdouble* params);
typedef void ( * PFNGLPROGRAMENVPARAMETER4FARBPROC) (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLPROGRAMENVPARAMETER4FVARBPROC) (GLenum target, GLuint index, const GLfloat* params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETER4DARBPROC) (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLPROGRAMLOCALPARAMETER4DVARBPROC) (GLenum target, GLuint index, const GLdouble* params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETER4FARBPROC) (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLPROGRAMLOCALPARAMETER4FVARBPROC) (GLenum target, GLuint index, const GLfloat* params);
typedef void ( * PFNGLPROGRAMSTRINGARBPROC) (GLenum target, GLenum format, GLsizei len, const void *string);
typedef void ( * PFNGLVERTEXATTRIB1DARBPROC) (GLuint index, GLdouble x);
typedef void ( * PFNGLVERTEXATTRIB1DVARBPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB1FARBPROC) (GLuint index, GLfloat x);
typedef void ( * PFNGLVERTEXATTRIB1FVARBPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB1SARBPROC) (GLuint index, GLshort x);
typedef void ( * PFNGLVERTEXATTRIB1SVARBPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB2DARBPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void ( * PFNGLVERTEXATTRIB2DVARBPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB2FARBPROC) (GLuint index, GLfloat x, GLfloat y);
typedef void ( * PFNGLVERTEXATTRIB2FVARBPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB2SARBPROC) (GLuint index, GLshort x, GLshort y);
typedef void ( * PFNGLVERTEXATTRIB2SVARBPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB3DARBPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLVERTEXATTRIB3DVARBPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB3FARBPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLVERTEXATTRIB3FVARBPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB3SARBPROC) (GLuint index, GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLVERTEXATTRIB3SVARBPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB4NBVARBPROC) (GLuint index, const GLbyte* v);
typedef void ( * PFNGLVERTEXATTRIB4NIVARBPROC) (GLuint index, const GLint* v);
typedef void ( * PFNGLVERTEXATTRIB4NSVARBPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB4NUBARBPROC) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
typedef void ( * PFNGLVERTEXATTRIB4NUBVARBPROC) (GLuint index, const GLubyte* v);
typedef void ( * PFNGLVERTEXATTRIB4NUIVARBPROC) (GLuint index, const GLuint* v);
typedef void ( * PFNGLVERTEXATTRIB4NUSVARBPROC) (GLuint index, const GLushort* v);
typedef void ( * PFNGLVERTEXATTRIB4BVARBPROC) (GLuint index, const GLbyte* v);
typedef void ( * PFNGLVERTEXATTRIB4DARBPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLVERTEXATTRIB4DVARBPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB4FARBPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLVERTEXATTRIB4FVARBPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB4IVARBPROC) (GLuint index, const GLint* v);
typedef void ( * PFNGLVERTEXATTRIB4SARBPROC) (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void ( * PFNGLVERTEXATTRIB4SVARBPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB4UBVARBPROC) (GLuint index, const GLubyte* v);
typedef void ( * PFNGLVERTEXATTRIB4UIVARBPROC) (GLuint index, const GLuint* v);
typedef void ( * PFNGLVERTEXATTRIB4USVARBPROC) (GLuint index, const GLushort* v);
typedef void ( * PFNGLVERTEXATTRIBPOINTERARBPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *pointer);
# 8323 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBINDATTRIBLOCATIONARBPROC) (GLhandleARB programObj, GLuint index, const GLcharARB* name);
typedef void ( * PFNGLGETACTIVEATTRIBARBPROC) (GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei* length, GLint *size, GLenum *type, GLcharARB *name);
typedef GLint ( * PFNGLGETATTRIBLOCATIONARBPROC) (GLhandleARB programObj, const GLcharARB* name);
# 8354 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCOLORP3UIPROC) (GLenum type, GLuint color);
typedef void ( * PFNGLCOLORP3UIVPROC) (GLenum type, const GLuint* color);
typedef void ( * PFNGLCOLORP4UIPROC) (GLenum type, GLuint color);
typedef void ( * PFNGLCOLORP4UIVPROC) (GLenum type, const GLuint* color);
typedef void ( * PFNGLMULTITEXCOORDP1UIPROC) (GLenum texture, GLenum type, GLuint coords);
typedef void ( * PFNGLMULTITEXCOORDP1UIVPROC) (GLenum texture, GLenum type, const GLuint* coords);
typedef void ( * PFNGLMULTITEXCOORDP2UIPROC) (GLenum texture, GLenum type, GLuint coords);
typedef void ( * PFNGLMULTITEXCOORDP2UIVPROC) (GLenum texture, GLenum type, const GLuint* coords);
typedef void ( * PFNGLMULTITEXCOORDP3UIPROC) (GLenum texture, GLenum type, GLuint coords);
typedef void ( * PFNGLMULTITEXCOORDP3UIVPROC) (GLenum texture, GLenum type, const GLuint* coords);
typedef void ( * PFNGLMULTITEXCOORDP4UIPROC) (GLenum texture, GLenum type, GLuint coords);
typedef void ( * PFNGLMULTITEXCOORDP4UIVPROC) (GLenum texture, GLenum type, const GLuint* coords);
typedef void ( * PFNGLNORMALP3UIPROC) (GLenum type, GLuint coords);
typedef void ( * PFNGLNORMALP3UIVPROC) (GLenum type, const GLuint* coords);
typedef void ( * PFNGLSECONDARYCOLORP3UIPROC) (GLenum type, GLuint color);
typedef void ( * PFNGLSECONDARYCOLORP3UIVPROC) (GLenum type, const GLuint* color);
typedef void ( * PFNGLTEXCOORDP1UIPROC) (GLenum type, GLuint coords);
typedef void ( * PFNGLTEXCOORDP1UIVPROC) (GLenum type, const GLuint* coords);
typedef void ( * PFNGLTEXCOORDP2UIPROC) (GLenum type, GLuint coords);
typedef void ( * PFNGLTEXCOORDP2UIVPROC) (GLenum type, const GLuint* coords);
typedef void ( * PFNGLTEXCOORDP3UIPROC) (GLenum type, GLuint coords);
typedef void ( * PFNGLTEXCOORDP3UIVPROC) (GLenum type, const GLuint* coords);
typedef void ( * PFNGLTEXCOORDP4UIPROC) (GLenum type, GLuint coords);
typedef void ( * PFNGLTEXCOORDP4UIVPROC) (GLenum type, const GLuint* coords);
typedef void ( * PFNGLVERTEXATTRIBP1UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void ( * PFNGLVERTEXATTRIBP1UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint* value);
typedef void ( * PFNGLVERTEXATTRIBP2UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void ( * PFNGLVERTEXATTRIBP2UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint* value);
typedef void ( * PFNGLVERTEXATTRIBP3UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void ( * PFNGLVERTEXATTRIBP3UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint* value);
typedef void ( * PFNGLVERTEXATTRIBP4UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void ( * PFNGLVERTEXATTRIBP4UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint* value);
typedef void ( * PFNGLVERTEXP2UIPROC) (GLenum type, GLuint value);
typedef void ( * PFNGLVERTEXP2UIVPROC) (GLenum type, const GLuint* value);
typedef void ( * PFNGLVERTEXP3UIPROC) (GLenum type, GLuint value);
typedef void ( * PFNGLVERTEXP3UIVPROC) (GLenum type, const GLuint* value);
typedef void ( * PFNGLVERTEXP4UIPROC) (GLenum type, GLuint value);
typedef void ( * PFNGLVERTEXP4UIVPROC) (GLenum type, const GLuint* value);
# 8455 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDEPTHRANGEARRAYVPROC) (GLuint first, GLsizei count, const GLclampd * v);
typedef void ( * PFNGLDEPTHRANGEINDEXEDPROC) (GLuint index, GLclampd n, GLclampd f);
typedef void ( * PFNGLGETDOUBLEI_VPROC) (GLenum target, GLuint index, GLdouble* data);
typedef void ( * PFNGLGETFLOATI_VPROC) (GLenum target, GLuint index, GLfloat* data);
typedef void ( * PFNGLSCISSORARRAYVPROC) (GLuint first, GLsizei count, const GLint * v);
typedef void ( * PFNGLSCISSORINDEXEDPROC) (GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height);
typedef void ( * PFNGLSCISSORINDEXEDVPROC) (GLuint index, const GLint * v);
typedef void ( * PFNGLVIEWPORTARRAYVPROC) (GLuint first, GLsizei count, const GLfloat * v);
typedef void ( * PFNGLVIEWPORTINDEXEDFPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h);
typedef void ( * PFNGLVIEWPORTINDEXEDFVPROC) (GLuint index, const GLfloat * v);
# 8486 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLWINDOWPOS2DARBPROC) (GLdouble x, GLdouble y);
typedef void ( * PFNGLWINDOWPOS2DVARBPROC) (const GLdouble* p);
typedef void ( * PFNGLWINDOWPOS2FARBPROC) (GLfloat x, GLfloat y);
typedef void ( * PFNGLWINDOWPOS2FVARBPROC) (const GLfloat* p);
typedef void ( * PFNGLWINDOWPOS2IARBPROC) (GLint x, GLint y);
typedef void ( * PFNGLWINDOWPOS2IVARBPROC) (const GLint* p);
typedef void ( * PFNGLWINDOWPOS2SARBPROC) (GLshort x, GLshort y);
typedef void ( * PFNGLWINDOWPOS2SVARBPROC) (const GLshort* p);
typedef void ( * PFNGLWINDOWPOS3DARBPROC) (GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLWINDOWPOS3DVARBPROC) (const GLdouble* p);
typedef void ( * PFNGLWINDOWPOS3FARBPROC) (GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLWINDOWPOS3FVARBPROC) (const GLfloat* p);
typedef void ( * PFNGLWINDOWPOS3IARBPROC) (GLint x, GLint y, GLint z);
typedef void ( * PFNGLWINDOWPOS3IVARBPROC) (const GLint* p);
typedef void ( * PFNGLWINDOWPOS3SARBPROC) (GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLWINDOWPOS3SVARBPROC) (const GLshort* p);
# 8665 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDRAWBUFFERSATIPROC) (GLsizei n, const GLenum* bufs);
# 8682 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDRAWELEMENTARRAYATIPROC) (GLenum mode, GLsizei count);
typedef void ( * PFNGLDRAWRANGEELEMENTARRAYATIPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count);
typedef void ( * PFNGLELEMENTPOINTERATIPROC) (GLenum type, const void *pointer);
# 8708 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETTEXBUMPPARAMETERFVATIPROC) (GLenum pname, GLfloat *param);
typedef void ( * PFNGLGETTEXBUMPPARAMETERIVATIPROC) (GLenum pname, GLint *param);
typedef void ( * PFNGLTEXBUMPPARAMETERFVATIPROC) (GLenum pname, GLfloat *param);
typedef void ( * PFNGLTEXBUMPPARAMETERIVATIPROC) (GLenum pname, GLint *param);
# 8782 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLALPHAFRAGMENTOP1ATIPROC) (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod);
typedef void ( * PFNGLALPHAFRAGMENTOP2ATIPROC) (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod);
typedef void ( * PFNGLALPHAFRAGMENTOP3ATIPROC) (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod);
typedef void ( * PFNGLBEGINFRAGMENTSHADERATIPROC) (void);
typedef void ( * PFNGLBINDFRAGMENTSHADERATIPROC) (GLuint id);
typedef void ( * PFNGLCOLORFRAGMENTOP1ATIPROC) (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod);
typedef void ( * PFNGLCOLORFRAGMENTOP2ATIPROC) (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod);
typedef void ( * PFNGLCOLORFRAGMENTOP3ATIPROC) (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod);
typedef void ( * PFNGLDELETEFRAGMENTSHADERATIPROC) (GLuint id);
typedef void ( * PFNGLENDFRAGMENTSHADERATIPROC) (void);
typedef GLuint ( * PFNGLGENFRAGMENTSHADERSATIPROC) (GLuint range);
typedef void ( * PFNGLPASSTEXCOORDATIPROC) (GLuint dst, GLuint coord, GLenum swizzle);
typedef void ( * PFNGLSAMPLEMAPATIPROC) (GLuint dst, GLuint interp, GLenum swizzle);
typedef void ( * PFNGLSETFRAGMENTSHADERCONSTANTATIPROC) (GLuint dst, const GLfloat* value);
# 8821 "/usr/include/GL/glew.h" 3 4
typedef void * ( * PFNGLMAPOBJECTBUFFERATIPROC) (GLuint buffer);
typedef void ( * PFNGLUNMAPOBJECTBUFFERATIPROC) (GLuint buffer);
# 8859 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLPNTRIANGLESFATIPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLPNTRIANGLESIATIPROC) (GLenum pname, GLint param);
# 8879 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLSTENCILFUNCSEPARATEATIPROC) (GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask);
typedef void ( * PFNGLSTENCILOPSEPARATEATIPROC) (GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
# 8981 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLARRAYOBJECTATIPROC) (GLenum array, GLint size, GLenum type, GLsizei stride, GLuint buffer, GLuint offset);
typedef void ( * PFNGLFREEOBJECTBUFFERATIPROC) (GLuint buffer);
typedef void ( * PFNGLGETARRAYOBJECTFVATIPROC) (GLenum array, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETARRAYOBJECTIVATIPROC) (GLenum array, GLenum pname, GLint* params);
typedef void ( * PFNGLGETOBJECTBUFFERFVATIPROC) (GLuint buffer, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETOBJECTBUFFERIVATIPROC) (GLuint buffer, GLenum pname, GLint* params);
typedef void ( * PFNGLGETVARIANTARRAYOBJECTFVATIPROC) (GLuint id, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETVARIANTARRAYOBJECTIVATIPROC) (GLuint id, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISOBJECTBUFFERATIPROC) (GLuint buffer);
typedef GLuint ( * PFNGLNEWOBJECTBUFFERATIPROC) (GLsizei size, const void *pointer, GLenum usage);
typedef void ( * PFNGLUPDATEOBJECTBUFFERATIPROC) (GLuint buffer, GLuint offset, GLsizei size, const void *pointer, GLenum preserve);
typedef void ( * PFNGLVARIANTARRAYOBJECTATIPROC) (GLuint id, GLenum type, GLsizei stride, GLuint buffer, GLuint offset);
# 9016 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETVERTEXATTRIBARRAYOBJECTFVATIPROC) (GLuint index, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETVERTEXATTRIBARRAYOBJECTIVATIPROC) (GLuint index, GLenum pname, GLint* params);
typedef void ( * PFNGLVERTEXATTRIBARRAYOBJECTATIPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint buffer, GLuint offset);
# 9044 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCLIENTACTIVEVERTEXSTREAMATIPROC) (GLenum stream);
typedef void ( * PFNGLNORMALSTREAM3BATIPROC) (GLenum stream, GLbyte x, GLbyte y, GLbyte z);
typedef void ( * PFNGLNORMALSTREAM3BVATIPROC) (GLenum stream, const GLbyte *coords);
typedef void ( * PFNGLNORMALSTREAM3DATIPROC) (GLenum stream, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLNORMALSTREAM3DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void ( * PFNGLNORMALSTREAM3FATIPROC) (GLenum stream, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLNORMALSTREAM3FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void ( * PFNGLNORMALSTREAM3IATIPROC) (GLenum stream, GLint x, GLint y, GLint z);
typedef void ( * PFNGLNORMALSTREAM3IVATIPROC) (GLenum stream, const GLint *coords);
typedef void ( * PFNGLNORMALSTREAM3SATIPROC) (GLenum stream, GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLNORMALSTREAM3SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void ( * PFNGLVERTEXBLENDENVFATIPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLVERTEXBLENDENVIATIPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLVERTEXSTREAM1DATIPROC) (GLenum stream, GLdouble x);
typedef void ( * PFNGLVERTEXSTREAM1DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void ( * PFNGLVERTEXSTREAM1FATIPROC) (GLenum stream, GLfloat x);
typedef void ( * PFNGLVERTEXSTREAM1FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void ( * PFNGLVERTEXSTREAM1IATIPROC) (GLenum stream, GLint x);
typedef void ( * PFNGLVERTEXSTREAM1IVATIPROC) (GLenum stream, const GLint *coords);
typedef void ( * PFNGLVERTEXSTREAM1SATIPROC) (GLenum stream, GLshort x);
typedef void ( * PFNGLVERTEXSTREAM1SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void ( * PFNGLVERTEXSTREAM2DATIPROC) (GLenum stream, GLdouble x, GLdouble y);
typedef void ( * PFNGLVERTEXSTREAM2DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void ( * PFNGLVERTEXSTREAM2FATIPROC) (GLenum stream, GLfloat x, GLfloat y);
typedef void ( * PFNGLVERTEXSTREAM2FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void ( * PFNGLVERTEXSTREAM2IATIPROC) (GLenum stream, GLint x, GLint y);
typedef void ( * PFNGLVERTEXSTREAM2IVATIPROC) (GLenum stream, const GLint *coords);
typedef void ( * PFNGLVERTEXSTREAM2SATIPROC) (GLenum stream, GLshort x, GLshort y);
typedef void ( * PFNGLVERTEXSTREAM2SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void ( * PFNGLVERTEXSTREAM3DATIPROC) (GLenum stream, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLVERTEXSTREAM3DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void ( * PFNGLVERTEXSTREAM3FATIPROC) (GLenum stream, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLVERTEXSTREAM3FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void ( * PFNGLVERTEXSTREAM3IATIPROC) (GLenum stream, GLint x, GLint y, GLint z);
typedef void ( * PFNGLVERTEXSTREAM3IVATIPROC) (GLenum stream, const GLint *coords);
typedef void ( * PFNGLVERTEXSTREAM3SATIPROC) (GLenum stream, GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLVERTEXSTREAM3SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void ( * PFNGLVERTEXSTREAM4DATIPROC) (GLenum stream, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLVERTEXSTREAM4DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void ( * PFNGLVERTEXSTREAM4FATIPROC) (GLenum stream, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLVERTEXSTREAM4FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void ( * PFNGLVERTEXSTREAM4IATIPROC) (GLenum stream, GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLVERTEXSTREAM4IVATIPROC) (GLenum stream, const GLint *coords);
typedef void ( * PFNGLVERTEXSTREAM4SATIPROC) (GLenum stream, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void ( * PFNGLVERTEXSTREAM4SVATIPROC) (GLenum stream, const GLshort *coords);
# 9213 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLEGLIMAGETARGETTEXSTORAGEEXTPROC) (GLenum target, GLeglImageOES image, const GLint* attrib_list);
typedef void ( * PFNGLEGLIMAGETARGETTEXTURESTORAGEEXTPROC) (GLuint texture, GLeglImageOES image, const GLint* attrib_list);
# 9259 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEEXTPROC) (GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance);
typedef void ( * PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEEXTPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLuint baseinstance);
typedef void ( * PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEEXTPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance);
# 9295 "/usr/include/GL/glew.h" 3 4
typedef GLint ( * PFNGLGETUNIFORMBUFFERSIZEEXTPROC) (GLuint program, GLint location);
typedef GLintptr ( * PFNGLGETUNIFORMOFFSETEXTPROC) (GLuint program, GLint location);
typedef void ( * PFNGLUNIFORMBUFFEREXTPROC) (GLuint program, GLint location, GLuint buffer);
# 9318 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBLENDCOLOREXTPROC) (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
# 9334 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBLENDEQUATIONSEPARATEEXTPROC) (GLenum modeRGB, GLenum modeAlpha);
# 9355 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBINDFRAGDATALOCATIONINDEXEDEXTPROC) (GLuint program, GLuint colorNumber, GLuint index, const GLchar * name);
typedef GLint ( * PFNGLGETFRAGDATAINDEXEXTPROC) (GLuint program, const GLchar * name);
typedef GLint ( * PFNGLGETPROGRAMRESOURCELOCATIONINDEXEXTPROC) (GLuint program, GLenum programInterface, const GLchar* name);
# 9377 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBLENDFUNCSEPARATEEXTPROC) (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
# 9404 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBLENDEQUATIONEXTPROC) (GLenum mode);
# 9439 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBUFFERSTORAGEEXTPROC) (GLenum target, GLsizeiptr size, const void *data, GLbitfield flags);
typedef void ( * PFNGLNAMEDBUFFERSTORAGEEXTPROC) (GLuint buffer, GLsizeiptr size, const void *data, GLbitfield flags);
# 9454 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCLEARTEXIMAGEEXTPROC) (GLuint texture, GLint level, GLenum format, GLenum type, const void *data);
typedef void ( * PFNGLCLEARTEXSUBIMAGEEXTPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data);
# 9476 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCLIPCONTROLEXTPROC) (GLenum origin, GLenum depth);
# 9560 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCOLORSUBTABLEEXTPROC) (GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void *data);
typedef void ( * PFNGLCOPYCOLORSUBTABLEEXTPROC) (GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);
# 9578 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLLOCKARRAYSEXTPROC) (GLint first, GLsizei count);
typedef void ( * PFNGLUNLOCKARRAYSEXTPROC) (void);
# 9632 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCONVOLUTIONFILTER1DEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *image);
typedef void ( * PFNGLCONVOLUTIONFILTER2DEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *image);
typedef void ( * PFNGLCONVOLUTIONPARAMETERFEXTPROC) (GLenum target, GLenum pname, GLfloat param);
typedef void ( * PFNGLCONVOLUTIONPARAMETERFVEXTPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLCONVOLUTIONPARAMETERIEXTPROC) (GLenum target, GLenum pname, GLint param);
typedef void ( * PFNGLCONVOLUTIONPARAMETERIVEXTPROC) (GLenum target, GLenum pname, const GLint* params);
typedef void ( * PFNGLCOPYCONVOLUTIONFILTER1DEXTPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCOPYCONVOLUTIONFILTER2DEXTPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLGETCONVOLUTIONFILTEREXTPROC) (GLenum target, GLenum format, GLenum type, void *image);
typedef void ( * PFNGLGETCONVOLUTIONPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETCONVOLUTIONPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETSEPARABLEFILTEREXTPROC) (GLenum target, GLenum format, GLenum type, void *row, void *column, void *span);
typedef void ( * PFNGLSEPARABLEFILTER2DEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *row, const void *column);
# 9684 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBINORMALPOINTEREXTPROC) (GLenum type, GLsizei stride, void *pointer);
typedef void ( * PFNGLTANGENTPOINTEREXTPROC) (GLenum type, GLsizei stride, void *pointer);
# 9699 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCOPYIMAGESUBDATAEXTPROC) (GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);
# 9712 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCOPYTEXIMAGE1DEXTPROC) (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
typedef void ( * PFNGLCOPYTEXIMAGE2DEXTPROC) (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
typedef void ( * PFNGLCOPYTEXSUBIMAGE1DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCOPYTEXSUBIMAGE2DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLCOPYTEXSUBIMAGE3DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
# 9737 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCULLPARAMETERDVEXTPROC) (GLenum pname, GLdouble* params);
typedef void ( * PFNGLCULLPARAMETERFVEXTPROC) (GLenum pname, GLfloat* params);
# 9759 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETOBJECTLABELEXTPROC) (GLenum type, GLuint object, GLsizei bufSize, GLsizei* length, GLchar *label);
typedef void ( * PFNGLLABELOBJECTEXTPROC) (GLenum type, GLuint object, GLsizei length, const GLchar* label);
# 9774 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLINSERTEVENTMARKEREXTPROC) (GLsizei length, const GLchar* marker);
typedef void ( * PFNGLPOPGROUPMARKEREXTPROC) (void);
typedef void ( * PFNGLPUSHGROUPMARKEREXTPROC) (GLsizei length, const GLchar* marker);
# 9794 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDEPTHBOUNDSEXTPROC) (GLclampd zmin, GLclampd zmax);
# 9822 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBINDMULTITEXTUREEXTPROC) (GLenum texunit, GLenum target, GLuint texture);
typedef GLenum ( * PFNGLCHECKNAMEDFRAMEBUFFERSTATUSEXTPROC) (GLuint framebuffer, GLenum target);
typedef void ( * PFNGLCLIENTATTRIBDEFAULTEXTPROC) (GLbitfield mask);
typedef void ( * PFNGLCOMPRESSEDMULTITEXIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDMULTITEXIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDMULTITEXIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDMULTITEXSUBIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDMULTITEXSUBIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDMULTITEXSUBIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXTUREIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXTUREIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXTUREIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXTURESUBIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXTURESUBIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXTURESUBIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOPYMULTITEXIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
typedef void ( * PFNGLCOPYMULTITEXIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
typedef void ( * PFNGLCOPYMULTITEXSUBIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCOPYMULTITEXSUBIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLCOPYMULTITEXSUBIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLCOPYTEXTUREIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
typedef void ( * PFNGLCOPYTEXTUREIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
typedef void ( * PFNGLCOPYTEXTURESUBIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCOPYTEXTURESUBIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLCOPYTEXTURESUBIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLDISABLECLIENTSTATEINDEXEDEXTPROC) (GLenum array, GLuint index);
typedef void ( * PFNGLDISABLECLIENTSTATEIEXTPROC) (GLenum array, GLuint index);
typedef void ( * PFNGLDISABLEVERTEXARRAYATTRIBEXTPROC) (GLuint vaobj, GLuint index);
typedef void ( * PFNGLDISABLEVERTEXARRAYEXTPROC) (GLuint vaobj, GLenum array);
typedef void ( * PFNGLENABLECLIENTSTATEINDEXEDEXTPROC) (GLenum array, GLuint index);
typedef void ( * PFNGLENABLECLIENTSTATEIEXTPROC) (GLenum array, GLuint index);
typedef void ( * PFNGLENABLEVERTEXARRAYATTRIBEXTPROC) (GLuint vaobj, GLuint index);
typedef void ( * PFNGLENABLEVERTEXARRAYEXTPROC) (GLuint vaobj, GLenum array);
typedef void ( * PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr length);
typedef void ( * PFNGLFRAMEBUFFERDRAWBUFFEREXTPROC) (GLuint framebuffer, GLenum mode);
typedef void ( * PFNGLFRAMEBUFFERDRAWBUFFERSEXTPROC) (GLuint framebuffer, GLsizei n, const GLenum* bufs);
typedef void ( * PFNGLFRAMEBUFFERREADBUFFEREXTPROC) (GLuint framebuffer, GLenum mode);
typedef void ( * PFNGLGENERATEMULTITEXMIPMAPEXTPROC) (GLenum texunit, GLenum target);
typedef void ( * PFNGLGENERATETEXTUREMIPMAPEXTPROC) (GLuint texture, GLenum target);
typedef void ( * PFNGLGETCOMPRESSEDMULTITEXIMAGEEXTPROC) (GLenum texunit, GLenum target, GLint level, void *img);
typedef void ( * PFNGLGETCOMPRESSEDTEXTUREIMAGEEXTPROC) (GLuint texture, GLenum target, GLint level, void *img);
typedef void ( * PFNGLGETDOUBLEINDEXEDVEXTPROC) (GLenum target, GLuint index, GLdouble* params);
typedef void ( * PFNGLGETDOUBLEI_VEXTPROC) (GLenum pname, GLuint index, GLdouble* params);
typedef void ( * PFNGLGETFLOATINDEXEDVEXTPROC) (GLenum target, GLuint index, GLfloat* params);
typedef void ( * PFNGLGETFLOATI_VEXTPROC) (GLenum pname, GLuint index, GLfloat* params);
typedef void ( * PFNGLGETFRAMEBUFFERPARAMETERIVEXTPROC) (GLuint framebuffer, GLenum pname, GLint* param);
typedef void ( * PFNGLGETMULTITEXENVFVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETMULTITEXENVIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETMULTITEXGENDVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLdouble* params);
typedef void ( * PFNGLGETMULTITEXGENFVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETMULTITEXGENIVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLint* params);
typedef void ( * PFNGLGETMULTITEXIMAGEEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, void *pixels);
typedef void ( * PFNGLGETMULTITEXLEVELPARAMETERFVEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETMULTITEXLEVELPARAMETERIVEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum pname, GLint* params);
typedef void ( * PFNGLGETMULTITEXPARAMETERIIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETMULTITEXPARAMETERIUIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLuint* params);
typedef void ( * PFNGLGETMULTITEXPARAMETERFVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETMULTITEXPARAMETERIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETNAMEDBUFFERPARAMETERIVEXTPROC) (GLuint buffer, GLenum pname, GLint* params);
typedef void ( * PFNGLGETNAMEDBUFFERPOINTERVEXTPROC) (GLuint buffer, GLenum pname, void** params);
typedef void ( * PFNGLGETNAMEDBUFFERSUBDATAEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr size, void *data);
typedef void ( * PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC) (GLuint framebuffer, GLenum attachment, GLenum pname, GLint* params);
typedef void ( * PFNGLGETNAMEDPROGRAMLOCALPARAMETERIIVEXTPROC) (GLuint program, GLenum target, GLuint index, GLint* params);
typedef void ( * PFNGLGETNAMEDPROGRAMLOCALPARAMETERIUIVEXTPROC) (GLuint program, GLenum target, GLuint index, GLuint* params);
typedef void ( * PFNGLGETNAMEDPROGRAMLOCALPARAMETERDVEXTPROC) (GLuint program, GLenum target, GLuint index, GLdouble* params);
typedef void ( * PFNGLGETNAMEDPROGRAMLOCALPARAMETERFVEXTPROC) (GLuint program, GLenum target, GLuint index, GLfloat* params);
typedef void ( * PFNGLGETNAMEDPROGRAMSTRINGEXTPROC) (GLuint program, GLenum target, GLenum pname, void *string);
typedef void ( * PFNGLGETNAMEDPROGRAMIVEXTPROC) (GLuint program, GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETNAMEDRENDERBUFFERPARAMETERIVEXTPROC) (GLuint renderbuffer, GLenum pname, GLint* params);
typedef void ( * PFNGLGETPOINTERINDEXEDVEXTPROC) (GLenum target, GLuint index, void** params);
typedef void ( * PFNGLGETPOINTERI_VEXTPROC) (GLenum pname, GLuint index, void** params);
typedef void ( * PFNGLGETTEXTUREIMAGEEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, void *pixels);
typedef void ( * PFNGLGETTEXTURELEVELPARAMETERFVEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETTEXTURELEVELPARAMETERIVEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum pname, GLint* params);
typedef void ( * PFNGLGETTEXTUREPARAMETERIIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETTEXTUREPARAMETERIUIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLuint* params);
typedef void ( * PFNGLGETTEXTUREPARAMETERFVEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETTEXTUREPARAMETERIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETVERTEXARRAYINTEGERI_VEXTPROC) (GLuint vaobj, GLuint index, GLenum pname, GLint* param);
typedef void ( * PFNGLGETVERTEXARRAYINTEGERVEXTPROC) (GLuint vaobj, GLenum pname, GLint* param);
typedef void ( * PFNGLGETVERTEXARRAYPOINTERI_VEXTPROC) (GLuint vaobj, GLuint index, GLenum pname, void** param);
typedef void ( * PFNGLGETVERTEXARRAYPOINTERVEXTPROC) (GLuint vaobj, GLenum pname, void** param);
typedef void * ( * PFNGLMAPNAMEDBUFFEREXTPROC) (GLuint buffer, GLenum access);
typedef void * ( * PFNGLMAPNAMEDBUFFERRANGEEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access);
typedef void ( * PFNGLMATRIXFRUSTUMEXTPROC) (GLenum matrixMode, GLdouble l, GLdouble r, GLdouble b, GLdouble t, GLdouble n, GLdouble f);
typedef void ( * PFNGLMATRIXLOADIDENTITYEXTPROC) (GLenum matrixMode);
typedef void ( * PFNGLMATRIXLOADTRANSPOSEDEXTPROC) (GLenum matrixMode, const GLdouble* m);
typedef void ( * PFNGLMATRIXLOADTRANSPOSEFEXTPROC) (GLenum matrixMode, const GLfloat* m);
typedef void ( * PFNGLMATRIXLOADDEXTPROC) (GLenum matrixMode, const GLdouble* m);
typedef void ( * PFNGLMATRIXLOADFEXTPROC) (GLenum matrixMode, const GLfloat* m);
typedef void ( * PFNGLMATRIXMULTTRANSPOSEDEXTPROC) (GLenum matrixMode, const GLdouble* m);
typedef void ( * PFNGLMATRIXMULTTRANSPOSEFEXTPROC) (GLenum matrixMode, const GLfloat* m);
typedef void ( * PFNGLMATRIXMULTDEXTPROC) (GLenum matrixMode, const GLdouble* m);
typedef void ( * PFNGLMATRIXMULTFEXTPROC) (GLenum matrixMode, const GLfloat* m);
typedef void ( * PFNGLMATRIXORTHOEXTPROC) (GLenum matrixMode, GLdouble l, GLdouble r, GLdouble b, GLdouble t, GLdouble n, GLdouble f);
typedef void ( * PFNGLMATRIXPOPEXTPROC) (GLenum matrixMode);
typedef void ( * PFNGLMATRIXPUSHEXTPROC) (GLenum matrixMode);
typedef void ( * PFNGLMATRIXROTATEDEXTPROC) (GLenum matrixMode, GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLMATRIXROTATEFEXTPROC) (GLenum matrixMode, GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLMATRIXSCALEDEXTPROC) (GLenum matrixMode, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLMATRIXSCALEFEXTPROC) (GLenum matrixMode, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLMATRIXTRANSLATEDEXTPROC) (GLenum matrixMode, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLMATRIXTRANSLATEFEXTPROC) (GLenum matrixMode, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLMULTITEXBUFFEREXTPROC) (GLenum texunit, GLenum target, GLenum internalformat, GLuint buffer);
typedef void ( * PFNGLMULTITEXCOORDPOINTEREXTPROC) (GLenum texunit, GLint size, GLenum type, GLsizei stride, const void *pointer);
typedef void ( * PFNGLMULTITEXENVFEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLfloat param);
typedef void ( * PFNGLMULTITEXENVFVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLMULTITEXENVIEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint param);
typedef void ( * PFNGLMULTITEXENVIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLint* params);
typedef void ( * PFNGLMULTITEXGENDEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLdouble param);
typedef void ( * PFNGLMULTITEXGENDVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, const GLdouble* params);
typedef void ( * PFNGLMULTITEXGENFEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLfloat param);
typedef void ( * PFNGLMULTITEXGENFVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLMULTITEXGENIEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLint param);
typedef void ( * PFNGLMULTITEXGENIVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, const GLint* params);
typedef void ( * PFNGLMULTITEXIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLMULTITEXIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLMULTITEXIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLMULTITEXPARAMETERIIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLint* params);
typedef void ( * PFNGLMULTITEXPARAMETERIUIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLuint* params);
typedef void ( * PFNGLMULTITEXPARAMETERFEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLfloat param);
typedef void ( * PFNGLMULTITEXPARAMETERFVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLfloat* param);
typedef void ( * PFNGLMULTITEXPARAMETERIEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint param);
typedef void ( * PFNGLMULTITEXPARAMETERIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLint* param);
typedef void ( * PFNGLMULTITEXRENDERBUFFEREXTPROC) (GLenum texunit, GLenum target, GLuint renderbuffer);
typedef void ( * PFNGLMULTITEXSUBIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLMULTITEXSUBIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLMULTITEXSUBIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLNAMEDBUFFERDATAEXTPROC) (GLuint buffer, GLsizeiptr size, const void *data, GLenum usage);
typedef void ( * PFNGLNAMEDBUFFERSUBDATAEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data);
typedef void ( * PFNGLNAMEDCOPYBUFFERSUBDATAEXTPROC) (GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
typedef void ( * PFNGLNAMEDFRAMEBUFFERRENDERBUFFEREXTPROC) (GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTURE1DEXTPROC) (GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTURE2DEXTPROC) (GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTURE3DEXTPROC) (GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTUREEXTPROC) (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level);
typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTUREFACEEXTPROC) (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLenum face);
typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTURELAYEREXTPROC) (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETER4DEXTPROC) (GLuint program, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETER4DVEXTPROC) (GLuint program, GLenum target, GLuint index, const GLdouble* params);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETER4FEXTPROC) (GLuint program, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETER4FVEXTPROC) (GLuint program, GLenum target, GLuint index, const GLfloat* params);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETERI4IEXTPROC) (GLuint program, GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETERI4IVEXTPROC) (GLuint program, GLenum target, GLuint index, const GLint* params);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIEXTPROC) (GLuint program, GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIVEXTPROC) (GLuint program, GLenum target, GLuint index, const GLuint* params);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETERS4FVEXTPROC) (GLuint program, GLenum target, GLuint index, GLsizei count, const GLfloat* params);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETERSI4IVEXTPROC) (GLuint program, GLenum target, GLuint index, GLsizei count, const GLint* params);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETERSI4UIVEXTPROC) (GLuint program, GLenum target, GLuint index, GLsizei count, const GLuint* params);
typedef void ( * PFNGLNAMEDPROGRAMSTRINGEXTPROC) (GLuint program, GLenum target, GLenum format, GLsizei len, const void *string);
typedef void ( * PFNGLNAMEDRENDERBUFFERSTORAGEEXTPROC) (GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLECOVERAGEEXTPROC) (GLuint renderbuffer, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC) (GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLPROGRAMUNIFORM1FEXTPROC) (GLuint program, GLint location, GLfloat v0);
typedef void ( * PFNGLPROGRAMUNIFORM1FVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORM1IEXTPROC) (GLuint program, GLint location, GLint v0);
typedef void ( * PFNGLPROGRAMUNIFORM1IVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLPROGRAMUNIFORM1UIEXTPROC) (GLuint program, GLint location, GLuint v0);
typedef void ( * PFNGLPROGRAMUNIFORM1UIVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLPROGRAMUNIFORM2FEXTPROC) (GLuint program, GLint location, GLfloat v0, GLfloat v1);
typedef void ( * PFNGLPROGRAMUNIFORM2FVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORM2IEXTPROC) (GLuint program, GLint location, GLint v0, GLint v1);
typedef void ( * PFNGLPROGRAMUNIFORM2IVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLPROGRAMUNIFORM2UIEXTPROC) (GLuint program, GLint location, GLuint v0, GLuint v1);
typedef void ( * PFNGLPROGRAMUNIFORM2UIVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLPROGRAMUNIFORM3FEXTPROC) (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void ( * PFNGLPROGRAMUNIFORM3FVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORM3IEXTPROC) (GLuint program, GLint location, GLint v0, GLint v1, GLint v2);
typedef void ( * PFNGLPROGRAMUNIFORM3IVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLPROGRAMUNIFORM3UIEXTPROC) (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2);
typedef void ( * PFNGLPROGRAMUNIFORM3UIVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLPROGRAMUNIFORM4FEXTPROC) (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void ( * PFNGLPROGRAMUNIFORM4FVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORM4IEXTPROC) (GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void ( * PFNGLPROGRAMUNIFORM4IVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLPROGRAMUNIFORM4UIEXTPROC) (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void ( * PFNGLPROGRAMUNIFORM4UIVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X3FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X4FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X2FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X4FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X2FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X3FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPUSHCLIENTATTRIBDEFAULTEXTPROC) (GLbitfield mask);
typedef void ( * PFNGLTEXTUREBUFFEREXTPROC) (GLuint texture, GLenum target, GLenum internalformat, GLuint buffer);
typedef void ( * PFNGLTEXTUREIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLTEXTUREIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLTEXTUREIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLTEXTUREPARAMETERIIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, const GLint* params);
typedef void ( * PFNGLTEXTUREPARAMETERIUIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, const GLuint* params);
typedef void ( * PFNGLTEXTUREPARAMETERFEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLfloat param);
typedef void ( * PFNGLTEXTUREPARAMETERFVEXTPROC) (GLuint texture, GLenum target, GLenum pname, const GLfloat* param);
typedef void ( * PFNGLTEXTUREPARAMETERIEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLint param);
typedef void ( * PFNGLTEXTUREPARAMETERIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, const GLint* param);
typedef void ( * PFNGLTEXTURERENDERBUFFEREXTPROC) (GLuint texture, GLenum target, GLuint renderbuffer);
typedef void ( * PFNGLTEXTURESUBIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLTEXTURESUBIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLTEXTURESUBIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
typedef GLboolean ( * PFNGLUNMAPNAMEDBUFFEREXTPROC) (GLuint buffer);
typedef void ( * PFNGLVERTEXARRAYCOLOROFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXARRAYEDGEFLAGOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXARRAYFOGCOORDOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXARRAYINDEXOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXARRAYMULTITEXCOORDOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLenum texunit, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXARRAYNORMALOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXARRAYSECONDARYCOLOROFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXARRAYTEXCOORDOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXARRAYVERTEXATTRIBDIVISOREXTPROC) (GLuint vaobj, GLuint index, GLuint divisor);
typedef void ( * PFNGLVERTEXARRAYVERTEXATTRIBIOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXARRAYVERTEXATTRIBOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXARRAYVERTEXOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
# 10265 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDISCARDFRAMEBUFFEREXTPROC) (GLenum target, GLsizei numAttachments, const GLenum* attachments);
# 10286 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBEGINQUERYEXTPROC) (GLenum target, GLuint id);
typedef void ( * PFNGLDELETEQUERIESEXTPROC) (GLsizei n, const GLuint* ids);
typedef void ( * PFNGLENDQUERYEXTPROC) (GLenum target);
typedef void ( * PFNGLGENQUERIESEXTPROC) (GLsizei n, GLuint* ids);
typedef void ( * PFNGLGETINTEGER64VEXTPROC) (GLenum pname, GLint64* data);
typedef void ( * PFNGLGETQUERYOBJECTIVEXTPROC) (GLuint id, GLenum pname, GLint* params);
typedef void ( * PFNGLGETQUERYOBJECTUIVEXTPROC) (GLuint id, GLenum pname, GLuint* params);
typedef void ( * PFNGLGETQUERYIVEXTPROC) (GLenum target, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISQUERYEXTPROC) (GLuint id);
typedef void ( * PFNGLQUERYCOUNTEREXTPROC) (GLuint id, GLenum target);
# 10352 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDRAWBUFFERSEXTPROC) (GLsizei n, const GLenum* bufs);
# 10365 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCOLORMASKINDEXEDEXTPROC) (GLuint buf, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
typedef void ( * PFNGLDISABLEINDEXEDEXTPROC) (GLenum target, GLuint index);
typedef void ( * PFNGLENABLEINDEXEDEXTPROC) (GLenum target, GLuint index);
typedef void ( * PFNGLGETBOOLEANINDEXEDVEXTPROC) (GLenum value, GLuint index, GLboolean* data);
typedef void ( * PFNGLGETINTEGERINDEXEDVEXTPROC) (GLenum value, GLuint index, GLint* data);
typedef GLboolean ( * PFNGLISENABLEDINDEXEDEXTPROC) (GLenum target, GLuint index);
# 10388 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBLENDEQUATIONSEPARATEIEXTPROC) (GLuint buf, GLenum modeRGB, GLenum modeAlpha);
typedef void ( * PFNGLBLENDEQUATIONIEXTPROC) (GLuint buf, GLenum mode);
typedef void ( * PFNGLBLENDFUNCSEPARATEIEXTPROC) (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
typedef void ( * PFNGLBLENDFUNCIEXTPROC) (GLuint buf, GLenum src, GLenum dst);
typedef void ( * PFNGLCOLORMASKIEXTPROC) (GLuint buf, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
typedef void ( * PFNGLDISABLEIEXTPROC) (GLenum target, GLuint index);
typedef void ( * PFNGLENABLEIEXTPROC) (GLenum target, GLuint index);
typedef GLboolean ( * PFNGLISENABLEDIEXTPROC) (GLenum target, GLuint index);
# 10415 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDRAWELEMENTSBASEVERTEXEXTPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLint basevertex);
typedef void ( * PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXEXTPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLint basevertex);
typedef void ( * PFNGLDRAWRANGEELEMENTSBASEVERTEXEXTPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices, GLint basevertex);
typedef void ( * PFNGLMULTIDRAWELEMENTSBASEVERTEXEXTPROC) (GLenum mode, const GLsizei* count, GLenum type, const void *const *indices, GLsizei primcount, const GLint *basevertex);
# 10434 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDRAWARRAYSINSTANCEDEXTPROC) (GLenum mode, GLint start, GLsizei count, GLsizei primcount);
typedef void ( * PFNGLDRAWELEMENTSINSTANCEDEXTPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount);
# 10452 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDRAWRANGEELEMENTSEXTPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices);
# 10465 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDRAWTRANSFORMFEEDBACKEXTPROC) (GLenum mode, GLuint id);
typedef void ( * PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDEXTPROC) (GLenum mode, GLuint id, GLsizei instancecount);
# 10480 "/usr/include/GL/glew.h" 3 4
typedef void* GLeglClientBufferEXT;

typedef void ( * PFNGLBUFFERSTORAGEEXTERNALEXTPROC) (GLenum target, GLintptr offset, GLsizeiptr size, GLeglClientBufferEXT clientBuffer, GLbitfield flags);
typedef void ( * PFNGLNAMEDBUFFERSTORAGEEXTERNALEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr size, GLeglClientBufferEXT clientBuffer, GLbitfield flags);
# 10515 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLFOGCOORDPOINTEREXTPROC) (GLenum type, GLsizei stride, const void *pointer);
typedef void ( * PFNGLFOGCOORDDEXTPROC) (GLdouble coord);
typedef void ( * PFNGLFOGCOORDDVEXTPROC) (const GLdouble *coord);
typedef void ( * PFNGLFOGCOORDFEXTPROC) (GLfloat coord);
typedef void ( * PFNGLFOGCOORDFVEXTPROC) (const GLfloat *coord);
# 10560 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLFRAGMENTCOLORMATERIALEXTPROC) (GLenum face, GLenum mode);
typedef void ( * PFNGLFRAGMENTLIGHTMODELFEXTPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLFRAGMENTLIGHTMODELFVEXTPROC) (GLenum pname, GLfloat* params);
typedef void ( * PFNGLFRAGMENTLIGHTMODELIEXTPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLFRAGMENTLIGHTMODELIVEXTPROC) (GLenum pname, GLint* params);
typedef void ( * PFNGLFRAGMENTLIGHTFEXTPROC) (GLenum light, GLenum pname, GLfloat param);
typedef void ( * PFNGLFRAGMENTLIGHTFVEXTPROC) (GLenum light, GLenum pname, GLfloat* params);
typedef void ( * PFNGLFRAGMENTLIGHTIEXTPROC) (GLenum light, GLenum pname, GLint param);
typedef void ( * PFNGLFRAGMENTLIGHTIVEXTPROC) (GLenum light, GLenum pname, GLint* params);
typedef void ( * PFNGLFRAGMENTMATERIALFEXTPROC) (GLenum face, GLenum pname, const GLfloat param);
typedef void ( * PFNGLFRAGMENTMATERIALFVEXTPROC) (GLenum face, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLFRAGMENTMATERIALIEXTPROC) (GLenum face, GLenum pname, const GLint param);
typedef void ( * PFNGLFRAGMENTMATERIALIVEXTPROC) (GLenum face, GLenum pname, const GLint* params);
typedef void ( * PFNGLGETFRAGMENTLIGHTFVEXTPROC) (GLenum light, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETFRAGMENTLIGHTIVEXTPROC) (GLenum light, GLenum pname, GLint* params);
typedef void ( * PFNGLGETFRAGMENTMATERIALFVEXTPROC) (GLenum face, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLGETFRAGMENTMATERIALIVEXTPROC) (GLenum face, GLenum pname, const GLint* params);
typedef void ( * PFNGLLIGHTENVIEXTPROC) (GLenum pname, GLint param);
# 10612 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBLITFRAMEBUFFEREXTPROC) (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
# 10629 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
# 10706 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBINDFRAMEBUFFEREXTPROC) (GLenum target, GLuint framebuffer);
typedef void ( * PFNGLBINDRENDERBUFFEREXTPROC) (GLenum target, GLuint renderbuffer);
typedef GLenum ( * PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC) (GLenum target);
typedef void ( * PFNGLDELETEFRAMEBUFFERSEXTPROC) (GLsizei n, const GLuint* framebuffers);
typedef void ( * PFNGLDELETERENDERBUFFERSEXTPROC) (GLsizei n, const GLuint* renderbuffers);
typedef void ( * PFNGLFRAMEBUFFERRENDERBUFFEREXTPROC) (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void ( * PFNGLFRAMEBUFFERTEXTURE1DEXTPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void ( * PFNGLFRAMEBUFFERTEXTURE2DEXTPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void ( * PFNGLFRAMEBUFFERTEXTURE3DEXTPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
typedef void ( * PFNGLGENFRAMEBUFFERSEXTPROC) (GLsizei n, GLuint* framebuffers);
typedef void ( * PFNGLGENRENDERBUFFERSEXTPROC) (GLsizei n, GLuint* renderbuffers);
typedef void ( * PFNGLGENERATEMIPMAPEXTPROC) (GLenum target);
typedef void ( * PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC) (GLenum target, GLenum attachment, GLenum pname, GLint* params);
typedef void ( * PFNGLGETRENDERBUFFERPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISFRAMEBUFFEREXTPROC) (GLuint framebuffer);
typedef GLboolean ( * PFNGLISRENDERBUFFEREXTPROC) (GLuint renderbuffer);
typedef void ( * PFNGLRENDERBUFFERSTORAGEEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
# 10870 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLFRAMEBUFFERTEXTUREEXTPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level);
typedef void ( * PFNGLFRAMEBUFFERTEXTUREFACEEXTPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);
typedef void ( * PFNGLPROGRAMPARAMETERIEXTPROC) (GLuint program, GLenum pname, GLint value);
# 10887 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLPROGRAMENVPARAMETERS4FVEXTPROC) (GLenum target, GLuint index, GLsizei count, const GLfloat* params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERS4FVEXTPROC) (GLenum target, GLuint index, GLsizei count, const GLfloat* params);
# 10929 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBINDFRAGDATALOCATIONEXTPROC) (GLuint program, GLuint color, const GLchar *name);
typedef GLint ( * PFNGLGETFRAGDATALOCATIONEXTPROC) (GLuint program, const GLchar *name);
typedef void ( * PFNGLGETUNIFORMUIVEXTPROC) (GLuint program, GLint location, GLuint *params);
typedef void ( * PFNGLGETVERTEXATTRIBIIVEXTPROC) (GLuint index, GLenum pname, GLint *params);
typedef void ( * PFNGLGETVERTEXATTRIBIUIVEXTPROC) (GLuint index, GLenum pname, GLuint *params);
typedef void ( * PFNGLUNIFORM1UIEXTPROC) (GLint location, GLuint v0);
typedef void ( * PFNGLUNIFORM1UIVEXTPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void ( * PFNGLUNIFORM2UIEXTPROC) (GLint location, GLuint v0, GLuint v1);
typedef void ( * PFNGLUNIFORM2UIVEXTPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void ( * PFNGLUNIFORM3UIEXTPROC) (GLint location, GLuint v0, GLuint v1, GLuint v2);
typedef void ( * PFNGLUNIFORM3UIVEXTPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void ( * PFNGLUNIFORM4UIEXTPROC) (GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void ( * PFNGLUNIFORM4UIVEXTPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void ( * PFNGLVERTEXATTRIBI1IEXTPROC) (GLuint index, GLint x);
typedef void ( * PFNGLVERTEXATTRIBI1IVEXTPROC) (GLuint index, const GLint *v);
typedef void ( * PFNGLVERTEXATTRIBI1UIEXTPROC) (GLuint index, GLuint x);
typedef void ( * PFNGLVERTEXATTRIBI1UIVEXTPROC) (GLuint index, const GLuint *v);
typedef void ( * PFNGLVERTEXATTRIBI2IEXTPROC) (GLuint index, GLint x, GLint y);
typedef void ( * PFNGLVERTEXATTRIBI2IVEXTPROC) (GLuint index, const GLint *v);
typedef void ( * PFNGLVERTEXATTRIBI2UIEXTPROC) (GLuint index, GLuint x, GLuint y);
typedef void ( * PFNGLVERTEXATTRIBI2UIVEXTPROC) (GLuint index, const GLuint *v);
typedef void ( * PFNGLVERTEXATTRIBI3IEXTPROC) (GLuint index, GLint x, GLint y, GLint z);
typedef void ( * PFNGLVERTEXATTRIBI3IVEXTPROC) (GLuint index, const GLint *v);
typedef void ( * PFNGLVERTEXATTRIBI3UIEXTPROC) (GLuint index, GLuint x, GLuint y, GLuint z);
typedef void ( * PFNGLVERTEXATTRIBI3UIVEXTPROC) (GLuint index, const GLuint *v);
typedef void ( * PFNGLVERTEXATTRIBI4BVEXTPROC) (GLuint index, const GLbyte *v);
typedef void ( * PFNGLVERTEXATTRIBI4IEXTPROC) (GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLVERTEXATTRIBI4IVEXTPROC) (GLuint index, const GLint *v);
typedef void ( * PFNGLVERTEXATTRIBI4SVEXTPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIBI4UBVEXTPROC) (GLuint index, const GLubyte *v);
typedef void ( * PFNGLVERTEXATTRIBI4UIEXTPROC) (GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void ( * PFNGLVERTEXATTRIBI4UIVEXTPROC) (GLuint index, const GLuint *v);
typedef void ( * PFNGLVERTEXATTRIBI4USVEXTPROC) (GLuint index, const GLushort *v);
typedef void ( * PFNGLVERTEXATTRIBIPOINTEREXTPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer);
# 11031 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETHISTOGRAMEXTPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, void *values);
typedef void ( * PFNGLGETHISTOGRAMPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETHISTOGRAMPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETMINMAXEXTPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, void *values);
typedef void ( * PFNGLGETMINMAXPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETMINMAXPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLHISTOGRAMEXTPROC) (GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
typedef void ( * PFNGLMINMAXEXTPROC) (GLenum target, GLenum internalformat, GLboolean sink);
typedef void ( * PFNGLRESETHISTOGRAMEXTPROC) (GLenum target);
typedef void ( * PFNGLRESETMINMAXEXTPROC) (GLenum target);
# 11071 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLINDEXFUNCEXTPROC) (GLenum func, GLfloat ref);
# 11084 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLINDEXMATERIALEXTPROC) (GLenum face, GLenum mode);
# 11108 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLVERTEXATTRIBDIVISOREXTPROC) (GLuint index, GLuint divisor);
# 11131 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLAPPLYTEXTUREEXTPROC) (GLenum mode);
typedef void ( * PFNGLTEXTURELIGHTEXTPROC) (GLenum pname);
typedef void ( * PFNGLTEXTUREMATERIALEXTPROC) (GLenum face, GLenum mode);
# 11155 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLFLUSHMAPPEDBUFFERRANGEEXTPROC) (GLenum target, GLintptr offset, GLsizeiptr length);
typedef void * ( * PFNGLMAPBUFFERRANGEEXTPROC) (GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);
# 11182 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBUFFERSTORAGEMEMEXTPROC) (GLenum target, GLsizeiptr size, GLuint memory, GLuint64 offset);
typedef void ( * PFNGLCREATEMEMORYOBJECTSEXTPROC) (GLsizei n, GLuint* memoryObjects);
typedef void ( * PFNGLDELETEMEMORYOBJECTSEXTPROC) (GLsizei n, const GLuint* memoryObjects);
typedef void ( * PFNGLGETMEMORYOBJECTPARAMETERIVEXTPROC) (GLuint memoryObject, GLenum pname, GLint* params);
typedef void ( * PFNGLGETUNSIGNEDBYTEI_VEXTPROC) (GLenum target, GLuint index, GLubyte* data);
typedef void ( * PFNGLGETUNSIGNEDBYTEVEXTPROC) (GLenum pname, GLubyte* data);
typedef GLboolean ( * PFNGLISMEMORYOBJECTEXTPROC) (GLuint memoryObject);
typedef void ( * PFNGLMEMORYOBJECTPARAMETERIVEXTPROC) (GLuint memoryObject, GLenum pname, const GLint* params);
typedef void ( * PFNGLNAMEDBUFFERSTORAGEMEMEXTPROC) (GLuint buffer, GLsizeiptr size, GLuint memory, GLuint64 offset);
typedef void ( * PFNGLTEXSTORAGEMEM1DEXTPROC) (GLenum target, GLsizei levels, GLenum internalFormat, GLsizei width, GLuint memory, GLuint64 offset);
typedef void ( * PFNGLTEXSTORAGEMEM2DEXTPROC) (GLenum target, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLuint memory, GLuint64 offset);
typedef void ( * PFNGLTEXSTORAGEMEM2DMULTISAMPLEEXTPROC) (GLenum target, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset);
typedef void ( * PFNGLTEXSTORAGEMEM3DEXTPROC) (GLenum target, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLuint memory, GLuint64 offset);
typedef void ( * PFNGLTEXSTORAGEMEM3DMULTISAMPLEEXTPROC) (GLenum target, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset);
typedef void ( * PFNGLTEXTURESTORAGEMEM1DEXTPROC) (GLuint texture, GLsizei levels, GLenum internalFormat, GLsizei width, GLuint memory, GLuint64 offset);
typedef void ( * PFNGLTEXTURESTORAGEMEM2DEXTPROC) (GLuint texture, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLuint memory, GLuint64 offset);
typedef void ( * PFNGLTEXTURESTORAGEMEM2DMULTISAMPLEEXTPROC) (GLuint texture, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset);
typedef void ( * PFNGLTEXTURESTORAGEMEM3DEXTPROC) (GLuint texture, GLsizei levels, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLuint memory, GLuint64 offset);
typedef void ( * PFNGLTEXTURESTORAGEMEM3DMULTISAMPLEEXTPROC) (GLuint texture, GLsizei samples, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations, GLuint memory, GLuint64 offset);
# 11233 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLIMPORTMEMORYFDEXTPROC) (GLuint memory, GLuint64 size, GLenum handleType, GLint fd);
# 11258 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLIMPORTMEMORYWIN32HANDLEEXTPROC) (GLuint memory, GLuint64 size, GLenum handleType, void *handle);
typedef void ( * PFNGLIMPORTMEMORYWIN32NAMEEXTPROC) (GLuint memory, GLuint64 size, GLenum handleType, const void *name);
# 11282 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLMULTIDRAWARRAYSEXTPROC) (GLenum mode, const GLint* first, const GLsizei *count, GLsizei primcount);
typedef void ( * PFNGLMULTIDRAWELEMENTSEXTPROC) (GLenum mode, GLsizei* count, GLenum type, const void *const *indices, GLsizei primcount);
# 11297 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLMULTIDRAWARRAYSINDIRECTEXTPROC) (GLenum mode, const void *indirect, GLsizei drawcount, GLsizei stride);
typedef void ( * PFNGLMULTIDRAWELEMENTSINDIRECTEXTPROC) (GLenum mode, GLenum type, const void *indirect, GLsizei drawcount, GLsizei stride);
# 11339 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLSAMPLEMASKEXTPROC) (GLclampf value, GLboolean invert);
typedef void ( * PFNGLSAMPLEPATTERNEXTPROC) (GLenum pattern);
# 11371 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLFRAMEBUFFERTEXTURE2DMULTISAMPLEEXTPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples);
# 11399 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDRAWBUFFERSINDEXEDEXTPROC) (GLint n, const GLenum* location, const GLint *indices);
typedef void ( * PFNGLGETINTEGERI_VEXTPROC) (GLenum target, GLuint index, GLint* data);
typedef void ( * PFNGLREADBUFFERINDEXEDEXTPROC) (GLenum src, GLint index);
# 11522 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCOLORTABLEEXTPROC) (GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const void *data);
typedef void ( * PFNGLGETCOLORTABLEEXTPROC) (GLenum target, GLenum format, GLenum type, void *data);
typedef void ( * PFNGLGETCOLORTABLEPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETCOLORTABLEPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint* params);
# 11565 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETPIXELTRANSFORMPARAMETERFVEXTPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLGETPIXELTRANSFORMPARAMETERIVEXTPROC) (GLenum target, GLenum pname, const GLint* params);
typedef void ( * PFNGLPIXELTRANSFORMPARAMETERFEXTPROC) (GLenum target, GLenum pname, const GLfloat param);
typedef void ( * PFNGLPIXELTRANSFORMPARAMETERFVEXTPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLPIXELTRANSFORMPARAMETERIEXTPROC) (GLenum target, GLenum pname, const GLint param);
typedef void ( * PFNGLPIXELTRANSFORMPARAMETERIVEXTPROC) (GLenum target, GLenum pname, const GLint* params);
# 11602 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLPOINTPARAMETERFEXTPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLPOINTPARAMETERFVEXTPROC) (GLenum pname, const GLfloat* params);
# 11621 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLPOLYGONOFFSETEXTPROC) (GLfloat factor, GLfloat bias);
# 11636 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLPOLYGONOFFSETCLAMPEXTPROC) (GLfloat factor, GLfloat units, GLfloat clamp);
# 11660 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLPRIMITIVEBOUNDINGBOXEXTPROC) (GLfloat minX, GLfloat minY, GLfloat minZ, GLfloat minW, GLfloat maxX, GLfloat maxY, GLfloat maxZ, GLfloat maxW);
# 11690 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLPROVOKINGVERTEXEXTPROC) (GLenum mode);
# 11732 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCOVERAGEMODULATIONNVPROC) (GLenum components);
typedef void ( * PFNGLCOVERAGEMODULATIONTABLENVPROC) (GLsizei n, const GLfloat* v);
typedef void ( * PFNGLGETCOVERAGEMODULATIONTABLENVPROC) (GLsizei bufsize, GLfloat* v);
typedef void ( * PFNGLRASTERSAMPLESEXTPROC) (GLuint samples, GLboolean fixedsamplelocations);
# 11801 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETNUNIFORMFVEXTPROC) (GLuint program, GLint location, GLsizei bufSize, GLfloat* params);
typedef void ( * PFNGLGETNUNIFORMIVEXTPROC) (GLuint program, GLint location, GLsizei bufSize, GLint* params);
typedef void ( * PFNGLREADNPIXELSEXTPROC) (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data);
# 11843 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBEGINSCENEEXTPROC) (void);
typedef void ( * PFNGLENDSCENEEXTPROC) (void);
# 11866 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLSECONDARYCOLOR3BEXTPROC) (GLbyte red, GLbyte green, GLbyte blue);
typedef void ( * PFNGLSECONDARYCOLOR3BVEXTPROC) (const GLbyte *v);
typedef void ( * PFNGLSECONDARYCOLOR3DEXTPROC) (GLdouble red, GLdouble green, GLdouble blue);
typedef void ( * PFNGLSECONDARYCOLOR3DVEXTPROC) (const GLdouble *v);
typedef void ( * PFNGLSECONDARYCOLOR3FEXTPROC) (GLfloat red, GLfloat green, GLfloat blue);
typedef void ( * PFNGLSECONDARYCOLOR3FVEXTPROC) (const GLfloat *v);
typedef void ( * PFNGLSECONDARYCOLOR3IEXTPROC) (GLint red, GLint green, GLint blue);
typedef void ( * PFNGLSECONDARYCOLOR3IVEXTPROC) (const GLint *v);
typedef void ( * PFNGLSECONDARYCOLOR3SEXTPROC) (GLshort red, GLshort green, GLshort blue);
typedef void ( * PFNGLSECONDARYCOLOR3SVEXTPROC) (const GLshort *v);
typedef void ( * PFNGLSECONDARYCOLOR3UBEXTPROC) (GLubyte red, GLubyte green, GLubyte blue);
typedef void ( * PFNGLSECONDARYCOLOR3UBVEXTPROC) (const GLubyte *v);
typedef void ( * PFNGLSECONDARYCOLOR3UIEXTPROC) (GLuint red, GLuint green, GLuint blue);
typedef void ( * PFNGLSECONDARYCOLOR3UIVEXTPROC) (const GLuint *v);
typedef void ( * PFNGLSECONDARYCOLOR3USEXTPROC) (GLushort red, GLushort green, GLushort blue);
typedef void ( * PFNGLSECONDARYCOLOR3USVEXTPROC) (const GLushort *v);
typedef void ( * PFNGLSECONDARYCOLORPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, const void *pointer);
# 11921 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDELETESEMAPHORESEXTPROC) (GLsizei n, const GLuint* semaphores);
typedef void ( * PFNGLGENSEMAPHORESEXTPROC) (GLsizei n, GLuint* semaphores);
typedef void ( * PFNGLGETSEMAPHOREPARAMETERUI64VEXTPROC) (GLuint semaphore, GLenum pname, GLuint64* params);
typedef GLboolean ( * PFNGLISSEMAPHOREEXTPROC) (GLuint semaphore);
typedef void ( * PFNGLSEMAPHOREPARAMETERUI64VEXTPROC) (GLuint semaphore, GLenum pname, const GLuint64* params);
typedef void ( * PFNGLSIGNALSEMAPHOREEXTPROC) (GLuint semaphore, GLuint numBufferBarriers, const GLuint* buffers, GLuint numTextureBarriers, const GLuint *textures, const GLenum *dstLayouts);
typedef void ( * PFNGLWAITSEMAPHOREEXTPROC) (GLuint semaphore, GLuint numBufferBarriers, const GLuint* buffers, GLuint numTextureBarriers, const GLuint *textures, const GLenum *srcLayouts);
# 11946 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLIMPORTSEMAPHOREFDEXTPROC) (GLuint semaphore, GLenum handleType, GLint fd);
# 11959 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLIMPORTSEMAPHOREWIN32HANDLEEXTPROC) (GLuint semaphore, GLenum handleType, void *handle);
typedef void ( * PFNGLIMPORTSEMAPHOREWIN32NAMEEXTPROC) (GLuint semaphore, GLenum handleType, const void *name);
# 11976 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLACTIVEPROGRAMEXTPROC) (GLuint program);
typedef GLuint ( * PFNGLCREATESHADERPROGRAMEXTPROC) (GLenum type, const GLchar* string);
typedef void ( * PFNGLUSESHADERPROGRAMEXTPROC) (GLenum type, GLuint program);
# 12008 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLFRAMEBUFFERFETCHBARRIEREXTPROC) (void);
# 12106 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBINDIMAGETEXTUREEXTPROC) (GLuint index, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLint format);
typedef void ( * PFNGLMEMORYBARRIEREXTPROC) (GLbitfield barriers);
# 12174 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCLEARPIXELLOCALSTORAGEUIEXTPROC) (GLsizei offset, GLsizei n, const GLuint* values);
typedef void ( * PFNGLFRAMEBUFFERPIXELLOCALSTORAGESIZEEXTPROC) (GLuint target, GLsizei size);
typedef GLsizei ( * PFNGLGETFRAMEBUFFERPIXELLOCALSTORAGESIZEEXTPROC) (GLuint target);
# 12251 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLTEXPAGECOMMITMENTEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit);
typedef void ( * PFNGLTEXTUREPAGECOMMITMENTEXTPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit);
# 12299 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLACTIVESTENCILFACEEXTPROC) (GLenum face);
# 12324 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLTEXSUBIMAGE1DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLTEXSUBIMAGE2DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLTEXSUBIMAGE3DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
# 12385 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLPATCHPARAMETERIEXTPROC) (GLenum pname, GLint value);
# 12513 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLTEXIMAGE3DEXTPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);
# 12535 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLFRAMEBUFFERTEXTURELAYEREXTPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
# 12551 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETSAMPLERPARAMETERIIVEXTPROC) (GLuint sampler, GLenum pname, GLint* params);
typedef void ( * PFNGLGETSAMPLERPARAMETERIUIVEXTPROC) (GLuint sampler, GLenum pname, GLuint* params);
typedef void ( * PFNGLSAMPLERPARAMETERIIVEXTPROC) (GLuint sampler, GLenum pname, const GLint* params);
typedef void ( * PFNGLSAMPLERPARAMETERIUIVEXTPROC) (GLuint sampler, GLenum pname, const GLuint* params);
# 12600 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLTEXBUFFEREXTPROC) (GLenum target, GLenum internalformat, GLuint buffer);
# 12921 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCLEARCOLORIIEXTPROC) (GLint red, GLint green, GLint blue, GLint alpha);
typedef void ( * PFNGLCLEARCOLORIUIEXTPROC) (GLuint red, GLuint green, GLuint blue, GLuint alpha);
typedef void ( * PFNGLGETTEXPARAMETERIIVEXTPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETTEXPARAMETERIUIVEXTPROC) (GLenum target, GLenum pname, GLuint *params);
typedef void ( * PFNGLTEXPARAMETERIIVEXTPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void ( * PFNGLTEXPARAMETERIUIVEXTPROC) (GLenum target, GLenum pname, const GLuint *params);
# 13005 "/usr/include/GL/glew.h" 3 4
typedef GLboolean ( * PFNGLARETEXTURESRESIDENTEXTPROC) (GLsizei n, const GLuint* textures, GLboolean* residences);
typedef void ( * PFNGLBINDTEXTUREEXTPROC) (GLenum target, GLuint texture);
typedef void ( * PFNGLDELETETEXTURESEXTPROC) (GLsizei n, const GLuint* textures);
typedef void ( * PFNGLGENTEXTURESEXTPROC) (GLsizei n, GLuint* textures);
typedef GLboolean ( * PFNGLISTEXTUREEXTPROC) (GLuint texture);
typedef void ( * PFNGLPRIORITIZETEXTURESEXTPROC) (GLsizei n, const GLuint* textures, const GLclampf* priorities);
# 13031 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLTEXTURENORMALEXTPROC) (GLenum mode);
# 13224 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLTEXSTORAGE1DEXTPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
typedef void ( * PFNGLTEXSTORAGE2DEXTPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLTEXSTORAGE3DEXTPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
typedef void ( * PFNGLTEXTURESTORAGE1DEXTPROC) (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
typedef void ( * PFNGLTEXTURESTORAGE2DEXTPROC) (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLTEXTURESTORAGE3DEXTPROC) (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
# 13279 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLTEXTUREVIEWEXTPROC) (GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers);
# 13294 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETQUERYOBJECTI64VEXTPROC) (GLuint id, GLenum pname, GLint64EXT *params);
typedef void ( * PFNGLGETQUERYOBJECTUI64VEXTPROC) (GLuint id, GLenum pname, GLuint64EXT *params);
# 13325 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBEGINTRANSFORMFEEDBACKEXTPROC) (GLenum primitiveMode);
typedef void ( * PFNGLBINDBUFFERBASEEXTPROC) (GLenum target, GLuint index, GLuint buffer);
typedef void ( * PFNGLBINDBUFFEROFFSETEXTPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset);
typedef void ( * PFNGLBINDBUFFERRANGEEXTPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void ( * PFNGLENDTRANSFORMFEEDBACKEXTPROC) (void);
typedef void ( * PFNGLGETTRANSFORMFEEDBACKVARYINGEXTPROC) (GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLsizei *size, GLenum *type, GLchar *name);
typedef void ( * PFNGLTRANSFORMFEEDBACKVARYINGSEXTPROC) (GLuint program, GLsizei count, const GLchar * const* varyings, GLenum bufferMode);
# 13397 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLARRAYELEMENTEXTPROC) (GLint i);
typedef void ( * PFNGLCOLORPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const void *pointer);
typedef void ( * PFNGLDRAWARRAYSEXTPROC) (GLenum mode, GLint first, GLsizei count);
typedef void ( * PFNGLEDGEFLAGPOINTEREXTPROC) (GLsizei stride, GLsizei count, const GLboolean* pointer);
typedef void ( * PFNGLINDEXPOINTEREXTPROC) (GLenum type, GLsizei stride, GLsizei count, const void *pointer);
typedef void ( * PFNGLNORMALPOINTEREXTPROC) (GLenum type, GLsizei stride, GLsizei count, const void *pointer);
typedef void ( * PFNGLTEXCOORDPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const void *pointer);
typedef void ( * PFNGLVERTEXPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const void *pointer);
# 13435 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBINDARRAYSETEXTPROC) (const void *arrayset);
typedef const void * ( * PFNGLCREATEARRAYSETEXTPROC) (void);
typedef void ( * PFNGLDELETEARRAYSETSEXTPROC) (GLsizei n, const void *arrayset[]);
# 13465 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETVERTEXATTRIBLDVEXTPROC) (GLuint index, GLenum pname, GLdouble* params);
typedef void ( * PFNGLVERTEXARRAYVERTEXATTRIBLOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXATTRIBL1DEXTPROC) (GLuint index, GLdouble x);
typedef void ( * PFNGLVERTEXATTRIBL1DVEXTPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBL2DEXTPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void ( * PFNGLVERTEXATTRIBL2DVEXTPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBL3DEXTPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLVERTEXATTRIBL3DVEXTPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBL4DEXTPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLVERTEXATTRIBL4DVEXTPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBLPOINTEREXTPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer);
# 13609 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBEGINVERTEXSHADEREXTPROC) (void);
typedef GLuint ( * PFNGLBINDLIGHTPARAMETEREXTPROC) (GLenum light, GLenum value);
typedef GLuint ( * PFNGLBINDMATERIALPARAMETEREXTPROC) (GLenum face, GLenum value);
typedef GLuint ( * PFNGLBINDPARAMETEREXTPROC) (GLenum value);
typedef GLuint ( * PFNGLBINDTEXGENPARAMETEREXTPROC) (GLenum unit, GLenum coord, GLenum value);
typedef GLuint ( * PFNGLBINDTEXTUREUNITPARAMETEREXTPROC) (GLenum unit, GLenum value);
typedef void ( * PFNGLBINDVERTEXSHADEREXTPROC) (GLuint id);
typedef void ( * PFNGLDELETEVERTEXSHADEREXTPROC) (GLuint id);
typedef void ( * PFNGLDISABLEVARIANTCLIENTSTATEEXTPROC) (GLuint id);
typedef void ( * PFNGLENABLEVARIANTCLIENTSTATEEXTPROC) (GLuint id);
typedef void ( * PFNGLENDVERTEXSHADEREXTPROC) (void);
typedef void ( * PFNGLEXTRACTCOMPONENTEXTPROC) (GLuint res, GLuint src, GLuint num);
typedef GLuint ( * PFNGLGENSYMBOLSEXTPROC) (GLenum dataType, GLenum storageType, GLenum range, GLuint components);
typedef GLuint ( * PFNGLGENVERTEXSHADERSEXTPROC) (GLuint range);
typedef void ( * PFNGLGETINVARIANTBOOLEANVEXTPROC) (GLuint id, GLenum value, GLboolean *data);
typedef void ( * PFNGLGETINVARIANTFLOATVEXTPROC) (GLuint id, GLenum value, GLfloat *data);
typedef void ( * PFNGLGETINVARIANTINTEGERVEXTPROC) (GLuint id, GLenum value, GLint *data);
typedef void ( * PFNGLGETLOCALCONSTANTBOOLEANVEXTPROC) (GLuint id, GLenum value, GLboolean *data);
typedef void ( * PFNGLGETLOCALCONSTANTFLOATVEXTPROC) (GLuint id, GLenum value, GLfloat *data);
typedef void ( * PFNGLGETLOCALCONSTANTINTEGERVEXTPROC) (GLuint id, GLenum value, GLint *data);
typedef void ( * PFNGLGETVARIANTBOOLEANVEXTPROC) (GLuint id, GLenum value, GLboolean *data);
typedef void ( * PFNGLGETVARIANTFLOATVEXTPROC) (GLuint id, GLenum value, GLfloat *data);
typedef void ( * PFNGLGETVARIANTINTEGERVEXTPROC) (GLuint id, GLenum value, GLint *data);
typedef void ( * PFNGLGETVARIANTPOINTERVEXTPROC) (GLuint id, GLenum value, void **data);
typedef void ( * PFNGLINSERTCOMPONENTEXTPROC) (GLuint res, GLuint src, GLuint num);
typedef GLboolean ( * PFNGLISVARIANTENABLEDEXTPROC) (GLuint id, GLenum cap);
typedef void ( * PFNGLSETINVARIANTEXTPROC) (GLuint id, GLenum type, void *addr);
typedef void ( * PFNGLSETLOCALCONSTANTEXTPROC) (GLuint id, GLenum type, void *addr);
typedef void ( * PFNGLSHADEROP1EXTPROC) (GLenum op, GLuint res, GLuint arg1);
typedef void ( * PFNGLSHADEROP2EXTPROC) (GLenum op, GLuint res, GLuint arg1, GLuint arg2);
typedef void ( * PFNGLSHADEROP3EXTPROC) (GLenum op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3);
typedef void ( * PFNGLSWIZZLEEXTPROC) (GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW);
typedef void ( * PFNGLVARIANTPOINTEREXTPROC) (GLuint id, GLenum type, GLuint stride, void *addr);
typedef void ( * PFNGLVARIANTBVEXTPROC) (GLuint id, GLbyte *addr);
typedef void ( * PFNGLVARIANTDVEXTPROC) (GLuint id, GLdouble *addr);
typedef void ( * PFNGLVARIANTFVEXTPROC) (GLuint id, GLfloat *addr);
typedef void ( * PFNGLVARIANTIVEXTPROC) (GLuint id, GLint *addr);
typedef void ( * PFNGLVARIANTSVEXTPROC) (GLuint id, GLshort *addr);
typedef void ( * PFNGLVARIANTUBVEXTPROC) (GLuint id, GLubyte *addr);
typedef void ( * PFNGLVARIANTUIVEXTPROC) (GLuint id, GLuint *addr);
typedef void ( * PFNGLVARIANTUSVEXTPROC) (GLuint id, GLushort *addr);
typedef void ( * PFNGLWRITEMASKEXTPROC) (GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW);
# 13718 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLVERTEXWEIGHTPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, void *pointer);
typedef void ( * PFNGLVERTEXWEIGHTFEXTPROC) (GLfloat weight);
typedef void ( * PFNGLVERTEXWEIGHTFVEXTPROC) (GLfloat* weight);
# 13735 "/usr/include/GL/glew.h" 3 4
typedef GLboolean ( * PFNGLACQUIREKEYEDMUTEXWIN32EXTPROC) (GLuint memory, GLuint64 key, GLuint timeout);
typedef GLboolean ( * PFNGLRELEASEKEYEDMUTEXWIN32EXTPROC) (GLuint memory, GLuint64 key);
# 13757 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLWINDOWRECTANGLESEXTPROC) (GLenum mode, GLsizei count, const GLint box[]);
# 13772 "/usr/include/GL/glew.h" 3 4
typedef GLsync ( * PFNGLIMPORTSYNCEXTPROC) (GLenum external_sync_type, GLintptr external_sync, GLbitfield flags);
# 13796 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLFRAMETERMINATORGREMEDYPROC) (void);
# 13809 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLSTRINGMARKERGREMEDYPROC) (GLsizei len, const void *string);
# 13831 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETIMAGETRANSFORMPARAMETERFVHPPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLGETIMAGETRANSFORMPARAMETERIVHPPROC) (GLenum target, GLenum pname, const GLint* params);
typedef void ( * PFNGLIMAGETRANSFORMPARAMETERFHPPROC) (GLenum target, GLenum pname, const GLfloat param);
typedef void ( * PFNGLIMAGETRANSFORMPARAMETERFVHPPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLIMAGETRANSFORMPARAMETERIHPPROC) (GLenum target, GLenum pname, const GLint param);
typedef void ( * PFNGLIMAGETRANSFORMPARAMETERIVHPPROC) (GLenum target, GLenum pname, const GLint* params);
# 13883 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLMULTIMODEDRAWARRAYSIBMPROC) (const GLenum* mode, const GLint *first, const GLsizei *count, GLsizei primcount, GLint modestride);
typedef void ( * PFNGLMULTIMODEDRAWELEMENTSIBMPROC) (const GLenum* mode, const GLsizei *count, GLenum type, const void *const *indices, GLsizei primcount, GLint modestride);
# 13949 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCOLORPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const void** pointer, GLint ptrstride);
typedef void ( * PFNGLEDGEFLAGPOINTERLISTIBMPROC) (GLint stride, const GLboolean ** pointer, GLint ptrstride);
typedef void ( * PFNGLFOGCOORDPOINTERLISTIBMPROC) (GLenum type, GLint stride, const void** pointer, GLint ptrstride);
typedef void ( * PFNGLINDEXPOINTERLISTIBMPROC) (GLenum type, GLint stride, const void** pointer, GLint ptrstride);
typedef void ( * PFNGLNORMALPOINTERLISTIBMPROC) (GLenum type, GLint stride, const void** pointer, GLint ptrstride);
typedef void ( * PFNGLSECONDARYCOLORPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const void** pointer, GLint ptrstride);
typedef void ( * PFNGLTEXCOORDPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const void** pointer, GLint ptrstride);
typedef void ( * PFNGLVERTEXPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const void** pointer, GLint ptrstride);
# 13976 "/usr/include/GL/glew.h" 3 4
typedef GLuint64 ( * PFNGLGETTEXTUREHANDLEIMGPROC) (GLuint texture);
typedef GLuint64 ( * PFNGLGETTEXTURESAMPLERHANDLEIMGPROC) (GLuint texture, GLuint sampler);
typedef void ( * PFNGLPROGRAMUNIFORMHANDLEUI64IMGPROC) (GLuint program, GLint location, GLuint64 value);
typedef void ( * PFNGLPROGRAMUNIFORMHANDLEUI64VIMGPROC) (GLuint program, GLint location, GLsizei count, const GLuint64* values);
typedef void ( * PFNGLUNIFORMHANDLEUI64IMGPROC) (GLint location, GLuint64 value);
typedef void ( * PFNGLUNIFORMHANDLEUI64VIMGPROC) (GLint location, GLsizei count, const GLuint64* value);
# 14004 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLFRAMEBUFFERTEXTURE2DDOWNSAMPLEIMGPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint xscale, GLint yscale);
typedef void ( * PFNGLFRAMEBUFFERTEXTURELAYERDOWNSAMPLEIMGPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer, GLint xscale, GLint yscale);
# 14024 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLFRAMEBUFFERTEXTURE2DMULTISAMPLEIMGPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples);
typedef void ( * PFNGLRENDERBUFFERSTORAGEMULTISAMPLEIMGPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
# 14203 "/usr/include/GL/glew.h" 3 4
typedef void * ( * PFNGLMAPTEXTURE2DINTELPROC) (GLuint texture, GLint level, GLbitfield access, GLint* stride, GLenum *layout);
typedef void ( * PFNGLSYNCTEXTUREINTELPROC) (GLuint texture);
typedef void ( * PFNGLUNMAPTEXTURE2DINTELPROC) (GLuint texture, GLint level);
# 14226 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCOLORPOINTERVINTELPROC) (GLint size, GLenum type, const void** pointer);
typedef void ( * PFNGLNORMALPOINTERVINTELPROC) (GLenum type, const void** pointer);
typedef void ( * PFNGLTEXCOORDPOINTERVINTELPROC) (GLint size, GLenum type, const void** pointer);
typedef void ( * PFNGLVERTEXPOINTERVINTELPROC) (GLint size, GLenum type, const void** pointer);
# 14266 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBEGINPERFQUERYINTELPROC) (GLuint queryHandle);
typedef void ( * PFNGLCREATEPERFQUERYINTELPROC) (GLuint queryId, GLuint* queryHandle);
typedef void ( * PFNGLDELETEPERFQUERYINTELPROC) (GLuint queryHandle);
typedef void ( * PFNGLENDPERFQUERYINTELPROC) (GLuint queryHandle);
typedef void ( * PFNGLGETFIRSTPERFQUERYIDINTELPROC) (GLuint* queryId);
typedef void ( * PFNGLGETNEXTPERFQUERYIDINTELPROC) (GLuint queryId, GLuint* nextQueryId);
typedef void ( * PFNGLGETPERFCOUNTERINFOINTELPROC) (GLuint queryId, GLuint counterId, GLuint counterNameLength, GLchar* counterName, GLuint counterDescLength, GLchar *counterDesc, GLuint *counterOffset, GLuint *counterDataSize, GLuint *counterTypeEnum, GLuint *counterDataTypeEnum, GLuint64 *rawCounterMaxValue);
typedef void ( * PFNGLGETPERFQUERYDATAINTELPROC) (GLuint queryHandle, GLuint flags, GLsizei dataSize, void *data, GLuint *bytesWritten);
typedef void ( * PFNGLGETPERFQUERYIDBYNAMEINTELPROC) (GLchar* queryName, GLuint *queryId);
typedef void ( * PFNGLGETPERFQUERYINFOINTELPROC) (GLuint queryId, GLuint queryNameLength, GLchar* queryName, GLuint *dataSize, GLuint *noCounters, GLuint *noInstances, GLuint *capsMask);
# 14306 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLTEXSCISSORFUNCINTELPROC) (GLenum target, GLenum lfunc, GLenum hfunc);
typedef void ( * PFNGLTEXSCISSORINTELPROC) (GLenum target, GLclampf tlow, GLclampf thigh);
# 14338 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBLENDBARRIERKHRPROC) (void);
# 14413 "/usr/include/GL/glew.h" 3 4
typedef void ( *GLDEBUGPROC)(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* message, const void* userParam);

typedef void ( * PFNGLDEBUGMESSAGECALLBACKPROC) (GLDEBUGPROC callback, const void *userParam);
typedef void ( * PFNGLDEBUGMESSAGECONTROLPROC) (GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint* ids, GLboolean enabled);
typedef void ( * PFNGLDEBUGMESSAGEINSERTPROC) (GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* buf);
typedef GLuint ( * PFNGLGETDEBUGMESSAGELOGPROC) (GLuint count, GLsizei bufSize, GLenum* sources, GLenum* types, GLuint* ids, GLenum* severities, GLsizei* lengths, GLchar* messageLog);
typedef void ( * PFNGLGETOBJECTLABELPROC) (GLenum identifier, GLuint name, GLsizei bufSize, GLsizei* length, GLchar *label);
typedef void ( * PFNGLGETOBJECTPTRLABELPROC) (void* ptr, GLsizei bufSize, GLsizei* length, GLchar *label);
typedef void ( * PFNGLOBJECTLABELPROC) (GLenum identifier, GLuint name, GLsizei length, const GLchar* label);
typedef void ( * PFNGLOBJECTPTRLABELPROC) (void* ptr, GLsizei length, const GLchar* label);
typedef void ( * PFNGLPOPDEBUGGROUPPROC) (void);
typedef void ( * PFNGLPUSHDEBUGGROUPPROC) (GLenum source, GLuint id, GLsizei length, const GLchar * message);
# 14460 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLMAXSHADERCOMPILERTHREADSKHRPROC) (GLuint count);
# 14491 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETNUNIFORMFVPROC) (GLuint program, GLint location, GLsizei bufSize, GLfloat* params);
typedef void ( * PFNGLGETNUNIFORMIVPROC) (GLuint program, GLint location, GLsizei bufSize, GLint* params);
typedef void ( * PFNGLGETNUNIFORMUIVPROC) (GLuint program, GLint location, GLsizei bufSize, GLuint* params);
typedef void ( * PFNGLREADNPIXELSPROC) (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data);
# 14662 "/usr/include/GL/glew.h" 3 4
typedef GLuint ( * PFNGLBUFFERREGIONENABLEDPROC) (void);
typedef void ( * PFNGLDELETEBUFFERREGIONPROC) (GLenum region);
typedef void ( * PFNGLDRAWBUFFERREGIONPROC) (GLuint region, GLint x, GLint y, GLsizei width, GLsizei height, GLint xDest, GLint yDest);
typedef GLuint ( * PFNGLNEWBUFFERREGIONPROC) (GLenum region);
typedef void ( * PFNGLREADBUFFERREGIONPROC) (GLuint region, GLint x, GLint y, GLsizei width, GLsizei height);
# 14701 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLFRAMEBUFFERPARAMETERIMESAPROC) (GLenum target, GLenum pname, GLint param);
typedef void ( * PFNGLGETFRAMEBUFFERPARAMETERIVMESAPROC) (GLenum target, GLenum pname, GLint* params);
# 14738 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLRESIZEBUFFERSMESAPROC) (void);
# 14769 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLWINDOWPOS2DMESAPROC) (GLdouble x, GLdouble y);
typedef void ( * PFNGLWINDOWPOS2DVMESAPROC) (const GLdouble* p);
typedef void ( * PFNGLWINDOWPOS2FMESAPROC) (GLfloat x, GLfloat y);
typedef void ( * PFNGLWINDOWPOS2FVMESAPROC) (const GLfloat* p);
typedef void ( * PFNGLWINDOWPOS2IMESAPROC) (GLint x, GLint y);
typedef void ( * PFNGLWINDOWPOS2IVMESAPROC) (const GLint* p);
typedef void ( * PFNGLWINDOWPOS2SMESAPROC) (GLshort x, GLshort y);
typedef void ( * PFNGLWINDOWPOS2SVMESAPROC) (const GLshort* p);
typedef void ( * PFNGLWINDOWPOS3DMESAPROC) (GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLWINDOWPOS3DVMESAPROC) (const GLdouble* p);
typedef void ( * PFNGLWINDOWPOS3FMESAPROC) (GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLWINDOWPOS3FVMESAPROC) (const GLfloat* p);
typedef void ( * PFNGLWINDOWPOS3IMESAPROC) (GLint x, GLint y, GLint z);
typedef void ( * PFNGLWINDOWPOS3IVMESAPROC) (const GLint* p);
typedef void ( * PFNGLWINDOWPOS3SMESAPROC) (GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLWINDOWPOS3SVMESAPROC) (const GLshort* p);
typedef void ( * PFNGLWINDOWPOS4DMESAPROC) (GLdouble x, GLdouble y, GLdouble z, GLdouble);
typedef void ( * PFNGLWINDOWPOS4DVMESAPROC) (const GLdouble* p);
typedef void ( * PFNGLWINDOWPOS4FMESAPROC) (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLWINDOWPOS4FVMESAPROC) (const GLfloat* p);
typedef void ( * PFNGLWINDOWPOS4IMESAPROC) (GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLWINDOWPOS4IVMESAPROC) (const GLint* p);
typedef void ( * PFNGLWINDOWPOS4SMESAPROC) (GLshort x, GLshort y, GLshort z, GLshort w);
typedef void ( * PFNGLWINDOWPOS4SVMESAPROC) (const GLshort* p);
# 14850 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBEGINCONDITIONALRENDERNVXPROC) (GLuint id);
typedef void ( * PFNGLENDCONDITIONALRENDERNVXPROC) (void);
# 14882 "/usr/include/GL/glew.h" 3 4
typedef GLsync ( * PFNGLASYNCCOPYBUFFERSUBDATANVXPROC) (GLsizei waitSemaphoreCount, const GLuint* waitSemaphoreArray, const GLuint64 *fenceValueArray, GLuint readGpu, GLbitfield writeGpuMask, GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size, GLsizei signalSemaphoreCount, const GLuint *signalSemaphoreArray, const GLuint64 *signalValueArray);
typedef GLuint ( * PFNGLASYNCCOPYIMAGESUBDATANVXPROC) (GLsizei waitSemaphoreCount, const GLuint* waitSemaphoreArray, const GLuint64 *waitValueArray, GLuint srcGpu, GLbitfield dstGpuMask, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth, GLsizei signalSemaphoreCount, const GLuint *signalSemaphoreArray, const GLuint64 *signalValueArray);
typedef void ( * PFNGLMULTICASTSCISSORARRAYVNVXPROC) (GLuint gpu, GLuint first, GLsizei count, const GLint* v);
typedef void ( * PFNGLMULTICASTVIEWPORTARRAYVNVXPROC) (GLuint gpu, GLuint first, GLsizei count, const GLfloat* v);
typedef void ( * PFNGLMULTICASTVIEWPORTPOSITIONWSCALENVXPROC) (GLuint gpu, GLuint index, GLfloat xcoeff, GLfloat ycoeff);
typedef void ( * PFNGLUPLOADGPUMASKNVXPROC) (GLbitfield mask);
# 14908 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLLGPUCOPYIMAGESUBDATANVXPROC) (GLuint sourceGpu, GLbitfield destinationGpuMask, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srxY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth);
typedef void ( * PFNGLLGPUINTERLOCKNVXPROC) (void);
typedef void ( * PFNGLLGPUNAMEDBUFFERSUBDATANVXPROC) (GLbitfield gpuMask, GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data);
# 14925 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCLIENTWAITSEMAPHOREUI64NVXPROC) (GLsizei fenceObjectCount, const GLuint* semaphoreArray, const GLuint64 *fenceValueArray);
typedef void ( * PFNGLSIGNALSEMAPHOREUI64NVXPROC) (GLuint signalGpu, GLsizei fenceObjectCount, const GLuint* semaphoreArray, const GLuint64 *fenceValueArray);
typedef void ( * PFNGLWAITSEMAPHOREUI64NVXPROC) (GLuint waitGpu, GLsizei fenceObjectCount, const GLuint* semaphoreArray, const GLuint64 *fenceValueArray);
# 14950 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLSTEREOPARAMETERFNVPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLSTEREOPARAMETERINVPROC) (GLenum pname, GLint param);
# 14984 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLALPHATOCOVERAGEDITHERCONTROLNVPROC) (GLenum mode);
# 15008 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSNVPROC) (GLenum mode, const void *indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount);
typedef void ( * PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSNVPROC) (GLenum mode, GLenum type, const void *indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount);
# 15023 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSCOUNTNVPROC) (GLenum mode, const void *indirect, GLintptr drawCount, GLsizei maxDrawCount, GLsizei stride, GLint vertexBufferCount);
typedef void ( * PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSCOUNTNVPROC) (GLenum mode, GLenum type, const void *indirect, GLintptr drawCount, GLsizei maxDrawCount, GLsizei stride, GLint vertexBufferCount);
# 15038 "/usr/include/GL/glew.h" 3 4
typedef GLuint64 ( * PFNGLGETIMAGEHANDLENVPROC) (GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format);
typedef GLuint64 ( * PFNGLGETTEXTUREHANDLENVPROC) (GLuint texture);
typedef GLuint64 ( * PFNGLGETTEXTURESAMPLERHANDLENVPROC) (GLuint texture, GLuint sampler);
typedef GLboolean ( * PFNGLISIMAGEHANDLERESIDENTNVPROC) (GLuint64 handle);
typedef GLboolean ( * PFNGLISTEXTUREHANDLERESIDENTNVPROC) (GLuint64 handle);
typedef void ( * PFNGLMAKEIMAGEHANDLENONRESIDENTNVPROC) (GLuint64 handle);
typedef void ( * PFNGLMAKEIMAGEHANDLERESIDENTNVPROC) (GLuint64 handle, GLenum access);
typedef void ( * PFNGLMAKETEXTUREHANDLENONRESIDENTNVPROC) (GLuint64 handle);
typedef void ( * PFNGLMAKETEXTUREHANDLERESIDENTNVPROC) (GLuint64 handle);
typedef void ( * PFNGLPROGRAMUNIFORMHANDLEUI64NVPROC) (GLuint program, GLint location, GLuint64 value);
typedef void ( * PFNGLPROGRAMUNIFORMHANDLEUI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64* values);
typedef void ( * PFNGLUNIFORMHANDLEUI64NVPROC) (GLint location, GLuint64 value);
typedef void ( * PFNGLUNIFORMHANDLEUI64VNVPROC) (GLint location, GLsizei count, const GLuint64* value);
# 15126 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBLENDBARRIERNVPROC) (void);
typedef void ( * PFNGLBLENDPARAMETERINVPROC) (GLenum pname, GLint value);
# 15175 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLVIEWPORTPOSITIONWSCALENVPROC) (GLuint index, GLfloat xcoeff, GLfloat ycoeff);
# 15208 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCALLCOMMANDLISTNVPROC) (GLuint list);
typedef void ( * PFNGLCOMMANDLISTSEGMENTSNVPROC) (GLuint list, GLuint segments);
typedef void ( * PFNGLCOMPILECOMMANDLISTNVPROC) (GLuint list);
typedef void ( * PFNGLCREATECOMMANDLISTSNVPROC) (GLsizei n, GLuint* lists);
typedef void ( * PFNGLCREATESTATESNVPROC) (GLsizei n, GLuint* states);
typedef void ( * PFNGLDELETECOMMANDLISTSNVPROC) (GLsizei n, const GLuint* lists);
typedef void ( * PFNGLDELETESTATESNVPROC) (GLsizei n, const GLuint* states);
typedef void ( * PFNGLDRAWCOMMANDSADDRESSNVPROC) (GLenum primitiveMode, const GLuint64* indirects, const GLsizei* sizes, GLuint count);
typedef void ( * PFNGLDRAWCOMMANDSNVPROC) (GLenum primitiveMode, GLuint buffer, const GLintptr* indirects, const GLsizei* sizes, GLuint count);
typedef void ( * PFNGLDRAWCOMMANDSSTATESADDRESSNVPROC) (const GLuint64* indirects, const GLsizei* sizes, const GLuint* states, const GLuint* fbos, GLuint count);
typedef void ( * PFNGLDRAWCOMMANDSSTATESNVPROC) (GLuint buffer, const GLintptr* indirects, const GLsizei* sizes, const GLuint* states, const GLuint* fbos, GLuint count);
typedef GLuint ( * PFNGLGETCOMMANDHEADERNVPROC) (GLenum tokenID, GLuint size);
typedef GLushort ( * PFNGLGETSTAGEINDEXNVPROC) (GLenum shadertype);
typedef GLboolean ( * PFNGLISCOMMANDLISTNVPROC) (GLuint list);
typedef GLboolean ( * PFNGLISSTATENVPROC) (GLuint state);
typedef void ( * PFNGLLISTDRAWCOMMANDSSTATESCLIENTNVPROC) (GLuint list, GLuint segment, const void** indirects, const GLsizei* sizes, const GLuint* states, const GLuint* fbos, GLuint count);
typedef void ( * PFNGLSTATECAPTURENVPROC) (GLuint state, GLenum mode);
# 15279 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBEGINCONDITIONALRENDERNVPROC) (GLuint id, GLenum mode);
typedef void ( * PFNGLENDCONDITIONALRENDERNVPROC) (void);
# 15299 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLSUBPIXELPRECISIONBIASNVPROC) (GLuint xbits, GLuint ybits);
# 15316 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCONSERVATIVERASTERPARAMETERFNVPROC) (GLenum pname, GLfloat value);
# 15344 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCONSERVATIVERASTERPARAMETERINVPROC) (GLenum pname, GLint param);
# 15369 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCOPYBUFFERSUBDATANVPROC) (GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size);
# 15394 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCOPYIMAGESUBDATANVPROC) (GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth);
# 15424 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCLEARDEPTHDNVPROC) (GLdouble depth);
typedef void ( * PFNGLDEPTHBOUNDSDNVPROC) (GLdouble zmin, GLdouble zmax);
typedef void ( * PFNGLDEPTHRANGEDNVPROC) (GLdouble zNear, GLdouble zFar);
# 15512 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDRAWBUFFERSNVPROC) (GLsizei n, const GLenum* bufs);
# 15525 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDRAWARRAYSINSTANCEDNVPROC) (GLenum mode, GLint first, GLsizei count, GLsizei primcount);
typedef void ( * PFNGLDRAWELEMENTSINSTANCEDNVPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount);
# 15540 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDRAWTEXTURENVPROC) (GLuint texture, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z, GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1);
# 15553 "/usr/include/GL/glew.h" 3 4
typedef void ( *GLVULKANPROCNV)(void);

typedef void ( * PFNGLDRAWVKIMAGENVPROC) (GLuint64 vkImage, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z, GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1);
typedef GLVULKANPROCNV ( * PFNGLGETVKPROCADDRNVPROC) (const GLchar* name);
typedef void ( * PFNGLSIGNALVKFENCENVPROC) (GLuint64 vkFence);
typedef void ( * PFNGLSIGNALVKSEMAPHORENVPROC) (GLuint64 vkSemaphore);
typedef void ( * PFNGLWAITVKSEMAPHORENVPROC) (GLuint64 vkSemaphore);
# 15601 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLEVALMAPSNVPROC) (GLenum target, GLenum mode);
typedef void ( * PFNGLGETMAPATTRIBPARAMETERFVNVPROC) (GLenum target, GLuint index, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETMAPATTRIBPARAMETERIVNVPROC) (GLenum target, GLuint index, GLenum pname, GLint* params);
typedef void ( * PFNGLGETMAPCONTROLPOINTSNVPROC) (GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, void *points);
typedef void ( * PFNGLGETMAPPARAMETERFVNVPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETMAPPARAMETERIVNVPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLMAPCONTROLPOINTSNVPROC) (GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const void *points);
typedef void ( * PFNGLMAPPARAMETERFVNVPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLMAPPARAMETERIVNVPROC) (GLenum target, GLenum pname, const GLint* params);
# 15650 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETMULTISAMPLEFVNVPROC) (GLenum pname, GLuint index, GLfloat* val);
typedef void ( * PFNGLSAMPLEMASKINDEXEDNVPROC) (GLuint index, GLbitfield mask);
typedef void ( * PFNGLTEXRENDERBUFFERNVPROC) (GLenum target, GLuint renderbuffer);
# 15698 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDELETEFENCESNVPROC) (GLsizei n, const GLuint* fences);
typedef void ( * PFNGLFINISHFENCENVPROC) (GLuint fence);
typedef void ( * PFNGLGENFENCESNVPROC) (GLsizei n, GLuint* fences);
typedef void ( * PFNGLGETFENCEIVNVPROC) (GLuint fence, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISFENCENVPROC) (GLuint fence);
typedef void ( * PFNGLSETFENCENVPROC) (GLuint fence, GLenum condition);
typedef GLboolean ( * PFNGLTESTFENCENVPROC) (GLuint fence);
# 15775 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLFRAGMENTCOVERAGECOLORNVPROC) (GLuint color);
# 15795 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETPROGRAMNAMEDPARAMETERDVNVPROC) (GLuint id, GLsizei len, const GLubyte* name, GLdouble *params);
typedef void ( * PFNGLGETPROGRAMNAMEDPARAMETERFVNVPROC) (GLuint id, GLsizei len, const GLubyte* name, GLfloat *params);
typedef void ( * PFNGLPROGRAMNAMEDPARAMETER4DNVPROC) (GLuint id, GLsizei len, const GLubyte* name, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLPROGRAMNAMEDPARAMETER4DVNVPROC) (GLuint id, GLsizei len, const GLubyte* name, const GLdouble v[]);
typedef void ( * PFNGLPROGRAMNAMEDPARAMETER4FNVPROC) (GLuint id, GLsizei len, const GLubyte* name, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLPROGRAMNAMEDPARAMETER4FVNVPROC) (GLuint id, GLsizei len, const GLubyte* name, const GLfloat v[]);
# 15874 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBLITFRAMEBUFFERNVPROC) (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
# 15915 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLRENDERBUFFERSTORAGEMULTISAMPLENVPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
# 15933 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENVPROC) (GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height);
# 15959 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLPROGRAMVERTEXLIMITNVPROC) (GLenum target, GLint limit);
# 15996 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLMULTICASTBARRIERNVPROC) (void);
typedef void ( * PFNGLMULTICASTBLITFRAMEBUFFERNVPROC) (GLuint srcGpu, GLuint dstGpu, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
typedef void ( * PFNGLMULTICASTBUFFERSUBDATANVPROC) (GLbitfield gpuMask, GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data);
typedef void ( * PFNGLMULTICASTCOPYBUFFERSUBDATANVPROC) (GLuint readGpu, GLbitfield writeGpuMask, GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
typedef void ( * PFNGLMULTICASTCOPYIMAGESUBDATANVPROC) (GLuint srcGpu, GLbitfield dstGpuMask, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);
typedef void ( * PFNGLMULTICASTFRAMEBUFFERSAMPLELOCATIONSFVNVPROC) (GLuint gpu, GLuint framebuffer, GLuint start, GLsizei count, const GLfloat* v);
typedef void ( * PFNGLMULTICASTGETQUERYOBJECTI64VNVPROC) (GLuint gpu, GLuint id, GLenum pname, GLint64* params);
typedef void ( * PFNGLMULTICASTGETQUERYOBJECTIVNVPROC) (GLuint gpu, GLuint id, GLenum pname, GLint* params);
typedef void ( * PFNGLMULTICASTGETQUERYOBJECTUI64VNVPROC) (GLuint gpu, GLuint id, GLenum pname, GLuint64* params);
typedef void ( * PFNGLMULTICASTGETQUERYOBJECTUIVNVPROC) (GLuint gpu, GLuint id, GLenum pname, GLuint* params);
typedef void ( * PFNGLMULTICASTWAITSYNCNVPROC) (GLuint signalGpu, GLbitfield waitGpuMask);
typedef void ( * PFNGLRENDERGPUMASKNVPROC) (GLbitfield mask);
# 16040 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLPROGRAMENVPARAMETERI4INVPROC) (GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLPROGRAMENVPARAMETERI4IVNVPROC) (GLenum target, GLuint index, const GLint *params);
typedef void ( * PFNGLPROGRAMENVPARAMETERI4UINVPROC) (GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void ( * PFNGLPROGRAMENVPARAMETERI4UIVNVPROC) (GLenum target, GLuint index, const GLuint *params);
typedef void ( * PFNGLPROGRAMENVPARAMETERSI4IVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLint *params);
typedef void ( * PFNGLPROGRAMENVPARAMETERSI4UIVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLuint *params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERI4INVPROC) (GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERI4IVNVPROC) (GLenum target, GLuint index, const GLint *params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERI4UINVPROC) (GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERI4UIVNVPROC) (GLenum target, GLuint index, const GLuint *params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERSI4IVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLint *params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERSI4UIVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLuint *params);
# 16138 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETUNIFORMI64VNVPROC) (GLuint program, GLint location, GLint64EXT* params);
typedef void ( * PFNGLGETUNIFORMUI64VNVPROC) (GLuint program, GLint location, GLuint64EXT* params);
typedef void ( * PFNGLPROGRAMUNIFORM1I64NVPROC) (GLuint program, GLint location, GLint64EXT x);
typedef void ( * PFNGLPROGRAMUNIFORM1I64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLint64EXT* value);
typedef void ( * PFNGLPROGRAMUNIFORM1UI64NVPROC) (GLuint program, GLint location, GLuint64EXT x);
typedef void ( * PFNGLPROGRAMUNIFORM1UI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
typedef void ( * PFNGLPROGRAMUNIFORM2I64NVPROC) (GLuint program, GLint location, GLint64EXT x, GLint64EXT y);
typedef void ( * PFNGLPROGRAMUNIFORM2I64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLint64EXT* value);
typedef void ( * PFNGLPROGRAMUNIFORM2UI64NVPROC) (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y);
typedef void ( * PFNGLPROGRAMUNIFORM2UI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
typedef void ( * PFNGLPROGRAMUNIFORM3I64NVPROC) (GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z);
typedef void ( * PFNGLPROGRAMUNIFORM3I64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLint64EXT* value);
typedef void ( * PFNGLPROGRAMUNIFORM3UI64NVPROC) (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
typedef void ( * PFNGLPROGRAMUNIFORM3UI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
typedef void ( * PFNGLPROGRAMUNIFORM4I64NVPROC) (GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
typedef void ( * PFNGLPROGRAMUNIFORM4I64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLint64EXT* value);
typedef void ( * PFNGLPROGRAMUNIFORM4UI64NVPROC) (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
typedef void ( * PFNGLPROGRAMUNIFORM4UI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
typedef void ( * PFNGLUNIFORM1I64NVPROC) (GLint location, GLint64EXT x);
typedef void ( * PFNGLUNIFORM1I64VNVPROC) (GLint location, GLsizei count, const GLint64EXT* value);
typedef void ( * PFNGLUNIFORM1UI64NVPROC) (GLint location, GLuint64EXT x);
typedef void ( * PFNGLUNIFORM1UI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT* value);
typedef void ( * PFNGLUNIFORM2I64NVPROC) (GLint location, GLint64EXT x, GLint64EXT y);
typedef void ( * PFNGLUNIFORM2I64VNVPROC) (GLint location, GLsizei count, const GLint64EXT* value);
typedef void ( * PFNGLUNIFORM2UI64NVPROC) (GLint location, GLuint64EXT x, GLuint64EXT y);
typedef void ( * PFNGLUNIFORM2UI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT* value);
typedef void ( * PFNGLUNIFORM3I64NVPROC) (GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z);
typedef void ( * PFNGLUNIFORM3I64VNVPROC) (GLint location, GLsizei count, const GLint64EXT* value);
typedef void ( * PFNGLUNIFORM3UI64NVPROC) (GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
typedef void ( * PFNGLUNIFORM3UI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT* value);
typedef void ( * PFNGLUNIFORM4I64NVPROC) (GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
typedef void ( * PFNGLUNIFORM4I64VNVPROC) (GLint location, GLsizei count, const GLint64EXT* value);
typedef void ( * PFNGLUNIFORM4UI64NVPROC) (GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
typedef void ( * PFNGLUNIFORM4UI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT* value);
# 16219 "/usr/include/GL/glew.h" 3 4
typedef unsigned short GLhalf;

typedef void ( * PFNGLCOLOR3HNVPROC) (GLhalf red, GLhalf green, GLhalf blue);
typedef void ( * PFNGLCOLOR3HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLCOLOR4HNVPROC) (GLhalf red, GLhalf green, GLhalf blue, GLhalf alpha);
typedef void ( * PFNGLCOLOR4HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLFOGCOORDHNVPROC) (GLhalf fog);
typedef void ( * PFNGLFOGCOORDHVNVPROC) (const GLhalf* fog);
typedef void ( * PFNGLMULTITEXCOORD1HNVPROC) (GLenum target, GLhalf s);
typedef void ( * PFNGLMULTITEXCOORD1HVNVPROC) (GLenum target, const GLhalf* v);
typedef void ( * PFNGLMULTITEXCOORD2HNVPROC) (GLenum target, GLhalf s, GLhalf t);
typedef void ( * PFNGLMULTITEXCOORD2HVNVPROC) (GLenum target, const GLhalf* v);
typedef void ( * PFNGLMULTITEXCOORD3HNVPROC) (GLenum target, GLhalf s, GLhalf t, GLhalf r);
typedef void ( * PFNGLMULTITEXCOORD3HVNVPROC) (GLenum target, const GLhalf* v);
typedef void ( * PFNGLMULTITEXCOORD4HNVPROC) (GLenum target, GLhalf s, GLhalf t, GLhalf r, GLhalf q);
typedef void ( * PFNGLMULTITEXCOORD4HVNVPROC) (GLenum target, const GLhalf* v);
typedef void ( * PFNGLNORMAL3HNVPROC) (GLhalf nx, GLhalf ny, GLhalf nz);
typedef void ( * PFNGLNORMAL3HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLSECONDARYCOLOR3HNVPROC) (GLhalf red, GLhalf green, GLhalf blue);
typedef void ( * PFNGLSECONDARYCOLOR3HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLTEXCOORD1HNVPROC) (GLhalf s);
typedef void ( * PFNGLTEXCOORD1HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLTEXCOORD2HNVPROC) (GLhalf s, GLhalf t);
typedef void ( * PFNGLTEXCOORD2HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLTEXCOORD3HNVPROC) (GLhalf s, GLhalf t, GLhalf r);
typedef void ( * PFNGLTEXCOORD3HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLTEXCOORD4HNVPROC) (GLhalf s, GLhalf t, GLhalf r, GLhalf q);
typedef void ( * PFNGLTEXCOORD4HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLVERTEX2HNVPROC) (GLhalf x, GLhalf y);
typedef void ( * PFNGLVERTEX2HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLVERTEX3HNVPROC) (GLhalf x, GLhalf y, GLhalf z);
typedef void ( * PFNGLVERTEX3HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLVERTEX4HNVPROC) (GLhalf x, GLhalf y, GLhalf z, GLhalf w);
typedef void ( * PFNGLVERTEX4HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLVERTEXATTRIB1HNVPROC) (GLuint index, GLhalf x);
typedef void ( * PFNGLVERTEXATTRIB1HVNVPROC) (GLuint index, const GLhalf* v);
typedef void ( * PFNGLVERTEXATTRIB2HNVPROC) (GLuint index, GLhalf x, GLhalf y);
typedef void ( * PFNGLVERTEXATTRIB2HVNVPROC) (GLuint index, const GLhalf* v);
typedef void ( * PFNGLVERTEXATTRIB3HNVPROC) (GLuint index, GLhalf x, GLhalf y, GLhalf z);
typedef void ( * PFNGLVERTEXATTRIB3HVNVPROC) (GLuint index, const GLhalf* v);
typedef void ( * PFNGLVERTEXATTRIB4HNVPROC) (GLuint index, GLhalf x, GLhalf y, GLhalf z, GLhalf w);
typedef void ( * PFNGLVERTEXATTRIB4HVNVPROC) (GLuint index, const GLhalf* v);
typedef void ( * PFNGLVERTEXATTRIBS1HVNVPROC) (GLuint index, GLsizei n, const GLhalf* v);
typedef void ( * PFNGLVERTEXATTRIBS2HVNVPROC) (GLuint index, GLsizei n, const GLhalf* v);
typedef void ( * PFNGLVERTEXATTRIBS3HVNVPROC) (GLuint index, GLsizei n, const GLhalf* v);
typedef void ( * PFNGLVERTEXATTRIBS4HVNVPROC) (GLuint index, GLsizei n, const GLhalf* v);
typedef void ( * PFNGLVERTEXWEIGHTHNVPROC) (GLhalf weight);
typedef void ( * PFNGLVERTEXWEIGHTHVNVPROC) (const GLhalf* weight);
# 16335 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLVERTEXATTRIBDIVISORNVPROC) (GLuint index, GLuint divisor);
# 16353 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETINTERNALFORMATSAMPLEIVNVPROC) (GLenum target, GLenum internalformat, GLsizei samples, GLenum pname, GLsizei bufSize, GLint* params);
# 16389 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBUFFERATTACHMEMORYNVPROC) (GLenum target, GLuint memory, GLuint64 offset);
typedef void ( * PFNGLGETMEMORYOBJECTDETACHEDRESOURCESUIVNVPROC) (GLuint memory, GLenum pname, GLint first, GLsizei count, GLuint* params);
typedef void ( * PFNGLNAMEDBUFFERATTACHMEMORYNVPROC) (GLuint buffer, GLuint memory, GLuint64 offset);
typedef void ( * PFNGLRESETMEMORYOBJECTPARAMETERNVPROC) (GLuint memory, GLenum pname);
typedef void ( * PFNGLTEXATTACHMEMORYNVPROC) (GLenum target, GLuint memory, GLuint64 offset);
typedef void ( * PFNGLTEXTUREATTACHMEMORYNVPROC) (GLuint texture, GLuint memory, GLuint64 offset);
# 16461 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDRAWMESHTASKSINDIRECTNVPROC) (GLintptr indirect);
typedef void ( * PFNGLDRAWMESHTASKSNVPROC) (GLuint first, GLuint count);
typedef void ( * PFNGLMULTIDRAWMESHTASKSINDIRECTCOUNTNVPROC) (GLintptr indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
typedef void ( * PFNGLMULTIDRAWMESHTASKSINDIRECTNVPROC) (GLintptr indirect, GLsizei drawcount, GLsizei stride);
# 16509 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLUNIFORMMATRIX2X3FVNVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLUNIFORMMATRIX2X4FVNVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLUNIFORMMATRIX3X2FVNVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLUNIFORMMATRIX3X4FVNVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLUNIFORMMATRIX4X2FVNVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLUNIFORMMATRIX4X3FVNVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
# 16537 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBEGINOCCLUSIONQUERYNVPROC) (GLuint id);
typedef void ( * PFNGLDELETEOCCLUSIONQUERIESNVPROC) (GLsizei n, const GLuint* ids);
typedef void ( * PFNGLENDOCCLUSIONQUERYNVPROC) (void);
typedef void ( * PFNGLGENOCCLUSIONQUERIESNVPROC) (GLsizei n, GLuint* ids);
typedef void ( * PFNGLGETOCCLUSIONQUERYIVNVPROC) (GLuint id, GLenum pname, GLint* params);
typedef void ( * PFNGLGETOCCLUSIONQUERYUIVNVPROC) (GLuint id, GLenum pname, GLuint* params);
typedef GLboolean ( * PFNGLISOCCLUSIONQUERYNVPROC) (GLuint id);
# 16617 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLPROGRAMBUFFERPARAMETERSIIVNVPROC) (GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLint *params);
typedef void ( * PFNGLPROGRAMBUFFERPARAMETERSIUIVNVPROC) (GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLuint *params);
typedef void ( * PFNGLPROGRAMBUFFERPARAMETERSFVNVPROC) (GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLfloat *params);
# 16793 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCOPYPATHNVPROC) (GLuint resultPath, GLuint srcPath);
typedef void ( * PFNGLCOVERFILLPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues);
typedef void ( * PFNGLCOVERFILLPATHNVPROC) (GLuint path, GLenum coverMode);
typedef void ( * PFNGLCOVERSTROKEPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues);
typedef void ( * PFNGLCOVERSTROKEPATHNVPROC) (GLuint path, GLenum coverMode);
typedef void ( * PFNGLDELETEPATHSNVPROC) (GLuint path, GLsizei range);
typedef GLuint ( * PFNGLGENPATHSNVPROC) (GLsizei range);
typedef void ( * PFNGLGETPATHCOLORGENFVNVPROC) (GLenum color, GLenum pname, GLfloat* value);
typedef void ( * PFNGLGETPATHCOLORGENIVNVPROC) (GLenum color, GLenum pname, GLint* value);
typedef void ( * PFNGLGETPATHCOMMANDSNVPROC) (GLuint path, GLubyte* commands);
typedef void ( * PFNGLGETPATHCOORDSNVPROC) (GLuint path, GLfloat* coords);
typedef void ( * PFNGLGETPATHDASHARRAYNVPROC) (GLuint path, GLfloat* dashArray);
typedef GLfloat ( * PFNGLGETPATHLENGTHNVPROC) (GLuint path, GLsizei startSegment, GLsizei numSegments);
typedef void ( * PFNGLGETPATHMETRICRANGENVPROC) (GLbitfield metricQueryMask, GLuint firstPathName, GLsizei numPaths, GLsizei stride, GLfloat* metrics);
typedef void ( * PFNGLGETPATHMETRICSNVPROC) (GLbitfield metricQueryMask, GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLsizei stride, GLfloat *metrics);
typedef void ( * PFNGLGETPATHPARAMETERFVNVPROC) (GLuint path, GLenum pname, GLfloat* value);
typedef void ( * PFNGLGETPATHPARAMETERIVNVPROC) (GLuint path, GLenum pname, GLint* value);
typedef void ( * PFNGLGETPATHSPACINGNVPROC) (GLenum pathListMode, GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLfloat advanceScale, GLfloat kerningScale, GLenum transformType, GLfloat *returnedSpacing);
typedef void ( * PFNGLGETPATHTEXGENFVNVPROC) (GLenum texCoordSet, GLenum pname, GLfloat* value);
typedef void ( * PFNGLGETPATHTEXGENIVNVPROC) (GLenum texCoordSet, GLenum pname, GLint* value);
typedef void ( * PFNGLGETPROGRAMRESOURCEFVNVPROC) (GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum* props, GLsizei bufSize, GLsizei *length, GLfloat *params);
typedef void ( * PFNGLINTERPOLATEPATHSNVPROC) (GLuint resultPath, GLuint pathA, GLuint pathB, GLfloat weight);
typedef GLboolean ( * PFNGLISPATHNVPROC) (GLuint path);
typedef GLboolean ( * PFNGLISPOINTINFILLPATHNVPROC) (GLuint path, GLuint mask, GLfloat x, GLfloat y);
typedef GLboolean ( * PFNGLISPOINTINSTROKEPATHNVPROC) (GLuint path, GLfloat x, GLfloat y);
typedef void ( * PFNGLMATRIXLOAD3X2FNVPROC) (GLenum matrixMode, const GLfloat* m);
typedef void ( * PFNGLMATRIXLOAD3X3FNVPROC) (GLenum matrixMode, const GLfloat* m);
typedef void ( * PFNGLMATRIXLOADTRANSPOSE3X3FNVPROC) (GLenum matrixMode, const GLfloat* m);
typedef void ( * PFNGLMATRIXMULT3X2FNVPROC) (GLenum matrixMode, const GLfloat* m);
typedef void ( * PFNGLMATRIXMULT3X3FNVPROC) (GLenum matrixMode, const GLfloat* m);
typedef void ( * PFNGLMATRIXMULTTRANSPOSE3X3FNVPROC) (GLenum matrixMode, const GLfloat* m);
typedef void ( * PFNGLPATHCOLORGENNVPROC) (GLenum color, GLenum genMode, GLenum colorFormat, const GLfloat* coeffs);
typedef void ( * PFNGLPATHCOMMANDSNVPROC) (GLuint path, GLsizei numCommands, const GLubyte* commands, GLsizei numCoords, GLenum coordType, const void*coords);
typedef void ( * PFNGLPATHCOORDSNVPROC) (GLuint path, GLsizei numCoords, GLenum coordType, const void *coords);
typedef void ( * PFNGLPATHCOVERDEPTHFUNCNVPROC) (GLenum zfunc);
typedef void ( * PFNGLPATHDASHARRAYNVPROC) (GLuint path, GLsizei dashCount, const GLfloat* dashArray);
typedef void ( * PFNGLPATHFOGGENNVPROC) (GLenum genMode);
typedef GLenum ( * PFNGLPATHGLYPHINDEXARRAYNVPROC) (GLuint firstPathName, GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
typedef GLenum ( * PFNGLPATHGLYPHINDEXRANGENVPROC) (GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLuint pathParameterTemplate, GLfloat emScale, GLuint baseAndCount[2]);
typedef void ( * PFNGLPATHGLYPHRANGENVPROC) (GLuint firstPathName, GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLuint firstGlyph, GLsizei numGlyphs, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
typedef void ( * PFNGLPATHGLYPHSNVPROC) (GLuint firstPathName, GLenum fontTarget, const void *fontName, GLbitfield fontStyle, GLsizei numGlyphs, GLenum type, const void*charcodes, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
typedef GLenum ( * PFNGLPATHMEMORYGLYPHINDEXARRAYNVPROC) (GLuint firstPathName, GLenum fontTarget, GLsizeiptr fontSize, const void *fontData, GLsizei faceIndex, GLuint firstGlyphIndex, GLsizei numGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
typedef void ( * PFNGLPATHPARAMETERFNVPROC) (GLuint path, GLenum pname, GLfloat value);
typedef void ( * PFNGLPATHPARAMETERFVNVPROC) (GLuint path, GLenum pname, const GLfloat* value);
typedef void ( * PFNGLPATHPARAMETERINVPROC) (GLuint path, GLenum pname, GLint value);
typedef void ( * PFNGLPATHPARAMETERIVNVPROC) (GLuint path, GLenum pname, const GLint* value);
typedef void ( * PFNGLPATHSTENCILDEPTHOFFSETNVPROC) (GLfloat factor, GLfloat units);
typedef void ( * PFNGLPATHSTENCILFUNCNVPROC) (GLenum func, GLint ref, GLuint mask);
typedef void ( * PFNGLPATHSTRINGNVPROC) (GLuint path, GLenum format, GLsizei length, const void *pathString);
typedef void ( * PFNGLPATHSUBCOMMANDSNVPROC) (GLuint path, GLsizei commandStart, GLsizei commandsToDelete, GLsizei numCommands, const GLubyte* commands, GLsizei numCoords, GLenum coordType, const void*coords);
typedef void ( * PFNGLPATHSUBCOORDSNVPROC) (GLuint path, GLsizei coordStart, GLsizei numCoords, GLenum coordType, const void *coords);
typedef void ( * PFNGLPATHTEXGENNVPROC) (GLenum texCoordSet, GLenum genMode, GLint components, const GLfloat* coeffs);
typedef GLboolean ( * PFNGLPOINTALONGPATHNVPROC) (GLuint path, GLsizei startSegment, GLsizei numSegments, GLfloat distance, GLfloat* x, GLfloat *y, GLfloat *tangentX, GLfloat *tangentY);
typedef void ( * PFNGLPROGRAMPATHFRAGMENTINPUTGENNVPROC) (GLuint program, GLint location, GLenum genMode, GLint components, const GLfloat* coeffs);
typedef void ( * PFNGLSTENCILFILLPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum transformType, const GLfloat *transformValues);
typedef void ( * PFNGLSTENCILFILLPATHNVPROC) (GLuint path, GLenum fillMode, GLuint mask);
typedef void ( * PFNGLSTENCILSTROKEPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLint reference, GLuint mask, GLenum transformType, const GLfloat *transformValues);
typedef void ( * PFNGLSTENCILSTROKEPATHNVPROC) (GLuint path, GLint reference, GLuint mask);
typedef void ( * PFNGLSTENCILTHENCOVERFILLPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat *transformValues);
typedef void ( * PFNGLSTENCILTHENCOVERFILLPATHNVPROC) (GLuint path, GLenum fillMode, GLuint mask, GLenum coverMode);
typedef void ( * PFNGLSTENCILTHENCOVERSTROKEPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void *paths, GLuint pathBase, GLint reference, GLuint mask, GLenum coverMode, GLenum transformType, const GLfloat *transformValues);
typedef void ( * PFNGLSTENCILTHENCOVERSTROKEPATHNVPROC) (GLuint path, GLint reference, GLuint mask, GLenum coverMode);
typedef void ( * PFNGLTRANSFORMPATHNVPROC) (GLuint resultPath, GLuint srcPath, GLenum transformType, const GLfloat* transformValues);
typedef void ( * PFNGLWEIGHTPATHSNVPROC) (GLuint resultPath, GLsizei numPaths, const GLuint paths[], const GLfloat weights[]);
# 16964 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLFLUSHPIXELDATARANGENVPROC) (GLenum target);
typedef void ( * PFNGLPIXELDATARANGENVPROC) (GLenum target, GLsizei length, void *pointer);
# 16994 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLPOINTPARAMETERINVPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLPOINTPARAMETERIVNVPROC) (GLenum pname, const GLint* params);
# 17016 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLPOLYGONMODENVPROC) (GLenum face, GLenum mode);
# 17036 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETVIDEOI64VNVPROC) (GLuint video_slot, GLenum pname, GLint64EXT* params);
typedef void ( * PFNGLGETVIDEOIVNVPROC) (GLuint video_slot, GLenum pname, GLint* params);
typedef void ( * PFNGLGETVIDEOUI64VNVPROC) (GLuint video_slot, GLenum pname, GLuint64EXT* params);
typedef void ( * PFNGLGETVIDEOUIVNVPROC) (GLuint video_slot, GLenum pname, GLuint* params);
typedef void ( * PFNGLPRESENTFRAMEDUALFILLNVPROC) (GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLenum target1, GLuint fill1, GLenum target2, GLuint fill2, GLenum target3, GLuint fill3);
typedef void ( * PFNGLPRESENTFRAMEKEYEDNVPROC) (GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLuint key0, GLenum target1, GLuint fill1, GLuint key1);
# 17062 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLPRIMITIVERESTARTINDEXNVPROC) (GLuint index);
typedef void ( * PFNGLPRIMITIVERESTARTNVPROC) (void);
# 17088 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLREADBUFFERNVPROC) (GLenum mode);
# 17191 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCOMBINERINPUTNVPROC) (GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage);
typedef void ( * PFNGLCOMBINEROUTPUTNVPROC) (GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum);
typedef void ( * PFNGLCOMBINERPARAMETERFNVPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLCOMBINERPARAMETERFVNVPROC) (GLenum pname, const GLfloat* params);
typedef void ( * PFNGLCOMBINERPARAMETERINVPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLCOMBINERPARAMETERIVNVPROC) (GLenum pname, const GLint* params);
typedef void ( * PFNGLFINALCOMBINERINPUTNVPROC) (GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage);
typedef void ( * PFNGLGETCOMBINERINPUTPARAMETERFVNVPROC) (GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETCOMBINERINPUTPARAMETERIVNVPROC) (GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint* params);
typedef void ( * PFNGLGETCOMBINEROUTPUTPARAMETERFVNVPROC) (GLenum stage, GLenum portion, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETCOMBINEROUTPUTPARAMETERIVNVPROC) (GLenum stage, GLenum portion, GLenum pname, GLint* params);
typedef void ( * PFNGLGETFINALCOMBINERINPUTPARAMETERFVNVPROC) (GLenum variable, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETFINALCOMBINERINPUTPARAMETERIVNVPROC) (GLenum variable, GLenum pname, GLint* params);
# 17230 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCOMBINERSTAGEPARAMETERFVNVPROC) (GLenum stage, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLGETCOMBINERSTAGEPARAMETERFVNVPROC) (GLenum stage, GLenum pname, GLfloat* params);
# 17296 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLFRAMEBUFFERSAMPLELOCATIONSFVNVPROC) (GLenum target, GLuint start, GLsizei count, const GLfloat* v);
typedef void ( * PFNGLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVNVPROC) (GLuint framebuffer, GLuint start, GLsizei count, const GLfloat* v);
typedef void ( * PFNGLRESOLVEDEPTHVALUESNVPROC) (void);
# 17325 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLSCISSOREXCLUSIVEARRAYVNVPROC) (GLuint first, GLsizei count, const GLint* v);
typedef void ( * PFNGLSCISSOREXCLUSIVENVPROC) (GLint x, GLint y, GLsizei width, GLsizei height);
# 17389 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETBUFFERPARAMETERUI64VNVPROC) (GLenum target, GLenum pname, GLuint64EXT* params);
typedef void ( * PFNGLGETINTEGERUI64VNVPROC) (GLenum value, GLuint64EXT* result);
typedef void ( * PFNGLGETNAMEDBUFFERPARAMETERUI64VNVPROC) (GLuint buffer, GLenum pname, GLuint64EXT* params);
typedef GLboolean ( * PFNGLISBUFFERRESIDENTNVPROC) (GLenum target);
typedef GLboolean ( * PFNGLISNAMEDBUFFERRESIDENTNVPROC) (GLuint buffer);
typedef void ( * PFNGLMAKEBUFFERNONRESIDENTNVPROC) (GLenum target);
typedef void ( * PFNGLMAKEBUFFERRESIDENTNVPROC) (GLenum target, GLenum access);
typedef void ( * PFNGLMAKENAMEDBUFFERNONRESIDENTNVPROC) (GLuint buffer);
typedef void ( * PFNGLMAKENAMEDBUFFERRESIDENTNVPROC) (GLuint buffer, GLenum access);
typedef void ( * PFNGLPROGRAMUNIFORMUI64NVPROC) (GLuint program, GLint location, GLuint64EXT value);
typedef void ( * PFNGLPROGRAMUNIFORMUI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
typedef void ( * PFNGLUNIFORMUI64NVPROC) (GLint location, GLuint64EXT value);
typedef void ( * PFNGLUNIFORMUI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT* value);
# 17508 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBINDSHADINGRATEIMAGENVPROC) (GLuint texture);
typedef void ( * PFNGLGETSHADINGRATEIMAGEPALETTENVPROC) (GLuint viewport, GLuint entry, GLenum* rate);
typedef void ( * PFNGLGETSHADINGRATESAMPLELOCATIONIVNVPROC) (GLenum rate, GLuint samples, GLuint index, GLint* location);
typedef void ( * PFNGLSHADINGRATEIMAGEBARRIERNVPROC) (GLenum order);
typedef void ( * PFNGLSHADINGRATEIMAGEPALETTENVPROC) (GLuint viewport, GLuint first, GLsizei count, const GLenum* rates);
typedef void ( * PFNGLSHADINGRATESAMPLEORDERCUSTOMNVPROC) (GLenum rate, GLuint samples, const GLint* locations);
# 17610 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCOMPRESSEDTEXIMAGE3DNVPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE3DNVPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOPYTEXSUBIMAGE3DNVPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLFRAMEBUFFERTEXTURELAYERNVPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
typedef void ( * PFNGLTEXIMAGE3DNVPROC) (GLenum target, GLint level, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLTEXSUBIMAGE3DNVPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
# 17633 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLTEXTUREBARRIERNVPROC) (void);
# 17733 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLTEXIMAGE2DMULTISAMPLECOVERAGENVPROC) (GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
typedef void ( * PFNGLTEXIMAGE3DMULTISAMPLECOVERAGENVPROC) (GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);
typedef void ( * PFNGLTEXTUREIMAGE2DMULTISAMPLECOVERAGENVPROC) (GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
typedef void ( * PFNGLTEXTUREIMAGE2DMULTISAMPLENVPROC) (GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
typedef void ( * PFNGLTEXTUREIMAGE3DMULTISAMPLECOVERAGENVPROC) (GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);
typedef void ( * PFNGLTEXTUREIMAGE3DMULTISAMPLENVPROC) (GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);
# 17962 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLACTIVEVARYINGNVPROC) (GLuint program, const GLchar *name);
typedef void ( * PFNGLBEGINTRANSFORMFEEDBACKNVPROC) (GLenum primitiveMode);
typedef void ( * PFNGLBINDBUFFERBASENVPROC) (GLenum target, GLuint index, GLuint buffer);
typedef void ( * PFNGLBINDBUFFEROFFSETNVPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset);
typedef void ( * PFNGLBINDBUFFERRANGENVPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void ( * PFNGLENDTRANSFORMFEEDBACKNVPROC) (void);
typedef void ( * PFNGLGETACTIVEVARYINGNVPROC) (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name);
typedef void ( * PFNGLGETTRANSFORMFEEDBACKVARYINGNVPROC) (GLuint program, GLuint index, GLint *location);
typedef GLint ( * PFNGLGETVARYINGLOCATIONNVPROC) (GLuint program, const GLchar *name);
typedef void ( * PFNGLTRANSFORMFEEDBACKATTRIBSNVPROC) (GLuint count, const GLint *attribs, GLenum bufferMode);
typedef void ( * PFNGLTRANSFORMFEEDBACKVARYINGSNVPROC) (GLuint program, GLsizei count, const GLint *locations, GLenum bufferMode);
# 18000 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBINDTRANSFORMFEEDBACKNVPROC) (GLenum target, GLuint id);
typedef void ( * PFNGLDELETETRANSFORMFEEDBACKSNVPROC) (GLsizei n, const GLuint* ids);
typedef void ( * PFNGLDRAWTRANSFORMFEEDBACKNVPROC) (GLenum mode, GLuint id);
typedef void ( * PFNGLGENTRANSFORMFEEDBACKSNVPROC) (GLsizei n, GLuint* ids);
typedef GLboolean ( * PFNGLISTRANSFORMFEEDBACKNVPROC) (GLuint id);
typedef void ( * PFNGLPAUSETRANSFORMFEEDBACKNVPROC) (void);
typedef void ( * PFNGLRESUMETRANSFORMFEEDBACKNVPROC) (void);
# 18043 "/usr/include/GL/glew.h" 3 4
typedef GLintptr GLvdpauSurfaceNV;

typedef void ( * PFNGLVDPAUFININVPROC) (void);
typedef void ( * PFNGLVDPAUGETSURFACEIVNVPROC) (GLvdpauSurfaceNV surface, GLenum pname, GLsizei bufSize, GLsizei* length, GLint *values);
typedef void ( * PFNGLVDPAUINITNVPROC) (const void* vdpDevice, const void*getProcAddress);
typedef void ( * PFNGLVDPAUISSURFACENVPROC) (GLvdpauSurfaceNV surface);
typedef void ( * PFNGLVDPAUMAPSURFACESNVPROC) (GLsizei numSurfaces, const GLvdpauSurfaceNV* surfaces);
typedef GLvdpauSurfaceNV ( * PFNGLVDPAUREGISTEROUTPUTSURFACENVPROC) (const void* vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames);
typedef GLvdpauSurfaceNV ( * PFNGLVDPAUREGISTERVIDEOSURFACENVPROC) (const void* vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames);
typedef void ( * PFNGLVDPAUSURFACEACCESSNVPROC) (GLvdpauSurfaceNV surface, GLenum access);
typedef void ( * PFNGLVDPAUUNMAPSURFACESNVPROC) (GLsizei numSurface, const GLvdpauSurfaceNV* surfaces);
typedef void ( * PFNGLVDPAUUNREGISTERSURFACENVPROC) (GLvdpauSurfaceNV surface);
# 18076 "/usr/include/GL/glew.h" 3 4
typedef GLvdpauSurfaceNV ( * PFNGLVDPAUREGISTERVIDEOSURFACEWITHPICTURESTRUCTURENVPROC) (const void *vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames, GLboolean isFrameStructure);
# 18095 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLFLUSHVERTEXARRAYRANGENVPROC) (void);
typedef void ( * PFNGLVERTEXARRAYRANGENVPROC) (GLsizei length, void *pointer);
# 18124 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETVERTEXATTRIBLI64VNVPROC) (GLuint index, GLenum pname, GLint64EXT* params);
typedef void ( * PFNGLGETVERTEXATTRIBLUI64VNVPROC) (GLuint index, GLenum pname, GLuint64EXT* params);
typedef void ( * PFNGLVERTEXATTRIBL1I64NVPROC) (GLuint index, GLint64EXT x);
typedef void ( * PFNGLVERTEXATTRIBL1I64VNVPROC) (GLuint index, const GLint64EXT* v);
typedef void ( * PFNGLVERTEXATTRIBL1UI64NVPROC) (GLuint index, GLuint64EXT x);
typedef void ( * PFNGLVERTEXATTRIBL1UI64VNVPROC) (GLuint index, const GLuint64EXT* v);
typedef void ( * PFNGLVERTEXATTRIBL2I64NVPROC) (GLuint index, GLint64EXT x, GLint64EXT y);
typedef void ( * PFNGLVERTEXATTRIBL2I64VNVPROC) (GLuint index, const GLint64EXT* v);
typedef void ( * PFNGLVERTEXATTRIBL2UI64NVPROC) (GLuint index, GLuint64EXT x, GLuint64EXT y);
typedef void ( * PFNGLVERTEXATTRIBL2UI64VNVPROC) (GLuint index, const GLuint64EXT* v);
typedef void ( * PFNGLVERTEXATTRIBL3I64NVPROC) (GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z);
typedef void ( * PFNGLVERTEXATTRIBL3I64VNVPROC) (GLuint index, const GLint64EXT* v);
typedef void ( * PFNGLVERTEXATTRIBL3UI64NVPROC) (GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
typedef void ( * PFNGLVERTEXATTRIBL3UI64VNVPROC) (GLuint index, const GLuint64EXT* v);
typedef void ( * PFNGLVERTEXATTRIBL4I64NVPROC) (GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
typedef void ( * PFNGLVERTEXATTRIBL4I64VNVPROC) (GLuint index, const GLint64EXT* v);
typedef void ( * PFNGLVERTEXATTRIBL4UI64NVPROC) (GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
typedef void ( * PFNGLVERTEXATTRIBL4UI64VNVPROC) (GLuint index, const GLuint64EXT* v);
typedef void ( * PFNGLVERTEXATTRIBLFORMATNVPROC) (GLuint index, GLint size, GLenum type, GLsizei stride);
# 18199 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBUFFERADDRESSRANGENVPROC) (GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length);
typedef void ( * PFNGLCOLORFORMATNVPROC) (GLint size, GLenum type, GLsizei stride);
typedef void ( * PFNGLEDGEFLAGFORMATNVPROC) (GLsizei stride);
typedef void ( * PFNGLFOGCOORDFORMATNVPROC) (GLenum type, GLsizei stride);
typedef void ( * PFNGLGETINTEGERUI64I_VNVPROC) (GLenum value, GLuint index, GLuint64EXT result[]);
typedef void ( * PFNGLINDEXFORMATNVPROC) (GLenum type, GLsizei stride);
typedef void ( * PFNGLNORMALFORMATNVPROC) (GLenum type, GLsizei stride);
typedef void ( * PFNGLSECONDARYCOLORFORMATNVPROC) (GLint size, GLenum type, GLsizei stride);
typedef void ( * PFNGLTEXCOORDFORMATNVPROC) (GLint size, GLenum type, GLsizei stride);
typedef void ( * PFNGLVERTEXATTRIBFORMATNVPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride);
typedef void ( * PFNGLVERTEXATTRIBIFORMATNVPROC) (GLuint index, GLint size, GLenum type, GLsizei stride);
typedef void ( * PFNGLVERTEXFORMATNVPROC) (GLint size, GLenum type, GLsizei stride);
# 18318 "/usr/include/GL/glew.h" 3 4
typedef GLboolean ( * PFNGLAREPROGRAMSRESIDENTNVPROC) (GLsizei n, const GLuint* ids, GLboolean *residences);
typedef void ( * PFNGLBINDPROGRAMNVPROC) (GLenum target, GLuint id);
typedef void ( * PFNGLDELETEPROGRAMSNVPROC) (GLsizei n, const GLuint* ids);
typedef void ( * PFNGLEXECUTEPROGRAMNVPROC) (GLenum target, GLuint id, const GLfloat* params);
typedef void ( * PFNGLGENPROGRAMSNVPROC) (GLsizei n, GLuint* ids);
typedef void ( * PFNGLGETPROGRAMPARAMETERDVNVPROC) (GLenum target, GLuint index, GLenum pname, GLdouble* params);
typedef void ( * PFNGLGETPROGRAMPARAMETERFVNVPROC) (GLenum target, GLuint index, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETPROGRAMSTRINGNVPROC) (GLuint id, GLenum pname, GLubyte* program);
typedef void ( * PFNGLGETPROGRAMIVNVPROC) (GLuint id, GLenum pname, GLint* params);
typedef void ( * PFNGLGETTRACKMATRIXIVNVPROC) (GLenum target, GLuint address, GLenum pname, GLint* params);
typedef void ( * PFNGLGETVERTEXATTRIBPOINTERVNVPROC) (GLuint index, GLenum pname, void** pointer);
typedef void ( * PFNGLGETVERTEXATTRIBDVNVPROC) (GLuint index, GLenum pname, GLdouble* params);
typedef void ( * PFNGLGETVERTEXATTRIBFVNVPROC) (GLuint index, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETVERTEXATTRIBIVNVPROC) (GLuint index, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISPROGRAMNVPROC) (GLuint id);
typedef void ( * PFNGLLOADPROGRAMNVPROC) (GLenum target, GLuint id, GLsizei len, const GLubyte* program);
typedef void ( * PFNGLPROGRAMPARAMETER4DNVPROC) (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLPROGRAMPARAMETER4DVNVPROC) (GLenum target, GLuint index, const GLdouble* params);
typedef void ( * PFNGLPROGRAMPARAMETER4FNVPROC) (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLPROGRAMPARAMETER4FVNVPROC) (GLenum target, GLuint index, const GLfloat* params);
typedef void ( * PFNGLPROGRAMPARAMETERS4DVNVPROC) (GLenum target, GLuint index, GLsizei num, const GLdouble* params);
typedef void ( * PFNGLPROGRAMPARAMETERS4FVNVPROC) (GLenum target, GLuint index, GLsizei num, const GLfloat* params);
typedef void ( * PFNGLREQUESTRESIDENTPROGRAMSNVPROC) (GLsizei n, GLuint* ids);
typedef void ( * PFNGLTRACKMATRIXNVPROC) (GLenum target, GLuint address, GLenum matrix, GLenum transform);
typedef void ( * PFNGLVERTEXATTRIB1DNVPROC) (GLuint index, GLdouble x);
typedef void ( * PFNGLVERTEXATTRIB1DVNVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB1FNVPROC) (GLuint index, GLfloat x);
typedef void ( * PFNGLVERTEXATTRIB1FVNVPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB1SNVPROC) (GLuint index, GLshort x);
typedef void ( * PFNGLVERTEXATTRIB1SVNVPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB2DNVPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void ( * PFNGLVERTEXATTRIB2DVNVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB2FNVPROC) (GLuint index, GLfloat x, GLfloat y);
typedef void ( * PFNGLVERTEXATTRIB2FVNVPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB2SNVPROC) (GLuint index, GLshort x, GLshort y);
typedef void ( * PFNGLVERTEXATTRIB2SVNVPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB3DNVPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLVERTEXATTRIB3DVNVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB3FNVPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLVERTEXATTRIB3FVNVPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB3SNVPROC) (GLuint index, GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLVERTEXATTRIB3SVNVPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB4DNVPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLVERTEXATTRIB4DVNVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB4FNVPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLVERTEXATTRIB4FVNVPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB4SNVPROC) (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void ( * PFNGLVERTEXATTRIB4SVNVPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB4UBNVPROC) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
typedef void ( * PFNGLVERTEXATTRIB4UBVNVPROC) (GLuint index, const GLubyte* v);
typedef void ( * PFNGLVERTEXATTRIBPOINTERNVPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer);
typedef void ( * PFNGLVERTEXATTRIBS1DVNVPROC) (GLuint index, GLsizei n, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBS1FVNVPROC) (GLuint index, GLsizei n, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIBS1SVNVPROC) (GLuint index, GLsizei n, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIBS2DVNVPROC) (GLuint index, GLsizei n, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBS2FVNVPROC) (GLuint index, GLsizei n, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIBS2SVNVPROC) (GLuint index, GLsizei n, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIBS3DVNVPROC) (GLuint index, GLsizei n, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBS3FVNVPROC) (GLuint index, GLsizei n, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIBS3SVNVPROC) (GLuint index, GLsizei n, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIBS4DVNVPROC) (GLuint index, GLsizei n, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBS4FVNVPROC) (GLuint index, GLsizei n, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIBS4SVNVPROC) (GLuint index, GLsizei n, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIBS4UBVNVPROC) (GLuint index, GLsizei n, const GLubyte* v);
# 18539 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBEGINVIDEOCAPTURENVPROC) (GLuint video_capture_slot);
typedef void ( * PFNGLBINDVIDEOCAPTURESTREAMBUFFERNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLintptrARB offset);
typedef void ( * PFNGLBINDVIDEOCAPTURESTREAMTEXTURENVPROC) (GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLenum target, GLuint texture);
typedef void ( * PFNGLENDVIDEOCAPTURENVPROC) (GLuint video_capture_slot);
typedef void ( * PFNGLGETVIDEOCAPTURESTREAMDVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, GLdouble* params);
typedef void ( * PFNGLGETVIDEOCAPTURESTREAMFVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETVIDEOCAPTURESTREAMIVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, GLint* params);
typedef void ( * PFNGLGETVIDEOCAPTUREIVNVPROC) (GLuint video_capture_slot, GLenum pname, GLint* params);
typedef GLenum ( * PFNGLVIDEOCAPTURENVPROC) (GLuint video_capture_slot, GLuint* sequence_num, GLuint64EXT *capture_time);
typedef void ( * PFNGLVIDEOCAPTURESTREAMPARAMETERDVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, const GLdouble* params);
typedef void ( * PFNGLVIDEOCAPTURESTREAMPARAMETERFVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLVIDEOCAPTURESTREAMPARAMETERIVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, const GLint* params);
# 18583 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDEPTHRANGEARRAYFVNVPROC) (GLuint first, GLsizei count, const GLfloat * v);
typedef void ( * PFNGLDEPTHRANGEINDEXEDFNVPROC) (GLuint index, GLfloat n, GLfloat f);
typedef void ( * PFNGLDISABLEINVPROC) (GLenum target, GLuint index);
typedef void ( * PFNGLENABLEINVPROC) (GLenum target, GLuint index);
typedef void ( * PFNGLGETFLOATI_VNVPROC) (GLenum target, GLuint index, GLfloat* data);
typedef GLboolean ( * PFNGLISENABLEDINVPROC) (GLenum target, GLuint index);
typedef void ( * PFNGLSCISSORARRAYVNVPROC) (GLuint first, GLsizei count, const GLint * v);
typedef void ( * PFNGLSCISSORINDEXEDNVPROC) (GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height);
typedef void ( * PFNGLSCISSORINDEXEDVNVPROC) (GLuint index, const GLint * v);
typedef void ( * PFNGLVIEWPORTARRAYVNVPROC) (GLuint first, GLsizei count, const GLfloat * v);
typedef void ( * PFNGLVIEWPORTINDEXEDFNVPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h);
typedef void ( * PFNGLVIEWPORTINDEXEDFVNVPROC) (GLuint index, const GLfloat * v);
# 18640 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLVIEWPORTSWIZZLENVPROC) (GLuint index, GLenum swizzlex, GLenum swizzley, GLenum swizzlez, GLenum swizzlew);
# 18653 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLEGLIMAGETARGETRENDERBUFFERSTORAGEOESPROC) (GLenum target, GLeglImageOES image);
typedef void ( * PFNGLEGLIMAGETARGETTEXTURE2DOESPROC) (GLenum target, GLeglImageOES image);
# 18694 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBLENDEQUATIONSEPARATEOESPROC) (GLenum modeRGB, GLenum modeAlpha);
# 18712 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBLENDFUNCSEPARATEOESPROC) (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
# 18730 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBLENDEQUATIONOESPROC) (GLenum mode);
# 18783 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCOPYIMAGESUBDATAOESPROC) (GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);
# 18846 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBLENDEQUATIONSEPARATEIOESPROC) (GLuint buf, GLenum modeRGB, GLenum modeAlpha);
typedef void ( * PFNGLBLENDEQUATIONIOESPROC) (GLuint buf, GLenum mode);
typedef void ( * PFNGLBLENDFUNCSEPARATEIOESPROC) (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
typedef void ( * PFNGLBLENDFUNCIOESPROC) (GLuint buf, GLenum src, GLenum dst);
typedef void ( * PFNGLCOLORMASKIOESPROC) (GLuint buf, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
typedef void ( * PFNGLDISABLEIOESPROC) (GLenum target, GLuint index);
typedef void ( * PFNGLENABLEIOESPROC) (GLenum target, GLuint index);
typedef GLboolean ( * PFNGLISENABLEDIOESPROC) (GLenum target, GLuint index);
# 18962 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBINDFRAMEBUFFEROESPROC) (GLenum target, GLuint framebuffer);
typedef void ( * PFNGLBINDRENDERBUFFEROESPROC) (GLenum target, GLuint renderbuffer);
typedef GLenum ( * PFNGLCHECKFRAMEBUFFERSTATUSOESPROC) (GLenum target);
typedef void ( * PFNGLDELETEFRAMEBUFFERSOESPROC) (GLsizei n, const GLuint* framebuffers);
typedef void ( * PFNGLDELETERENDERBUFFERSOESPROC) (GLsizei n, const GLuint* renderbuffers);
typedef void ( * PFNGLFRAMEBUFFERRENDERBUFFEROESPROC) (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void ( * PFNGLFRAMEBUFFERTEXTURE2DOESPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void ( * PFNGLGENFRAMEBUFFERSOESPROC) (GLsizei n, GLuint* framebuffers);
typedef void ( * PFNGLGENRENDERBUFFERSOESPROC) (GLsizei n, GLuint* renderbuffers);
typedef void ( * PFNGLGENERATEMIPMAPOESPROC) (GLenum target);
typedef void ( * PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVOESPROC) (GLenum target, GLenum attachment, GLenum pname, GLint* params);
typedef void ( * PFNGLGETRENDERBUFFERPARAMETERIVOESPROC) (GLenum target, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISFRAMEBUFFEROESPROC) (GLuint framebuffer);
typedef GLboolean ( * PFNGLISRENDERBUFFEROESPROC) (GLuint renderbuffer);
typedef void ( * PFNGLRENDERBUFFERSTORAGEOESPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
# 19093 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETPROGRAMBINARYOESPROC) (GLuint program, GLsizei bufSize, GLsizei* length, GLenum *binaryFormat, void*binary);
typedef void ( * PFNGLPROGRAMBINARYOESPROC) (GLuint program, GLenum binaryFormat, const void *binary, GLint length);
# 19122 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETBUFFERPOINTERVOESPROC) (GLenum target, GLenum pname, void** params);
typedef void * ( * PFNGLMAPBUFFEROESPROC) (GLenum target, GLenum access);
typedef GLboolean ( * PFNGLUNMAPBUFFEROESPROC) (GLenum target);
# 19169 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCURRENTPALETTEMATRIXOESPROC) (GLuint index);
typedef void ( * PFNGLMATRIXINDEXPOINTEROESPROC) (GLint size, GLenum type, GLsizei stride, void *pointer);
typedef void ( * PFNGLWEIGHTPOINTEROESPROC) (GLint size, GLenum type, GLsizei stride, void *pointer);
# 19278 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLMINSAMPLESHADINGOESPROC) (GLfloat value);
# 19331 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCLEARDEPTHFOESPROC) (GLclampf depth);
typedef void ( * PFNGLCLIPPLANEFOESPROC) (GLenum plane, const GLfloat* equation);
typedef void ( * PFNGLDEPTHRANGEFOESPROC) (GLclampf n, GLclampf f);
typedef void ( * PFNGLFRUSTUMFOESPROC) (GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f);
typedef void ( * PFNGLGETCLIPPLANEFOESPROC) (GLenum plane, GLfloat* equation);
typedef void ( * PFNGLORTHOFOESPROC) (GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f);
# 19520 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCOMPRESSEDTEXIMAGE3DOESPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE3DOESPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
typedef void ( * PFNGLCOPYTEXSUBIMAGE3DOESPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLFRAMEBUFFERTEXTURE3DOESPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
typedef void ( * PFNGLTEXIMAGE3DOESPROC) (GLenum target, GLint level, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLTEXSUBIMAGE3DOESPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
# 19546 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETSAMPLERPARAMETERIIVOESPROC) (GLuint sampler, GLenum pname, GLint* params);
typedef void ( * PFNGLGETSAMPLERPARAMETERIUIVOESPROC) (GLuint sampler, GLenum pname, GLuint* params);
typedef void ( * PFNGLGETTEXPARAMETERIIVOESPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETTEXPARAMETERIUIVOESPROC) (GLenum target, GLenum pname, GLuint* params);
typedef void ( * PFNGLSAMPLERPARAMETERIIVOESPROC) (GLuint sampler, GLenum pname, const GLint* params);
typedef void ( * PFNGLSAMPLERPARAMETERIUIVOESPROC) (GLuint sampler, GLenum pname, const GLuint* params);
typedef void ( * PFNGLTEXPARAMETERIIVOESPROC) (GLenum target, GLenum pname, const GLint* params);
typedef void ( * PFNGLTEXPARAMETERIUIVOESPROC) (GLenum target, GLenum pname, const GLuint* params);
# 19588 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLTEXBUFFEROESPROC) (GLenum target, GLenum internalformat, GLuint buffer);
typedef void ( * PFNGLTEXBUFFERRANGEOESPROC) (GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
# 19675 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETTEXGENFVOESPROC) (GLenum coord, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETTEXGENIVOESPROC) (GLenum coord, GLenum pname, GLint* params);
typedef void ( * PFNGLGETTEXGENXVOESPROC) (GLenum coord, GLenum pname, GLfixed* params);
typedef void ( * PFNGLTEXGENFOESPROC) (GLenum coord, GLenum pname, GLfloat param);
typedef void ( * PFNGLTEXGENFVOESPROC) (GLenum coord, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLTEXGENIOESPROC) (GLenum coord, GLenum pname, GLint param);
typedef void ( * PFNGLTEXGENIVOESPROC) (GLenum coord, GLenum pname, const GLint* params);
typedef void ( * PFNGLTEXGENXOESPROC) (GLenum coord, GLenum pname, GLfixed param);
typedef void ( * PFNGLTEXGENXVOESPROC) (GLenum coord, GLenum pname, const GLfixed* params);
# 19770 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLTEXSTORAGE3DMULTISAMPLEOESPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
# 19789 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLTEXTUREVIEWOESPROC) (GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers);
# 19804 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLBINDVERTEXARRAYOESPROC) (GLuint array);
typedef void ( * PFNGLDELETEVERTEXARRAYSOESPROC) (GLsizei n, const GLuint* arrays);
typedef void ( * PFNGLGENVERTEXARRAYSOESPROC) (GLsizei n, GLuint* arrays);
typedef GLboolean ( * PFNGLISVERTEXARRAYOESPROC) (GLuint array);
# 19891 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLFRAMEBUFFERTEXTUREMULTIVIEWOVRPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint baseViewIndex, GLsizei numViews);
typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTUREMULTIVIEWOVRPROC) (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint baseViewIndex, GLsizei numViews);
# 19915 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLFRAMEBUFFERTEXTUREMULTISAMPLEMULTIVIEWOVRPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLsizei samples, GLint baseViewIndex, GLsizei numViews);
# 20003 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLALPHAFUNCQCOMPROC) (GLenum func, GLclampf ref);
# 20031 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDISABLEDRIVERCONTROLQCOMPROC) (GLuint driverControl);
typedef void ( * PFNGLENABLEDRIVERCONTROLQCOMPROC) (GLuint driverControl);
typedef void ( * PFNGLGETDRIVERCONTROLSTRINGQCOMPROC) (GLuint driverControl, GLsizei bufSize, GLsizei* length, GLchar *driverControlString);
typedef void ( * PFNGLGETDRIVERCONTROLSQCOMPROC) (GLint* num, GLsizei size, GLuint *driverControls);
# 20062 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLEXTGETBUFFERPOINTERVQCOMPROC) (GLenum target, void** params);
typedef void ( * PFNGLEXTGETBUFFERSQCOMPROC) (GLuint* buffers, GLint maxBuffers, GLint* numBuffers);
typedef void ( * PFNGLEXTGETFRAMEBUFFERSQCOMPROC) (GLuint* framebuffers, GLint maxFramebuffers, GLint* numFramebuffers);
typedef void ( * PFNGLEXTGETRENDERBUFFERSQCOMPROC) (GLuint* renderbuffers, GLint maxRenderbuffers, GLint* numRenderbuffers);
typedef void ( * PFNGLEXTGETTEXLEVELPARAMETERIVQCOMPROC) (GLuint texture, GLenum face, GLint level, GLenum pname, GLint* params);
typedef void ( * PFNGLEXTGETTEXSUBIMAGEQCOMPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, void *texels);
typedef void ( * PFNGLEXTGETTEXTURESQCOMPROC) (GLuint* textures, GLint maxTextures, GLint* numTextures);
typedef void ( * PFNGLEXTTEXOBJECTSTATEOVERRIDEIQCOMPROC) (GLenum target, GLenum pname, GLint param);
# 20089 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLEXTGETPROGRAMBINARYSOURCEQCOMPROC) (GLuint program, GLenum shadertype, GLchar* source, GLint* length);
typedef void ( * PFNGLEXTGETPROGRAMSQCOMPROC) (GLuint* programs, GLint maxPrograms, GLint* numPrograms);
typedef void ( * PFNGLEXTGETSHADERSQCOMPROC) (GLuint* shaders, GLint maxShaders, GLint* numShaders);
typedef GLboolean ( * PFNGLEXTISPROGRAMBINARYQCOMPROC) (GLuint program);
# 20111 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLFRAMEBUFFERFOVEATIONCONFIGQCOMPROC) (GLuint fbo, GLuint numLayers, GLuint focalPointsPerLayer, GLuint requestedFeatures, GLuint* providedFeatures);
typedef void ( * PFNGLFRAMEBUFFERFOVEATIONPARAMETERSQCOMPROC) (GLuint fbo, GLuint layer, GLuint focalPoint, GLfloat focalX, GLfloat focalY, GLfloat gainX, GLfloat gainY, GLfloat foveaArea);
# 20139 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLFRAMEBUFFERFETCHBARRIERQCOMPROC) (void);
# 20169 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLTEXTUREFOVEATIONPARAMETERSQCOMPROC) (GLuint texture, GLuint layer, GLuint focalPoint, GLfloat focalX, GLfloat focalY, GLfloat gainX, GLfloat gainY, GLfloat foveaArea);
# 20227 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLENDTILINGQCOMPROC) (GLbitfield preserveMask);
typedef void ( * PFNGLSTARTTILINGQCOMPROC) (GLuint x, GLuint y, GLuint width, GLuint height, GLbitfield preserveMask);
# 20253 "/usr/include/GL/glew.h" 3 4
typedef int GLclampx;

typedef void ( * PFNGLALPHAFUNCXPROC) (GLenum func, GLclampx ref);
typedef void ( * PFNGLCLEARCOLORXPROC) (GLclampx red, GLclampx green, GLclampx blue, GLclampx alpha);
typedef void ( * PFNGLCLEARDEPTHXPROC) (GLclampx depth);
typedef void ( * PFNGLCOLOR4XPROC) (GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha);
typedef void ( * PFNGLDEPTHRANGEXPROC) (GLclampx zNear, GLclampx zFar);
typedef void ( * PFNGLFOGXPROC) (GLenum pname, GLfixed param);
typedef void ( * PFNGLFOGXVPROC) (GLenum pname, const GLfixed* params);
typedef void ( * PFNGLFRUSTUMFPROC) (GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);
typedef void ( * PFNGLFRUSTUMXPROC) (GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);
typedef void ( * PFNGLLIGHTMODELXPROC) (GLenum pname, GLfixed param);
typedef void ( * PFNGLLIGHTMODELXVPROC) (GLenum pname, const GLfixed* params);
typedef void ( * PFNGLLIGHTXPROC) (GLenum light, GLenum pname, GLfixed param);
typedef void ( * PFNGLLIGHTXVPROC) (GLenum light, GLenum pname, const GLfixed* params);
typedef void ( * PFNGLLINEWIDTHXPROC) (GLfixed width);
typedef void ( * PFNGLLOADMATRIXXPROC) (const GLfixed* m);
typedef void ( * PFNGLMATERIALXPROC) (GLenum face, GLenum pname, GLfixed param);
typedef void ( * PFNGLMATERIALXVPROC) (GLenum face, GLenum pname, const GLfixed* params);
typedef void ( * PFNGLMULTMATRIXXPROC) (const GLfixed* m);
typedef void ( * PFNGLMULTITEXCOORD4XPROC) (GLenum target, GLfixed s, GLfixed t, GLfixed r, GLfixed q);
typedef void ( * PFNGLNORMAL3XPROC) (GLfixed nx, GLfixed ny, GLfixed nz);
typedef void ( * PFNGLORTHOFPROC) (GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);
typedef void ( * PFNGLORTHOXPROC) (GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);
typedef void ( * PFNGLPOINTSIZEXPROC) (GLfixed size);
typedef void ( * PFNGLPOLYGONOFFSETXPROC) (GLfixed factor, GLfixed units);
typedef void ( * PFNGLROTATEXPROC) (GLfixed angle, GLfixed x, GLfixed y, GLfixed z);
typedef void ( * PFNGLSAMPLECOVERAGEXPROC) (GLclampx value, GLboolean invert);
typedef void ( * PFNGLSCALEXPROC) (GLfixed x, GLfixed y, GLfixed z);
typedef void ( * PFNGLTEXENVXPROC) (GLenum target, GLenum pname, GLfixed param);
typedef void ( * PFNGLTEXENVXVPROC) (GLenum target, GLenum pname, const GLfixed* params);
typedef void ( * PFNGLTEXPARAMETERXPROC) (GLenum target, GLenum pname, GLfixed param);
typedef void ( * PFNGLTRANSLATEXPROC) (GLfixed x, GLfixed y, GLfixed z);
# 20328 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCLIPPLANEFPROC) (GLenum plane, const GLfloat* equation);
typedef void ( * PFNGLCLIPPLANEXPROC) (GLenum plane, const GLfixed* equation);
typedef void ( * PFNGLGETCLIPPLANEFPROC) (GLenum pname, GLfloat eqn[4]);
typedef void ( * PFNGLGETCLIPPLANEXPROC) (GLenum pname, GLfixed eqn[4]);
typedef void ( * PFNGLGETFIXEDVPROC) (GLenum pname, GLfixed* params);
typedef void ( * PFNGLGETLIGHTXVPROC) (GLenum light, GLenum pname, GLfixed* params);
typedef void ( * PFNGLGETMATERIALXVPROC) (GLenum face, GLenum pname, GLfixed* params);
typedef void ( * PFNGLGETTEXENVXVPROC) (GLenum env, GLenum pname, GLfixed* params);
typedef void ( * PFNGLGETTEXPARAMETERXVPROC) (GLenum target, GLenum pname, GLfixed* params);
typedef void ( * PFNGLPOINTPARAMETERXPROC) (GLenum pname, GLfixed param);
typedef void ( * PFNGLPOINTPARAMETERXVPROC) (GLenum pname, const GLfixed* params);
typedef void ( * PFNGLPOINTSIZEPOINTEROESPROC) (GLenum type, GLsizei stride, const void *pointer);
typedef void ( * PFNGLTEXPARAMETERXVPROC) (GLenum target, GLenum pname, const GLfixed* params);
# 20385 "/usr/include/GL/glew.h" 3 4
typedef const GLchar* ( * PFNGLERRORSTRINGREGALPROC) (GLenum error);
# 20398 "/usr/include/GL/glew.h" 3 4
typedef GLboolean ( * PFNGLGETEXTENSIONREGALPROC) (const GLchar* ext);
typedef GLboolean ( * PFNGLISSUPPORTEDREGALPROC) (const GLchar* ext);
# 20423 "/usr/include/GL/glew.h" 3 4
typedef void ( *GLLOGPROCREGAL)(GLenum stream, GLsizei length, const GLchar *message, void *context);

typedef void ( * PFNGLLOGMESSAGECALLBACKREGALPROC) (GLLOGPROCREGAL callback);
# 20438 "/usr/include/GL/glew.h" 3 4
typedef void * ( * PFNGLGETPROCADDRESSREGALPROC) (const GLchar *name);
# 20507 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDETAILTEXFUNCSGISPROC) (GLenum target, GLsizei n, const GLfloat* points);
typedef void ( * PFNGLGETDETAILTEXFUNCSGISPROC) (GLenum target, GLfloat* points);
# 20522 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLFOGFUNCSGISPROC) (GLsizei n, const GLfloat* points);
typedef void ( * PFNGLGETFOGFUNCSGISPROC) (GLfloat* points);
# 20575 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLSAMPLEMASKSGISPROC) (GLclampf value, GLboolean invert);
typedef void ( * PFNGLSAMPLEPATTERNSGISPROC) (GLenum pattern);
# 20602 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLINTERLEAVEDTEXTURECOORDSETSSGISPROC) (GLint factor);
typedef void ( * PFNGLSELECTTEXTURECOORDSETSGISPROC) (GLenum target);
typedef void ( * PFNGLSELECTTEXTURESGISPROC) (GLenum target);
typedef void ( * PFNGLSELECTTEXTURETRANSFORMSGISPROC) (GLenum target);
# 20648 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLMULTISAMPLESUBRECTPOSSGISPROC) (GLint x, GLint y);
# 20661 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETSHARPENTEXFUNCSGISPROC) (GLenum target, GLfloat* points);
typedef void ( * PFNGLSHARPENTEXFUNCSGISPROC) (GLenum target, GLsizei n, const GLfloat* points);
# 20676 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLTEXIMAGE4DSGISPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei extent, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void ( * PFNGLTEXSUBIMAGE4DSGISPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei extent, GLenum format, GLenum type, const void *pixels);
# 20713 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETTEXFILTERFUNCSGISPROC) (GLenum target, GLenum filter, GLfloat* weights);
typedef void ( * PFNGLTEXFILTERFUNCSGISPROC) (GLenum target, GLenum filter, GLsizei n, const GLfloat* weights);
# 20753 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLASYNCMARKERSGIXPROC) (GLuint marker);
typedef void ( * PFNGLDELETEASYNCMARKERSSGIXPROC) (GLuint marker, GLsizei range);
typedef GLint ( * PFNGLFINISHASYNCSGIXPROC) (GLuint* markerp);
typedef GLuint ( * PFNGLGENASYNCMARKERSSGIXPROC) (GLsizei range);
typedef GLboolean ( * PFNGLISASYNCMARKERSGIXPROC) (GLuint marker);
typedef GLint ( * PFNGLPOLLASYNCSGIXPROC) (GLuint* markerp);
# 20963 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLADDRESSSPACEPROC) (GLenum space, GLbitfield mask);
typedef GLint ( * PFNGLDATAPIPEPROC) (GLenum space);
# 21022 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLFLUSHRASTERSGIXPROC) (void);
# 21063 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLFOGLAYERSSGIXPROC) (GLsizei n, const GLfloat* points);
typedef void ( * PFNGLGETFOGLAYERSSGIXPROC) (GLfloat* points);
# 21111 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLTEXTUREFOGSGIXPROC) (GLenum pname);
# 21138 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLFRAGMENTCOLORMATERIALSGIXPROC) (GLenum face, GLenum mode);
typedef void ( * PFNGLFRAGMENTLIGHTMODELFSGIXPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLFRAGMENTLIGHTMODELFVSGIXPROC) (GLenum pname, GLfloat* params);
typedef void ( * PFNGLFRAGMENTLIGHTMODELISGIXPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLFRAGMENTLIGHTMODELIVSGIXPROC) (GLenum pname, GLint* params);
typedef void ( * PFNGLFRAGMENTLIGHTFSGIXPROC) (GLenum light, GLenum pname, GLfloat param);
typedef void ( * PFNGLFRAGMENTLIGHTFVSGIXPROC) (GLenum light, GLenum pname, GLfloat* params);
typedef void ( * PFNGLFRAGMENTLIGHTISGIXPROC) (GLenum light, GLenum pname, GLint param);
typedef void ( * PFNGLFRAGMENTLIGHTIVSGIXPROC) (GLenum light, GLenum pname, GLint* params);
typedef void ( * PFNGLFRAGMENTMATERIALFSGIXPROC) (GLenum face, GLenum pname, const GLfloat param);
typedef void ( * PFNGLFRAGMENTMATERIALFVSGIXPROC) (GLenum face, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLFRAGMENTMATERIALISGIXPROC) (GLenum face, GLenum pname, const GLint param);
typedef void ( * PFNGLFRAGMENTMATERIALIVSGIXPROC) (GLenum face, GLenum pname, const GLint* params);
typedef void ( * PFNGLGETFRAGMENTLIGHTFVSGIXPROC) (GLenum light, GLenum value, GLfloat* data);
typedef void ( * PFNGLGETFRAGMENTLIGHTIVSGIXPROC) (GLenum light, GLenum value, GLint* data);
typedef void ( * PFNGLGETFRAGMENTMATERIALFVSGIXPROC) (GLenum face, GLenum pname, GLfloat* data);
typedef void ( * PFNGLGETFRAGMENTMATERIALIVSGIXPROC) (GLenum face, GLenum pname, GLint* data);
# 21196 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLFRAMEZOOMSGIXPROC) (GLint factor);
# 21240 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLIGLOOINTERFACESGIXPROC) (GLenum pname, void *param);
# 21320 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLALLOCMPEGPREDICTORSSGIXPROC) (GLsizei width, GLsizei height, GLsizei n, GLuint* predictors);
typedef void ( * PFNGLDELETEMPEGPREDICTORSSGIXPROC) (GLsizei n, GLuint* predictors);
typedef void ( * PFNGLGENMPEGPREDICTORSSGIXPROC) (GLsizei n, GLuint* predictors);
typedef void ( * PFNGLGETMPEGPARAMETERFVSGIXPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETMPEGPARAMETERIVSGIXPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETMPEGPREDICTORSGIXPROC) (GLenum target, GLenum format, GLenum type, void *pixels);
typedef void ( * PFNGLGETMPEGQUANTTABLEUBVPROC) (GLenum target, GLubyte* values);
typedef GLboolean ( * PFNGLISMPEGPREDICTORSGIXPROC) (GLuint predictor);
typedef void ( * PFNGLMPEGPREDICTORSGIXPROC) (GLenum target, GLenum format, GLenum type, void *pixels);
typedef void ( * PFNGLMPEGQUANTTABLEUBVPROC) (GLenum target, GLubyte* values);
typedef void ( * PFNGLSWAPMPEGPREDICTORSSGIXPROC) (GLenum target0, GLenum target1);
# 21362 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETNONLINLIGHTFVSGIXPROC) (GLenum light, GLenum pname, GLint* terms, GLfloat *data);
typedef void ( * PFNGLGETNONLINMATERIALFVSGIXPROC) (GLenum face, GLenum pname, GLint* terms, const GLfloat *data);
typedef void ( * PFNGLNONLINLIGHTFVSGIXPROC) (GLenum light, GLenum pname, GLint terms, GLfloat* params);
typedef void ( * PFNGLNONLINMATERIALFVSGIXPROC) (GLenum face, GLenum pname, GLint terms, const GLfloat* params);
# 21431 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLPIXELTEXGENSGIXPROC) (GLenum mode);
# 21474 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLDEFORMSGIXPROC) (GLbitfield mask);
typedef void ( * PFNGLLOADIDENTITYDEFORMATIONMAPSGIXPROC) (GLbitfield mask);
# 21489 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLMESHBREADTHSGIXPROC) (GLint breadth);
typedef void ( * PFNGLMESHSTRIDESGIXPROC) (GLint stride);
# 21504 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLREFERENCEPLANESGIXPROC) (const GLdouble* equation);
# 21593 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLSPRITEPARAMETERFSGIXPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLSPRITEPARAMETERFVSGIXPROC) (GLenum pname, GLfloat* params);
typedef void ( * PFNGLSPRITEPARAMETERISGIXPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLSPRITEPARAMETERIVSGIXPROC) (GLenum pname, GLint* params);
# 21636 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLTAGSAMPLEBUFFERSGIXPROC) (void);
# 21775 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETVECTOROPERATIONSGIXPROC) (GLenum operation);
typedef void ( * PFNGLVECTOROPERATIONSGIXPROC) (GLenum operation);
# 21790 "/usr/include/GL/glew.h" 3 4
typedef GLboolean ( * PFNGLAREVERTEXARRAYSRESIDENTSGIXPROC) (GLsizei n, const GLuint* arrays, GLboolean* residences);
typedef void ( * PFNGLBINDVERTEXARRAYSGIXPROC) (GLuint array);
typedef void ( * PFNGLDELETEVERTEXARRAYSSGIXPROC) (GLsizei n, const GLuint* arrays);
typedef void ( * PFNGLGENVERTEXARRAYSSGIXPROC) (GLsizei n, GLuint* arrays);
typedef GLboolean ( * PFNGLISVERTEXARRAYSGIXPROC) (GLuint array);
typedef void ( * PFNGLPRIORITIZEVERTEXARRAYSSGIXPROC) (GLsizei n, const GLuint* arrays, const GLclampf* priorities);
# 21905 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCOLORTABLEPARAMETERFVSGIPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLCOLORTABLEPARAMETERIVSGIPROC) (GLenum target, GLenum pname, const GLint* params);
typedef void ( * PFNGLCOLORTABLESGIPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *table);
typedef void ( * PFNGLCOPYCOLORTABLESGIPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLGETCOLORTABLEPARAMETERFVSGIPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETCOLORTABLEPARAMETERIVSGIPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETCOLORTABLESGIPROC) (GLenum target, GLenum format, GLenum type, void *table);
# 21962 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGETPIXELTRANSFORMPARAMETERFVSGIPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETPIXELTRANSFORMPARAMETERIVSGIPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLPIXELTRANSFORMPARAMETERFSGIPROC) (GLenum target, GLenum pname, GLfloat param);
typedef void ( * PFNGLPIXELTRANSFORMPARAMETERFVSGIPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLPIXELTRANSFORMPARAMETERISGIPROC) (GLenum target, GLenum pname, GLint param);
typedef void ( * PFNGLPIXELTRANSFORMPARAMETERIVSGIPROC) (GLenum target, GLenum pname, const GLint* params);
typedef void ( * PFNGLPIXELTRANSFORMSGIPROC) (GLenum target);
# 22002 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLFINISHTEXTURESUNXPROC) (void);
# 22029 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLGLOBALALPHAFACTORBSUNPROC) (GLbyte factor);
typedef void ( * PFNGLGLOBALALPHAFACTORDSUNPROC) (GLdouble factor);
typedef void ( * PFNGLGLOBALALPHAFACTORFSUNPROC) (GLfloat factor);
typedef void ( * PFNGLGLOBALALPHAFACTORISUNPROC) (GLint factor);
typedef void ( * PFNGLGLOBALALPHAFACTORSSUNPROC) (GLshort factor);
typedef void ( * PFNGLGLOBALALPHAFACTORUBSUNPROC) (GLubyte factor);
typedef void ( * PFNGLGLOBALALPHAFACTORUISUNPROC) (GLuint factor);
typedef void ( * PFNGLGLOBALALPHAFACTORUSSUNPROC) (GLushort factor);
# 22068 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLREADVIDEOPIXELSSUNPROC) (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void* pixels);
# 22110 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLREPLACEMENTCODEPOINTERSUNPROC) (GLenum type, GLsizei stride, const void *pointer);
typedef void ( * PFNGLREPLACEMENTCODEUBSUNPROC) (GLubyte code);
typedef void ( * PFNGLREPLACEMENTCODEUBVSUNPROC) (const GLubyte* code);
typedef void ( * PFNGLREPLACEMENTCODEUISUNPROC) (GLuint code);
typedef void ( * PFNGLREPLACEMENTCODEUIVSUNPROC) (const GLuint* code);
typedef void ( * PFNGLREPLACEMENTCODEUSSUNPROC) (GLushort code);
typedef void ( * PFNGLREPLACEMENTCODEUSVSUNPROC) (const GLushort* code);
# 22135 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLCOLOR3FVERTEX3FSUNPROC) (GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLCOLOR3FVERTEX3FVSUNPROC) (const GLfloat* c, const GLfloat *v);
typedef void ( * PFNGLCOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLCOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLfloat* c, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLCOLOR4UBVERTEX2FSUNPROC) (GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y);
typedef void ( * PFNGLCOLOR4UBVERTEX2FVSUNPROC) (const GLubyte* c, const GLfloat *v);
typedef void ( * PFNGLCOLOR4UBVERTEX3FSUNPROC) (GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLCOLOR4UBVERTEX3FVSUNPROC) (const GLubyte* c, const GLfloat *v);
typedef void ( * PFNGLNORMAL3FVERTEX3FSUNPROC) (GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLNORMAL3FVERTEX3FVSUNPROC) (const GLfloat* n, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FSUNPROC) (GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *c, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FSUNPROC) (GLuint rc, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FVSUNPROC) (const GLuint* rc, const GLubyte *c, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *tc, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FSUNPROC) (GLuint rc, GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *tc, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUIVERTEX3FSUNPROC) (GLuint rc, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUIVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD2FCOLOR3FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLTEXCOORD2FCOLOR3FVERTEX3FVSUNPROC) (const GLfloat* tc, const GLfloat *c, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLfloat* tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD2FCOLOR4UBVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLTEXCOORD2FCOLOR4UBVERTEX3FVSUNPROC) (const GLfloat* tc, const GLubyte *c, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD2FNORMAL3FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLTEXCOORD2FNORMAL3FVERTEX3FVSUNPROC) (const GLfloat* tc, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD2FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLTEXCOORD2FVERTEX3FVSUNPROC) (const GLfloat* tc, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FSUNPROC) (GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FVSUNPROC) (const GLfloat* tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD4FVERTEX4FSUNPROC) (GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLTEXCOORD4FVERTEX4FVSUNPROC) (const GLfloat* tc, const GLfloat *v);
# 22269 "/usr/include/GL/glew.h" 3 4
typedef void ( * PFNGLADDSWAPHINTRECTWINPROC) (GLint x, GLint y, GLsizei width, GLsizei height);
# 22281 "/usr/include/GL/glew.h" 3 4
extern __attribute__ ((visibility("default"))) PFNGLCOPYTEXSUBIMAGE3DPROC __glewCopyTexSubImage3D;
extern __attribute__ ((visibility("default"))) PFNGLDRAWRANGEELEMENTSPROC __glewDrawRangeElements;
extern __attribute__ ((visibility("default"))) PFNGLTEXIMAGE3DPROC __glewTexImage3D;
extern __attribute__ ((visibility("default"))) PFNGLTEXSUBIMAGE3DPROC __glewTexSubImage3D;

extern __attribute__ ((visibility("default"))) PFNGLACTIVETEXTUREPROC __glewActiveTexture;
extern __attribute__ ((visibility("default"))) PFNGLCLIENTACTIVETEXTUREPROC __glewClientActiveTexture;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXIMAGE1DPROC __glewCompressedTexImage1D;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXIMAGE2DPROC __glewCompressedTexImage2D;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXIMAGE3DPROC __glewCompressedTexImage3D;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC __glewCompressedTexSubImage1D;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC __glewCompressedTexSubImage2D;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC __glewCompressedTexSubImage3D;
extern __attribute__ ((visibility("default"))) PFNGLGETCOMPRESSEDTEXIMAGEPROC __glewGetCompressedTexImage;
extern __attribute__ ((visibility("default"))) PFNGLLOADTRANSPOSEMATRIXDPROC __glewLoadTransposeMatrixd;
extern __attribute__ ((visibility("default"))) PFNGLLOADTRANSPOSEMATRIXFPROC __glewLoadTransposeMatrixf;
extern __attribute__ ((visibility("default"))) PFNGLMULTTRANSPOSEMATRIXDPROC __glewMultTransposeMatrixd;
extern __attribute__ ((visibility("default"))) PFNGLMULTTRANSPOSEMATRIXFPROC __glewMultTransposeMatrixf;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1DPROC __glewMultiTexCoord1d;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1DVPROC __glewMultiTexCoord1dv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1FPROC __glewMultiTexCoord1f;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1FVPROC __glewMultiTexCoord1fv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1IPROC __glewMultiTexCoord1i;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1IVPROC __glewMultiTexCoord1iv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1SPROC __glewMultiTexCoord1s;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1SVPROC __glewMultiTexCoord1sv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2DPROC __glewMultiTexCoord2d;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2DVPROC __glewMultiTexCoord2dv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2FPROC __glewMultiTexCoord2f;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2FVPROC __glewMultiTexCoord2fv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2IPROC __glewMultiTexCoord2i;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2IVPROC __glewMultiTexCoord2iv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2SPROC __glewMultiTexCoord2s;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2SVPROC __glewMultiTexCoord2sv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3DPROC __glewMultiTexCoord3d;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3DVPROC __glewMultiTexCoord3dv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3FPROC __glewMultiTexCoord3f;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3FVPROC __glewMultiTexCoord3fv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3IPROC __glewMultiTexCoord3i;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3IVPROC __glewMultiTexCoord3iv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3SPROC __glewMultiTexCoord3s;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3SVPROC __glewMultiTexCoord3sv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4DPROC __glewMultiTexCoord4d;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4DVPROC __glewMultiTexCoord4dv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4FPROC __glewMultiTexCoord4f;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4FVPROC __glewMultiTexCoord4fv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4IPROC __glewMultiTexCoord4i;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4IVPROC __glewMultiTexCoord4iv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4SPROC __glewMultiTexCoord4s;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4SVPROC __glewMultiTexCoord4sv;
extern __attribute__ ((visibility("default"))) PFNGLSAMPLECOVERAGEPROC __glewSampleCoverage;

extern __attribute__ ((visibility("default"))) PFNGLBLENDCOLORPROC __glewBlendColor;
extern __attribute__ ((visibility("default"))) PFNGLBLENDEQUATIONPROC __glewBlendEquation;
extern __attribute__ ((visibility("default"))) PFNGLBLENDFUNCSEPARATEPROC __glewBlendFuncSeparate;
extern __attribute__ ((visibility("default"))) PFNGLFOGCOORDPOINTERPROC __glewFogCoordPointer;
extern __attribute__ ((visibility("default"))) PFNGLFOGCOORDDPROC __glewFogCoordd;
extern __attribute__ ((visibility("default"))) PFNGLFOGCOORDDVPROC __glewFogCoorddv;
extern __attribute__ ((visibility("default"))) PFNGLFOGCOORDFPROC __glewFogCoordf;
extern __attribute__ ((visibility("default"))) PFNGLFOGCOORDFVPROC __glewFogCoordfv;
extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWARRAYSPROC __glewMultiDrawArrays;
extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWELEMENTSPROC __glewMultiDrawElements;
extern __attribute__ ((visibility("default"))) PFNGLPOINTPARAMETERFPROC __glewPointParameterf;
extern __attribute__ ((visibility("default"))) PFNGLPOINTPARAMETERFVPROC __glewPointParameterfv;
extern __attribute__ ((visibility("default"))) PFNGLPOINTPARAMETERIPROC __glewPointParameteri;
extern __attribute__ ((visibility("default"))) PFNGLPOINTPARAMETERIVPROC __glewPointParameteriv;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3BPROC __glewSecondaryColor3b;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3BVPROC __glewSecondaryColor3bv;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3DPROC __glewSecondaryColor3d;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3DVPROC __glewSecondaryColor3dv;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3FPROC __glewSecondaryColor3f;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3FVPROC __glewSecondaryColor3fv;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3IPROC __glewSecondaryColor3i;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3IVPROC __glewSecondaryColor3iv;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3SPROC __glewSecondaryColor3s;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3SVPROC __glewSecondaryColor3sv;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3UBPROC __glewSecondaryColor3ub;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3UBVPROC __glewSecondaryColor3ubv;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3UIPROC __glewSecondaryColor3ui;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3UIVPROC __glewSecondaryColor3uiv;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3USPROC __glewSecondaryColor3us;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3USVPROC __glewSecondaryColor3usv;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLORPOINTERPROC __glewSecondaryColorPointer;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2DPROC __glewWindowPos2d;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2DVPROC __glewWindowPos2dv;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2FPROC __glewWindowPos2f;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2FVPROC __glewWindowPos2fv;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2IPROC __glewWindowPos2i;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2IVPROC __glewWindowPos2iv;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2SPROC __glewWindowPos2s;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2SVPROC __glewWindowPos2sv;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3DPROC __glewWindowPos3d;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3DVPROC __glewWindowPos3dv;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3FPROC __glewWindowPos3f;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3FVPROC __glewWindowPos3fv;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3IPROC __glewWindowPos3i;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3IVPROC __glewWindowPos3iv;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3SPROC __glewWindowPos3s;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3SVPROC __glewWindowPos3sv;

extern __attribute__ ((visibility("default"))) PFNGLBEGINQUERYPROC __glewBeginQuery;
extern __attribute__ ((visibility("default"))) PFNGLBINDBUFFERPROC __glewBindBuffer;
extern __attribute__ ((visibility("default"))) PFNGLBUFFERDATAPROC __glewBufferData;
extern __attribute__ ((visibility("default"))) PFNGLBUFFERSUBDATAPROC __glewBufferSubData;
extern __attribute__ ((visibility("default"))) PFNGLDELETEBUFFERSPROC __glewDeleteBuffers;
extern __attribute__ ((visibility("default"))) PFNGLDELETEQUERIESPROC __glewDeleteQueries;
extern __attribute__ ((visibility("default"))) PFNGLENDQUERYPROC __glewEndQuery;
extern __attribute__ ((visibility("default"))) PFNGLGENBUFFERSPROC __glewGenBuffers;
extern __attribute__ ((visibility("default"))) PFNGLGENQUERIESPROC __glewGenQueries;
extern __attribute__ ((visibility("default"))) PFNGLGETBUFFERPARAMETERIVPROC __glewGetBufferParameteriv;
extern __attribute__ ((visibility("default"))) PFNGLGETBUFFERPOINTERVPROC __glewGetBufferPointerv;
extern __attribute__ ((visibility("default"))) PFNGLGETBUFFERSUBDATAPROC __glewGetBufferSubData;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYOBJECTIVPROC __glewGetQueryObjectiv;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYOBJECTUIVPROC __glewGetQueryObjectuiv;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYIVPROC __glewGetQueryiv;
extern __attribute__ ((visibility("default"))) PFNGLISBUFFERPROC __glewIsBuffer;
extern __attribute__ ((visibility("default"))) PFNGLISQUERYPROC __glewIsQuery;
extern __attribute__ ((visibility("default"))) PFNGLMAPBUFFERPROC __glewMapBuffer;
extern __attribute__ ((visibility("default"))) PFNGLUNMAPBUFFERPROC __glewUnmapBuffer;

extern __attribute__ ((visibility("default"))) PFNGLATTACHSHADERPROC __glewAttachShader;
extern __attribute__ ((visibility("default"))) PFNGLBINDATTRIBLOCATIONPROC __glewBindAttribLocation;
extern __attribute__ ((visibility("default"))) PFNGLBLENDEQUATIONSEPARATEPROC __glewBlendEquationSeparate;
extern __attribute__ ((visibility("default"))) PFNGLCOMPILESHADERPROC __glewCompileShader;
extern __attribute__ ((visibility("default"))) PFNGLCREATEPROGRAMPROC __glewCreateProgram;
extern __attribute__ ((visibility("default"))) PFNGLCREATESHADERPROC __glewCreateShader;
extern __attribute__ ((visibility("default"))) PFNGLDELETEPROGRAMPROC __glewDeleteProgram;
extern __attribute__ ((visibility("default"))) PFNGLDELETESHADERPROC __glewDeleteShader;
extern __attribute__ ((visibility("default"))) PFNGLDETACHSHADERPROC __glewDetachShader;
extern __attribute__ ((visibility("default"))) PFNGLDISABLEVERTEXATTRIBARRAYPROC __glewDisableVertexAttribArray;
extern __attribute__ ((visibility("default"))) PFNGLDRAWBUFFERSPROC __glewDrawBuffers;
extern __attribute__ ((visibility("default"))) PFNGLENABLEVERTEXATTRIBARRAYPROC __glewEnableVertexAttribArray;
extern __attribute__ ((visibility("default"))) PFNGLGETACTIVEATTRIBPROC __glewGetActiveAttrib;
extern __attribute__ ((visibility("default"))) PFNGLGETACTIVEUNIFORMPROC __glewGetActiveUniform;
extern __attribute__ ((visibility("default"))) PFNGLGETATTACHEDSHADERSPROC __glewGetAttachedShaders;
extern __attribute__ ((visibility("default"))) PFNGLGETATTRIBLOCATIONPROC __glewGetAttribLocation;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMINFOLOGPROC __glewGetProgramInfoLog;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMIVPROC __glewGetProgramiv;
extern __attribute__ ((visibility("default"))) PFNGLGETSHADERINFOLOGPROC __glewGetShaderInfoLog;
extern __attribute__ ((visibility("default"))) PFNGLGETSHADERSOURCEPROC __glewGetShaderSource;
extern __attribute__ ((visibility("default"))) PFNGLGETSHADERIVPROC __glewGetShaderiv;
extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMLOCATIONPROC __glewGetUniformLocation;
extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMFVPROC __glewGetUniformfv;
extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMIVPROC __glewGetUniformiv;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBPOINTERVPROC __glewGetVertexAttribPointerv;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBDVPROC __glewGetVertexAttribdv;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBFVPROC __glewGetVertexAttribfv;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBIVPROC __glewGetVertexAttribiv;
extern __attribute__ ((visibility("default"))) PFNGLISPROGRAMPROC __glewIsProgram;
extern __attribute__ ((visibility("default"))) PFNGLISSHADERPROC __glewIsShader;
extern __attribute__ ((visibility("default"))) PFNGLLINKPROGRAMPROC __glewLinkProgram;
extern __attribute__ ((visibility("default"))) PFNGLSHADERSOURCEPROC __glewShaderSource;
extern __attribute__ ((visibility("default"))) PFNGLSTENCILFUNCSEPARATEPROC __glewStencilFuncSeparate;
extern __attribute__ ((visibility("default"))) PFNGLSTENCILMASKSEPARATEPROC __glewStencilMaskSeparate;
extern __attribute__ ((visibility("default"))) PFNGLSTENCILOPSEPARATEPROC __glewStencilOpSeparate;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1FPROC __glewUniform1f;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1FVPROC __glewUniform1fv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1IPROC __glewUniform1i;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1IVPROC __glewUniform1iv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2FPROC __glewUniform2f;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2FVPROC __glewUniform2fv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2IPROC __glewUniform2i;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2IVPROC __glewUniform2iv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3FPROC __glewUniform3f;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3FVPROC __glewUniform3fv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3IPROC __glewUniform3i;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3IVPROC __glewUniform3iv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4FPROC __glewUniform4f;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4FVPROC __glewUniform4fv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4IPROC __glewUniform4i;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4IVPROC __glewUniform4iv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX2FVPROC __glewUniformMatrix2fv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX3FVPROC __glewUniformMatrix3fv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX4FVPROC __glewUniformMatrix4fv;
extern __attribute__ ((visibility("default"))) PFNGLUSEPROGRAMPROC __glewUseProgram;
extern __attribute__ ((visibility("default"))) PFNGLVALIDATEPROGRAMPROC __glewValidateProgram;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1DPROC __glewVertexAttrib1d;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1DVPROC __glewVertexAttrib1dv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1FPROC __glewVertexAttrib1f;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1FVPROC __glewVertexAttrib1fv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1SPROC __glewVertexAttrib1s;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1SVPROC __glewVertexAttrib1sv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2DPROC __glewVertexAttrib2d;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2DVPROC __glewVertexAttrib2dv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2FPROC __glewVertexAttrib2f;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2FVPROC __glewVertexAttrib2fv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2SPROC __glewVertexAttrib2s;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2SVPROC __glewVertexAttrib2sv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3DPROC __glewVertexAttrib3d;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3DVPROC __glewVertexAttrib3dv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3FPROC __glewVertexAttrib3f;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3FVPROC __glewVertexAttrib3fv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3SPROC __glewVertexAttrib3s;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3SVPROC __glewVertexAttrib3sv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4NBVPROC __glewVertexAttrib4Nbv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4NIVPROC __glewVertexAttrib4Niv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4NSVPROC __glewVertexAttrib4Nsv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4NUBPROC __glewVertexAttrib4Nub;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4NUBVPROC __glewVertexAttrib4Nubv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4NUIVPROC __glewVertexAttrib4Nuiv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4NUSVPROC __glewVertexAttrib4Nusv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4BVPROC __glewVertexAttrib4bv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4DPROC __glewVertexAttrib4d;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4DVPROC __glewVertexAttrib4dv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4FPROC __glewVertexAttrib4f;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4FVPROC __glewVertexAttrib4fv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4IVPROC __glewVertexAttrib4iv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4SPROC __glewVertexAttrib4s;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4SVPROC __glewVertexAttrib4sv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4UBVPROC __glewVertexAttrib4ubv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4UIVPROC __glewVertexAttrib4uiv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4USVPROC __glewVertexAttrib4usv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBPOINTERPROC __glewVertexAttribPointer;

extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX2X3FVPROC __glewUniformMatrix2x3fv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX2X4FVPROC __glewUniformMatrix2x4fv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX3X2FVPROC __glewUniformMatrix3x2fv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX3X4FVPROC __glewUniformMatrix3x4fv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX4X2FVPROC __glewUniformMatrix4x2fv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX4X3FVPROC __glewUniformMatrix4x3fv;

extern __attribute__ ((visibility("default"))) PFNGLBEGINCONDITIONALRENDERPROC __glewBeginConditionalRender;
extern __attribute__ ((visibility("default"))) PFNGLBEGINTRANSFORMFEEDBACKPROC __glewBeginTransformFeedback;
extern __attribute__ ((visibility("default"))) PFNGLBINDFRAGDATALOCATIONPROC __glewBindFragDataLocation;
extern __attribute__ ((visibility("default"))) PFNGLCLAMPCOLORPROC __glewClampColor;
extern __attribute__ ((visibility("default"))) PFNGLCLEARBUFFERFIPROC __glewClearBufferfi;
extern __attribute__ ((visibility("default"))) PFNGLCLEARBUFFERFVPROC __glewClearBufferfv;
extern __attribute__ ((visibility("default"))) PFNGLCLEARBUFFERIVPROC __glewClearBufferiv;
extern __attribute__ ((visibility("default"))) PFNGLCLEARBUFFERUIVPROC __glewClearBufferuiv;
extern __attribute__ ((visibility("default"))) PFNGLCOLORMASKIPROC __glewColorMaski;
extern __attribute__ ((visibility("default"))) PFNGLDISABLEIPROC __glewDisablei;
extern __attribute__ ((visibility("default"))) PFNGLENABLEIPROC __glewEnablei;
extern __attribute__ ((visibility("default"))) PFNGLENDCONDITIONALRENDERPROC __glewEndConditionalRender;
extern __attribute__ ((visibility("default"))) PFNGLENDTRANSFORMFEEDBACKPROC __glewEndTransformFeedback;
extern __attribute__ ((visibility("default"))) PFNGLGETBOOLEANI_VPROC __glewGetBooleani_v;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAGDATALOCATIONPROC __glewGetFragDataLocation;
extern __attribute__ ((visibility("default"))) PFNGLGETSTRINGIPROC __glewGetStringi;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXPARAMETERIIVPROC __glewGetTexParameterIiv;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXPARAMETERIUIVPROC __glewGetTexParameterIuiv;
extern __attribute__ ((visibility("default"))) PFNGLGETTRANSFORMFEEDBACKVARYINGPROC __glewGetTransformFeedbackVarying;
extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMUIVPROC __glewGetUniformuiv;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBIIVPROC __glewGetVertexAttribIiv;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBIUIVPROC __glewGetVertexAttribIuiv;
extern __attribute__ ((visibility("default"))) PFNGLISENABLEDIPROC __glewIsEnabledi;
extern __attribute__ ((visibility("default"))) PFNGLTEXPARAMETERIIVPROC __glewTexParameterIiv;
extern __attribute__ ((visibility("default"))) PFNGLTEXPARAMETERIUIVPROC __glewTexParameterIuiv;
extern __attribute__ ((visibility("default"))) PFNGLTRANSFORMFEEDBACKVARYINGSPROC __glewTransformFeedbackVaryings;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1UIPROC __glewUniform1ui;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1UIVPROC __glewUniform1uiv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2UIPROC __glewUniform2ui;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2UIVPROC __glewUniform2uiv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3UIPROC __glewUniform3ui;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3UIVPROC __glewUniform3uiv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4UIPROC __glewUniform4ui;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4UIVPROC __glewUniform4uiv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI1IPROC __glewVertexAttribI1i;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI1IVPROC __glewVertexAttribI1iv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI1UIPROC __glewVertexAttribI1ui;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI1UIVPROC __glewVertexAttribI1uiv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI2IPROC __glewVertexAttribI2i;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI2IVPROC __glewVertexAttribI2iv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI2UIPROC __glewVertexAttribI2ui;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI2UIVPROC __glewVertexAttribI2uiv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI3IPROC __glewVertexAttribI3i;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI3IVPROC __glewVertexAttribI3iv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI3UIPROC __glewVertexAttribI3ui;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI3UIVPROC __glewVertexAttribI3uiv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI4BVPROC __glewVertexAttribI4bv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI4IPROC __glewVertexAttribI4i;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI4IVPROC __glewVertexAttribI4iv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI4SVPROC __glewVertexAttribI4sv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI4UBVPROC __glewVertexAttribI4ubv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI4UIPROC __glewVertexAttribI4ui;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI4UIVPROC __glewVertexAttribI4uiv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI4USVPROC __glewVertexAttribI4usv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBIPOINTERPROC __glewVertexAttribIPointer;

extern __attribute__ ((visibility("default"))) PFNGLDRAWARRAYSINSTANCEDPROC __glewDrawArraysInstanced;
extern __attribute__ ((visibility("default"))) PFNGLDRAWELEMENTSINSTANCEDPROC __glewDrawElementsInstanced;
extern __attribute__ ((visibility("default"))) PFNGLPRIMITIVERESTARTINDEXPROC __glewPrimitiveRestartIndex;
extern __attribute__ ((visibility("default"))) PFNGLTEXBUFFERPROC __glewTexBuffer;

extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTUREPROC __glewFramebufferTexture;
extern __attribute__ ((visibility("default"))) PFNGLGETBUFFERPARAMETERI64VPROC __glewGetBufferParameteri64v;
extern __attribute__ ((visibility("default"))) PFNGLGETINTEGER64I_VPROC __glewGetInteger64i_v;

extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBDIVISORPROC __glewVertexAttribDivisor;

extern __attribute__ ((visibility("default"))) PFNGLBLENDEQUATIONSEPARATEIPROC __glewBlendEquationSeparatei;
extern __attribute__ ((visibility("default"))) PFNGLBLENDEQUATIONIPROC __glewBlendEquationi;
extern __attribute__ ((visibility("default"))) PFNGLBLENDFUNCSEPARATEIPROC __glewBlendFuncSeparatei;
extern __attribute__ ((visibility("default"))) PFNGLBLENDFUNCIPROC __glewBlendFunci;
extern __attribute__ ((visibility("default"))) PFNGLMINSAMPLESHADINGPROC __glewMinSampleShading;

extern __attribute__ ((visibility("default"))) PFNGLGETGRAPHICSRESETSTATUSPROC __glewGetGraphicsResetStatus;
extern __attribute__ ((visibility("default"))) PFNGLGETNCOMPRESSEDTEXIMAGEPROC __glewGetnCompressedTexImage;
extern __attribute__ ((visibility("default"))) PFNGLGETNTEXIMAGEPROC __glewGetnTexImage;
extern __attribute__ ((visibility("default"))) PFNGLGETNUNIFORMDVPROC __glewGetnUniformdv;

extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWARRAYSINDIRECTCOUNTPROC __glewMultiDrawArraysIndirectCount;
extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTPROC __glewMultiDrawElementsIndirectCount;
extern __attribute__ ((visibility("default"))) PFNGLSPECIALIZESHADERPROC __glewSpecializeShader;

extern __attribute__ ((visibility("default"))) PFNGLTBUFFERMASK3DFXPROC __glewTbufferMask3DFX;

extern __attribute__ ((visibility("default"))) PFNGLDEBUGMESSAGECALLBACKAMDPROC __glewDebugMessageCallbackAMD;
extern __attribute__ ((visibility("default"))) PFNGLDEBUGMESSAGEENABLEAMDPROC __glewDebugMessageEnableAMD;
extern __attribute__ ((visibility("default"))) PFNGLDEBUGMESSAGEINSERTAMDPROC __glewDebugMessageInsertAMD;
extern __attribute__ ((visibility("default"))) PFNGLGETDEBUGMESSAGELOGAMDPROC __glewGetDebugMessageLogAMD;

extern __attribute__ ((visibility("default"))) PFNGLBLENDEQUATIONINDEXEDAMDPROC __glewBlendEquationIndexedAMD;
extern __attribute__ ((visibility("default"))) PFNGLBLENDEQUATIONSEPARATEINDEXEDAMDPROC __glewBlendEquationSeparateIndexedAMD;
extern __attribute__ ((visibility("default"))) PFNGLBLENDFUNCINDEXEDAMDPROC __glewBlendFuncIndexedAMD;
extern __attribute__ ((visibility("default"))) PFNGLBLENDFUNCSEPARATEINDEXEDAMDPROC __glewBlendFuncSeparateIndexedAMD;

extern __attribute__ ((visibility("default"))) PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEADVANCEDAMDPROC __glewNamedRenderbufferStorageMultisampleAdvancedAMD;
extern __attribute__ ((visibility("default"))) PFNGLRENDERBUFFERSTORAGEMULTISAMPLEADVANCEDAMDPROC __glewRenderbufferStorageMultisampleAdvancedAMD;

extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERSAMPLEPOSITIONSFVAMDPROC __glewFramebufferSamplePositionsfvAMD;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAMEBUFFERPARAMETERFVAMDPROC __glewGetFramebufferParameterfvAMD;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDFRAMEBUFFERPARAMETERFVAMDPROC __glewGetNamedFramebufferParameterfvAMD;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDFRAMEBUFFERSAMPLEPOSITIONSFVAMDPROC __glewNamedFramebufferSamplePositionsfvAMD;

extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBPARAMETERIAMDPROC __glewVertexAttribParameteriAMD;

extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWARRAYSINDIRECTAMDPROC __glewMultiDrawArraysIndirectAMD;
extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWELEMENTSINDIRECTAMDPROC __glewMultiDrawElementsIndirectAMD;

extern __attribute__ ((visibility("default"))) PFNGLDELETENAMESAMDPROC __glewDeleteNamesAMD;
extern __attribute__ ((visibility("default"))) PFNGLGENNAMESAMDPROC __glewGenNamesAMD;
extern __attribute__ ((visibility("default"))) PFNGLISNAMEAMDPROC __glewIsNameAMD;

extern __attribute__ ((visibility("default"))) PFNGLQUERYOBJECTPARAMETERUIAMDPROC __glewQueryObjectParameteruiAMD;

extern __attribute__ ((visibility("default"))) PFNGLBEGINPERFMONITORAMDPROC __glewBeginPerfMonitorAMD;
extern __attribute__ ((visibility("default"))) PFNGLDELETEPERFMONITORSAMDPROC __glewDeletePerfMonitorsAMD;
extern __attribute__ ((visibility("default"))) PFNGLENDPERFMONITORAMDPROC __glewEndPerfMonitorAMD;
extern __attribute__ ((visibility("default"))) PFNGLGENPERFMONITORSAMDPROC __glewGenPerfMonitorsAMD;
extern __attribute__ ((visibility("default"))) PFNGLGETPERFMONITORCOUNTERDATAAMDPROC __glewGetPerfMonitorCounterDataAMD;
extern __attribute__ ((visibility("default"))) PFNGLGETPERFMONITORCOUNTERINFOAMDPROC __glewGetPerfMonitorCounterInfoAMD;
extern __attribute__ ((visibility("default"))) PFNGLGETPERFMONITORCOUNTERSTRINGAMDPROC __glewGetPerfMonitorCounterStringAMD;
extern __attribute__ ((visibility("default"))) PFNGLGETPERFMONITORCOUNTERSAMDPROC __glewGetPerfMonitorCountersAMD;
extern __attribute__ ((visibility("default"))) PFNGLGETPERFMONITORGROUPSTRINGAMDPROC __glewGetPerfMonitorGroupStringAMD;
extern __attribute__ ((visibility("default"))) PFNGLGETPERFMONITORGROUPSAMDPROC __glewGetPerfMonitorGroupsAMD;
extern __attribute__ ((visibility("default"))) PFNGLSELECTPERFMONITORCOUNTERSAMDPROC __glewSelectPerfMonitorCountersAMD;

extern __attribute__ ((visibility("default"))) PFNGLSETMULTISAMPLEFVAMDPROC __glewSetMultisamplefvAMD;

extern __attribute__ ((visibility("default"))) PFNGLTEXSTORAGESPARSEAMDPROC __glewTexStorageSparseAMD;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESTORAGESPARSEAMDPROC __glewTextureStorageSparseAMD;

extern __attribute__ ((visibility("default"))) PFNGLSTENCILOPVALUEAMDPROC __glewStencilOpValueAMD;

extern __attribute__ ((visibility("default"))) PFNGLTESSELLATIONFACTORAMDPROC __glewTessellationFactorAMD;
extern __attribute__ ((visibility("default"))) PFNGLTESSELLATIONMODEAMDPROC __glewTessellationModeAMD;

extern __attribute__ ((visibility("default"))) PFNGLBLITFRAMEBUFFERANGLEPROC __glewBlitFramebufferANGLE;

extern __attribute__ ((visibility("default"))) PFNGLRENDERBUFFERSTORAGEMULTISAMPLEANGLEPROC __glewRenderbufferStorageMultisampleANGLE;

extern __attribute__ ((visibility("default"))) PFNGLDRAWARRAYSINSTANCEDANGLEPROC __glewDrawArraysInstancedANGLE;
extern __attribute__ ((visibility("default"))) PFNGLDRAWELEMENTSINSTANCEDANGLEPROC __glewDrawElementsInstancedANGLE;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBDIVISORANGLEPROC __glewVertexAttribDivisorANGLE;

extern __attribute__ ((visibility("default"))) PFNGLBEGINQUERYANGLEPROC __glewBeginQueryANGLE;
extern __attribute__ ((visibility("default"))) PFNGLDELETEQUERIESANGLEPROC __glewDeleteQueriesANGLE;
extern __attribute__ ((visibility("default"))) PFNGLENDQUERYANGLEPROC __glewEndQueryANGLE;
extern __attribute__ ((visibility("default"))) PFNGLGENQUERIESANGLEPROC __glewGenQueriesANGLE;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYOBJECTI64VANGLEPROC __glewGetQueryObjecti64vANGLE;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYOBJECTIVANGLEPROC __glewGetQueryObjectivANGLE;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYOBJECTUI64VANGLEPROC __glewGetQueryObjectui64vANGLE;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYOBJECTUIVANGLEPROC __glewGetQueryObjectuivANGLE;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYIVANGLEPROC __glewGetQueryivANGLE;
extern __attribute__ ((visibility("default"))) PFNGLISQUERYANGLEPROC __glewIsQueryANGLE;
extern __attribute__ ((visibility("default"))) PFNGLQUERYCOUNTERANGLEPROC __glewQueryCounterANGLE;

extern __attribute__ ((visibility("default"))) PFNGLGETTRANSLATEDSHADERSOURCEANGLEPROC __glewGetTranslatedShaderSourceANGLE;

extern __attribute__ ((visibility("default"))) PFNGLCOPYTEXTURELEVELSAPPLEPROC __glewCopyTextureLevelsAPPLE;

extern __attribute__ ((visibility("default"))) PFNGLDRAWELEMENTARRAYAPPLEPROC __glewDrawElementArrayAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLDRAWRANGEELEMENTARRAYAPPLEPROC __glewDrawRangeElementArrayAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLELEMENTPOINTERAPPLEPROC __glewElementPointerAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWELEMENTARRAYAPPLEPROC __glewMultiDrawElementArrayAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWRANGEELEMENTARRAYAPPLEPROC __glewMultiDrawRangeElementArrayAPPLE;

extern __attribute__ ((visibility("default"))) PFNGLDELETEFENCESAPPLEPROC __glewDeleteFencesAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLFINISHFENCEAPPLEPROC __glewFinishFenceAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLFINISHOBJECTAPPLEPROC __glewFinishObjectAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLGENFENCESAPPLEPROC __glewGenFencesAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLISFENCEAPPLEPROC __glewIsFenceAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLSETFENCEAPPLEPROC __glewSetFenceAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLTESTFENCEAPPLEPROC __glewTestFenceAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLTESTOBJECTAPPLEPROC __glewTestObjectAPPLE;

extern __attribute__ ((visibility("default"))) PFNGLBUFFERPARAMETERIAPPLEPROC __glewBufferParameteriAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLFLUSHMAPPEDBUFFERRANGEAPPLEPROC __glewFlushMappedBufferRangeAPPLE;

extern __attribute__ ((visibility("default"))) PFNGLRENDERBUFFERSTORAGEMULTISAMPLEAPPLEPROC __glewRenderbufferStorageMultisampleAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLRESOLVEMULTISAMPLEFRAMEBUFFERAPPLEPROC __glewResolveMultisampleFramebufferAPPLE;

extern __attribute__ ((visibility("default"))) PFNGLGETOBJECTPARAMETERIVAPPLEPROC __glewGetObjectParameterivAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLOBJECTPURGEABLEAPPLEPROC __glewObjectPurgeableAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLOBJECTUNPURGEABLEAPPLEPROC __glewObjectUnpurgeableAPPLE;

extern __attribute__ ((visibility("default"))) PFNGLCLIENTWAITSYNCAPPLEPROC __glewClientWaitSyncAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLDELETESYNCAPPLEPROC __glewDeleteSyncAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLFENCESYNCAPPLEPROC __glewFenceSyncAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLGETINTEGER64VAPPLEPROC __glewGetInteger64vAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLGETSYNCIVAPPLEPROC __glewGetSyncivAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLISSYNCAPPLEPROC __glewIsSyncAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLWAITSYNCAPPLEPROC __glewWaitSyncAPPLE;

extern __attribute__ ((visibility("default"))) PFNGLGETTEXPARAMETERPOINTERVAPPLEPROC __glewGetTexParameterPointervAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURERANGEAPPLEPROC __glewTextureRangeAPPLE;

extern __attribute__ ((visibility("default"))) PFNGLBINDVERTEXARRAYAPPLEPROC __glewBindVertexArrayAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLDELETEVERTEXARRAYSAPPLEPROC __glewDeleteVertexArraysAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLGENVERTEXARRAYSAPPLEPROC __glewGenVertexArraysAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLISVERTEXARRAYAPPLEPROC __glewIsVertexArrayAPPLE;

extern __attribute__ ((visibility("default"))) PFNGLFLUSHVERTEXARRAYRANGEAPPLEPROC __glewFlushVertexArrayRangeAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYPARAMETERIAPPLEPROC __glewVertexArrayParameteriAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYRANGEAPPLEPROC __glewVertexArrayRangeAPPLE;

extern __attribute__ ((visibility("default"))) PFNGLDISABLEVERTEXATTRIBAPPLEPROC __glewDisableVertexAttribAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLENABLEVERTEXATTRIBAPPLEPROC __glewEnableVertexAttribAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLISVERTEXATTRIBENABLEDAPPLEPROC __glewIsVertexAttribEnabledAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLMAPVERTEXATTRIB1DAPPLEPROC __glewMapVertexAttrib1dAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLMAPVERTEXATTRIB1FAPPLEPROC __glewMapVertexAttrib1fAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLMAPVERTEXATTRIB2DAPPLEPROC __glewMapVertexAttrib2dAPPLE;
extern __attribute__ ((visibility("default"))) PFNGLMAPVERTEXATTRIB2FAPPLEPROC __glewMapVertexAttrib2fAPPLE;

extern __attribute__ ((visibility("default"))) PFNGLCLEARDEPTHFPROC __glewClearDepthf;
extern __attribute__ ((visibility("default"))) PFNGLDEPTHRANGEFPROC __glewDepthRangef;
extern __attribute__ ((visibility("default"))) PFNGLGETSHADERPRECISIONFORMATPROC __glewGetShaderPrecisionFormat;
extern __attribute__ ((visibility("default"))) PFNGLRELEASESHADERCOMPILERPROC __glewReleaseShaderCompiler;
extern __attribute__ ((visibility("default"))) PFNGLSHADERBINARYPROC __glewShaderBinary;

extern __attribute__ ((visibility("default"))) PFNGLMEMORYBARRIERBYREGIONPROC __glewMemoryBarrierByRegion;

extern __attribute__ ((visibility("default"))) PFNGLPRIMITIVEBOUNDINGBOXARBPROC __glewPrimitiveBoundingBoxARB;

extern __attribute__ ((visibility("default"))) PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC __glewDrawArraysInstancedBaseInstance;
extern __attribute__ ((visibility("default"))) PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC __glewDrawElementsInstancedBaseInstance;
extern __attribute__ ((visibility("default"))) PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC __glewDrawElementsInstancedBaseVertexBaseInstance;

extern __attribute__ ((visibility("default"))) PFNGLGETIMAGEHANDLEARBPROC __glewGetImageHandleARB;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTUREHANDLEARBPROC __glewGetTextureHandleARB;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTURESAMPLERHANDLEARBPROC __glewGetTextureSamplerHandleARB;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBLUI64VARBPROC __glewGetVertexAttribLui64vARB;
extern __attribute__ ((visibility("default"))) PFNGLISIMAGEHANDLERESIDENTARBPROC __glewIsImageHandleResidentARB;
extern __attribute__ ((visibility("default"))) PFNGLISTEXTUREHANDLERESIDENTARBPROC __glewIsTextureHandleResidentARB;
extern __attribute__ ((visibility("default"))) PFNGLMAKEIMAGEHANDLENONRESIDENTARBPROC __glewMakeImageHandleNonResidentARB;
extern __attribute__ ((visibility("default"))) PFNGLMAKEIMAGEHANDLERESIDENTARBPROC __glewMakeImageHandleResidentARB;
extern __attribute__ ((visibility("default"))) PFNGLMAKETEXTUREHANDLENONRESIDENTARBPROC __glewMakeTextureHandleNonResidentARB;
extern __attribute__ ((visibility("default"))) PFNGLMAKETEXTUREHANDLERESIDENTARBPROC __glewMakeTextureHandleResidentARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMHANDLEUI64ARBPROC __glewProgramUniformHandleui64ARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMHANDLEUI64VARBPROC __glewProgramUniformHandleui64vARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMHANDLEUI64ARBPROC __glewUniformHandleui64ARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMHANDLEUI64VARBPROC __glewUniformHandleui64vARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL1UI64ARBPROC __glewVertexAttribL1ui64ARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL1UI64VARBPROC __glewVertexAttribL1ui64vARB;

extern __attribute__ ((visibility("default"))) PFNGLBINDFRAGDATALOCATIONINDEXEDPROC __glewBindFragDataLocationIndexed;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAGDATAINDEXPROC __glewGetFragDataIndex;

extern __attribute__ ((visibility("default"))) PFNGLBUFFERSTORAGEPROC __glewBufferStorage;

extern __attribute__ ((visibility("default"))) PFNGLCREATESYNCFROMCLEVENTARBPROC __glewCreateSyncFromCLeventARB;

extern __attribute__ ((visibility("default"))) PFNGLCLEARBUFFERDATAPROC __glewClearBufferData;
extern __attribute__ ((visibility("default"))) PFNGLCLEARBUFFERSUBDATAPROC __glewClearBufferSubData;
extern __attribute__ ((visibility("default"))) PFNGLCLEARNAMEDBUFFERDATAEXTPROC __glewClearNamedBufferDataEXT;
extern __attribute__ ((visibility("default"))) PFNGLCLEARNAMEDBUFFERSUBDATAEXTPROC __glewClearNamedBufferSubDataEXT;

extern __attribute__ ((visibility("default"))) PFNGLCLEARTEXIMAGEPROC __glewClearTexImage;
extern __attribute__ ((visibility("default"))) PFNGLCLEARTEXSUBIMAGEPROC __glewClearTexSubImage;

extern __attribute__ ((visibility("default"))) PFNGLCLIPCONTROLPROC __glewClipControl;

extern __attribute__ ((visibility("default"))) PFNGLCLAMPCOLORARBPROC __glewClampColorARB;

extern __attribute__ ((visibility("default"))) PFNGLDISPATCHCOMPUTEPROC __glewDispatchCompute;
extern __attribute__ ((visibility("default"))) PFNGLDISPATCHCOMPUTEINDIRECTPROC __glewDispatchComputeIndirect;

extern __attribute__ ((visibility("default"))) PFNGLDISPATCHCOMPUTEGROUPSIZEARBPROC __glewDispatchComputeGroupSizeARB;

extern __attribute__ ((visibility("default"))) PFNGLCOPYBUFFERSUBDATAPROC __glewCopyBufferSubData;

extern __attribute__ ((visibility("default"))) PFNGLCOPYIMAGESUBDATAPROC __glewCopyImageSubData;

extern __attribute__ ((visibility("default"))) PFNGLDEBUGMESSAGECALLBACKARBPROC __glewDebugMessageCallbackARB;
extern __attribute__ ((visibility("default"))) PFNGLDEBUGMESSAGECONTROLARBPROC __glewDebugMessageControlARB;
extern __attribute__ ((visibility("default"))) PFNGLDEBUGMESSAGEINSERTARBPROC __glewDebugMessageInsertARB;
extern __attribute__ ((visibility("default"))) PFNGLGETDEBUGMESSAGELOGARBPROC __glewGetDebugMessageLogARB;

extern __attribute__ ((visibility("default"))) PFNGLBINDTEXTUREUNITPROC __glewBindTextureUnit;
extern __attribute__ ((visibility("default"))) PFNGLBLITNAMEDFRAMEBUFFERPROC __glewBlitNamedFramebuffer;
extern __attribute__ ((visibility("default"))) PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC __glewCheckNamedFramebufferStatus;
extern __attribute__ ((visibility("default"))) PFNGLCLEARNAMEDBUFFERDATAPROC __glewClearNamedBufferData;
extern __attribute__ ((visibility("default"))) PFNGLCLEARNAMEDBUFFERSUBDATAPROC __glewClearNamedBufferSubData;
extern __attribute__ ((visibility("default"))) PFNGLCLEARNAMEDFRAMEBUFFERFIPROC __glewClearNamedFramebufferfi;
extern __attribute__ ((visibility("default"))) PFNGLCLEARNAMEDFRAMEBUFFERFVPROC __glewClearNamedFramebufferfv;
extern __attribute__ ((visibility("default"))) PFNGLCLEARNAMEDFRAMEBUFFERIVPROC __glewClearNamedFramebufferiv;
extern __attribute__ ((visibility("default"))) PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC __glewClearNamedFramebufferuiv;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC __glewCompressedTextureSubImage1D;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC __glewCompressedTextureSubImage2D;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC __glewCompressedTextureSubImage3D;
extern __attribute__ ((visibility("default"))) PFNGLCOPYNAMEDBUFFERSUBDATAPROC __glewCopyNamedBufferSubData;
extern __attribute__ ((visibility("default"))) PFNGLCOPYTEXTURESUBIMAGE1DPROC __glewCopyTextureSubImage1D;
extern __attribute__ ((visibility("default"))) PFNGLCOPYTEXTURESUBIMAGE2DPROC __glewCopyTextureSubImage2D;
extern __attribute__ ((visibility("default"))) PFNGLCOPYTEXTURESUBIMAGE3DPROC __glewCopyTextureSubImage3D;
extern __attribute__ ((visibility("default"))) PFNGLCREATEBUFFERSPROC __glewCreateBuffers;
extern __attribute__ ((visibility("default"))) PFNGLCREATEFRAMEBUFFERSPROC __glewCreateFramebuffers;
extern __attribute__ ((visibility("default"))) PFNGLCREATEPROGRAMPIPELINESPROC __glewCreateProgramPipelines;
extern __attribute__ ((visibility("default"))) PFNGLCREATEQUERIESPROC __glewCreateQueries;
extern __attribute__ ((visibility("default"))) PFNGLCREATERENDERBUFFERSPROC __glewCreateRenderbuffers;
extern __attribute__ ((visibility("default"))) PFNGLCREATESAMPLERSPROC __glewCreateSamplers;
extern __attribute__ ((visibility("default"))) PFNGLCREATETEXTURESPROC __glewCreateTextures;
extern __attribute__ ((visibility("default"))) PFNGLCREATETRANSFORMFEEDBACKSPROC __glewCreateTransformFeedbacks;
extern __attribute__ ((visibility("default"))) PFNGLCREATEVERTEXARRAYSPROC __glewCreateVertexArrays;
extern __attribute__ ((visibility("default"))) PFNGLDISABLEVERTEXARRAYATTRIBPROC __glewDisableVertexArrayAttrib;
extern __attribute__ ((visibility("default"))) PFNGLENABLEVERTEXARRAYATTRIBPROC __glewEnableVertexArrayAttrib;
extern __attribute__ ((visibility("default"))) PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC __glewFlushMappedNamedBufferRange;
extern __attribute__ ((visibility("default"))) PFNGLGENERATETEXTUREMIPMAPPROC __glewGenerateTextureMipmap;
extern __attribute__ ((visibility("default"))) PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC __glewGetCompressedTextureImage;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDBUFFERPARAMETERI64VPROC __glewGetNamedBufferParameteri64v;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDBUFFERPARAMETERIVPROC __glewGetNamedBufferParameteriv;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDBUFFERPOINTERVPROC __glewGetNamedBufferPointerv;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDBUFFERSUBDATAPROC __glewGetNamedBufferSubData;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC __glewGetNamedFramebufferAttachmentParameteriv;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC __glewGetNamedFramebufferParameteriv;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC __glewGetNamedRenderbufferParameteriv;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYBUFFEROBJECTI64VPROC __glewGetQueryBufferObjecti64v;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYBUFFEROBJECTIVPROC __glewGetQueryBufferObjectiv;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYBUFFEROBJECTUI64VPROC __glewGetQueryBufferObjectui64v;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYBUFFEROBJECTUIVPROC __glewGetQueryBufferObjectuiv;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTUREIMAGEPROC __glewGetTextureImage;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTURELEVELPARAMETERFVPROC __glewGetTextureLevelParameterfv;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTURELEVELPARAMETERIVPROC __glewGetTextureLevelParameteriv;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTUREPARAMETERIIVPROC __glewGetTextureParameterIiv;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTUREPARAMETERIUIVPROC __glewGetTextureParameterIuiv;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTUREPARAMETERFVPROC __glewGetTextureParameterfv;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTUREPARAMETERIVPROC __glewGetTextureParameteriv;
extern __attribute__ ((visibility("default"))) PFNGLGETTRANSFORMFEEDBACKI64_VPROC __glewGetTransformFeedbacki64_v;
extern __attribute__ ((visibility("default"))) PFNGLGETTRANSFORMFEEDBACKI_VPROC __glewGetTransformFeedbacki_v;
extern __attribute__ ((visibility("default"))) PFNGLGETTRANSFORMFEEDBACKIVPROC __glewGetTransformFeedbackiv;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXARRAYINDEXED64IVPROC __glewGetVertexArrayIndexed64iv;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXARRAYINDEXEDIVPROC __glewGetVertexArrayIndexediv;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXARRAYIVPROC __glewGetVertexArrayiv;
extern __attribute__ ((visibility("default"))) PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC __glewInvalidateNamedFramebufferData;
extern __attribute__ ((visibility("default"))) PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC __glewInvalidateNamedFramebufferSubData;
extern __attribute__ ((visibility("default"))) PFNGLMAPNAMEDBUFFERPROC __glewMapNamedBuffer;
extern __attribute__ ((visibility("default"))) PFNGLMAPNAMEDBUFFERRANGEPROC __glewMapNamedBufferRange;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDBUFFERDATAPROC __glewNamedBufferData;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDBUFFERSTORAGEPROC __glewNamedBufferStorage;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDBUFFERSUBDATAPROC __glewNamedBufferSubData;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC __glewNamedFramebufferDrawBuffer;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC __glewNamedFramebufferDrawBuffers;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC __glewNamedFramebufferParameteri;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC __glewNamedFramebufferReadBuffer;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC __glewNamedFramebufferRenderbuffer;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDFRAMEBUFFERTEXTUREPROC __glewNamedFramebufferTexture;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC __glewNamedFramebufferTextureLayer;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDRENDERBUFFERSTORAGEPROC __glewNamedRenderbufferStorage;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC __glewNamedRenderbufferStorageMultisample;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREBUFFERPROC __glewTextureBuffer;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREBUFFERRANGEPROC __glewTextureBufferRange;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREPARAMETERIIVPROC __glewTextureParameterIiv;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREPARAMETERIUIVPROC __glewTextureParameterIuiv;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREPARAMETERFPROC __glewTextureParameterf;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREPARAMETERFVPROC __glewTextureParameterfv;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREPARAMETERIPROC __glewTextureParameteri;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREPARAMETERIVPROC __glewTextureParameteriv;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESTORAGE1DPROC __glewTextureStorage1D;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESTORAGE2DPROC __glewTextureStorage2D;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC __glewTextureStorage2DMultisample;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESTORAGE3DPROC __glewTextureStorage3D;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC __glewTextureStorage3DMultisample;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESUBIMAGE1DPROC __glewTextureSubImage1D;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESUBIMAGE2DPROC __glewTextureSubImage2D;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESUBIMAGE3DPROC __glewTextureSubImage3D;
extern __attribute__ ((visibility("default"))) PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC __glewTransformFeedbackBufferBase;
extern __attribute__ ((visibility("default"))) PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC __glewTransformFeedbackBufferRange;
extern __attribute__ ((visibility("default"))) PFNGLUNMAPNAMEDBUFFERPROC __glewUnmapNamedBuffer;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYATTRIBBINDINGPROC __glewVertexArrayAttribBinding;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYATTRIBFORMATPROC __glewVertexArrayAttribFormat;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYATTRIBIFORMATPROC __glewVertexArrayAttribIFormat;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYATTRIBLFORMATPROC __glewVertexArrayAttribLFormat;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYBINDINGDIVISORPROC __glewVertexArrayBindingDivisor;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYELEMENTBUFFERPROC __glewVertexArrayElementBuffer;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYVERTEXBUFFERPROC __glewVertexArrayVertexBuffer;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYVERTEXBUFFERSPROC __glewVertexArrayVertexBuffers;

extern __attribute__ ((visibility("default"))) PFNGLDRAWBUFFERSARBPROC __glewDrawBuffersARB;

extern __attribute__ ((visibility("default"))) PFNGLBLENDEQUATIONSEPARATEIARBPROC __glewBlendEquationSeparateiARB;
extern __attribute__ ((visibility("default"))) PFNGLBLENDEQUATIONIARBPROC __glewBlendEquationiARB;
extern __attribute__ ((visibility("default"))) PFNGLBLENDFUNCSEPARATEIARBPROC __glewBlendFuncSeparateiARB;
extern __attribute__ ((visibility("default"))) PFNGLBLENDFUNCIARBPROC __glewBlendFunciARB;

extern __attribute__ ((visibility("default"))) PFNGLDRAWELEMENTSBASEVERTEXPROC __glewDrawElementsBaseVertex;
extern __attribute__ ((visibility("default"))) PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC __glewDrawElementsInstancedBaseVertex;
extern __attribute__ ((visibility("default"))) PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC __glewDrawRangeElementsBaseVertex;
extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC __glewMultiDrawElementsBaseVertex;

extern __attribute__ ((visibility("default"))) PFNGLDRAWARRAYSINDIRECTPROC __glewDrawArraysIndirect;
extern __attribute__ ((visibility("default"))) PFNGLDRAWELEMENTSINDIRECTPROC __glewDrawElementsIndirect;

extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERPARAMETERIPROC __glewFramebufferParameteri;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAMEBUFFERPARAMETERIVPROC __glewGetFramebufferParameteriv;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVEXTPROC __glewGetNamedFramebufferParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDFRAMEBUFFERPARAMETERIEXTPROC __glewNamedFramebufferParameteriEXT;

extern __attribute__ ((visibility("default"))) PFNGLBINDFRAMEBUFFERPROC __glewBindFramebuffer;
extern __attribute__ ((visibility("default"))) PFNGLBINDRENDERBUFFERPROC __glewBindRenderbuffer;
extern __attribute__ ((visibility("default"))) PFNGLBLITFRAMEBUFFERPROC __glewBlitFramebuffer;
extern __attribute__ ((visibility("default"))) PFNGLCHECKFRAMEBUFFERSTATUSPROC __glewCheckFramebufferStatus;
extern __attribute__ ((visibility("default"))) PFNGLDELETEFRAMEBUFFERSPROC __glewDeleteFramebuffers;
extern __attribute__ ((visibility("default"))) PFNGLDELETERENDERBUFFERSPROC __glewDeleteRenderbuffers;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERRENDERBUFFERPROC __glewFramebufferRenderbuffer;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTURE1DPROC __glewFramebufferTexture1D;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTURE2DPROC __glewFramebufferTexture2D;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTURE3DPROC __glewFramebufferTexture3D;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTURELAYERPROC __glewFramebufferTextureLayer;
extern __attribute__ ((visibility("default"))) PFNGLGENFRAMEBUFFERSPROC __glewGenFramebuffers;
extern __attribute__ ((visibility("default"))) PFNGLGENRENDERBUFFERSPROC __glewGenRenderbuffers;
extern __attribute__ ((visibility("default"))) PFNGLGENERATEMIPMAPPROC __glewGenerateMipmap;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC __glewGetFramebufferAttachmentParameteriv;
extern __attribute__ ((visibility("default"))) PFNGLGETRENDERBUFFERPARAMETERIVPROC __glewGetRenderbufferParameteriv;
extern __attribute__ ((visibility("default"))) PFNGLISFRAMEBUFFERPROC __glewIsFramebuffer;
extern __attribute__ ((visibility("default"))) PFNGLISRENDERBUFFERPROC __glewIsRenderbuffer;
extern __attribute__ ((visibility("default"))) PFNGLRENDERBUFFERSTORAGEPROC __glewRenderbufferStorage;
extern __attribute__ ((visibility("default"))) PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC __glewRenderbufferStorageMultisample;

extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTUREARBPROC __glewFramebufferTextureARB;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTUREFACEARBPROC __glewFramebufferTextureFaceARB;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTURELAYERARBPROC __glewFramebufferTextureLayerARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMPARAMETERIARBPROC __glewProgramParameteriARB;

extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMBINARYPROC __glewGetProgramBinary;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMBINARYPROC __glewProgramBinary;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMPARAMETERIPROC __glewProgramParameteri;

extern __attribute__ ((visibility("default"))) PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC __glewGetCompressedTextureSubImage;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTURESUBIMAGEPROC __glewGetTextureSubImage;

extern __attribute__ ((visibility("default"))) PFNGLSPECIALIZESHADERARBPROC __glewSpecializeShaderARB;

extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMDVPROC __glewGetUniformdv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1DPROC __glewUniform1d;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1DVPROC __glewUniform1dv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2DPROC __glewUniform2d;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2DVPROC __glewUniform2dv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3DPROC __glewUniform3d;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3DVPROC __glewUniform3dv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4DPROC __glewUniform4d;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4DVPROC __glewUniform4dv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX2DVPROC __glewUniformMatrix2dv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX2X3DVPROC __glewUniformMatrix2x3dv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX2X4DVPROC __glewUniformMatrix2x4dv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX3DVPROC __glewUniformMatrix3dv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX3X2DVPROC __glewUniformMatrix3x2dv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX3X4DVPROC __glewUniformMatrix3x4dv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX4DVPROC __glewUniformMatrix4dv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX4X2DVPROC __glewUniformMatrix4x2dv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX4X3DVPROC __glewUniformMatrix4x3dv;

extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMI64VARBPROC __glewGetUniformi64vARB;
extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMUI64VARBPROC __glewGetUniformui64vARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNUNIFORMI64VARBPROC __glewGetnUniformi64vARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNUNIFORMUI64VARBPROC __glewGetnUniformui64vARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1I64ARBPROC __glewProgramUniform1i64ARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1I64VARBPROC __glewProgramUniform1i64vARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1UI64ARBPROC __glewProgramUniform1ui64ARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1UI64VARBPROC __glewProgramUniform1ui64vARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2I64ARBPROC __glewProgramUniform2i64ARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2I64VARBPROC __glewProgramUniform2i64vARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2UI64ARBPROC __glewProgramUniform2ui64ARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2UI64VARBPROC __glewProgramUniform2ui64vARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3I64ARBPROC __glewProgramUniform3i64ARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3I64VARBPROC __glewProgramUniform3i64vARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3UI64ARBPROC __glewProgramUniform3ui64ARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3UI64VARBPROC __glewProgramUniform3ui64vARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4I64ARBPROC __glewProgramUniform4i64ARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4I64VARBPROC __glewProgramUniform4i64vARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4UI64ARBPROC __glewProgramUniform4ui64ARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4UI64VARBPROC __glewProgramUniform4ui64vARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1I64ARBPROC __glewUniform1i64ARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1I64VARBPROC __glewUniform1i64vARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1UI64ARBPROC __glewUniform1ui64ARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1UI64VARBPROC __glewUniform1ui64vARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2I64ARBPROC __glewUniform2i64ARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2I64VARBPROC __glewUniform2i64vARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2UI64ARBPROC __glewUniform2ui64ARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2UI64VARBPROC __glewUniform2ui64vARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3I64ARBPROC __glewUniform3i64ARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3I64VARBPROC __glewUniform3i64vARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3UI64ARBPROC __glewUniform3ui64ARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3UI64VARBPROC __glewUniform3ui64vARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4I64ARBPROC __glewUniform4i64ARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4I64VARBPROC __glewUniform4i64vARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4UI64ARBPROC __glewUniform4ui64ARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4UI64VARBPROC __glewUniform4ui64vARB;

extern __attribute__ ((visibility("default"))) PFNGLCOLORSUBTABLEPROC __glewColorSubTable;
extern __attribute__ ((visibility("default"))) PFNGLCOLORTABLEPROC __glewColorTable;
extern __attribute__ ((visibility("default"))) PFNGLCOLORTABLEPARAMETERFVPROC __glewColorTableParameterfv;
extern __attribute__ ((visibility("default"))) PFNGLCOLORTABLEPARAMETERIVPROC __glewColorTableParameteriv;
extern __attribute__ ((visibility("default"))) PFNGLCONVOLUTIONFILTER1DPROC __glewConvolutionFilter1D;
extern __attribute__ ((visibility("default"))) PFNGLCONVOLUTIONFILTER2DPROC __glewConvolutionFilter2D;
extern __attribute__ ((visibility("default"))) PFNGLCONVOLUTIONPARAMETERFPROC __glewConvolutionParameterf;
extern __attribute__ ((visibility("default"))) PFNGLCONVOLUTIONPARAMETERFVPROC __glewConvolutionParameterfv;
extern __attribute__ ((visibility("default"))) PFNGLCONVOLUTIONPARAMETERIPROC __glewConvolutionParameteri;
extern __attribute__ ((visibility("default"))) PFNGLCONVOLUTIONPARAMETERIVPROC __glewConvolutionParameteriv;
extern __attribute__ ((visibility("default"))) PFNGLCOPYCOLORSUBTABLEPROC __glewCopyColorSubTable;
extern __attribute__ ((visibility("default"))) PFNGLCOPYCOLORTABLEPROC __glewCopyColorTable;
extern __attribute__ ((visibility("default"))) PFNGLCOPYCONVOLUTIONFILTER1DPROC __glewCopyConvolutionFilter1D;
extern __attribute__ ((visibility("default"))) PFNGLCOPYCONVOLUTIONFILTER2DPROC __glewCopyConvolutionFilter2D;
extern __attribute__ ((visibility("default"))) PFNGLGETCOLORTABLEPROC __glewGetColorTable;
extern __attribute__ ((visibility("default"))) PFNGLGETCOLORTABLEPARAMETERFVPROC __glewGetColorTableParameterfv;
extern __attribute__ ((visibility("default"))) PFNGLGETCOLORTABLEPARAMETERIVPROC __glewGetColorTableParameteriv;
extern __attribute__ ((visibility("default"))) PFNGLGETCONVOLUTIONFILTERPROC __glewGetConvolutionFilter;
extern __attribute__ ((visibility("default"))) PFNGLGETCONVOLUTIONPARAMETERFVPROC __glewGetConvolutionParameterfv;
extern __attribute__ ((visibility("default"))) PFNGLGETCONVOLUTIONPARAMETERIVPROC __glewGetConvolutionParameteriv;
extern __attribute__ ((visibility("default"))) PFNGLGETHISTOGRAMPROC __glewGetHistogram;
extern __attribute__ ((visibility("default"))) PFNGLGETHISTOGRAMPARAMETERFVPROC __glewGetHistogramParameterfv;
extern __attribute__ ((visibility("default"))) PFNGLGETHISTOGRAMPARAMETERIVPROC __glewGetHistogramParameteriv;
extern __attribute__ ((visibility("default"))) PFNGLGETMINMAXPROC __glewGetMinmax;
extern __attribute__ ((visibility("default"))) PFNGLGETMINMAXPARAMETERFVPROC __glewGetMinmaxParameterfv;
extern __attribute__ ((visibility("default"))) PFNGLGETMINMAXPARAMETERIVPROC __glewGetMinmaxParameteriv;
extern __attribute__ ((visibility("default"))) PFNGLGETSEPARABLEFILTERPROC __glewGetSeparableFilter;
extern __attribute__ ((visibility("default"))) PFNGLHISTOGRAMPROC __glewHistogram;
extern __attribute__ ((visibility("default"))) PFNGLMINMAXPROC __glewMinmax;
extern __attribute__ ((visibility("default"))) PFNGLRESETHISTOGRAMPROC __glewResetHistogram;
extern __attribute__ ((visibility("default"))) PFNGLRESETMINMAXPROC __glewResetMinmax;
extern __attribute__ ((visibility("default"))) PFNGLSEPARABLEFILTER2DPROC __glewSeparableFilter2D;

extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWARRAYSINDIRECTCOUNTARBPROC __glewMultiDrawArraysIndirectCountARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTARBPROC __glewMultiDrawElementsIndirectCountARB;

extern __attribute__ ((visibility("default"))) PFNGLDRAWARRAYSINSTANCEDARBPROC __glewDrawArraysInstancedARB;
extern __attribute__ ((visibility("default"))) PFNGLDRAWELEMENTSINSTANCEDARBPROC __glewDrawElementsInstancedARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBDIVISORARBPROC __glewVertexAttribDivisorARB;

extern __attribute__ ((visibility("default"))) PFNGLGETINTERNALFORMATIVPROC __glewGetInternalformativ;

extern __attribute__ ((visibility("default"))) PFNGLGETINTERNALFORMATI64VPROC __glewGetInternalformati64v;

extern __attribute__ ((visibility("default"))) PFNGLINVALIDATEBUFFERDATAPROC __glewInvalidateBufferData;
extern __attribute__ ((visibility("default"))) PFNGLINVALIDATEBUFFERSUBDATAPROC __glewInvalidateBufferSubData;
extern __attribute__ ((visibility("default"))) PFNGLINVALIDATEFRAMEBUFFERPROC __glewInvalidateFramebuffer;
extern __attribute__ ((visibility("default"))) PFNGLINVALIDATESUBFRAMEBUFFERPROC __glewInvalidateSubFramebuffer;
extern __attribute__ ((visibility("default"))) PFNGLINVALIDATETEXIMAGEPROC __glewInvalidateTexImage;
extern __attribute__ ((visibility("default"))) PFNGLINVALIDATETEXSUBIMAGEPROC __glewInvalidateTexSubImage;

extern __attribute__ ((visibility("default"))) PFNGLFLUSHMAPPEDBUFFERRANGEPROC __glewFlushMappedBufferRange;
extern __attribute__ ((visibility("default"))) PFNGLMAPBUFFERRANGEPROC __glewMapBufferRange;

extern __attribute__ ((visibility("default"))) PFNGLCURRENTPALETTEMATRIXARBPROC __glewCurrentPaletteMatrixARB;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXINDEXPOINTERARBPROC __glewMatrixIndexPointerARB;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXINDEXUBVARBPROC __glewMatrixIndexubvARB;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXINDEXUIVARBPROC __glewMatrixIndexuivARB;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXINDEXUSVARBPROC __glewMatrixIndexusvARB;

extern __attribute__ ((visibility("default"))) PFNGLBINDBUFFERSBASEPROC __glewBindBuffersBase;
extern __attribute__ ((visibility("default"))) PFNGLBINDBUFFERSRANGEPROC __glewBindBuffersRange;
extern __attribute__ ((visibility("default"))) PFNGLBINDIMAGETEXTURESPROC __glewBindImageTextures;
extern __attribute__ ((visibility("default"))) PFNGLBINDSAMPLERSPROC __glewBindSamplers;
extern __attribute__ ((visibility("default"))) PFNGLBINDTEXTURESPROC __glewBindTextures;
extern __attribute__ ((visibility("default"))) PFNGLBINDVERTEXBUFFERSPROC __glewBindVertexBuffers;

extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWARRAYSINDIRECTPROC __glewMultiDrawArraysIndirect;
extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWELEMENTSINDIRECTPROC __glewMultiDrawElementsIndirect;

extern __attribute__ ((visibility("default"))) PFNGLSAMPLECOVERAGEARBPROC __glewSampleCoverageARB;

extern __attribute__ ((visibility("default"))) PFNGLACTIVETEXTUREARBPROC __glewActiveTextureARB;
extern __attribute__ ((visibility("default"))) PFNGLCLIENTACTIVETEXTUREARBPROC __glewClientActiveTextureARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1DARBPROC __glewMultiTexCoord1dARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1DVARBPROC __glewMultiTexCoord1dvARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1FARBPROC __glewMultiTexCoord1fARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1FVARBPROC __glewMultiTexCoord1fvARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1IARBPROC __glewMultiTexCoord1iARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1IVARBPROC __glewMultiTexCoord1ivARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1SARBPROC __glewMultiTexCoord1sARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1SVARBPROC __glewMultiTexCoord1svARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2DARBPROC __glewMultiTexCoord2dARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2DVARBPROC __glewMultiTexCoord2dvARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2FARBPROC __glewMultiTexCoord2fARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2FVARBPROC __glewMultiTexCoord2fvARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2IARBPROC __glewMultiTexCoord2iARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2IVARBPROC __glewMultiTexCoord2ivARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2SARBPROC __glewMultiTexCoord2sARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2SVARBPROC __glewMultiTexCoord2svARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3DARBPROC __glewMultiTexCoord3dARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3DVARBPROC __glewMultiTexCoord3dvARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3FARBPROC __glewMultiTexCoord3fARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3FVARBPROC __glewMultiTexCoord3fvARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3IARBPROC __glewMultiTexCoord3iARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3IVARBPROC __glewMultiTexCoord3ivARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3SARBPROC __glewMultiTexCoord3sARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3SVARBPROC __glewMultiTexCoord3svARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4DARBPROC __glewMultiTexCoord4dARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4DVARBPROC __glewMultiTexCoord4dvARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4FARBPROC __glewMultiTexCoord4fARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4FVARBPROC __glewMultiTexCoord4fvARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4IARBPROC __glewMultiTexCoord4iARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4IVARBPROC __glewMultiTexCoord4ivARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4SARBPROC __glewMultiTexCoord4sARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4SVARBPROC __glewMultiTexCoord4svARB;

extern __attribute__ ((visibility("default"))) PFNGLBEGINQUERYARBPROC __glewBeginQueryARB;
extern __attribute__ ((visibility("default"))) PFNGLDELETEQUERIESARBPROC __glewDeleteQueriesARB;
extern __attribute__ ((visibility("default"))) PFNGLENDQUERYARBPROC __glewEndQueryARB;
extern __attribute__ ((visibility("default"))) PFNGLGENQUERIESARBPROC __glewGenQueriesARB;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYOBJECTIVARBPROC __glewGetQueryObjectivARB;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYOBJECTUIVARBPROC __glewGetQueryObjectuivARB;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYIVARBPROC __glewGetQueryivARB;
extern __attribute__ ((visibility("default"))) PFNGLISQUERYARBPROC __glewIsQueryARB;

extern __attribute__ ((visibility("default"))) PFNGLMAXSHADERCOMPILERTHREADSARBPROC __glewMaxShaderCompilerThreadsARB;

extern __attribute__ ((visibility("default"))) PFNGLPOINTPARAMETERFARBPROC __glewPointParameterfARB;
extern __attribute__ ((visibility("default"))) PFNGLPOINTPARAMETERFVARBPROC __glewPointParameterfvARB;

extern __attribute__ ((visibility("default"))) PFNGLPOLYGONOFFSETCLAMPPROC __glewPolygonOffsetClamp;

extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMINTERFACEIVPROC __glewGetProgramInterfaceiv;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMRESOURCEINDEXPROC __glewGetProgramResourceIndex;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMRESOURCELOCATIONPROC __glewGetProgramResourceLocation;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC __glewGetProgramResourceLocationIndex;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMRESOURCENAMEPROC __glewGetProgramResourceName;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMRESOURCEIVPROC __glewGetProgramResourceiv;

extern __attribute__ ((visibility("default"))) PFNGLPROVOKINGVERTEXPROC __glewProvokingVertex;

extern __attribute__ ((visibility("default"))) PFNGLGETGRAPHICSRESETSTATUSARBPROC __glewGetGraphicsResetStatusARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNCOLORTABLEARBPROC __glewGetnColorTableARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNCOMPRESSEDTEXIMAGEARBPROC __glewGetnCompressedTexImageARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNCONVOLUTIONFILTERARBPROC __glewGetnConvolutionFilterARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNHISTOGRAMARBPROC __glewGetnHistogramARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNMAPDVARBPROC __glewGetnMapdvARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNMAPFVARBPROC __glewGetnMapfvARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNMAPIVARBPROC __glewGetnMapivARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNMINMAXARBPROC __glewGetnMinmaxARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNPIXELMAPFVARBPROC __glewGetnPixelMapfvARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNPIXELMAPUIVARBPROC __glewGetnPixelMapuivARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNPIXELMAPUSVARBPROC __glewGetnPixelMapusvARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNPOLYGONSTIPPLEARBPROC __glewGetnPolygonStippleARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNSEPARABLEFILTERARBPROC __glewGetnSeparableFilterARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNTEXIMAGEARBPROC __glewGetnTexImageARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNUNIFORMDVARBPROC __glewGetnUniformdvARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNUNIFORMFVARBPROC __glewGetnUniformfvARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNUNIFORMIVARBPROC __glewGetnUniformivARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNUNIFORMUIVARBPROC __glewGetnUniformuivARB;
extern __attribute__ ((visibility("default"))) PFNGLREADNPIXELSARBPROC __glewReadnPixelsARB;

extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERSAMPLELOCATIONSFVARBPROC __glewFramebufferSampleLocationsfvARB;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVARBPROC __glewNamedFramebufferSampleLocationsfvARB;

extern __attribute__ ((visibility("default"))) PFNGLMINSAMPLESHADINGARBPROC __glewMinSampleShadingARB;

extern __attribute__ ((visibility("default"))) PFNGLBINDSAMPLERPROC __glewBindSampler;
extern __attribute__ ((visibility("default"))) PFNGLDELETESAMPLERSPROC __glewDeleteSamplers;
extern __attribute__ ((visibility("default"))) PFNGLGENSAMPLERSPROC __glewGenSamplers;
extern __attribute__ ((visibility("default"))) PFNGLGETSAMPLERPARAMETERIIVPROC __glewGetSamplerParameterIiv;
extern __attribute__ ((visibility("default"))) PFNGLGETSAMPLERPARAMETERIUIVPROC __glewGetSamplerParameterIuiv;
extern __attribute__ ((visibility("default"))) PFNGLGETSAMPLERPARAMETERFVPROC __glewGetSamplerParameterfv;
extern __attribute__ ((visibility("default"))) PFNGLGETSAMPLERPARAMETERIVPROC __glewGetSamplerParameteriv;
extern __attribute__ ((visibility("default"))) PFNGLISSAMPLERPROC __glewIsSampler;
extern __attribute__ ((visibility("default"))) PFNGLSAMPLERPARAMETERIIVPROC __glewSamplerParameterIiv;
extern __attribute__ ((visibility("default"))) PFNGLSAMPLERPARAMETERIUIVPROC __glewSamplerParameterIuiv;
extern __attribute__ ((visibility("default"))) PFNGLSAMPLERPARAMETERFPROC __glewSamplerParameterf;
extern __attribute__ ((visibility("default"))) PFNGLSAMPLERPARAMETERFVPROC __glewSamplerParameterfv;
extern __attribute__ ((visibility("default"))) PFNGLSAMPLERPARAMETERIPROC __glewSamplerParameteri;
extern __attribute__ ((visibility("default"))) PFNGLSAMPLERPARAMETERIVPROC __glewSamplerParameteriv;

extern __attribute__ ((visibility("default"))) PFNGLACTIVESHADERPROGRAMPROC __glewActiveShaderProgram;
extern __attribute__ ((visibility("default"))) PFNGLBINDPROGRAMPIPELINEPROC __glewBindProgramPipeline;
extern __attribute__ ((visibility("default"))) PFNGLCREATESHADERPROGRAMVPROC __glewCreateShaderProgramv;
extern __attribute__ ((visibility("default"))) PFNGLDELETEPROGRAMPIPELINESPROC __glewDeleteProgramPipelines;
extern __attribute__ ((visibility("default"))) PFNGLGENPROGRAMPIPELINESPROC __glewGenProgramPipelines;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMPIPELINEINFOLOGPROC __glewGetProgramPipelineInfoLog;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMPIPELINEIVPROC __glewGetProgramPipelineiv;
extern __attribute__ ((visibility("default"))) PFNGLISPROGRAMPIPELINEPROC __glewIsProgramPipeline;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1DPROC __glewProgramUniform1d;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1DVPROC __glewProgramUniform1dv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1FPROC __glewProgramUniform1f;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1FVPROC __glewProgramUniform1fv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1IPROC __glewProgramUniform1i;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1IVPROC __glewProgramUniform1iv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1UIPROC __glewProgramUniform1ui;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1UIVPROC __glewProgramUniform1uiv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2DPROC __glewProgramUniform2d;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2DVPROC __glewProgramUniform2dv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2FPROC __glewProgramUniform2f;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2FVPROC __glewProgramUniform2fv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2IPROC __glewProgramUniform2i;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2IVPROC __glewProgramUniform2iv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2UIPROC __glewProgramUniform2ui;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2UIVPROC __glewProgramUniform2uiv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3DPROC __glewProgramUniform3d;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3DVPROC __glewProgramUniform3dv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3FPROC __glewProgramUniform3f;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3FVPROC __glewProgramUniform3fv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3IPROC __glewProgramUniform3i;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3IVPROC __glewProgramUniform3iv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3UIPROC __glewProgramUniform3ui;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3UIVPROC __glewProgramUniform3uiv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4DPROC __glewProgramUniform4d;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4DVPROC __glewProgramUniform4dv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4FPROC __glewProgramUniform4f;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4FVPROC __glewProgramUniform4fv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4IPROC __glewProgramUniform4i;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4IVPROC __glewProgramUniform4iv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4UIPROC __glewProgramUniform4ui;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4UIVPROC __glewProgramUniform4uiv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX2DVPROC __glewProgramUniformMatrix2dv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX2FVPROC __glewProgramUniformMatrix2fv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC __glewProgramUniformMatrix2x3dv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC __glewProgramUniformMatrix2x3fv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC __glewProgramUniformMatrix2x4dv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC __glewProgramUniformMatrix2x4fv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX3DVPROC __glewProgramUniformMatrix3dv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX3FVPROC __glewProgramUniformMatrix3fv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC __glewProgramUniformMatrix3x2dv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC __glewProgramUniformMatrix3x2fv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC __glewProgramUniformMatrix3x4dv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC __glewProgramUniformMatrix3x4fv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX4DVPROC __glewProgramUniformMatrix4dv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX4FVPROC __glewProgramUniformMatrix4fv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC __glewProgramUniformMatrix4x2dv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC __glewProgramUniformMatrix4x2fv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC __glewProgramUniformMatrix4x3dv;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC __glewProgramUniformMatrix4x3fv;
extern __attribute__ ((visibility("default"))) PFNGLUSEPROGRAMSTAGESPROC __glewUseProgramStages;
extern __attribute__ ((visibility("default"))) PFNGLVALIDATEPROGRAMPIPELINEPROC __glewValidateProgramPipeline;

extern __attribute__ ((visibility("default"))) PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC __glewGetActiveAtomicCounterBufferiv;

extern __attribute__ ((visibility("default"))) PFNGLBINDIMAGETEXTUREPROC __glewBindImageTexture;
extern __attribute__ ((visibility("default"))) PFNGLMEMORYBARRIERPROC __glewMemoryBarrier;

extern __attribute__ ((visibility("default"))) PFNGLATTACHOBJECTARBPROC __glewAttachObjectARB;
extern __attribute__ ((visibility("default"))) PFNGLCOMPILESHADERARBPROC __glewCompileShaderARB;
extern __attribute__ ((visibility("default"))) PFNGLCREATEPROGRAMOBJECTARBPROC __glewCreateProgramObjectARB;
extern __attribute__ ((visibility("default"))) PFNGLCREATESHADEROBJECTARBPROC __glewCreateShaderObjectARB;
extern __attribute__ ((visibility("default"))) PFNGLDELETEOBJECTARBPROC __glewDeleteObjectARB;
extern __attribute__ ((visibility("default"))) PFNGLDETACHOBJECTARBPROC __glewDetachObjectARB;
extern __attribute__ ((visibility("default"))) PFNGLGETACTIVEUNIFORMARBPROC __glewGetActiveUniformARB;
extern __attribute__ ((visibility("default"))) PFNGLGETATTACHEDOBJECTSARBPROC __glewGetAttachedObjectsARB;
extern __attribute__ ((visibility("default"))) PFNGLGETHANDLEARBPROC __glewGetHandleARB;
extern __attribute__ ((visibility("default"))) PFNGLGETINFOLOGARBPROC __glewGetInfoLogARB;
extern __attribute__ ((visibility("default"))) PFNGLGETOBJECTPARAMETERFVARBPROC __glewGetObjectParameterfvARB;
extern __attribute__ ((visibility("default"))) PFNGLGETOBJECTPARAMETERIVARBPROC __glewGetObjectParameterivARB;
extern __attribute__ ((visibility("default"))) PFNGLGETSHADERSOURCEARBPROC __glewGetShaderSourceARB;
extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMLOCATIONARBPROC __glewGetUniformLocationARB;
extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMFVARBPROC __glewGetUniformfvARB;
extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMIVARBPROC __glewGetUniformivARB;
extern __attribute__ ((visibility("default"))) PFNGLLINKPROGRAMARBPROC __glewLinkProgramARB;
extern __attribute__ ((visibility("default"))) PFNGLSHADERSOURCEARBPROC __glewShaderSourceARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1FARBPROC __glewUniform1fARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1FVARBPROC __glewUniform1fvARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1IARBPROC __glewUniform1iARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1IVARBPROC __glewUniform1ivARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2FARBPROC __glewUniform2fARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2FVARBPROC __glewUniform2fvARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2IARBPROC __glewUniform2iARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2IVARBPROC __glewUniform2ivARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3FARBPROC __glewUniform3fARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3FVARBPROC __glewUniform3fvARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3IARBPROC __glewUniform3iARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3IVARBPROC __glewUniform3ivARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4FARBPROC __glewUniform4fARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4FVARBPROC __glewUniform4fvARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4IARBPROC __glewUniform4iARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4IVARBPROC __glewUniform4ivARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX2FVARBPROC __glewUniformMatrix2fvARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX3FVARBPROC __glewUniformMatrix3fvARB;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX4FVARBPROC __glewUniformMatrix4fvARB;
extern __attribute__ ((visibility("default"))) PFNGLUSEPROGRAMOBJECTARBPROC __glewUseProgramObjectARB;
extern __attribute__ ((visibility("default"))) PFNGLVALIDATEPROGRAMARBPROC __glewValidateProgramARB;

extern __attribute__ ((visibility("default"))) PFNGLSHADERSTORAGEBLOCKBINDINGPROC __glewShaderStorageBlockBinding;

extern __attribute__ ((visibility("default"))) PFNGLGETACTIVESUBROUTINENAMEPROC __glewGetActiveSubroutineName;
extern __attribute__ ((visibility("default"))) PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC __glewGetActiveSubroutineUniformName;
extern __attribute__ ((visibility("default"))) PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC __glewGetActiveSubroutineUniformiv;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMSTAGEIVPROC __glewGetProgramStageiv;
extern __attribute__ ((visibility("default"))) PFNGLGETSUBROUTINEINDEXPROC __glewGetSubroutineIndex;
extern __attribute__ ((visibility("default"))) PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC __glewGetSubroutineUniformLocation;
extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMSUBROUTINEUIVPROC __glewGetUniformSubroutineuiv;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMSUBROUTINESUIVPROC __glewUniformSubroutinesuiv;

extern __attribute__ ((visibility("default"))) PFNGLCOMPILESHADERINCLUDEARBPROC __glewCompileShaderIncludeARB;
extern __attribute__ ((visibility("default"))) PFNGLDELETENAMEDSTRINGARBPROC __glewDeleteNamedStringARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDSTRINGARBPROC __glewGetNamedStringARB;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDSTRINGIVARBPROC __glewGetNamedStringivARB;
extern __attribute__ ((visibility("default"))) PFNGLISNAMEDSTRINGARBPROC __glewIsNamedStringARB;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDSTRINGARBPROC __glewNamedStringARB;

extern __attribute__ ((visibility("default"))) PFNGLBUFFERPAGECOMMITMENTARBPROC __glewBufferPageCommitmentARB;

extern __attribute__ ((visibility("default"))) PFNGLTEXPAGECOMMITMENTARBPROC __glewTexPageCommitmentARB;

extern __attribute__ ((visibility("default"))) PFNGLCLIENTWAITSYNCPROC __glewClientWaitSync;
extern __attribute__ ((visibility("default"))) PFNGLDELETESYNCPROC __glewDeleteSync;
extern __attribute__ ((visibility("default"))) PFNGLFENCESYNCPROC __glewFenceSync;
extern __attribute__ ((visibility("default"))) PFNGLGETINTEGER64VPROC __glewGetInteger64v;
extern __attribute__ ((visibility("default"))) PFNGLGETSYNCIVPROC __glewGetSynciv;
extern __attribute__ ((visibility("default"))) PFNGLISSYNCPROC __glewIsSync;
extern __attribute__ ((visibility("default"))) PFNGLWAITSYNCPROC __glewWaitSync;

extern __attribute__ ((visibility("default"))) PFNGLPATCHPARAMETERFVPROC __glewPatchParameterfv;
extern __attribute__ ((visibility("default"))) PFNGLPATCHPARAMETERIPROC __glewPatchParameteri;

extern __attribute__ ((visibility("default"))) PFNGLTEXTUREBARRIERPROC __glewTextureBarrier;

extern __attribute__ ((visibility("default"))) PFNGLTEXBUFFERARBPROC __glewTexBufferARB;

extern __attribute__ ((visibility("default"))) PFNGLTEXBUFFERRANGEPROC __glewTexBufferRange;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREBUFFERRANGEEXTPROC __glewTextureBufferRangeEXT;

extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXIMAGE1DARBPROC __glewCompressedTexImage1DARB;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXIMAGE2DARBPROC __glewCompressedTexImage2DARB;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXIMAGE3DARBPROC __glewCompressedTexImage3DARB;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXSUBIMAGE1DARBPROC __glewCompressedTexSubImage1DARB;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXSUBIMAGE2DARBPROC __glewCompressedTexSubImage2DARB;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXSUBIMAGE3DARBPROC __glewCompressedTexSubImage3DARB;
extern __attribute__ ((visibility("default"))) PFNGLGETCOMPRESSEDTEXIMAGEARBPROC __glewGetCompressedTexImageARB;

extern __attribute__ ((visibility("default"))) PFNGLGETMULTISAMPLEFVPROC __glewGetMultisamplefv;
extern __attribute__ ((visibility("default"))) PFNGLSAMPLEMASKIPROC __glewSampleMaski;
extern __attribute__ ((visibility("default"))) PFNGLTEXIMAGE2DMULTISAMPLEPROC __glewTexImage2DMultisample;
extern __attribute__ ((visibility("default"))) PFNGLTEXIMAGE3DMULTISAMPLEPROC __glewTexImage3DMultisample;

extern __attribute__ ((visibility("default"))) PFNGLTEXSTORAGE1DPROC __glewTexStorage1D;
extern __attribute__ ((visibility("default"))) PFNGLTEXSTORAGE2DPROC __glewTexStorage2D;
extern __attribute__ ((visibility("default"))) PFNGLTEXSTORAGE3DPROC __glewTexStorage3D;

extern __attribute__ ((visibility("default"))) PFNGLTEXSTORAGE2DMULTISAMPLEPROC __glewTexStorage2DMultisample;
extern __attribute__ ((visibility("default"))) PFNGLTEXSTORAGE3DMULTISAMPLEPROC __glewTexStorage3DMultisample;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESTORAGE2DMULTISAMPLEEXTPROC __glewTextureStorage2DMultisampleEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESTORAGE3DMULTISAMPLEEXTPROC __glewTextureStorage3DMultisampleEXT;

extern __attribute__ ((visibility("default"))) PFNGLTEXTUREVIEWPROC __glewTextureView;

extern __attribute__ ((visibility("default"))) PFNGLGETQUERYOBJECTI64VPROC __glewGetQueryObjecti64v;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYOBJECTUI64VPROC __glewGetQueryObjectui64v;
extern __attribute__ ((visibility("default"))) PFNGLQUERYCOUNTERPROC __glewQueryCounter;

extern __attribute__ ((visibility("default"))) PFNGLBINDTRANSFORMFEEDBACKPROC __glewBindTransformFeedback;
extern __attribute__ ((visibility("default"))) PFNGLDELETETRANSFORMFEEDBACKSPROC __glewDeleteTransformFeedbacks;
extern __attribute__ ((visibility("default"))) PFNGLDRAWTRANSFORMFEEDBACKPROC __glewDrawTransformFeedback;
extern __attribute__ ((visibility("default"))) PFNGLGENTRANSFORMFEEDBACKSPROC __glewGenTransformFeedbacks;
extern __attribute__ ((visibility("default"))) PFNGLISTRANSFORMFEEDBACKPROC __glewIsTransformFeedback;
extern __attribute__ ((visibility("default"))) PFNGLPAUSETRANSFORMFEEDBACKPROC __glewPauseTransformFeedback;
extern __attribute__ ((visibility("default"))) PFNGLRESUMETRANSFORMFEEDBACKPROC __glewResumeTransformFeedback;

extern __attribute__ ((visibility("default"))) PFNGLBEGINQUERYINDEXEDPROC __glewBeginQueryIndexed;
extern __attribute__ ((visibility("default"))) PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC __glewDrawTransformFeedbackStream;
extern __attribute__ ((visibility("default"))) PFNGLENDQUERYINDEXEDPROC __glewEndQueryIndexed;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYINDEXEDIVPROC __glewGetQueryIndexediv;

extern __attribute__ ((visibility("default"))) PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC __glewDrawTransformFeedbackInstanced;
extern __attribute__ ((visibility("default"))) PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC __glewDrawTransformFeedbackStreamInstanced;

extern __attribute__ ((visibility("default"))) PFNGLLOADTRANSPOSEMATRIXDARBPROC __glewLoadTransposeMatrixdARB;
extern __attribute__ ((visibility("default"))) PFNGLLOADTRANSPOSEMATRIXFARBPROC __glewLoadTransposeMatrixfARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTTRANSPOSEMATRIXDARBPROC __glewMultTransposeMatrixdARB;
extern __attribute__ ((visibility("default"))) PFNGLMULTTRANSPOSEMATRIXFARBPROC __glewMultTransposeMatrixfARB;

extern __attribute__ ((visibility("default"))) PFNGLBINDBUFFERBASEPROC __glewBindBufferBase;
extern __attribute__ ((visibility("default"))) PFNGLBINDBUFFERRANGEPROC __glewBindBufferRange;
extern __attribute__ ((visibility("default"))) PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC __glewGetActiveUniformBlockName;
extern __attribute__ ((visibility("default"))) PFNGLGETACTIVEUNIFORMBLOCKIVPROC __glewGetActiveUniformBlockiv;
extern __attribute__ ((visibility("default"))) PFNGLGETACTIVEUNIFORMNAMEPROC __glewGetActiveUniformName;
extern __attribute__ ((visibility("default"))) PFNGLGETACTIVEUNIFORMSIVPROC __glewGetActiveUniformsiv;
extern __attribute__ ((visibility("default"))) PFNGLGETINTEGERI_VPROC __glewGetIntegeri_v;
extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMBLOCKINDEXPROC __glewGetUniformBlockIndex;
extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMINDICESPROC __glewGetUniformIndices;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMBLOCKBINDINGPROC __glewUniformBlockBinding;

extern __attribute__ ((visibility("default"))) PFNGLBINDVERTEXARRAYPROC __glewBindVertexArray;
extern __attribute__ ((visibility("default"))) PFNGLDELETEVERTEXARRAYSPROC __glewDeleteVertexArrays;
extern __attribute__ ((visibility("default"))) PFNGLGENVERTEXARRAYSPROC __glewGenVertexArrays;
extern __attribute__ ((visibility("default"))) PFNGLISVERTEXARRAYPROC __glewIsVertexArray;

extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBLDVPROC __glewGetVertexAttribLdv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL1DPROC __glewVertexAttribL1d;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL1DVPROC __glewVertexAttribL1dv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL2DPROC __glewVertexAttribL2d;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL2DVPROC __glewVertexAttribL2dv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL3DPROC __glewVertexAttribL3d;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL3DVPROC __glewVertexAttribL3dv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL4DPROC __glewVertexAttribL4d;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL4DVPROC __glewVertexAttribL4dv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBLPOINTERPROC __glewVertexAttribLPointer;

extern __attribute__ ((visibility("default"))) PFNGLBINDVERTEXBUFFERPROC __glewBindVertexBuffer;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYBINDVERTEXBUFFEREXTPROC __glewVertexArrayBindVertexBufferEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYVERTEXATTRIBBINDINGEXTPROC __glewVertexArrayVertexAttribBindingEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYVERTEXATTRIBFORMATEXTPROC __glewVertexArrayVertexAttribFormatEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYVERTEXATTRIBIFORMATEXTPROC __glewVertexArrayVertexAttribIFormatEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYVERTEXATTRIBLFORMATEXTPROC __glewVertexArrayVertexAttribLFormatEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYVERTEXBINDINGDIVISOREXTPROC __glewVertexArrayVertexBindingDivisorEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBBINDINGPROC __glewVertexAttribBinding;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBFORMATPROC __glewVertexAttribFormat;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBIFORMATPROC __glewVertexAttribIFormat;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBLFORMATPROC __glewVertexAttribLFormat;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXBINDINGDIVISORPROC __glewVertexBindingDivisor;

extern __attribute__ ((visibility("default"))) PFNGLVERTEXBLENDARBPROC __glewVertexBlendARB;
extern __attribute__ ((visibility("default"))) PFNGLWEIGHTPOINTERARBPROC __glewWeightPointerARB;
extern __attribute__ ((visibility("default"))) PFNGLWEIGHTBVARBPROC __glewWeightbvARB;
extern __attribute__ ((visibility("default"))) PFNGLWEIGHTDVARBPROC __glewWeightdvARB;
extern __attribute__ ((visibility("default"))) PFNGLWEIGHTFVARBPROC __glewWeightfvARB;
extern __attribute__ ((visibility("default"))) PFNGLWEIGHTIVARBPROC __glewWeightivARB;
extern __attribute__ ((visibility("default"))) PFNGLWEIGHTSVARBPROC __glewWeightsvARB;
extern __attribute__ ((visibility("default"))) PFNGLWEIGHTUBVARBPROC __glewWeightubvARB;
extern __attribute__ ((visibility("default"))) PFNGLWEIGHTUIVARBPROC __glewWeightuivARB;
extern __attribute__ ((visibility("default"))) PFNGLWEIGHTUSVARBPROC __glewWeightusvARB;

extern __attribute__ ((visibility("default"))) PFNGLBINDBUFFERARBPROC __glewBindBufferARB;
extern __attribute__ ((visibility("default"))) PFNGLBUFFERDATAARBPROC __glewBufferDataARB;
extern __attribute__ ((visibility("default"))) PFNGLBUFFERSUBDATAARBPROC __glewBufferSubDataARB;
extern __attribute__ ((visibility("default"))) PFNGLDELETEBUFFERSARBPROC __glewDeleteBuffersARB;
extern __attribute__ ((visibility("default"))) PFNGLGENBUFFERSARBPROC __glewGenBuffersARB;
extern __attribute__ ((visibility("default"))) PFNGLGETBUFFERPARAMETERIVARBPROC __glewGetBufferParameterivARB;
extern __attribute__ ((visibility("default"))) PFNGLGETBUFFERPOINTERVARBPROC __glewGetBufferPointervARB;
extern __attribute__ ((visibility("default"))) PFNGLGETBUFFERSUBDATAARBPROC __glewGetBufferSubDataARB;
extern __attribute__ ((visibility("default"))) PFNGLISBUFFERARBPROC __glewIsBufferARB;
extern __attribute__ ((visibility("default"))) PFNGLMAPBUFFERARBPROC __glewMapBufferARB;
extern __attribute__ ((visibility("default"))) PFNGLUNMAPBUFFERARBPROC __glewUnmapBufferARB;

extern __attribute__ ((visibility("default"))) PFNGLBINDPROGRAMARBPROC __glewBindProgramARB;
extern __attribute__ ((visibility("default"))) PFNGLDELETEPROGRAMSARBPROC __glewDeleteProgramsARB;
extern __attribute__ ((visibility("default"))) PFNGLDISABLEVERTEXATTRIBARRAYARBPROC __glewDisableVertexAttribArrayARB;
extern __attribute__ ((visibility("default"))) PFNGLENABLEVERTEXATTRIBARRAYARBPROC __glewEnableVertexAttribArrayARB;
extern __attribute__ ((visibility("default"))) PFNGLGENPROGRAMSARBPROC __glewGenProgramsARB;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMENVPARAMETERDVARBPROC __glewGetProgramEnvParameterdvARB;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMENVPARAMETERFVARBPROC __glewGetProgramEnvParameterfvARB;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMLOCALPARAMETERDVARBPROC __glewGetProgramLocalParameterdvARB;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMLOCALPARAMETERFVARBPROC __glewGetProgramLocalParameterfvARB;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMSTRINGARBPROC __glewGetProgramStringARB;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMIVARBPROC __glewGetProgramivARB;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBPOINTERVARBPROC __glewGetVertexAttribPointervARB;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBDVARBPROC __glewGetVertexAttribdvARB;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBFVARBPROC __glewGetVertexAttribfvARB;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBIVARBPROC __glewGetVertexAttribivARB;
extern __attribute__ ((visibility("default"))) PFNGLISPROGRAMARBPROC __glewIsProgramARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMENVPARAMETER4DARBPROC __glewProgramEnvParameter4dARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMENVPARAMETER4DVARBPROC __glewProgramEnvParameter4dvARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMENVPARAMETER4FARBPROC __glewProgramEnvParameter4fARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMENVPARAMETER4FVARBPROC __glewProgramEnvParameter4fvARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMLOCALPARAMETER4DARBPROC __glewProgramLocalParameter4dARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMLOCALPARAMETER4DVARBPROC __glewProgramLocalParameter4dvARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMLOCALPARAMETER4FARBPROC __glewProgramLocalParameter4fARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMLOCALPARAMETER4FVARBPROC __glewProgramLocalParameter4fvARB;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMSTRINGARBPROC __glewProgramStringARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1DARBPROC __glewVertexAttrib1dARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1DVARBPROC __glewVertexAttrib1dvARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1FARBPROC __glewVertexAttrib1fARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1FVARBPROC __glewVertexAttrib1fvARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1SARBPROC __glewVertexAttrib1sARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1SVARBPROC __glewVertexAttrib1svARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2DARBPROC __glewVertexAttrib2dARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2DVARBPROC __glewVertexAttrib2dvARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2FARBPROC __glewVertexAttrib2fARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2FVARBPROC __glewVertexAttrib2fvARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2SARBPROC __glewVertexAttrib2sARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2SVARBPROC __glewVertexAttrib2svARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3DARBPROC __glewVertexAttrib3dARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3DVARBPROC __glewVertexAttrib3dvARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3FARBPROC __glewVertexAttrib3fARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3FVARBPROC __glewVertexAttrib3fvARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3SARBPROC __glewVertexAttrib3sARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3SVARBPROC __glewVertexAttrib3svARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4NBVARBPROC __glewVertexAttrib4NbvARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4NIVARBPROC __glewVertexAttrib4NivARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4NSVARBPROC __glewVertexAttrib4NsvARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4NUBARBPROC __glewVertexAttrib4NubARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4NUBVARBPROC __glewVertexAttrib4NubvARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4NUIVARBPROC __glewVertexAttrib4NuivARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4NUSVARBPROC __glewVertexAttrib4NusvARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4BVARBPROC __glewVertexAttrib4bvARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4DARBPROC __glewVertexAttrib4dARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4DVARBPROC __glewVertexAttrib4dvARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4FARBPROC __glewVertexAttrib4fARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4FVARBPROC __glewVertexAttrib4fvARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4IVARBPROC __glewVertexAttrib4ivARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4SARBPROC __glewVertexAttrib4sARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4SVARBPROC __glewVertexAttrib4svARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4UBVARBPROC __glewVertexAttrib4ubvARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4UIVARBPROC __glewVertexAttrib4uivARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4USVARBPROC __glewVertexAttrib4usvARB;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBPOINTERARBPROC __glewVertexAttribPointerARB;

extern __attribute__ ((visibility("default"))) PFNGLBINDATTRIBLOCATIONARBPROC __glewBindAttribLocationARB;
extern __attribute__ ((visibility("default"))) PFNGLGETACTIVEATTRIBARBPROC __glewGetActiveAttribARB;
extern __attribute__ ((visibility("default"))) PFNGLGETATTRIBLOCATIONARBPROC __glewGetAttribLocationARB;

extern __attribute__ ((visibility("default"))) PFNGLCOLORP3UIPROC __glewColorP3ui;
extern __attribute__ ((visibility("default"))) PFNGLCOLORP3UIVPROC __glewColorP3uiv;
extern __attribute__ ((visibility("default"))) PFNGLCOLORP4UIPROC __glewColorP4ui;
extern __attribute__ ((visibility("default"))) PFNGLCOLORP4UIVPROC __glewColorP4uiv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORDP1UIPROC __glewMultiTexCoordP1ui;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORDP1UIVPROC __glewMultiTexCoordP1uiv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORDP2UIPROC __glewMultiTexCoordP2ui;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORDP2UIVPROC __glewMultiTexCoordP2uiv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORDP3UIPROC __glewMultiTexCoordP3ui;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORDP3UIVPROC __glewMultiTexCoordP3uiv;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORDP4UIPROC __glewMultiTexCoordP4ui;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORDP4UIVPROC __glewMultiTexCoordP4uiv;
extern __attribute__ ((visibility("default"))) PFNGLNORMALP3UIPROC __glewNormalP3ui;
extern __attribute__ ((visibility("default"))) PFNGLNORMALP3UIVPROC __glewNormalP3uiv;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLORP3UIPROC __glewSecondaryColorP3ui;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLORP3UIVPROC __glewSecondaryColorP3uiv;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORDP1UIPROC __glewTexCoordP1ui;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORDP1UIVPROC __glewTexCoordP1uiv;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORDP2UIPROC __glewTexCoordP2ui;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORDP2UIVPROC __glewTexCoordP2uiv;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORDP3UIPROC __glewTexCoordP3ui;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORDP3UIVPROC __glewTexCoordP3uiv;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORDP4UIPROC __glewTexCoordP4ui;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORDP4UIVPROC __glewTexCoordP4uiv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBP1UIPROC __glewVertexAttribP1ui;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBP1UIVPROC __glewVertexAttribP1uiv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBP2UIPROC __glewVertexAttribP2ui;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBP2UIVPROC __glewVertexAttribP2uiv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBP3UIPROC __glewVertexAttribP3ui;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBP3UIVPROC __glewVertexAttribP3uiv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBP4UIPROC __glewVertexAttribP4ui;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBP4UIVPROC __glewVertexAttribP4uiv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXP2UIPROC __glewVertexP2ui;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXP2UIVPROC __glewVertexP2uiv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXP3UIPROC __glewVertexP3ui;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXP3UIVPROC __glewVertexP3uiv;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXP4UIPROC __glewVertexP4ui;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXP4UIVPROC __glewVertexP4uiv;

extern __attribute__ ((visibility("default"))) PFNGLDEPTHRANGEARRAYVPROC __glewDepthRangeArrayv;
extern __attribute__ ((visibility("default"))) PFNGLDEPTHRANGEINDEXEDPROC __glewDepthRangeIndexed;
extern __attribute__ ((visibility("default"))) PFNGLGETDOUBLEI_VPROC __glewGetDoublei_v;
extern __attribute__ ((visibility("default"))) PFNGLGETFLOATI_VPROC __glewGetFloati_v;
extern __attribute__ ((visibility("default"))) PFNGLSCISSORARRAYVPROC __glewScissorArrayv;
extern __attribute__ ((visibility("default"))) PFNGLSCISSORINDEXEDPROC __glewScissorIndexed;
extern __attribute__ ((visibility("default"))) PFNGLSCISSORINDEXEDVPROC __glewScissorIndexedv;
extern __attribute__ ((visibility("default"))) PFNGLVIEWPORTARRAYVPROC __glewViewportArrayv;
extern __attribute__ ((visibility("default"))) PFNGLVIEWPORTINDEXEDFPROC __glewViewportIndexedf;
extern __attribute__ ((visibility("default"))) PFNGLVIEWPORTINDEXEDFVPROC __glewViewportIndexedfv;

extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2DARBPROC __glewWindowPos2dARB;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2DVARBPROC __glewWindowPos2dvARB;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2FARBPROC __glewWindowPos2fARB;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2FVARBPROC __glewWindowPos2fvARB;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2IARBPROC __glewWindowPos2iARB;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2IVARBPROC __glewWindowPos2ivARB;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2SARBPROC __glewWindowPos2sARB;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2SVARBPROC __glewWindowPos2svARB;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3DARBPROC __glewWindowPos3dARB;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3DVARBPROC __glewWindowPos3dvARB;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3FARBPROC __glewWindowPos3fARB;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3FVARBPROC __glewWindowPos3fvARB;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3IARBPROC __glewWindowPos3iARB;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3IVARBPROC __glewWindowPos3ivARB;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3SARBPROC __glewWindowPos3sARB;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3SVARBPROC __glewWindowPos3svARB;

extern __attribute__ ((visibility("default"))) PFNGLDRAWBUFFERSATIPROC __glewDrawBuffersATI;

extern __attribute__ ((visibility("default"))) PFNGLDRAWELEMENTARRAYATIPROC __glewDrawElementArrayATI;
extern __attribute__ ((visibility("default"))) PFNGLDRAWRANGEELEMENTARRAYATIPROC __glewDrawRangeElementArrayATI;
extern __attribute__ ((visibility("default"))) PFNGLELEMENTPOINTERATIPROC __glewElementPointerATI;

extern __attribute__ ((visibility("default"))) PFNGLGETTEXBUMPPARAMETERFVATIPROC __glewGetTexBumpParameterfvATI;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXBUMPPARAMETERIVATIPROC __glewGetTexBumpParameterivATI;
extern __attribute__ ((visibility("default"))) PFNGLTEXBUMPPARAMETERFVATIPROC __glewTexBumpParameterfvATI;
extern __attribute__ ((visibility("default"))) PFNGLTEXBUMPPARAMETERIVATIPROC __glewTexBumpParameterivATI;

extern __attribute__ ((visibility("default"))) PFNGLALPHAFRAGMENTOP1ATIPROC __glewAlphaFragmentOp1ATI;
extern __attribute__ ((visibility("default"))) PFNGLALPHAFRAGMENTOP2ATIPROC __glewAlphaFragmentOp2ATI;
extern __attribute__ ((visibility("default"))) PFNGLALPHAFRAGMENTOP3ATIPROC __glewAlphaFragmentOp3ATI;
extern __attribute__ ((visibility("default"))) PFNGLBEGINFRAGMENTSHADERATIPROC __glewBeginFragmentShaderATI;
extern __attribute__ ((visibility("default"))) PFNGLBINDFRAGMENTSHADERATIPROC __glewBindFragmentShaderATI;
extern __attribute__ ((visibility("default"))) PFNGLCOLORFRAGMENTOP1ATIPROC __glewColorFragmentOp1ATI;
extern __attribute__ ((visibility("default"))) PFNGLCOLORFRAGMENTOP2ATIPROC __glewColorFragmentOp2ATI;
extern __attribute__ ((visibility("default"))) PFNGLCOLORFRAGMENTOP3ATIPROC __glewColorFragmentOp3ATI;
extern __attribute__ ((visibility("default"))) PFNGLDELETEFRAGMENTSHADERATIPROC __glewDeleteFragmentShaderATI;
extern __attribute__ ((visibility("default"))) PFNGLENDFRAGMENTSHADERATIPROC __glewEndFragmentShaderATI;
extern __attribute__ ((visibility("default"))) PFNGLGENFRAGMENTSHADERSATIPROC __glewGenFragmentShadersATI;
extern __attribute__ ((visibility("default"))) PFNGLPASSTEXCOORDATIPROC __glewPassTexCoordATI;
extern __attribute__ ((visibility("default"))) PFNGLSAMPLEMAPATIPROC __glewSampleMapATI;
extern __attribute__ ((visibility("default"))) PFNGLSETFRAGMENTSHADERCONSTANTATIPROC __glewSetFragmentShaderConstantATI;

extern __attribute__ ((visibility("default"))) PFNGLMAPOBJECTBUFFERATIPROC __glewMapObjectBufferATI;
extern __attribute__ ((visibility("default"))) PFNGLUNMAPOBJECTBUFFERATIPROC __glewUnmapObjectBufferATI;

extern __attribute__ ((visibility("default"))) PFNGLPNTRIANGLESFATIPROC __glewPNTrianglesfATI;
extern __attribute__ ((visibility("default"))) PFNGLPNTRIANGLESIATIPROC __glewPNTrianglesiATI;

extern __attribute__ ((visibility("default"))) PFNGLSTENCILFUNCSEPARATEATIPROC __glewStencilFuncSeparateATI;
extern __attribute__ ((visibility("default"))) PFNGLSTENCILOPSEPARATEATIPROC __glewStencilOpSeparateATI;

extern __attribute__ ((visibility("default"))) PFNGLARRAYOBJECTATIPROC __glewArrayObjectATI;
extern __attribute__ ((visibility("default"))) PFNGLFREEOBJECTBUFFERATIPROC __glewFreeObjectBufferATI;
extern __attribute__ ((visibility("default"))) PFNGLGETARRAYOBJECTFVATIPROC __glewGetArrayObjectfvATI;
extern __attribute__ ((visibility("default"))) PFNGLGETARRAYOBJECTIVATIPROC __glewGetArrayObjectivATI;
extern __attribute__ ((visibility("default"))) PFNGLGETOBJECTBUFFERFVATIPROC __glewGetObjectBufferfvATI;
extern __attribute__ ((visibility("default"))) PFNGLGETOBJECTBUFFERIVATIPROC __glewGetObjectBufferivATI;
extern __attribute__ ((visibility("default"))) PFNGLGETVARIANTARRAYOBJECTFVATIPROC __glewGetVariantArrayObjectfvATI;
extern __attribute__ ((visibility("default"))) PFNGLGETVARIANTARRAYOBJECTIVATIPROC __glewGetVariantArrayObjectivATI;
extern __attribute__ ((visibility("default"))) PFNGLISOBJECTBUFFERATIPROC __glewIsObjectBufferATI;
extern __attribute__ ((visibility("default"))) PFNGLNEWOBJECTBUFFERATIPROC __glewNewObjectBufferATI;
extern __attribute__ ((visibility("default"))) PFNGLUPDATEOBJECTBUFFERATIPROC __glewUpdateObjectBufferATI;
extern __attribute__ ((visibility("default"))) PFNGLVARIANTARRAYOBJECTATIPROC __glewVariantArrayObjectATI;

extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBARRAYOBJECTFVATIPROC __glewGetVertexAttribArrayObjectfvATI;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBARRAYOBJECTIVATIPROC __glewGetVertexAttribArrayObjectivATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBARRAYOBJECTATIPROC __glewVertexAttribArrayObjectATI;

extern __attribute__ ((visibility("default"))) PFNGLCLIENTACTIVEVERTEXSTREAMATIPROC __glewClientActiveVertexStreamATI;
extern __attribute__ ((visibility("default"))) PFNGLNORMALSTREAM3BATIPROC __glewNormalStream3bATI;
extern __attribute__ ((visibility("default"))) PFNGLNORMALSTREAM3BVATIPROC __glewNormalStream3bvATI;
extern __attribute__ ((visibility("default"))) PFNGLNORMALSTREAM3DATIPROC __glewNormalStream3dATI;
extern __attribute__ ((visibility("default"))) PFNGLNORMALSTREAM3DVATIPROC __glewNormalStream3dvATI;
extern __attribute__ ((visibility("default"))) PFNGLNORMALSTREAM3FATIPROC __glewNormalStream3fATI;
extern __attribute__ ((visibility("default"))) PFNGLNORMALSTREAM3FVATIPROC __glewNormalStream3fvATI;
extern __attribute__ ((visibility("default"))) PFNGLNORMALSTREAM3IATIPROC __glewNormalStream3iATI;
extern __attribute__ ((visibility("default"))) PFNGLNORMALSTREAM3IVATIPROC __glewNormalStream3ivATI;
extern __attribute__ ((visibility("default"))) PFNGLNORMALSTREAM3SATIPROC __glewNormalStream3sATI;
extern __attribute__ ((visibility("default"))) PFNGLNORMALSTREAM3SVATIPROC __glewNormalStream3svATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXBLENDENVFATIPROC __glewVertexBlendEnvfATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXBLENDENVIATIPROC __glewVertexBlendEnviATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM1DATIPROC __glewVertexStream1dATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM1DVATIPROC __glewVertexStream1dvATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM1FATIPROC __glewVertexStream1fATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM1FVATIPROC __glewVertexStream1fvATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM1IATIPROC __glewVertexStream1iATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM1IVATIPROC __glewVertexStream1ivATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM1SATIPROC __glewVertexStream1sATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM1SVATIPROC __glewVertexStream1svATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM2DATIPROC __glewVertexStream2dATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM2DVATIPROC __glewVertexStream2dvATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM2FATIPROC __glewVertexStream2fATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM2FVATIPROC __glewVertexStream2fvATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM2IATIPROC __glewVertexStream2iATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM2IVATIPROC __glewVertexStream2ivATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM2SATIPROC __glewVertexStream2sATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM2SVATIPROC __glewVertexStream2svATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM3DATIPROC __glewVertexStream3dATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM3DVATIPROC __glewVertexStream3dvATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM3FATIPROC __glewVertexStream3fATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM3FVATIPROC __glewVertexStream3fvATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM3IATIPROC __glewVertexStream3iATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM3IVATIPROC __glewVertexStream3ivATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM3SATIPROC __glewVertexStream3sATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM3SVATIPROC __glewVertexStream3svATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM4DATIPROC __glewVertexStream4dATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM4DVATIPROC __glewVertexStream4dvATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM4FATIPROC __glewVertexStream4fATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM4FVATIPROC __glewVertexStream4fvATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM4IATIPROC __glewVertexStream4iATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM4IVATIPROC __glewVertexStream4ivATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM4SATIPROC __glewVertexStream4sATI;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXSTREAM4SVATIPROC __glewVertexStream4svATI;

extern __attribute__ ((visibility("default"))) PFNGLEGLIMAGETARGETTEXSTORAGEEXTPROC __glewEGLImageTargetTexStorageEXT;
extern __attribute__ ((visibility("default"))) PFNGLEGLIMAGETARGETTEXTURESTORAGEEXTPROC __glewEGLImageTargetTextureStorageEXT;

extern __attribute__ ((visibility("default"))) PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEEXTPROC __glewDrawArraysInstancedBaseInstanceEXT;
extern __attribute__ ((visibility("default"))) PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEEXTPROC __glewDrawElementsInstancedBaseInstanceEXT;
extern __attribute__ ((visibility("default"))) PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEEXTPROC __glewDrawElementsInstancedBaseVertexBaseInstanceEXT;

extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMBUFFERSIZEEXTPROC __glewGetUniformBufferSizeEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMOFFSETEXTPROC __glewGetUniformOffsetEXT;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMBUFFEREXTPROC __glewUniformBufferEXT;

extern __attribute__ ((visibility("default"))) PFNGLBLENDCOLOREXTPROC __glewBlendColorEXT;

extern __attribute__ ((visibility("default"))) PFNGLBLENDEQUATIONSEPARATEEXTPROC __glewBlendEquationSeparateEXT;

extern __attribute__ ((visibility("default"))) PFNGLBINDFRAGDATALOCATIONINDEXEDEXTPROC __glewBindFragDataLocationIndexedEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAGDATAINDEXEXTPROC __glewGetFragDataIndexEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMRESOURCELOCATIONINDEXEXTPROC __glewGetProgramResourceLocationIndexEXT;

extern __attribute__ ((visibility("default"))) PFNGLBLENDFUNCSEPARATEEXTPROC __glewBlendFuncSeparateEXT;

extern __attribute__ ((visibility("default"))) PFNGLBLENDEQUATIONEXTPROC __glewBlendEquationEXT;

extern __attribute__ ((visibility("default"))) PFNGLBUFFERSTORAGEEXTPROC __glewBufferStorageEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDBUFFERSTORAGEEXTPROC __glewNamedBufferStorageEXT;

extern __attribute__ ((visibility("default"))) PFNGLCLEARTEXIMAGEEXTPROC __glewClearTexImageEXT;
extern __attribute__ ((visibility("default"))) PFNGLCLEARTEXSUBIMAGEEXTPROC __glewClearTexSubImageEXT;

extern __attribute__ ((visibility("default"))) PFNGLCLIPCONTROLEXTPROC __glewClipControlEXT;

extern __attribute__ ((visibility("default"))) PFNGLCOLORSUBTABLEEXTPROC __glewColorSubTableEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYCOLORSUBTABLEEXTPROC __glewCopyColorSubTableEXT;

extern __attribute__ ((visibility("default"))) PFNGLLOCKARRAYSEXTPROC __glewLockArraysEXT;
extern __attribute__ ((visibility("default"))) PFNGLUNLOCKARRAYSEXTPROC __glewUnlockArraysEXT;

extern __attribute__ ((visibility("default"))) PFNGLCONVOLUTIONFILTER1DEXTPROC __glewConvolutionFilter1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCONVOLUTIONFILTER2DEXTPROC __glewConvolutionFilter2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCONVOLUTIONPARAMETERFEXTPROC __glewConvolutionParameterfEXT;
extern __attribute__ ((visibility("default"))) PFNGLCONVOLUTIONPARAMETERFVEXTPROC __glewConvolutionParameterfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLCONVOLUTIONPARAMETERIEXTPROC __glewConvolutionParameteriEXT;
extern __attribute__ ((visibility("default"))) PFNGLCONVOLUTIONPARAMETERIVEXTPROC __glewConvolutionParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYCONVOLUTIONFILTER1DEXTPROC __glewCopyConvolutionFilter1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYCONVOLUTIONFILTER2DEXTPROC __glewCopyConvolutionFilter2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETCONVOLUTIONFILTEREXTPROC __glewGetConvolutionFilterEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETCONVOLUTIONPARAMETERFVEXTPROC __glewGetConvolutionParameterfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETCONVOLUTIONPARAMETERIVEXTPROC __glewGetConvolutionParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETSEPARABLEFILTEREXTPROC __glewGetSeparableFilterEXT;
extern __attribute__ ((visibility("default"))) PFNGLSEPARABLEFILTER2DEXTPROC __glewSeparableFilter2DEXT;

extern __attribute__ ((visibility("default"))) PFNGLBINORMALPOINTEREXTPROC __glewBinormalPointerEXT;
extern __attribute__ ((visibility("default"))) PFNGLTANGENTPOINTEREXTPROC __glewTangentPointerEXT;

extern __attribute__ ((visibility("default"))) PFNGLCOPYIMAGESUBDATAEXTPROC __glewCopyImageSubDataEXT;

extern __attribute__ ((visibility("default"))) PFNGLCOPYTEXIMAGE1DEXTPROC __glewCopyTexImage1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYTEXIMAGE2DEXTPROC __glewCopyTexImage2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYTEXSUBIMAGE1DEXTPROC __glewCopyTexSubImage1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYTEXSUBIMAGE2DEXTPROC __glewCopyTexSubImage2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYTEXSUBIMAGE3DEXTPROC __glewCopyTexSubImage3DEXT;

extern __attribute__ ((visibility("default"))) PFNGLCULLPARAMETERDVEXTPROC __glewCullParameterdvEXT;
extern __attribute__ ((visibility("default"))) PFNGLCULLPARAMETERFVEXTPROC __glewCullParameterfvEXT;

extern __attribute__ ((visibility("default"))) PFNGLGETOBJECTLABELEXTPROC __glewGetObjectLabelEXT;
extern __attribute__ ((visibility("default"))) PFNGLLABELOBJECTEXTPROC __glewLabelObjectEXT;

extern __attribute__ ((visibility("default"))) PFNGLINSERTEVENTMARKEREXTPROC __glewInsertEventMarkerEXT;
extern __attribute__ ((visibility("default"))) PFNGLPOPGROUPMARKEREXTPROC __glewPopGroupMarkerEXT;
extern __attribute__ ((visibility("default"))) PFNGLPUSHGROUPMARKEREXTPROC __glewPushGroupMarkerEXT;

extern __attribute__ ((visibility("default"))) PFNGLDEPTHBOUNDSEXTPROC __glewDepthBoundsEXT;

extern __attribute__ ((visibility("default"))) PFNGLBINDMULTITEXTUREEXTPROC __glewBindMultiTextureEXT;
extern __attribute__ ((visibility("default"))) PFNGLCHECKNAMEDFRAMEBUFFERSTATUSEXTPROC __glewCheckNamedFramebufferStatusEXT;
extern __attribute__ ((visibility("default"))) PFNGLCLIENTATTRIBDEFAULTEXTPROC __glewClientAttribDefaultEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDMULTITEXIMAGE1DEXTPROC __glewCompressedMultiTexImage1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDMULTITEXIMAGE2DEXTPROC __glewCompressedMultiTexImage2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDMULTITEXIMAGE3DEXTPROC __glewCompressedMultiTexImage3DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDMULTITEXSUBIMAGE1DEXTPROC __glewCompressedMultiTexSubImage1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDMULTITEXSUBIMAGE2DEXTPROC __glewCompressedMultiTexSubImage2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDMULTITEXSUBIMAGE3DEXTPROC __glewCompressedMultiTexSubImage3DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXTUREIMAGE1DEXTPROC __glewCompressedTextureImage1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXTUREIMAGE2DEXTPROC __glewCompressedTextureImage2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXTUREIMAGE3DEXTPROC __glewCompressedTextureImage3DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXTURESUBIMAGE1DEXTPROC __glewCompressedTextureSubImage1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXTURESUBIMAGE2DEXTPROC __glewCompressedTextureSubImage2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXTURESUBIMAGE3DEXTPROC __glewCompressedTextureSubImage3DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYMULTITEXIMAGE1DEXTPROC __glewCopyMultiTexImage1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYMULTITEXIMAGE2DEXTPROC __glewCopyMultiTexImage2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYMULTITEXSUBIMAGE1DEXTPROC __glewCopyMultiTexSubImage1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYMULTITEXSUBIMAGE2DEXTPROC __glewCopyMultiTexSubImage2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYMULTITEXSUBIMAGE3DEXTPROC __glewCopyMultiTexSubImage3DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYTEXTUREIMAGE1DEXTPROC __glewCopyTextureImage1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYTEXTUREIMAGE2DEXTPROC __glewCopyTextureImage2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYTEXTURESUBIMAGE1DEXTPROC __glewCopyTextureSubImage1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYTEXTURESUBIMAGE2DEXTPROC __glewCopyTextureSubImage2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOPYTEXTURESUBIMAGE3DEXTPROC __glewCopyTextureSubImage3DEXT;
extern __attribute__ ((visibility("default"))) PFNGLDISABLECLIENTSTATEINDEXEDEXTPROC __glewDisableClientStateIndexedEXT;
extern __attribute__ ((visibility("default"))) PFNGLDISABLECLIENTSTATEIEXTPROC __glewDisableClientStateiEXT;
extern __attribute__ ((visibility("default"))) PFNGLDISABLEVERTEXARRAYATTRIBEXTPROC __glewDisableVertexArrayAttribEXT;
extern __attribute__ ((visibility("default"))) PFNGLDISABLEVERTEXARRAYEXTPROC __glewDisableVertexArrayEXT;
extern __attribute__ ((visibility("default"))) PFNGLENABLECLIENTSTATEINDEXEDEXTPROC __glewEnableClientStateIndexedEXT;
extern __attribute__ ((visibility("default"))) PFNGLENABLECLIENTSTATEIEXTPROC __glewEnableClientStateiEXT;
extern __attribute__ ((visibility("default"))) PFNGLENABLEVERTEXARRAYATTRIBEXTPROC __glewEnableVertexArrayAttribEXT;
extern __attribute__ ((visibility("default"))) PFNGLENABLEVERTEXARRAYEXTPROC __glewEnableVertexArrayEXT;
extern __attribute__ ((visibility("default"))) PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEEXTPROC __glewFlushMappedNamedBufferRangeEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERDRAWBUFFEREXTPROC __glewFramebufferDrawBufferEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERDRAWBUFFERSEXTPROC __glewFramebufferDrawBuffersEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERREADBUFFEREXTPROC __glewFramebufferReadBufferEXT;
extern __attribute__ ((visibility("default"))) PFNGLGENERATEMULTITEXMIPMAPEXTPROC __glewGenerateMultiTexMipmapEXT;
extern __attribute__ ((visibility("default"))) PFNGLGENERATETEXTUREMIPMAPEXTPROC __glewGenerateTextureMipmapEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETCOMPRESSEDMULTITEXIMAGEEXTPROC __glewGetCompressedMultiTexImageEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETCOMPRESSEDTEXTUREIMAGEEXTPROC __glewGetCompressedTextureImageEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETDOUBLEINDEXEDVEXTPROC __glewGetDoubleIndexedvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETDOUBLEI_VEXTPROC __glewGetDoublei_vEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETFLOATINDEXEDVEXTPROC __glewGetFloatIndexedvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETFLOATI_VEXTPROC __glewGetFloati_vEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAMEBUFFERPARAMETERIVEXTPROC __glewGetFramebufferParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETMULTITEXENVFVEXTPROC __glewGetMultiTexEnvfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETMULTITEXENVIVEXTPROC __glewGetMultiTexEnvivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETMULTITEXGENDVEXTPROC __glewGetMultiTexGendvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETMULTITEXGENFVEXTPROC __glewGetMultiTexGenfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETMULTITEXGENIVEXTPROC __glewGetMultiTexGenivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETMULTITEXIMAGEEXTPROC __glewGetMultiTexImageEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETMULTITEXLEVELPARAMETERFVEXTPROC __glewGetMultiTexLevelParameterfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETMULTITEXLEVELPARAMETERIVEXTPROC __glewGetMultiTexLevelParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETMULTITEXPARAMETERIIVEXTPROC __glewGetMultiTexParameterIivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETMULTITEXPARAMETERIUIVEXTPROC __glewGetMultiTexParameterIuivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETMULTITEXPARAMETERFVEXTPROC __glewGetMultiTexParameterfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETMULTITEXPARAMETERIVEXTPROC __glewGetMultiTexParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDBUFFERPARAMETERIVEXTPROC __glewGetNamedBufferParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDBUFFERPOINTERVEXTPROC __glewGetNamedBufferPointervEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDBUFFERSUBDATAEXTPROC __glewGetNamedBufferSubDataEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC __glewGetNamedFramebufferAttachmentParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDPROGRAMLOCALPARAMETERIIVEXTPROC __glewGetNamedProgramLocalParameterIivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDPROGRAMLOCALPARAMETERIUIVEXTPROC __glewGetNamedProgramLocalParameterIuivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDPROGRAMLOCALPARAMETERDVEXTPROC __glewGetNamedProgramLocalParameterdvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDPROGRAMLOCALPARAMETERFVEXTPROC __glewGetNamedProgramLocalParameterfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDPROGRAMSTRINGEXTPROC __glewGetNamedProgramStringEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDPROGRAMIVEXTPROC __glewGetNamedProgramivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDRENDERBUFFERPARAMETERIVEXTPROC __glewGetNamedRenderbufferParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETPOINTERINDEXEDVEXTPROC __glewGetPointerIndexedvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETPOINTERI_VEXTPROC __glewGetPointeri_vEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTUREIMAGEEXTPROC __glewGetTextureImageEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTURELEVELPARAMETERFVEXTPROC __glewGetTextureLevelParameterfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTURELEVELPARAMETERIVEXTPROC __glewGetTextureLevelParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTUREPARAMETERIIVEXTPROC __glewGetTextureParameterIivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTUREPARAMETERIUIVEXTPROC __glewGetTextureParameterIuivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTUREPARAMETERFVEXTPROC __glewGetTextureParameterfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTUREPARAMETERIVEXTPROC __glewGetTextureParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXARRAYINTEGERI_VEXTPROC __glewGetVertexArrayIntegeri_vEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXARRAYINTEGERVEXTPROC __glewGetVertexArrayIntegervEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXARRAYPOINTERI_VEXTPROC __glewGetVertexArrayPointeri_vEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXARRAYPOINTERVEXTPROC __glewGetVertexArrayPointervEXT;
extern __attribute__ ((visibility("default"))) PFNGLMAPNAMEDBUFFEREXTPROC __glewMapNamedBufferEXT;
extern __attribute__ ((visibility("default"))) PFNGLMAPNAMEDBUFFERRANGEEXTPROC __glewMapNamedBufferRangeEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXFRUSTUMEXTPROC __glewMatrixFrustumEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXLOADIDENTITYEXTPROC __glewMatrixLoadIdentityEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXLOADTRANSPOSEDEXTPROC __glewMatrixLoadTransposedEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXLOADTRANSPOSEFEXTPROC __glewMatrixLoadTransposefEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXLOADDEXTPROC __glewMatrixLoaddEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXLOADFEXTPROC __glewMatrixLoadfEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXMULTTRANSPOSEDEXTPROC __glewMatrixMultTransposedEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXMULTTRANSPOSEFEXTPROC __glewMatrixMultTransposefEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXMULTDEXTPROC __glewMatrixMultdEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXMULTFEXTPROC __glewMatrixMultfEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXORTHOEXTPROC __glewMatrixOrthoEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXPOPEXTPROC __glewMatrixPopEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXPUSHEXTPROC __glewMatrixPushEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXROTATEDEXTPROC __glewMatrixRotatedEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXROTATEFEXTPROC __glewMatrixRotatefEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXSCALEDEXTPROC __glewMatrixScaledEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXSCALEFEXTPROC __glewMatrixScalefEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXTRANSLATEDEXTPROC __glewMatrixTranslatedEXT;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXTRANSLATEFEXTPROC __glewMatrixTranslatefEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXBUFFEREXTPROC __glewMultiTexBufferEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORDPOINTEREXTPROC __glewMultiTexCoordPointerEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXENVFEXTPROC __glewMultiTexEnvfEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXENVFVEXTPROC __glewMultiTexEnvfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXENVIEXTPROC __glewMultiTexEnviEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXENVIVEXTPROC __glewMultiTexEnvivEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXGENDEXTPROC __glewMultiTexGendEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXGENDVEXTPROC __glewMultiTexGendvEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXGENFEXTPROC __glewMultiTexGenfEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXGENFVEXTPROC __glewMultiTexGenfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXGENIEXTPROC __glewMultiTexGeniEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXGENIVEXTPROC __glewMultiTexGenivEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXIMAGE1DEXTPROC __glewMultiTexImage1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXIMAGE2DEXTPROC __glewMultiTexImage2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXIMAGE3DEXTPROC __glewMultiTexImage3DEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXPARAMETERIIVEXTPROC __glewMultiTexParameterIivEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXPARAMETERIUIVEXTPROC __glewMultiTexParameterIuivEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXPARAMETERFEXTPROC __glewMultiTexParameterfEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXPARAMETERFVEXTPROC __glewMultiTexParameterfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXPARAMETERIEXTPROC __glewMultiTexParameteriEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXPARAMETERIVEXTPROC __glewMultiTexParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXRENDERBUFFEREXTPROC __glewMultiTexRenderbufferEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXSUBIMAGE1DEXTPROC __glewMultiTexSubImage1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXSUBIMAGE2DEXTPROC __glewMultiTexSubImage2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXSUBIMAGE3DEXTPROC __glewMultiTexSubImage3DEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDBUFFERDATAEXTPROC __glewNamedBufferDataEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDBUFFERSUBDATAEXTPROC __glewNamedBufferSubDataEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDCOPYBUFFERSUBDATAEXTPROC __glewNamedCopyBufferSubDataEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDFRAMEBUFFERRENDERBUFFEREXTPROC __glewNamedFramebufferRenderbufferEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDFRAMEBUFFERTEXTURE1DEXTPROC __glewNamedFramebufferTexture1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDFRAMEBUFFERTEXTURE2DEXTPROC __glewNamedFramebufferTexture2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDFRAMEBUFFERTEXTURE3DEXTPROC __glewNamedFramebufferTexture3DEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDFRAMEBUFFERTEXTUREEXTPROC __glewNamedFramebufferTextureEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDFRAMEBUFFERTEXTUREFACEEXTPROC __glewNamedFramebufferTextureFaceEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDFRAMEBUFFERTEXTURELAYEREXTPROC __glewNamedFramebufferTextureLayerEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDPROGRAMLOCALPARAMETER4DEXTPROC __glewNamedProgramLocalParameter4dEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDPROGRAMLOCALPARAMETER4DVEXTPROC __glewNamedProgramLocalParameter4dvEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDPROGRAMLOCALPARAMETER4FEXTPROC __glewNamedProgramLocalParameter4fEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDPROGRAMLOCALPARAMETER4FVEXTPROC __glewNamedProgramLocalParameter4fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDPROGRAMLOCALPARAMETERI4IEXTPROC __glewNamedProgramLocalParameterI4iEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDPROGRAMLOCALPARAMETERI4IVEXTPROC __glewNamedProgramLocalParameterI4ivEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIEXTPROC __glewNamedProgramLocalParameterI4uiEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIVEXTPROC __glewNamedProgramLocalParameterI4uivEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDPROGRAMLOCALPARAMETERS4FVEXTPROC __glewNamedProgramLocalParameters4fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDPROGRAMLOCALPARAMETERSI4IVEXTPROC __glewNamedProgramLocalParametersI4ivEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDPROGRAMLOCALPARAMETERSI4UIVEXTPROC __glewNamedProgramLocalParametersI4uivEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDPROGRAMSTRINGEXTPROC __glewNamedProgramStringEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDRENDERBUFFERSTORAGEEXTPROC __glewNamedRenderbufferStorageEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLECOVERAGEEXTPROC __glewNamedRenderbufferStorageMultisampleCoverageEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC __glewNamedRenderbufferStorageMultisampleEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1FEXTPROC __glewProgramUniform1fEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1FVEXTPROC __glewProgramUniform1fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1IEXTPROC __glewProgramUniform1iEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1IVEXTPROC __glewProgramUniform1ivEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1UIEXTPROC __glewProgramUniform1uiEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1UIVEXTPROC __glewProgramUniform1uivEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2FEXTPROC __glewProgramUniform2fEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2FVEXTPROC __glewProgramUniform2fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2IEXTPROC __glewProgramUniform2iEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2IVEXTPROC __glewProgramUniform2ivEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2UIEXTPROC __glewProgramUniform2uiEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2UIVEXTPROC __glewProgramUniform2uivEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3FEXTPROC __glewProgramUniform3fEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3FVEXTPROC __glewProgramUniform3fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3IEXTPROC __glewProgramUniform3iEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3IVEXTPROC __glewProgramUniform3ivEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3UIEXTPROC __glewProgramUniform3uiEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3UIVEXTPROC __glewProgramUniform3uivEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4FEXTPROC __glewProgramUniform4fEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4FVEXTPROC __glewProgramUniform4fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4IEXTPROC __glewProgramUniform4iEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4IVEXTPROC __glewProgramUniform4ivEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4UIEXTPROC __glewProgramUniform4uiEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4UIVEXTPROC __glewProgramUniform4uivEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX2FVEXTPROC __glewProgramUniformMatrix2fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX2X3FVEXTPROC __glewProgramUniformMatrix2x3fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX2X4FVEXTPROC __glewProgramUniformMatrix2x4fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX3FVEXTPROC __glewProgramUniformMatrix3fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX3X2FVEXTPROC __glewProgramUniformMatrix3x2fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX3X4FVEXTPROC __glewProgramUniformMatrix3x4fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX4FVEXTPROC __glewProgramUniformMatrix4fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX4X2FVEXTPROC __glewProgramUniformMatrix4x2fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMMATRIX4X3FVEXTPROC __glewProgramUniformMatrix4x3fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLPUSHCLIENTATTRIBDEFAULTEXTPROC __glewPushClientAttribDefaultEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREBUFFEREXTPROC __glewTextureBufferEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREIMAGE1DEXTPROC __glewTextureImage1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREIMAGE2DEXTPROC __glewTextureImage2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREIMAGE3DEXTPROC __glewTextureImage3DEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREPARAMETERIIVEXTPROC __glewTextureParameterIivEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREPARAMETERIUIVEXTPROC __glewTextureParameterIuivEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREPARAMETERFEXTPROC __glewTextureParameterfEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREPARAMETERFVEXTPROC __glewTextureParameterfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREPARAMETERIEXTPROC __glewTextureParameteriEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREPARAMETERIVEXTPROC __glewTextureParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURERENDERBUFFEREXTPROC __glewTextureRenderbufferEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESUBIMAGE1DEXTPROC __glewTextureSubImage1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESUBIMAGE2DEXTPROC __glewTextureSubImage2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESUBIMAGE3DEXTPROC __glewTextureSubImage3DEXT;
extern __attribute__ ((visibility("default"))) PFNGLUNMAPNAMEDBUFFEREXTPROC __glewUnmapNamedBufferEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYCOLOROFFSETEXTPROC __glewVertexArrayColorOffsetEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYEDGEFLAGOFFSETEXTPROC __glewVertexArrayEdgeFlagOffsetEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYFOGCOORDOFFSETEXTPROC __glewVertexArrayFogCoordOffsetEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYINDEXOFFSETEXTPROC __glewVertexArrayIndexOffsetEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYMULTITEXCOORDOFFSETEXTPROC __glewVertexArrayMultiTexCoordOffsetEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYNORMALOFFSETEXTPROC __glewVertexArrayNormalOffsetEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYSECONDARYCOLOROFFSETEXTPROC __glewVertexArraySecondaryColorOffsetEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYTEXCOORDOFFSETEXTPROC __glewVertexArrayTexCoordOffsetEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYVERTEXATTRIBDIVISOREXTPROC __glewVertexArrayVertexAttribDivisorEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYVERTEXATTRIBIOFFSETEXTPROC __glewVertexArrayVertexAttribIOffsetEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYVERTEXATTRIBOFFSETEXTPROC __glewVertexArrayVertexAttribOffsetEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYVERTEXOFFSETEXTPROC __glewVertexArrayVertexOffsetEXT;

extern __attribute__ ((visibility("default"))) PFNGLDISCARDFRAMEBUFFEREXTPROC __glewDiscardFramebufferEXT;

extern __attribute__ ((visibility("default"))) PFNGLBEGINQUERYEXTPROC __glewBeginQueryEXT;
extern __attribute__ ((visibility("default"))) PFNGLDELETEQUERIESEXTPROC __glewDeleteQueriesEXT;
extern __attribute__ ((visibility("default"))) PFNGLENDQUERYEXTPROC __glewEndQueryEXT;
extern __attribute__ ((visibility("default"))) PFNGLGENQUERIESEXTPROC __glewGenQueriesEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETINTEGER64VEXTPROC __glewGetInteger64vEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYOBJECTIVEXTPROC __glewGetQueryObjectivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYOBJECTUIVEXTPROC __glewGetQueryObjectuivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYIVEXTPROC __glewGetQueryivEXT;
extern __attribute__ ((visibility("default"))) PFNGLISQUERYEXTPROC __glewIsQueryEXT;
extern __attribute__ ((visibility("default"))) PFNGLQUERYCOUNTEREXTPROC __glewQueryCounterEXT;

extern __attribute__ ((visibility("default"))) PFNGLDRAWBUFFERSEXTPROC __glewDrawBuffersEXT;

extern __attribute__ ((visibility("default"))) PFNGLCOLORMASKINDEXEDEXTPROC __glewColorMaskIndexedEXT;
extern __attribute__ ((visibility("default"))) PFNGLDISABLEINDEXEDEXTPROC __glewDisableIndexedEXT;
extern __attribute__ ((visibility("default"))) PFNGLENABLEINDEXEDEXTPROC __glewEnableIndexedEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETBOOLEANINDEXEDVEXTPROC __glewGetBooleanIndexedvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETINTEGERINDEXEDVEXTPROC __glewGetIntegerIndexedvEXT;
extern __attribute__ ((visibility("default"))) PFNGLISENABLEDINDEXEDEXTPROC __glewIsEnabledIndexedEXT;

extern __attribute__ ((visibility("default"))) PFNGLBLENDEQUATIONSEPARATEIEXTPROC __glewBlendEquationSeparateiEXT;
extern __attribute__ ((visibility("default"))) PFNGLBLENDEQUATIONIEXTPROC __glewBlendEquationiEXT;
extern __attribute__ ((visibility("default"))) PFNGLBLENDFUNCSEPARATEIEXTPROC __glewBlendFuncSeparateiEXT;
extern __attribute__ ((visibility("default"))) PFNGLBLENDFUNCIEXTPROC __glewBlendFunciEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOLORMASKIEXTPROC __glewColorMaskiEXT;
extern __attribute__ ((visibility("default"))) PFNGLDISABLEIEXTPROC __glewDisableiEXT;
extern __attribute__ ((visibility("default"))) PFNGLENABLEIEXTPROC __glewEnableiEXT;
extern __attribute__ ((visibility("default"))) PFNGLISENABLEDIEXTPROC __glewIsEnablediEXT;

extern __attribute__ ((visibility("default"))) PFNGLDRAWELEMENTSBASEVERTEXEXTPROC __glewDrawElementsBaseVertexEXT;
extern __attribute__ ((visibility("default"))) PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXEXTPROC __glewDrawElementsInstancedBaseVertexEXT;
extern __attribute__ ((visibility("default"))) PFNGLDRAWRANGEELEMENTSBASEVERTEXEXTPROC __glewDrawRangeElementsBaseVertexEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWELEMENTSBASEVERTEXEXTPROC __glewMultiDrawElementsBaseVertexEXT;

extern __attribute__ ((visibility("default"))) PFNGLDRAWARRAYSINSTANCEDEXTPROC __glewDrawArraysInstancedEXT;
extern __attribute__ ((visibility("default"))) PFNGLDRAWELEMENTSINSTANCEDEXTPROC __glewDrawElementsInstancedEXT;

extern __attribute__ ((visibility("default"))) PFNGLDRAWRANGEELEMENTSEXTPROC __glewDrawRangeElementsEXT;

extern __attribute__ ((visibility("default"))) PFNGLDRAWTRANSFORMFEEDBACKEXTPROC __glewDrawTransformFeedbackEXT;
extern __attribute__ ((visibility("default"))) PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDEXTPROC __glewDrawTransformFeedbackInstancedEXT;

extern __attribute__ ((visibility("default"))) PFNGLBUFFERSTORAGEEXTERNALEXTPROC __glewBufferStorageExternalEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDBUFFERSTORAGEEXTERNALEXTPROC __glewNamedBufferStorageExternalEXT;

extern __attribute__ ((visibility("default"))) PFNGLFOGCOORDPOINTEREXTPROC __glewFogCoordPointerEXT;
extern __attribute__ ((visibility("default"))) PFNGLFOGCOORDDEXTPROC __glewFogCoorddEXT;
extern __attribute__ ((visibility("default"))) PFNGLFOGCOORDDVEXTPROC __glewFogCoorddvEXT;
extern __attribute__ ((visibility("default"))) PFNGLFOGCOORDFEXTPROC __glewFogCoordfEXT;
extern __attribute__ ((visibility("default"))) PFNGLFOGCOORDFVEXTPROC __glewFogCoordfvEXT;

extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTCOLORMATERIALEXTPROC __glewFragmentColorMaterialEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTLIGHTMODELFEXTPROC __glewFragmentLightModelfEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTLIGHTMODELFVEXTPROC __glewFragmentLightModelfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTLIGHTMODELIEXTPROC __glewFragmentLightModeliEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTLIGHTMODELIVEXTPROC __glewFragmentLightModelivEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTLIGHTFEXTPROC __glewFragmentLightfEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTLIGHTFVEXTPROC __glewFragmentLightfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTLIGHTIEXTPROC __glewFragmentLightiEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTLIGHTIVEXTPROC __glewFragmentLightivEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTMATERIALFEXTPROC __glewFragmentMaterialfEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTMATERIALFVEXTPROC __glewFragmentMaterialfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTMATERIALIEXTPROC __glewFragmentMaterialiEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTMATERIALIVEXTPROC __glewFragmentMaterialivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAGMENTLIGHTFVEXTPROC __glewGetFragmentLightfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAGMENTLIGHTIVEXTPROC __glewGetFragmentLightivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAGMENTMATERIALFVEXTPROC __glewGetFragmentMaterialfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAGMENTMATERIALIVEXTPROC __glewGetFragmentMaterialivEXT;
extern __attribute__ ((visibility("default"))) PFNGLLIGHTENVIEXTPROC __glewLightEnviEXT;

extern __attribute__ ((visibility("default"))) PFNGLBLITFRAMEBUFFEREXTPROC __glewBlitFramebufferEXT;

extern __attribute__ ((visibility("default"))) PFNGLRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC __glewRenderbufferStorageMultisampleEXT;

extern __attribute__ ((visibility("default"))) PFNGLBINDFRAMEBUFFEREXTPROC __glewBindFramebufferEXT;
extern __attribute__ ((visibility("default"))) PFNGLBINDRENDERBUFFEREXTPROC __glewBindRenderbufferEXT;
extern __attribute__ ((visibility("default"))) PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC __glewCheckFramebufferStatusEXT;
extern __attribute__ ((visibility("default"))) PFNGLDELETEFRAMEBUFFERSEXTPROC __glewDeleteFramebuffersEXT;
extern __attribute__ ((visibility("default"))) PFNGLDELETERENDERBUFFERSEXTPROC __glewDeleteRenderbuffersEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERRENDERBUFFEREXTPROC __glewFramebufferRenderbufferEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTURE1DEXTPROC __glewFramebufferTexture1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTURE2DEXTPROC __glewFramebufferTexture2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTURE3DEXTPROC __glewFramebufferTexture3DEXT;
extern __attribute__ ((visibility("default"))) PFNGLGENFRAMEBUFFERSEXTPROC __glewGenFramebuffersEXT;
extern __attribute__ ((visibility("default"))) PFNGLGENRENDERBUFFERSEXTPROC __glewGenRenderbuffersEXT;
extern __attribute__ ((visibility("default"))) PFNGLGENERATEMIPMAPEXTPROC __glewGenerateMipmapEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC __glewGetFramebufferAttachmentParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETRENDERBUFFERPARAMETERIVEXTPROC __glewGetRenderbufferParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLISFRAMEBUFFEREXTPROC __glewIsFramebufferEXT;
extern __attribute__ ((visibility("default"))) PFNGLISRENDERBUFFEREXTPROC __glewIsRenderbufferEXT;
extern __attribute__ ((visibility("default"))) PFNGLRENDERBUFFERSTORAGEEXTPROC __glewRenderbufferStorageEXT;

extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTUREEXTPROC __glewFramebufferTextureEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTUREFACEEXTPROC __glewFramebufferTextureFaceEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMPARAMETERIEXTPROC __glewProgramParameteriEXT;

extern __attribute__ ((visibility("default"))) PFNGLPROGRAMENVPARAMETERS4FVEXTPROC __glewProgramEnvParameters4fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMLOCALPARAMETERS4FVEXTPROC __glewProgramLocalParameters4fvEXT;

extern __attribute__ ((visibility("default"))) PFNGLBINDFRAGDATALOCATIONEXTPROC __glewBindFragDataLocationEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAGDATALOCATIONEXTPROC __glewGetFragDataLocationEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMUIVEXTPROC __glewGetUniformuivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBIIVEXTPROC __glewGetVertexAttribIivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBIUIVEXTPROC __glewGetVertexAttribIuivEXT;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1UIEXTPROC __glewUniform1uiEXT;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1UIVEXTPROC __glewUniform1uivEXT;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2UIEXTPROC __glewUniform2uiEXT;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2UIVEXTPROC __glewUniform2uivEXT;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3UIEXTPROC __glewUniform3uiEXT;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3UIVEXTPROC __glewUniform3uivEXT;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4UIEXTPROC __glewUniform4uiEXT;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4UIVEXTPROC __glewUniform4uivEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI1IEXTPROC __glewVertexAttribI1iEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI1IVEXTPROC __glewVertexAttribI1ivEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI1UIEXTPROC __glewVertexAttribI1uiEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI1UIVEXTPROC __glewVertexAttribI1uivEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI2IEXTPROC __glewVertexAttribI2iEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI2IVEXTPROC __glewVertexAttribI2ivEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI2UIEXTPROC __glewVertexAttribI2uiEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI2UIVEXTPROC __glewVertexAttribI2uivEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI3IEXTPROC __glewVertexAttribI3iEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI3IVEXTPROC __glewVertexAttribI3ivEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI3UIEXTPROC __glewVertexAttribI3uiEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI3UIVEXTPROC __glewVertexAttribI3uivEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI4BVEXTPROC __glewVertexAttribI4bvEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI4IEXTPROC __glewVertexAttribI4iEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI4IVEXTPROC __glewVertexAttribI4ivEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI4SVEXTPROC __glewVertexAttribI4svEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI4UBVEXTPROC __glewVertexAttribI4ubvEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI4UIEXTPROC __glewVertexAttribI4uiEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI4UIVEXTPROC __glewVertexAttribI4uivEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBI4USVEXTPROC __glewVertexAttribI4usvEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBIPOINTEREXTPROC __glewVertexAttribIPointerEXT;

extern __attribute__ ((visibility("default"))) PFNGLGETHISTOGRAMEXTPROC __glewGetHistogramEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETHISTOGRAMPARAMETERFVEXTPROC __glewGetHistogramParameterfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETHISTOGRAMPARAMETERIVEXTPROC __glewGetHistogramParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETMINMAXEXTPROC __glewGetMinmaxEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETMINMAXPARAMETERFVEXTPROC __glewGetMinmaxParameterfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETMINMAXPARAMETERIVEXTPROC __glewGetMinmaxParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLHISTOGRAMEXTPROC __glewHistogramEXT;
extern __attribute__ ((visibility("default"))) PFNGLMINMAXEXTPROC __glewMinmaxEXT;
extern __attribute__ ((visibility("default"))) PFNGLRESETHISTOGRAMEXTPROC __glewResetHistogramEXT;
extern __attribute__ ((visibility("default"))) PFNGLRESETMINMAXEXTPROC __glewResetMinmaxEXT;

extern __attribute__ ((visibility("default"))) PFNGLINDEXFUNCEXTPROC __glewIndexFuncEXT;

extern __attribute__ ((visibility("default"))) PFNGLINDEXMATERIALEXTPROC __glewIndexMaterialEXT;

extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBDIVISOREXTPROC __glewVertexAttribDivisorEXT;

extern __attribute__ ((visibility("default"))) PFNGLAPPLYTEXTUREEXTPROC __glewApplyTextureEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURELIGHTEXTPROC __glewTextureLightEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREMATERIALEXTPROC __glewTextureMaterialEXT;

extern __attribute__ ((visibility("default"))) PFNGLFLUSHMAPPEDBUFFERRANGEEXTPROC __glewFlushMappedBufferRangeEXT;
extern __attribute__ ((visibility("default"))) PFNGLMAPBUFFERRANGEEXTPROC __glewMapBufferRangeEXT;

extern __attribute__ ((visibility("default"))) PFNGLBUFFERSTORAGEMEMEXTPROC __glewBufferStorageMemEXT;
extern __attribute__ ((visibility("default"))) PFNGLCREATEMEMORYOBJECTSEXTPROC __glewCreateMemoryObjectsEXT;
extern __attribute__ ((visibility("default"))) PFNGLDELETEMEMORYOBJECTSEXTPROC __glewDeleteMemoryObjectsEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETMEMORYOBJECTPARAMETERIVEXTPROC __glewGetMemoryObjectParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETUNSIGNEDBYTEI_VEXTPROC __glewGetUnsignedBytei_vEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETUNSIGNEDBYTEVEXTPROC __glewGetUnsignedBytevEXT;
extern __attribute__ ((visibility("default"))) PFNGLISMEMORYOBJECTEXTPROC __glewIsMemoryObjectEXT;
extern __attribute__ ((visibility("default"))) PFNGLMEMORYOBJECTPARAMETERIVEXTPROC __glewMemoryObjectParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDBUFFERSTORAGEMEMEXTPROC __glewNamedBufferStorageMemEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXSTORAGEMEM1DEXTPROC __glewTexStorageMem1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXSTORAGEMEM2DEXTPROC __glewTexStorageMem2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXSTORAGEMEM2DMULTISAMPLEEXTPROC __glewTexStorageMem2DMultisampleEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXSTORAGEMEM3DEXTPROC __glewTexStorageMem3DEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXSTORAGEMEM3DMULTISAMPLEEXTPROC __glewTexStorageMem3DMultisampleEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESTORAGEMEM1DEXTPROC __glewTextureStorageMem1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESTORAGEMEM2DEXTPROC __glewTextureStorageMem2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESTORAGEMEM2DMULTISAMPLEEXTPROC __glewTextureStorageMem2DMultisampleEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESTORAGEMEM3DEXTPROC __glewTextureStorageMem3DEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESTORAGEMEM3DMULTISAMPLEEXTPROC __glewTextureStorageMem3DMultisampleEXT;

extern __attribute__ ((visibility("default"))) PFNGLIMPORTMEMORYFDEXTPROC __glewImportMemoryFdEXT;

extern __attribute__ ((visibility("default"))) PFNGLIMPORTMEMORYWIN32HANDLEEXTPROC __glewImportMemoryWin32HandleEXT;
extern __attribute__ ((visibility("default"))) PFNGLIMPORTMEMORYWIN32NAMEEXTPROC __glewImportMemoryWin32NameEXT;

extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWARRAYSEXTPROC __glewMultiDrawArraysEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWELEMENTSEXTPROC __glewMultiDrawElementsEXT;

extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWARRAYSINDIRECTEXTPROC __glewMultiDrawArraysIndirectEXT;
extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWELEMENTSINDIRECTEXTPROC __glewMultiDrawElementsIndirectEXT;

extern __attribute__ ((visibility("default"))) PFNGLSAMPLEMASKEXTPROC __glewSampleMaskEXT;
extern __attribute__ ((visibility("default"))) PFNGLSAMPLEPATTERNEXTPROC __glewSamplePatternEXT;

extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTURE2DMULTISAMPLEEXTPROC __glewFramebufferTexture2DMultisampleEXT;

extern __attribute__ ((visibility("default"))) PFNGLDRAWBUFFERSINDEXEDEXTPROC __glewDrawBuffersIndexedEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETINTEGERI_VEXTPROC __glewGetIntegeri_vEXT;
extern __attribute__ ((visibility("default"))) PFNGLREADBUFFERINDEXEDEXTPROC __glewReadBufferIndexedEXT;

extern __attribute__ ((visibility("default"))) PFNGLCOLORTABLEEXTPROC __glewColorTableEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETCOLORTABLEEXTPROC __glewGetColorTableEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETCOLORTABLEPARAMETERFVEXTPROC __glewGetColorTableParameterfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETCOLORTABLEPARAMETERIVEXTPROC __glewGetColorTableParameterivEXT;

extern __attribute__ ((visibility("default"))) PFNGLGETPIXELTRANSFORMPARAMETERFVEXTPROC __glewGetPixelTransformParameterfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETPIXELTRANSFORMPARAMETERIVEXTPROC __glewGetPixelTransformParameterivEXT;
extern __attribute__ ((visibility("default"))) PFNGLPIXELTRANSFORMPARAMETERFEXTPROC __glewPixelTransformParameterfEXT;
extern __attribute__ ((visibility("default"))) PFNGLPIXELTRANSFORMPARAMETERFVEXTPROC __glewPixelTransformParameterfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLPIXELTRANSFORMPARAMETERIEXTPROC __glewPixelTransformParameteriEXT;
extern __attribute__ ((visibility("default"))) PFNGLPIXELTRANSFORMPARAMETERIVEXTPROC __glewPixelTransformParameterivEXT;

extern __attribute__ ((visibility("default"))) PFNGLPOINTPARAMETERFEXTPROC __glewPointParameterfEXT;
extern __attribute__ ((visibility("default"))) PFNGLPOINTPARAMETERFVEXTPROC __glewPointParameterfvEXT;

extern __attribute__ ((visibility("default"))) PFNGLPOLYGONOFFSETEXTPROC __glewPolygonOffsetEXT;

extern __attribute__ ((visibility("default"))) PFNGLPOLYGONOFFSETCLAMPEXTPROC __glewPolygonOffsetClampEXT;

extern __attribute__ ((visibility("default"))) PFNGLPRIMITIVEBOUNDINGBOXEXTPROC __glewPrimitiveBoundingBoxEXT;

extern __attribute__ ((visibility("default"))) PFNGLPROVOKINGVERTEXEXTPROC __glewProvokingVertexEXT;

extern __attribute__ ((visibility("default"))) PFNGLCOVERAGEMODULATIONNVPROC __glewCoverageModulationNV;
extern __attribute__ ((visibility("default"))) PFNGLCOVERAGEMODULATIONTABLENVPROC __glewCoverageModulationTableNV;
extern __attribute__ ((visibility("default"))) PFNGLGETCOVERAGEMODULATIONTABLENVPROC __glewGetCoverageModulationTableNV;
extern __attribute__ ((visibility("default"))) PFNGLRASTERSAMPLESEXTPROC __glewRasterSamplesEXT;

extern __attribute__ ((visibility("default"))) PFNGLGETNUNIFORMFVEXTPROC __glewGetnUniformfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETNUNIFORMIVEXTPROC __glewGetnUniformivEXT;
extern __attribute__ ((visibility("default"))) PFNGLREADNPIXELSEXTPROC __glewReadnPixelsEXT;

extern __attribute__ ((visibility("default"))) PFNGLBEGINSCENEEXTPROC __glewBeginSceneEXT;
extern __attribute__ ((visibility("default"))) PFNGLENDSCENEEXTPROC __glewEndSceneEXT;

extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3BEXTPROC __glewSecondaryColor3bEXT;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3BVEXTPROC __glewSecondaryColor3bvEXT;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3DEXTPROC __glewSecondaryColor3dEXT;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3DVEXTPROC __glewSecondaryColor3dvEXT;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3FEXTPROC __glewSecondaryColor3fEXT;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3FVEXTPROC __glewSecondaryColor3fvEXT;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3IEXTPROC __glewSecondaryColor3iEXT;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3IVEXTPROC __glewSecondaryColor3ivEXT;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3SEXTPROC __glewSecondaryColor3sEXT;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3SVEXTPROC __glewSecondaryColor3svEXT;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3UBEXTPROC __glewSecondaryColor3ubEXT;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3UBVEXTPROC __glewSecondaryColor3ubvEXT;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3UIEXTPROC __glewSecondaryColor3uiEXT;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3UIVEXTPROC __glewSecondaryColor3uivEXT;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3USEXTPROC __glewSecondaryColor3usEXT;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3USVEXTPROC __glewSecondaryColor3usvEXT;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLORPOINTEREXTPROC __glewSecondaryColorPointerEXT;

extern __attribute__ ((visibility("default"))) PFNGLDELETESEMAPHORESEXTPROC __glewDeleteSemaphoresEXT;
extern __attribute__ ((visibility("default"))) PFNGLGENSEMAPHORESEXTPROC __glewGenSemaphoresEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETSEMAPHOREPARAMETERUI64VEXTPROC __glewGetSemaphoreParameterui64vEXT;
extern __attribute__ ((visibility("default"))) PFNGLISSEMAPHOREEXTPROC __glewIsSemaphoreEXT;
extern __attribute__ ((visibility("default"))) PFNGLSEMAPHOREPARAMETERUI64VEXTPROC __glewSemaphoreParameterui64vEXT;
extern __attribute__ ((visibility("default"))) PFNGLSIGNALSEMAPHOREEXTPROC __glewSignalSemaphoreEXT;
extern __attribute__ ((visibility("default"))) PFNGLWAITSEMAPHOREEXTPROC __glewWaitSemaphoreEXT;

extern __attribute__ ((visibility("default"))) PFNGLIMPORTSEMAPHOREFDEXTPROC __glewImportSemaphoreFdEXT;

extern __attribute__ ((visibility("default"))) PFNGLIMPORTSEMAPHOREWIN32HANDLEEXTPROC __glewImportSemaphoreWin32HandleEXT;
extern __attribute__ ((visibility("default"))) PFNGLIMPORTSEMAPHOREWIN32NAMEEXTPROC __glewImportSemaphoreWin32NameEXT;

extern __attribute__ ((visibility("default"))) PFNGLACTIVEPROGRAMEXTPROC __glewActiveProgramEXT;
extern __attribute__ ((visibility("default"))) PFNGLCREATESHADERPROGRAMEXTPROC __glewCreateShaderProgramEXT;
extern __attribute__ ((visibility("default"))) PFNGLUSESHADERPROGRAMEXTPROC __glewUseShaderProgramEXT;

extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERFETCHBARRIEREXTPROC __glewFramebufferFetchBarrierEXT;

extern __attribute__ ((visibility("default"))) PFNGLBINDIMAGETEXTUREEXTPROC __glewBindImageTextureEXT;
extern __attribute__ ((visibility("default"))) PFNGLMEMORYBARRIEREXTPROC __glewMemoryBarrierEXT;

extern __attribute__ ((visibility("default"))) PFNGLCLEARPIXELLOCALSTORAGEUIEXTPROC __glewClearPixelLocalStorageuiEXT;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERPIXELLOCALSTORAGESIZEEXTPROC __glewFramebufferPixelLocalStorageSizeEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAMEBUFFERPIXELLOCALSTORAGESIZEEXTPROC __glewGetFramebufferPixelLocalStorageSizeEXT;

extern __attribute__ ((visibility("default"))) PFNGLTEXPAGECOMMITMENTEXTPROC __glewTexPageCommitmentEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREPAGECOMMITMENTEXTPROC __glewTexturePageCommitmentEXT;

extern __attribute__ ((visibility("default"))) PFNGLACTIVESTENCILFACEEXTPROC __glewActiveStencilFaceEXT;

extern __attribute__ ((visibility("default"))) PFNGLTEXSUBIMAGE1DEXTPROC __glewTexSubImage1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXSUBIMAGE2DEXTPROC __glewTexSubImage2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXSUBIMAGE3DEXTPROC __glewTexSubImage3DEXT;

extern __attribute__ ((visibility("default"))) PFNGLPATCHPARAMETERIEXTPROC __glewPatchParameteriEXT;

extern __attribute__ ((visibility("default"))) PFNGLTEXIMAGE3DEXTPROC __glewTexImage3DEXT;

extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTURELAYEREXTPROC __glewFramebufferTextureLayerEXT;

extern __attribute__ ((visibility("default"))) PFNGLGETSAMPLERPARAMETERIIVEXTPROC __glewGetSamplerParameterIivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETSAMPLERPARAMETERIUIVEXTPROC __glewGetSamplerParameterIuivEXT;
extern __attribute__ ((visibility("default"))) PFNGLSAMPLERPARAMETERIIVEXTPROC __glewSamplerParameterIivEXT;
extern __attribute__ ((visibility("default"))) PFNGLSAMPLERPARAMETERIUIVEXTPROC __glewSamplerParameterIuivEXT;

extern __attribute__ ((visibility("default"))) PFNGLTEXBUFFEREXTPROC __glewTexBufferEXT;

extern __attribute__ ((visibility("default"))) PFNGLCLEARCOLORIIEXTPROC __glewClearColorIiEXT;
extern __attribute__ ((visibility("default"))) PFNGLCLEARCOLORIUIEXTPROC __glewClearColorIuiEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXPARAMETERIIVEXTPROC __glewGetTexParameterIivEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXPARAMETERIUIVEXTPROC __glewGetTexParameterIuivEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXPARAMETERIIVEXTPROC __glewTexParameterIivEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXPARAMETERIUIVEXTPROC __glewTexParameterIuivEXT;

extern __attribute__ ((visibility("default"))) PFNGLARETEXTURESRESIDENTEXTPROC __glewAreTexturesResidentEXT;
extern __attribute__ ((visibility("default"))) PFNGLBINDTEXTUREEXTPROC __glewBindTextureEXT;
extern __attribute__ ((visibility("default"))) PFNGLDELETETEXTURESEXTPROC __glewDeleteTexturesEXT;
extern __attribute__ ((visibility("default"))) PFNGLGENTEXTURESEXTPROC __glewGenTexturesEXT;
extern __attribute__ ((visibility("default"))) PFNGLISTEXTUREEXTPROC __glewIsTextureEXT;
extern __attribute__ ((visibility("default"))) PFNGLPRIORITIZETEXTURESEXTPROC __glewPrioritizeTexturesEXT;

extern __attribute__ ((visibility("default"))) PFNGLTEXTURENORMALEXTPROC __glewTextureNormalEXT;

extern __attribute__ ((visibility("default"))) PFNGLTEXSTORAGE1DEXTPROC __glewTexStorage1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXSTORAGE2DEXTPROC __glewTexStorage2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXSTORAGE3DEXTPROC __glewTexStorage3DEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESTORAGE1DEXTPROC __glewTextureStorage1DEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESTORAGE2DEXTPROC __glewTextureStorage2DEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXTURESTORAGE3DEXTPROC __glewTextureStorage3DEXT;

extern __attribute__ ((visibility("default"))) PFNGLTEXTUREVIEWEXTPROC __glewTextureViewEXT;

extern __attribute__ ((visibility("default"))) PFNGLGETQUERYOBJECTI64VEXTPROC __glewGetQueryObjecti64vEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETQUERYOBJECTUI64VEXTPROC __glewGetQueryObjectui64vEXT;

extern __attribute__ ((visibility("default"))) PFNGLBEGINTRANSFORMFEEDBACKEXTPROC __glewBeginTransformFeedbackEXT;
extern __attribute__ ((visibility("default"))) PFNGLBINDBUFFERBASEEXTPROC __glewBindBufferBaseEXT;
extern __attribute__ ((visibility("default"))) PFNGLBINDBUFFEROFFSETEXTPROC __glewBindBufferOffsetEXT;
extern __attribute__ ((visibility("default"))) PFNGLBINDBUFFERRANGEEXTPROC __glewBindBufferRangeEXT;
extern __attribute__ ((visibility("default"))) PFNGLENDTRANSFORMFEEDBACKEXTPROC __glewEndTransformFeedbackEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETTRANSFORMFEEDBACKVARYINGEXTPROC __glewGetTransformFeedbackVaryingEXT;
extern __attribute__ ((visibility("default"))) PFNGLTRANSFORMFEEDBACKVARYINGSEXTPROC __glewTransformFeedbackVaryingsEXT;

extern __attribute__ ((visibility("default"))) PFNGLARRAYELEMENTEXTPROC __glewArrayElementEXT;
extern __attribute__ ((visibility("default"))) PFNGLCOLORPOINTEREXTPROC __glewColorPointerEXT;
extern __attribute__ ((visibility("default"))) PFNGLDRAWARRAYSEXTPROC __glewDrawArraysEXT;
extern __attribute__ ((visibility("default"))) PFNGLEDGEFLAGPOINTEREXTPROC __glewEdgeFlagPointerEXT;
extern __attribute__ ((visibility("default"))) PFNGLINDEXPOINTEREXTPROC __glewIndexPointerEXT;
extern __attribute__ ((visibility("default"))) PFNGLNORMALPOINTEREXTPROC __glewNormalPointerEXT;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORDPOINTEREXTPROC __glewTexCoordPointerEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXPOINTEREXTPROC __glewVertexPointerEXT;

extern __attribute__ ((visibility("default"))) PFNGLBINDARRAYSETEXTPROC __glewBindArraySetEXT;
extern __attribute__ ((visibility("default"))) PFNGLCREATEARRAYSETEXTPROC __glewCreateArraySetExt;
extern __attribute__ ((visibility("default"))) PFNGLDELETEARRAYSETSEXTPROC __glewDeleteArraySetsEXT;

extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBLDVEXTPROC __glewGetVertexAttribLdvEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYVERTEXATTRIBLOFFSETEXTPROC __glewVertexArrayVertexAttribLOffsetEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL1DEXTPROC __glewVertexAttribL1dEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL1DVEXTPROC __glewVertexAttribL1dvEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL2DEXTPROC __glewVertexAttribL2dEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL2DVEXTPROC __glewVertexAttribL2dvEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL3DEXTPROC __glewVertexAttribL3dEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL3DVEXTPROC __glewVertexAttribL3dvEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL4DEXTPROC __glewVertexAttribL4dEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL4DVEXTPROC __glewVertexAttribL4dvEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBLPOINTEREXTPROC __glewVertexAttribLPointerEXT;

extern __attribute__ ((visibility("default"))) PFNGLBEGINVERTEXSHADEREXTPROC __glewBeginVertexShaderEXT;
extern __attribute__ ((visibility("default"))) PFNGLBINDLIGHTPARAMETEREXTPROC __glewBindLightParameterEXT;
extern __attribute__ ((visibility("default"))) PFNGLBINDMATERIALPARAMETEREXTPROC __glewBindMaterialParameterEXT;
extern __attribute__ ((visibility("default"))) PFNGLBINDPARAMETEREXTPROC __glewBindParameterEXT;
extern __attribute__ ((visibility("default"))) PFNGLBINDTEXGENPARAMETEREXTPROC __glewBindTexGenParameterEXT;
extern __attribute__ ((visibility("default"))) PFNGLBINDTEXTUREUNITPARAMETEREXTPROC __glewBindTextureUnitParameterEXT;
extern __attribute__ ((visibility("default"))) PFNGLBINDVERTEXSHADEREXTPROC __glewBindVertexShaderEXT;
extern __attribute__ ((visibility("default"))) PFNGLDELETEVERTEXSHADEREXTPROC __glewDeleteVertexShaderEXT;
extern __attribute__ ((visibility("default"))) PFNGLDISABLEVARIANTCLIENTSTATEEXTPROC __glewDisableVariantClientStateEXT;
extern __attribute__ ((visibility("default"))) PFNGLENABLEVARIANTCLIENTSTATEEXTPROC __glewEnableVariantClientStateEXT;
extern __attribute__ ((visibility("default"))) PFNGLENDVERTEXSHADEREXTPROC __glewEndVertexShaderEXT;
extern __attribute__ ((visibility("default"))) PFNGLEXTRACTCOMPONENTEXTPROC __glewExtractComponentEXT;
extern __attribute__ ((visibility("default"))) PFNGLGENSYMBOLSEXTPROC __glewGenSymbolsEXT;
extern __attribute__ ((visibility("default"))) PFNGLGENVERTEXSHADERSEXTPROC __glewGenVertexShadersEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETINVARIANTBOOLEANVEXTPROC __glewGetInvariantBooleanvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETINVARIANTFLOATVEXTPROC __glewGetInvariantFloatvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETINVARIANTINTEGERVEXTPROC __glewGetInvariantIntegervEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETLOCALCONSTANTBOOLEANVEXTPROC __glewGetLocalConstantBooleanvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETLOCALCONSTANTFLOATVEXTPROC __glewGetLocalConstantFloatvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETLOCALCONSTANTINTEGERVEXTPROC __glewGetLocalConstantIntegervEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETVARIANTBOOLEANVEXTPROC __glewGetVariantBooleanvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETVARIANTFLOATVEXTPROC __glewGetVariantFloatvEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETVARIANTINTEGERVEXTPROC __glewGetVariantIntegervEXT;
extern __attribute__ ((visibility("default"))) PFNGLGETVARIANTPOINTERVEXTPROC __glewGetVariantPointervEXT;
extern __attribute__ ((visibility("default"))) PFNGLINSERTCOMPONENTEXTPROC __glewInsertComponentEXT;
extern __attribute__ ((visibility("default"))) PFNGLISVARIANTENABLEDEXTPROC __glewIsVariantEnabledEXT;
extern __attribute__ ((visibility("default"))) PFNGLSETINVARIANTEXTPROC __glewSetInvariantEXT;
extern __attribute__ ((visibility("default"))) PFNGLSETLOCALCONSTANTEXTPROC __glewSetLocalConstantEXT;
extern __attribute__ ((visibility("default"))) PFNGLSHADEROP1EXTPROC __glewShaderOp1EXT;
extern __attribute__ ((visibility("default"))) PFNGLSHADEROP2EXTPROC __glewShaderOp2EXT;
extern __attribute__ ((visibility("default"))) PFNGLSHADEROP3EXTPROC __glewShaderOp3EXT;
extern __attribute__ ((visibility("default"))) PFNGLSWIZZLEEXTPROC __glewSwizzleEXT;
extern __attribute__ ((visibility("default"))) PFNGLVARIANTPOINTEREXTPROC __glewVariantPointerEXT;
extern __attribute__ ((visibility("default"))) PFNGLVARIANTBVEXTPROC __glewVariantbvEXT;
extern __attribute__ ((visibility("default"))) PFNGLVARIANTDVEXTPROC __glewVariantdvEXT;
extern __attribute__ ((visibility("default"))) PFNGLVARIANTFVEXTPROC __glewVariantfvEXT;
extern __attribute__ ((visibility("default"))) PFNGLVARIANTIVEXTPROC __glewVariantivEXT;
extern __attribute__ ((visibility("default"))) PFNGLVARIANTSVEXTPROC __glewVariantsvEXT;
extern __attribute__ ((visibility("default"))) PFNGLVARIANTUBVEXTPROC __glewVariantubvEXT;
extern __attribute__ ((visibility("default"))) PFNGLVARIANTUIVEXTPROC __glewVariantuivEXT;
extern __attribute__ ((visibility("default"))) PFNGLVARIANTUSVEXTPROC __glewVariantusvEXT;
extern __attribute__ ((visibility("default"))) PFNGLWRITEMASKEXTPROC __glewWriteMaskEXT;

extern __attribute__ ((visibility("default"))) PFNGLVERTEXWEIGHTPOINTEREXTPROC __glewVertexWeightPointerEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXWEIGHTFEXTPROC __glewVertexWeightfEXT;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXWEIGHTFVEXTPROC __glewVertexWeightfvEXT;

extern __attribute__ ((visibility("default"))) PFNGLACQUIREKEYEDMUTEXWIN32EXTPROC __glewAcquireKeyedMutexWin32EXT;
extern __attribute__ ((visibility("default"))) PFNGLRELEASEKEYEDMUTEXWIN32EXTPROC __glewReleaseKeyedMutexWin32EXT;

extern __attribute__ ((visibility("default"))) PFNGLWINDOWRECTANGLESEXTPROC __glewWindowRectanglesEXT;

extern __attribute__ ((visibility("default"))) PFNGLIMPORTSYNCEXTPROC __glewImportSyncEXT;

extern __attribute__ ((visibility("default"))) PFNGLFRAMETERMINATORGREMEDYPROC __glewFrameTerminatorGREMEDY;

extern __attribute__ ((visibility("default"))) PFNGLSTRINGMARKERGREMEDYPROC __glewStringMarkerGREMEDY;

extern __attribute__ ((visibility("default"))) PFNGLGETIMAGETRANSFORMPARAMETERFVHPPROC __glewGetImageTransformParameterfvHP;
extern __attribute__ ((visibility("default"))) PFNGLGETIMAGETRANSFORMPARAMETERIVHPPROC __glewGetImageTransformParameterivHP;
extern __attribute__ ((visibility("default"))) PFNGLIMAGETRANSFORMPARAMETERFHPPROC __glewImageTransformParameterfHP;
extern __attribute__ ((visibility("default"))) PFNGLIMAGETRANSFORMPARAMETERFVHPPROC __glewImageTransformParameterfvHP;
extern __attribute__ ((visibility("default"))) PFNGLIMAGETRANSFORMPARAMETERIHPPROC __glewImageTransformParameteriHP;
extern __attribute__ ((visibility("default"))) PFNGLIMAGETRANSFORMPARAMETERIVHPPROC __glewImageTransformParameterivHP;

extern __attribute__ ((visibility("default"))) PFNGLMULTIMODEDRAWARRAYSIBMPROC __glewMultiModeDrawArraysIBM;
extern __attribute__ ((visibility("default"))) PFNGLMULTIMODEDRAWELEMENTSIBMPROC __glewMultiModeDrawElementsIBM;

extern __attribute__ ((visibility("default"))) PFNGLCOLORPOINTERLISTIBMPROC __glewColorPointerListIBM;
extern __attribute__ ((visibility("default"))) PFNGLEDGEFLAGPOINTERLISTIBMPROC __glewEdgeFlagPointerListIBM;
extern __attribute__ ((visibility("default"))) PFNGLFOGCOORDPOINTERLISTIBMPROC __glewFogCoordPointerListIBM;
extern __attribute__ ((visibility("default"))) PFNGLINDEXPOINTERLISTIBMPROC __glewIndexPointerListIBM;
extern __attribute__ ((visibility("default"))) PFNGLNORMALPOINTERLISTIBMPROC __glewNormalPointerListIBM;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLORPOINTERLISTIBMPROC __glewSecondaryColorPointerListIBM;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORDPOINTERLISTIBMPROC __glewTexCoordPointerListIBM;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXPOINTERLISTIBMPROC __glewVertexPointerListIBM;

extern __attribute__ ((visibility("default"))) PFNGLGETTEXTUREHANDLEIMGPROC __glewGetTextureHandleIMG;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTURESAMPLERHANDLEIMGPROC __glewGetTextureSamplerHandleIMG;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMHANDLEUI64IMGPROC __glewProgramUniformHandleui64IMG;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMHANDLEUI64VIMGPROC __glewProgramUniformHandleui64vIMG;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMHANDLEUI64IMGPROC __glewUniformHandleui64IMG;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMHANDLEUI64VIMGPROC __glewUniformHandleui64vIMG;

extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTURE2DDOWNSAMPLEIMGPROC __glewFramebufferTexture2DDownsampleIMG;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTURELAYERDOWNSAMPLEIMGPROC __glewFramebufferTextureLayerDownsampleIMG;

extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTURE2DMULTISAMPLEIMGPROC __glewFramebufferTexture2DMultisampleIMG;
extern __attribute__ ((visibility("default"))) PFNGLRENDERBUFFERSTORAGEMULTISAMPLEIMGPROC __glewRenderbufferStorageMultisampleIMG;

extern __attribute__ ((visibility("default"))) PFNGLMAPTEXTURE2DINTELPROC __glewMapTexture2DINTEL;
extern __attribute__ ((visibility("default"))) PFNGLSYNCTEXTUREINTELPROC __glewSyncTextureINTEL;
extern __attribute__ ((visibility("default"))) PFNGLUNMAPTEXTURE2DINTELPROC __glewUnmapTexture2DINTEL;

extern __attribute__ ((visibility("default"))) PFNGLCOLORPOINTERVINTELPROC __glewColorPointervINTEL;
extern __attribute__ ((visibility("default"))) PFNGLNORMALPOINTERVINTELPROC __glewNormalPointervINTEL;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORDPOINTERVINTELPROC __glewTexCoordPointervINTEL;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXPOINTERVINTELPROC __glewVertexPointervINTEL;

extern __attribute__ ((visibility("default"))) PFNGLBEGINPERFQUERYINTELPROC __glewBeginPerfQueryINTEL;
extern __attribute__ ((visibility("default"))) PFNGLCREATEPERFQUERYINTELPROC __glewCreatePerfQueryINTEL;
extern __attribute__ ((visibility("default"))) PFNGLDELETEPERFQUERYINTELPROC __glewDeletePerfQueryINTEL;
extern __attribute__ ((visibility("default"))) PFNGLENDPERFQUERYINTELPROC __glewEndPerfQueryINTEL;
extern __attribute__ ((visibility("default"))) PFNGLGETFIRSTPERFQUERYIDINTELPROC __glewGetFirstPerfQueryIdINTEL;
extern __attribute__ ((visibility("default"))) PFNGLGETNEXTPERFQUERYIDINTELPROC __glewGetNextPerfQueryIdINTEL;
extern __attribute__ ((visibility("default"))) PFNGLGETPERFCOUNTERINFOINTELPROC __glewGetPerfCounterInfoINTEL;
extern __attribute__ ((visibility("default"))) PFNGLGETPERFQUERYDATAINTELPROC __glewGetPerfQueryDataINTEL;
extern __attribute__ ((visibility("default"))) PFNGLGETPERFQUERYIDBYNAMEINTELPROC __glewGetPerfQueryIdByNameINTEL;
extern __attribute__ ((visibility("default"))) PFNGLGETPERFQUERYINFOINTELPROC __glewGetPerfQueryInfoINTEL;

extern __attribute__ ((visibility("default"))) PFNGLTEXSCISSORFUNCINTELPROC __glewTexScissorFuncINTEL;
extern __attribute__ ((visibility("default"))) PFNGLTEXSCISSORINTELPROC __glewTexScissorINTEL;

extern __attribute__ ((visibility("default"))) PFNGLBLENDBARRIERKHRPROC __glewBlendBarrierKHR;

extern __attribute__ ((visibility("default"))) PFNGLDEBUGMESSAGECALLBACKPROC __glewDebugMessageCallback;
extern __attribute__ ((visibility("default"))) PFNGLDEBUGMESSAGECONTROLPROC __glewDebugMessageControl;
extern __attribute__ ((visibility("default"))) PFNGLDEBUGMESSAGEINSERTPROC __glewDebugMessageInsert;
extern __attribute__ ((visibility("default"))) PFNGLGETDEBUGMESSAGELOGPROC __glewGetDebugMessageLog;
extern __attribute__ ((visibility("default"))) PFNGLGETOBJECTLABELPROC __glewGetObjectLabel;
extern __attribute__ ((visibility("default"))) PFNGLGETOBJECTPTRLABELPROC __glewGetObjectPtrLabel;
extern __attribute__ ((visibility("default"))) PFNGLOBJECTLABELPROC __glewObjectLabel;
extern __attribute__ ((visibility("default"))) PFNGLOBJECTPTRLABELPROC __glewObjectPtrLabel;
extern __attribute__ ((visibility("default"))) PFNGLPOPDEBUGGROUPPROC __glewPopDebugGroup;
extern __attribute__ ((visibility("default"))) PFNGLPUSHDEBUGGROUPPROC __glewPushDebugGroup;

extern __attribute__ ((visibility("default"))) PFNGLMAXSHADERCOMPILERTHREADSKHRPROC __glewMaxShaderCompilerThreadsKHR;

extern __attribute__ ((visibility("default"))) PFNGLGETNUNIFORMFVPROC __glewGetnUniformfv;
extern __attribute__ ((visibility("default"))) PFNGLGETNUNIFORMIVPROC __glewGetnUniformiv;
extern __attribute__ ((visibility("default"))) PFNGLGETNUNIFORMUIVPROC __glewGetnUniformuiv;
extern __attribute__ ((visibility("default"))) PFNGLREADNPIXELSPROC __glewReadnPixels;

extern __attribute__ ((visibility("default"))) PFNGLBUFFERREGIONENABLEDPROC __glewBufferRegionEnabled;
extern __attribute__ ((visibility("default"))) PFNGLDELETEBUFFERREGIONPROC __glewDeleteBufferRegion;
extern __attribute__ ((visibility("default"))) PFNGLDRAWBUFFERREGIONPROC __glewDrawBufferRegion;
extern __attribute__ ((visibility("default"))) PFNGLNEWBUFFERREGIONPROC __glewNewBufferRegion;
extern __attribute__ ((visibility("default"))) PFNGLREADBUFFERREGIONPROC __glewReadBufferRegion;

extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERPARAMETERIMESAPROC __glewFramebufferParameteriMESA;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAMEBUFFERPARAMETERIVMESAPROC __glewGetFramebufferParameterivMESA;

extern __attribute__ ((visibility("default"))) PFNGLRESIZEBUFFERSMESAPROC __glewResizeBuffersMESA;

extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2DMESAPROC __glewWindowPos2dMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2DVMESAPROC __glewWindowPos2dvMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2FMESAPROC __glewWindowPos2fMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2FVMESAPROC __glewWindowPos2fvMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2IMESAPROC __glewWindowPos2iMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2IVMESAPROC __glewWindowPos2ivMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2SMESAPROC __glewWindowPos2sMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS2SVMESAPROC __glewWindowPos2svMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3DMESAPROC __glewWindowPos3dMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3DVMESAPROC __glewWindowPos3dvMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3FMESAPROC __glewWindowPos3fMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3FVMESAPROC __glewWindowPos3fvMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3IMESAPROC __glewWindowPos3iMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3IVMESAPROC __glewWindowPos3ivMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3SMESAPROC __glewWindowPos3sMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS3SVMESAPROC __glewWindowPos3svMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS4DMESAPROC __glewWindowPos4dMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS4DVMESAPROC __glewWindowPos4dvMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS4FMESAPROC __glewWindowPos4fMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS4FVMESAPROC __glewWindowPos4fvMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS4IMESAPROC __glewWindowPos4iMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS4IVMESAPROC __glewWindowPos4ivMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS4SMESAPROC __glewWindowPos4sMESA;
extern __attribute__ ((visibility("default"))) PFNGLWINDOWPOS4SVMESAPROC __glewWindowPos4svMESA;

extern __attribute__ ((visibility("default"))) PFNGLBEGINCONDITIONALRENDERNVXPROC __glewBeginConditionalRenderNVX;
extern __attribute__ ((visibility("default"))) PFNGLENDCONDITIONALRENDERNVXPROC __glewEndConditionalRenderNVX;

extern __attribute__ ((visibility("default"))) PFNGLASYNCCOPYBUFFERSUBDATANVXPROC __glewAsyncCopyBufferSubDataNVX;
extern __attribute__ ((visibility("default"))) PFNGLASYNCCOPYIMAGESUBDATANVXPROC __glewAsyncCopyImageSubDataNVX;
extern __attribute__ ((visibility("default"))) PFNGLMULTICASTSCISSORARRAYVNVXPROC __glewMulticastScissorArrayvNVX;
extern __attribute__ ((visibility("default"))) PFNGLMULTICASTVIEWPORTARRAYVNVXPROC __glewMulticastViewportArrayvNVX;
extern __attribute__ ((visibility("default"))) PFNGLMULTICASTVIEWPORTPOSITIONWSCALENVXPROC __glewMulticastViewportPositionWScaleNVX;
extern __attribute__ ((visibility("default"))) PFNGLUPLOADGPUMASKNVXPROC __glewUploadGpuMaskNVX;

extern __attribute__ ((visibility("default"))) PFNGLLGPUCOPYIMAGESUBDATANVXPROC __glewLGPUCopyImageSubDataNVX;
extern __attribute__ ((visibility("default"))) PFNGLLGPUINTERLOCKNVXPROC __glewLGPUInterlockNVX;
extern __attribute__ ((visibility("default"))) PFNGLLGPUNAMEDBUFFERSUBDATANVXPROC __glewLGPUNamedBufferSubDataNVX;

extern __attribute__ ((visibility("default"))) PFNGLCLIENTWAITSEMAPHOREUI64NVXPROC __glewClientWaitSemaphoreui64NVX;
extern __attribute__ ((visibility("default"))) PFNGLSIGNALSEMAPHOREUI64NVXPROC __glewSignalSemaphoreui64NVX;
extern __attribute__ ((visibility("default"))) PFNGLWAITSEMAPHOREUI64NVXPROC __glewWaitSemaphoreui64NVX;

extern __attribute__ ((visibility("default"))) PFNGLSTEREOPARAMETERFNVPROC __glewStereoParameterfNV;
extern __attribute__ ((visibility("default"))) PFNGLSTEREOPARAMETERINVPROC __glewStereoParameteriNV;

extern __attribute__ ((visibility("default"))) PFNGLALPHATOCOVERAGEDITHERCONTROLNVPROC __glewAlphaToCoverageDitherControlNV;

extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSNVPROC __glewMultiDrawArraysIndirectBindlessNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSNVPROC __glewMultiDrawElementsIndirectBindlessNV;

extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSCOUNTNVPROC __glewMultiDrawArraysIndirectBindlessCountNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSCOUNTNVPROC __glewMultiDrawElementsIndirectBindlessCountNV;

extern __attribute__ ((visibility("default"))) PFNGLGETIMAGEHANDLENVPROC __glewGetImageHandleNV;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTUREHANDLENVPROC __glewGetTextureHandleNV;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXTURESAMPLERHANDLENVPROC __glewGetTextureSamplerHandleNV;
extern __attribute__ ((visibility("default"))) PFNGLISIMAGEHANDLERESIDENTNVPROC __glewIsImageHandleResidentNV;
extern __attribute__ ((visibility("default"))) PFNGLISTEXTUREHANDLERESIDENTNVPROC __glewIsTextureHandleResidentNV;
extern __attribute__ ((visibility("default"))) PFNGLMAKEIMAGEHANDLENONRESIDENTNVPROC __glewMakeImageHandleNonResidentNV;
extern __attribute__ ((visibility("default"))) PFNGLMAKEIMAGEHANDLERESIDENTNVPROC __glewMakeImageHandleResidentNV;
extern __attribute__ ((visibility("default"))) PFNGLMAKETEXTUREHANDLENONRESIDENTNVPROC __glewMakeTextureHandleNonResidentNV;
extern __attribute__ ((visibility("default"))) PFNGLMAKETEXTUREHANDLERESIDENTNVPROC __glewMakeTextureHandleResidentNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMHANDLEUI64NVPROC __glewProgramUniformHandleui64NV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMHANDLEUI64VNVPROC __glewProgramUniformHandleui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMHANDLEUI64NVPROC __glewUniformHandleui64NV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMHANDLEUI64VNVPROC __glewUniformHandleui64vNV;

extern __attribute__ ((visibility("default"))) PFNGLBLENDBARRIERNVPROC __glewBlendBarrierNV;
extern __attribute__ ((visibility("default"))) PFNGLBLENDPARAMETERINVPROC __glewBlendParameteriNV;

extern __attribute__ ((visibility("default"))) PFNGLVIEWPORTPOSITIONWSCALENVPROC __glewViewportPositionWScaleNV;

extern __attribute__ ((visibility("default"))) PFNGLCALLCOMMANDLISTNVPROC __glewCallCommandListNV;
extern __attribute__ ((visibility("default"))) PFNGLCOMMANDLISTSEGMENTSNVPROC __glewCommandListSegmentsNV;
extern __attribute__ ((visibility("default"))) PFNGLCOMPILECOMMANDLISTNVPROC __glewCompileCommandListNV;
extern __attribute__ ((visibility("default"))) PFNGLCREATECOMMANDLISTSNVPROC __glewCreateCommandListsNV;
extern __attribute__ ((visibility("default"))) PFNGLCREATESTATESNVPROC __glewCreateStatesNV;
extern __attribute__ ((visibility("default"))) PFNGLDELETECOMMANDLISTSNVPROC __glewDeleteCommandListsNV;
extern __attribute__ ((visibility("default"))) PFNGLDELETESTATESNVPROC __glewDeleteStatesNV;
extern __attribute__ ((visibility("default"))) PFNGLDRAWCOMMANDSADDRESSNVPROC __glewDrawCommandsAddressNV;
extern __attribute__ ((visibility("default"))) PFNGLDRAWCOMMANDSNVPROC __glewDrawCommandsNV;
extern __attribute__ ((visibility("default"))) PFNGLDRAWCOMMANDSSTATESADDRESSNVPROC __glewDrawCommandsStatesAddressNV;
extern __attribute__ ((visibility("default"))) PFNGLDRAWCOMMANDSSTATESNVPROC __glewDrawCommandsStatesNV;
extern __attribute__ ((visibility("default"))) PFNGLGETCOMMANDHEADERNVPROC __glewGetCommandHeaderNV;
extern __attribute__ ((visibility("default"))) PFNGLGETSTAGEINDEXNVPROC __glewGetStageIndexNV;
extern __attribute__ ((visibility("default"))) PFNGLISCOMMANDLISTNVPROC __glewIsCommandListNV;
extern __attribute__ ((visibility("default"))) PFNGLISSTATENVPROC __glewIsStateNV;
extern __attribute__ ((visibility("default"))) PFNGLLISTDRAWCOMMANDSSTATESCLIENTNVPROC __glewListDrawCommandsStatesClientNV;
extern __attribute__ ((visibility("default"))) PFNGLSTATECAPTURENVPROC __glewStateCaptureNV;

extern __attribute__ ((visibility("default"))) PFNGLBEGINCONDITIONALRENDERNVPROC __glewBeginConditionalRenderNV;
extern __attribute__ ((visibility("default"))) PFNGLENDCONDITIONALRENDERNVPROC __glewEndConditionalRenderNV;

extern __attribute__ ((visibility("default"))) PFNGLSUBPIXELPRECISIONBIASNVPROC __glewSubpixelPrecisionBiasNV;

extern __attribute__ ((visibility("default"))) PFNGLCONSERVATIVERASTERPARAMETERFNVPROC __glewConservativeRasterParameterfNV;

extern __attribute__ ((visibility("default"))) PFNGLCONSERVATIVERASTERPARAMETERINVPROC __glewConservativeRasterParameteriNV;

extern __attribute__ ((visibility("default"))) PFNGLCOPYBUFFERSUBDATANVPROC __glewCopyBufferSubDataNV;

extern __attribute__ ((visibility("default"))) PFNGLCOPYIMAGESUBDATANVPROC __glewCopyImageSubDataNV;

extern __attribute__ ((visibility("default"))) PFNGLCLEARDEPTHDNVPROC __glewClearDepthdNV;
extern __attribute__ ((visibility("default"))) PFNGLDEPTHBOUNDSDNVPROC __glewDepthBoundsdNV;
extern __attribute__ ((visibility("default"))) PFNGLDEPTHRANGEDNVPROC __glewDepthRangedNV;

extern __attribute__ ((visibility("default"))) PFNGLDRAWBUFFERSNVPROC __glewDrawBuffersNV;

extern __attribute__ ((visibility("default"))) PFNGLDRAWARRAYSINSTANCEDNVPROC __glewDrawArraysInstancedNV;
extern __attribute__ ((visibility("default"))) PFNGLDRAWELEMENTSINSTANCEDNVPROC __glewDrawElementsInstancedNV;

extern __attribute__ ((visibility("default"))) PFNGLDRAWTEXTURENVPROC __glewDrawTextureNV;

extern __attribute__ ((visibility("default"))) PFNGLDRAWVKIMAGENVPROC __glewDrawVkImageNV;
extern __attribute__ ((visibility("default"))) PFNGLGETVKPROCADDRNVPROC __glewGetVkProcAddrNV;
extern __attribute__ ((visibility("default"))) PFNGLSIGNALVKFENCENVPROC __glewSignalVkFenceNV;
extern __attribute__ ((visibility("default"))) PFNGLSIGNALVKSEMAPHORENVPROC __glewSignalVkSemaphoreNV;
extern __attribute__ ((visibility("default"))) PFNGLWAITVKSEMAPHORENVPROC __glewWaitVkSemaphoreNV;

extern __attribute__ ((visibility("default"))) PFNGLEVALMAPSNVPROC __glewEvalMapsNV;
extern __attribute__ ((visibility("default"))) PFNGLGETMAPATTRIBPARAMETERFVNVPROC __glewGetMapAttribParameterfvNV;
extern __attribute__ ((visibility("default"))) PFNGLGETMAPATTRIBPARAMETERIVNVPROC __glewGetMapAttribParameterivNV;
extern __attribute__ ((visibility("default"))) PFNGLGETMAPCONTROLPOINTSNVPROC __glewGetMapControlPointsNV;
extern __attribute__ ((visibility("default"))) PFNGLGETMAPPARAMETERFVNVPROC __glewGetMapParameterfvNV;
extern __attribute__ ((visibility("default"))) PFNGLGETMAPPARAMETERIVNVPROC __glewGetMapParameterivNV;
extern __attribute__ ((visibility("default"))) PFNGLMAPCONTROLPOINTSNVPROC __glewMapControlPointsNV;
extern __attribute__ ((visibility("default"))) PFNGLMAPPARAMETERFVNVPROC __glewMapParameterfvNV;
extern __attribute__ ((visibility("default"))) PFNGLMAPPARAMETERIVNVPROC __glewMapParameterivNV;

extern __attribute__ ((visibility("default"))) PFNGLGETMULTISAMPLEFVNVPROC __glewGetMultisamplefvNV;
extern __attribute__ ((visibility("default"))) PFNGLSAMPLEMASKINDEXEDNVPROC __glewSampleMaskIndexedNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXRENDERBUFFERNVPROC __glewTexRenderbufferNV;

extern __attribute__ ((visibility("default"))) PFNGLDELETEFENCESNVPROC __glewDeleteFencesNV;
extern __attribute__ ((visibility("default"))) PFNGLFINISHFENCENVPROC __glewFinishFenceNV;
extern __attribute__ ((visibility("default"))) PFNGLGENFENCESNVPROC __glewGenFencesNV;
extern __attribute__ ((visibility("default"))) PFNGLGETFENCEIVNVPROC __glewGetFenceivNV;
extern __attribute__ ((visibility("default"))) PFNGLISFENCENVPROC __glewIsFenceNV;
extern __attribute__ ((visibility("default"))) PFNGLSETFENCENVPROC __glewSetFenceNV;
extern __attribute__ ((visibility("default"))) PFNGLTESTFENCENVPROC __glewTestFenceNV;

extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTCOVERAGECOLORNVPROC __glewFragmentCoverageColorNV;

extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMNAMEDPARAMETERDVNVPROC __glewGetProgramNamedParameterdvNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMNAMEDPARAMETERFVNVPROC __glewGetProgramNamedParameterfvNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMNAMEDPARAMETER4DNVPROC __glewProgramNamedParameter4dNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMNAMEDPARAMETER4DVNVPROC __glewProgramNamedParameter4dvNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMNAMEDPARAMETER4FNVPROC __glewProgramNamedParameter4fNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMNAMEDPARAMETER4FVNVPROC __glewProgramNamedParameter4fvNV;

extern __attribute__ ((visibility("default"))) PFNGLBLITFRAMEBUFFERNVPROC __glewBlitFramebufferNV;

extern __attribute__ ((visibility("default"))) PFNGLRENDERBUFFERSTORAGEMULTISAMPLENVPROC __glewRenderbufferStorageMultisampleNV;

extern __attribute__ ((visibility("default"))) PFNGLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENVPROC __glewRenderbufferStorageMultisampleCoverageNV;

extern __attribute__ ((visibility("default"))) PFNGLPROGRAMVERTEXLIMITNVPROC __glewProgramVertexLimitNV;

extern __attribute__ ((visibility("default"))) PFNGLMULTICASTBARRIERNVPROC __glewMulticastBarrierNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTICASTBLITFRAMEBUFFERNVPROC __glewMulticastBlitFramebufferNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTICASTBUFFERSUBDATANVPROC __glewMulticastBufferSubDataNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTICASTCOPYBUFFERSUBDATANVPROC __glewMulticastCopyBufferSubDataNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTICASTCOPYIMAGESUBDATANVPROC __glewMulticastCopyImageSubDataNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTICASTFRAMEBUFFERSAMPLELOCATIONSFVNVPROC __glewMulticastFramebufferSampleLocationsfvNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTICASTGETQUERYOBJECTI64VNVPROC __glewMulticastGetQueryObjecti64vNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTICASTGETQUERYOBJECTIVNVPROC __glewMulticastGetQueryObjectivNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTICASTGETQUERYOBJECTUI64VNVPROC __glewMulticastGetQueryObjectui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTICASTGETQUERYOBJECTUIVNVPROC __glewMulticastGetQueryObjectuivNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTICASTWAITSYNCNVPROC __glewMulticastWaitSyncNV;
extern __attribute__ ((visibility("default"))) PFNGLRENDERGPUMASKNVPROC __glewRenderGpuMaskNV;

extern __attribute__ ((visibility("default"))) PFNGLPROGRAMENVPARAMETERI4INVPROC __glewProgramEnvParameterI4iNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMENVPARAMETERI4IVNVPROC __glewProgramEnvParameterI4ivNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMENVPARAMETERI4UINVPROC __glewProgramEnvParameterI4uiNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMENVPARAMETERI4UIVNVPROC __glewProgramEnvParameterI4uivNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMENVPARAMETERSI4IVNVPROC __glewProgramEnvParametersI4ivNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMENVPARAMETERSI4UIVNVPROC __glewProgramEnvParametersI4uivNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMLOCALPARAMETERI4INVPROC __glewProgramLocalParameterI4iNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMLOCALPARAMETERI4IVNVPROC __glewProgramLocalParameterI4ivNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMLOCALPARAMETERI4UINVPROC __glewProgramLocalParameterI4uiNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMLOCALPARAMETERI4UIVNVPROC __glewProgramLocalParameterI4uivNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMLOCALPARAMETERSI4IVNVPROC __glewProgramLocalParametersI4ivNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMLOCALPARAMETERSI4UIVNVPROC __glewProgramLocalParametersI4uivNV;

extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMI64VNVPROC __glewGetUniformi64vNV;
extern __attribute__ ((visibility("default"))) PFNGLGETUNIFORMUI64VNVPROC __glewGetUniformui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1I64NVPROC __glewProgramUniform1i64NV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1I64VNVPROC __glewProgramUniform1i64vNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1UI64NVPROC __glewProgramUniform1ui64NV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM1UI64VNVPROC __glewProgramUniform1ui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2I64NVPROC __glewProgramUniform2i64NV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2I64VNVPROC __glewProgramUniform2i64vNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2UI64NVPROC __glewProgramUniform2ui64NV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM2UI64VNVPROC __glewProgramUniform2ui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3I64NVPROC __glewProgramUniform3i64NV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3I64VNVPROC __glewProgramUniform3i64vNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3UI64NVPROC __glewProgramUniform3ui64NV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM3UI64VNVPROC __glewProgramUniform3ui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4I64NVPROC __glewProgramUniform4i64NV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4I64VNVPROC __glewProgramUniform4i64vNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4UI64NVPROC __glewProgramUniform4ui64NV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORM4UI64VNVPROC __glewProgramUniform4ui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1I64NVPROC __glewUniform1i64NV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1I64VNVPROC __glewUniform1i64vNV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1UI64NVPROC __glewUniform1ui64NV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM1UI64VNVPROC __glewUniform1ui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2I64NVPROC __glewUniform2i64NV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2I64VNVPROC __glewUniform2i64vNV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2UI64NVPROC __glewUniform2ui64NV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM2UI64VNVPROC __glewUniform2ui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3I64NVPROC __glewUniform3i64NV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3I64VNVPROC __glewUniform3i64vNV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3UI64NVPROC __glewUniform3ui64NV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM3UI64VNVPROC __glewUniform3ui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4I64NVPROC __glewUniform4i64NV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4I64VNVPROC __glewUniform4i64vNV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4UI64NVPROC __glewUniform4ui64NV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORM4UI64VNVPROC __glewUniform4ui64vNV;

extern __attribute__ ((visibility("default"))) PFNGLCOLOR3HNVPROC __glewColor3hNV;
extern __attribute__ ((visibility("default"))) PFNGLCOLOR3HVNVPROC __glewColor3hvNV;
extern __attribute__ ((visibility("default"))) PFNGLCOLOR4HNVPROC __glewColor4hNV;
extern __attribute__ ((visibility("default"))) PFNGLCOLOR4HVNVPROC __glewColor4hvNV;
extern __attribute__ ((visibility("default"))) PFNGLFOGCOORDHNVPROC __glewFogCoordhNV;
extern __attribute__ ((visibility("default"))) PFNGLFOGCOORDHVNVPROC __glewFogCoordhvNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1HNVPROC __glewMultiTexCoord1hNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD1HVNVPROC __glewMultiTexCoord1hvNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2HNVPROC __glewMultiTexCoord2hNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD2HVNVPROC __glewMultiTexCoord2hvNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3HNVPROC __glewMultiTexCoord3hNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD3HVNVPROC __glewMultiTexCoord3hvNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4HNVPROC __glewMultiTexCoord4hNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4HVNVPROC __glewMultiTexCoord4hvNV;
extern __attribute__ ((visibility("default"))) PFNGLNORMAL3HNVPROC __glewNormal3hNV;
extern __attribute__ ((visibility("default"))) PFNGLNORMAL3HVNVPROC __glewNormal3hvNV;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3HNVPROC __glewSecondaryColor3hNV;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLOR3HVNVPROC __glewSecondaryColor3hvNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD1HNVPROC __glewTexCoord1hNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD1HVNVPROC __glewTexCoord1hvNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD2HNVPROC __glewTexCoord2hNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD2HVNVPROC __glewTexCoord2hvNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD3HNVPROC __glewTexCoord3hNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD3HVNVPROC __glewTexCoord3hvNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD4HNVPROC __glewTexCoord4hNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD4HVNVPROC __glewTexCoord4hvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEX2HNVPROC __glewVertex2hNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEX2HVNVPROC __glewVertex2hvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEX3HNVPROC __glewVertex3hNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEX3HVNVPROC __glewVertex3hvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEX4HNVPROC __glewVertex4hNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEX4HVNVPROC __glewVertex4hvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1HNVPROC __glewVertexAttrib1hNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1HVNVPROC __glewVertexAttrib1hvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2HNVPROC __glewVertexAttrib2hNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2HVNVPROC __glewVertexAttrib2hvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3HNVPROC __glewVertexAttrib3hNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3HVNVPROC __glewVertexAttrib3hvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4HNVPROC __glewVertexAttrib4hNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4HVNVPROC __glewVertexAttrib4hvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS1HVNVPROC __glewVertexAttribs1hvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS2HVNVPROC __glewVertexAttribs2hvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS3HVNVPROC __glewVertexAttribs3hvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS4HVNVPROC __glewVertexAttribs4hvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXWEIGHTHNVPROC __glewVertexWeighthNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXWEIGHTHVNVPROC __glewVertexWeighthvNV;

extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBDIVISORNVPROC __glewVertexAttribDivisorNV;

extern __attribute__ ((visibility("default"))) PFNGLGETINTERNALFORMATSAMPLEIVNVPROC __glewGetInternalformatSampleivNV;

extern __attribute__ ((visibility("default"))) PFNGLBUFFERATTACHMEMORYNVPROC __glewBufferAttachMemoryNV;
extern __attribute__ ((visibility("default"))) PFNGLGETMEMORYOBJECTDETACHEDRESOURCESUIVNVPROC __glewGetMemoryObjectDetachedResourcesuivNV;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDBUFFERATTACHMEMORYNVPROC __glewNamedBufferAttachMemoryNV;
extern __attribute__ ((visibility("default"))) PFNGLRESETMEMORYOBJECTPARAMETERNVPROC __glewResetMemoryObjectParameterNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXATTACHMEMORYNVPROC __glewTexAttachMemoryNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREATTACHMEMORYNVPROC __glewTextureAttachMemoryNV;

extern __attribute__ ((visibility("default"))) PFNGLDRAWMESHTASKSINDIRECTNVPROC __glewDrawMeshTasksIndirectNV;
extern __attribute__ ((visibility("default"))) PFNGLDRAWMESHTASKSNVPROC __glewDrawMeshTasksNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWMESHTASKSINDIRECTCOUNTNVPROC __glewMultiDrawMeshTasksIndirectCountNV;
extern __attribute__ ((visibility("default"))) PFNGLMULTIDRAWMESHTASKSINDIRECTNVPROC __glewMultiDrawMeshTasksIndirectNV;

extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX2X3FVNVPROC __glewUniformMatrix2x3fvNV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX2X4FVNVPROC __glewUniformMatrix2x4fvNV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX3X2FVNVPROC __glewUniformMatrix3x2fvNV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX3X4FVNVPROC __glewUniformMatrix3x4fvNV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX4X2FVNVPROC __glewUniformMatrix4x2fvNV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMMATRIX4X3FVNVPROC __glewUniformMatrix4x3fvNV;

extern __attribute__ ((visibility("default"))) PFNGLBEGINOCCLUSIONQUERYNVPROC __glewBeginOcclusionQueryNV;
extern __attribute__ ((visibility("default"))) PFNGLDELETEOCCLUSIONQUERIESNVPROC __glewDeleteOcclusionQueriesNV;
extern __attribute__ ((visibility("default"))) PFNGLENDOCCLUSIONQUERYNVPROC __glewEndOcclusionQueryNV;
extern __attribute__ ((visibility("default"))) PFNGLGENOCCLUSIONQUERIESNVPROC __glewGenOcclusionQueriesNV;
extern __attribute__ ((visibility("default"))) PFNGLGETOCCLUSIONQUERYIVNVPROC __glewGetOcclusionQueryivNV;
extern __attribute__ ((visibility("default"))) PFNGLGETOCCLUSIONQUERYUIVNVPROC __glewGetOcclusionQueryuivNV;
extern __attribute__ ((visibility("default"))) PFNGLISOCCLUSIONQUERYNVPROC __glewIsOcclusionQueryNV;

extern __attribute__ ((visibility("default"))) PFNGLPROGRAMBUFFERPARAMETERSIIVNVPROC __glewProgramBufferParametersIivNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMBUFFERPARAMETERSIUIVNVPROC __glewProgramBufferParametersIuivNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMBUFFERPARAMETERSFVNVPROC __glewProgramBufferParametersfvNV;

extern __attribute__ ((visibility("default"))) PFNGLCOPYPATHNVPROC __glewCopyPathNV;
extern __attribute__ ((visibility("default"))) PFNGLCOVERFILLPATHINSTANCEDNVPROC __glewCoverFillPathInstancedNV;
extern __attribute__ ((visibility("default"))) PFNGLCOVERFILLPATHNVPROC __glewCoverFillPathNV;
extern __attribute__ ((visibility("default"))) PFNGLCOVERSTROKEPATHINSTANCEDNVPROC __glewCoverStrokePathInstancedNV;
extern __attribute__ ((visibility("default"))) PFNGLCOVERSTROKEPATHNVPROC __glewCoverStrokePathNV;
extern __attribute__ ((visibility("default"))) PFNGLDELETEPATHSNVPROC __glewDeletePathsNV;
extern __attribute__ ((visibility("default"))) PFNGLGENPATHSNVPROC __glewGenPathsNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPATHCOLORGENFVNVPROC __glewGetPathColorGenfvNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPATHCOLORGENIVNVPROC __glewGetPathColorGenivNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPATHCOMMANDSNVPROC __glewGetPathCommandsNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPATHCOORDSNVPROC __glewGetPathCoordsNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPATHDASHARRAYNVPROC __glewGetPathDashArrayNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPATHLENGTHNVPROC __glewGetPathLengthNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPATHMETRICRANGENVPROC __glewGetPathMetricRangeNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPATHMETRICSNVPROC __glewGetPathMetricsNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPATHPARAMETERFVNVPROC __glewGetPathParameterfvNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPATHPARAMETERIVNVPROC __glewGetPathParameterivNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPATHSPACINGNVPROC __glewGetPathSpacingNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPATHTEXGENFVNVPROC __glewGetPathTexGenfvNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPATHTEXGENIVNVPROC __glewGetPathTexGenivNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMRESOURCEFVNVPROC __glewGetProgramResourcefvNV;
extern __attribute__ ((visibility("default"))) PFNGLINTERPOLATEPATHSNVPROC __glewInterpolatePathsNV;
extern __attribute__ ((visibility("default"))) PFNGLISPATHNVPROC __glewIsPathNV;
extern __attribute__ ((visibility("default"))) PFNGLISPOINTINFILLPATHNVPROC __glewIsPointInFillPathNV;
extern __attribute__ ((visibility("default"))) PFNGLISPOINTINSTROKEPATHNVPROC __glewIsPointInStrokePathNV;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXLOAD3X2FNVPROC __glewMatrixLoad3x2fNV;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXLOAD3X3FNVPROC __glewMatrixLoad3x3fNV;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXLOADTRANSPOSE3X3FNVPROC __glewMatrixLoadTranspose3x3fNV;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXMULT3X2FNVPROC __glewMatrixMult3x2fNV;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXMULT3X3FNVPROC __glewMatrixMult3x3fNV;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXMULTTRANSPOSE3X3FNVPROC __glewMatrixMultTranspose3x3fNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHCOLORGENNVPROC __glewPathColorGenNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHCOMMANDSNVPROC __glewPathCommandsNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHCOORDSNVPROC __glewPathCoordsNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHCOVERDEPTHFUNCNVPROC __glewPathCoverDepthFuncNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHDASHARRAYNVPROC __glewPathDashArrayNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHFOGGENNVPROC __glewPathFogGenNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHGLYPHINDEXARRAYNVPROC __glewPathGlyphIndexArrayNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHGLYPHINDEXRANGENVPROC __glewPathGlyphIndexRangeNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHGLYPHRANGENVPROC __glewPathGlyphRangeNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHGLYPHSNVPROC __glewPathGlyphsNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHMEMORYGLYPHINDEXARRAYNVPROC __glewPathMemoryGlyphIndexArrayNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHPARAMETERFNVPROC __glewPathParameterfNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHPARAMETERFVNVPROC __glewPathParameterfvNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHPARAMETERINVPROC __glewPathParameteriNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHPARAMETERIVNVPROC __glewPathParameterivNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHSTENCILDEPTHOFFSETNVPROC __glewPathStencilDepthOffsetNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHSTENCILFUNCNVPROC __glewPathStencilFuncNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHSTRINGNVPROC __glewPathStringNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHSUBCOMMANDSNVPROC __glewPathSubCommandsNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHSUBCOORDSNVPROC __glewPathSubCoordsNV;
extern __attribute__ ((visibility("default"))) PFNGLPATHTEXGENNVPROC __glewPathTexGenNV;
extern __attribute__ ((visibility("default"))) PFNGLPOINTALONGPATHNVPROC __glewPointAlongPathNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMPATHFRAGMENTINPUTGENNVPROC __glewProgramPathFragmentInputGenNV;
extern __attribute__ ((visibility("default"))) PFNGLSTENCILFILLPATHINSTANCEDNVPROC __glewStencilFillPathInstancedNV;
extern __attribute__ ((visibility("default"))) PFNGLSTENCILFILLPATHNVPROC __glewStencilFillPathNV;
extern __attribute__ ((visibility("default"))) PFNGLSTENCILSTROKEPATHINSTANCEDNVPROC __glewStencilStrokePathInstancedNV;
extern __attribute__ ((visibility("default"))) PFNGLSTENCILSTROKEPATHNVPROC __glewStencilStrokePathNV;
extern __attribute__ ((visibility("default"))) PFNGLSTENCILTHENCOVERFILLPATHINSTANCEDNVPROC __glewStencilThenCoverFillPathInstancedNV;
extern __attribute__ ((visibility("default"))) PFNGLSTENCILTHENCOVERFILLPATHNVPROC __glewStencilThenCoverFillPathNV;
extern __attribute__ ((visibility("default"))) PFNGLSTENCILTHENCOVERSTROKEPATHINSTANCEDNVPROC __glewStencilThenCoverStrokePathInstancedNV;
extern __attribute__ ((visibility("default"))) PFNGLSTENCILTHENCOVERSTROKEPATHNVPROC __glewStencilThenCoverStrokePathNV;
extern __attribute__ ((visibility("default"))) PFNGLTRANSFORMPATHNVPROC __glewTransformPathNV;
extern __attribute__ ((visibility("default"))) PFNGLWEIGHTPATHSNVPROC __glewWeightPathsNV;

extern __attribute__ ((visibility("default"))) PFNGLFLUSHPIXELDATARANGENVPROC __glewFlushPixelDataRangeNV;
extern __attribute__ ((visibility("default"))) PFNGLPIXELDATARANGENVPROC __glewPixelDataRangeNV;

extern __attribute__ ((visibility("default"))) PFNGLPOINTPARAMETERINVPROC __glewPointParameteriNV;
extern __attribute__ ((visibility("default"))) PFNGLPOINTPARAMETERIVNVPROC __glewPointParameterivNV;

extern __attribute__ ((visibility("default"))) PFNGLPOLYGONMODENVPROC __glewPolygonModeNV;

extern __attribute__ ((visibility("default"))) PFNGLGETVIDEOI64VNVPROC __glewGetVideoi64vNV;
extern __attribute__ ((visibility("default"))) PFNGLGETVIDEOIVNVPROC __glewGetVideoivNV;
extern __attribute__ ((visibility("default"))) PFNGLGETVIDEOUI64VNVPROC __glewGetVideoui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLGETVIDEOUIVNVPROC __glewGetVideouivNV;
extern __attribute__ ((visibility("default"))) PFNGLPRESENTFRAMEDUALFILLNVPROC __glewPresentFrameDualFillNV;
extern __attribute__ ((visibility("default"))) PFNGLPRESENTFRAMEKEYEDNVPROC __glewPresentFrameKeyedNV;

extern __attribute__ ((visibility("default"))) PFNGLPRIMITIVERESTARTINDEXNVPROC __glewPrimitiveRestartIndexNV;
extern __attribute__ ((visibility("default"))) PFNGLPRIMITIVERESTARTNVPROC __glewPrimitiveRestartNV;

extern __attribute__ ((visibility("default"))) PFNGLREADBUFFERNVPROC __glewReadBufferNV;

extern __attribute__ ((visibility("default"))) PFNGLCOMBINERINPUTNVPROC __glewCombinerInputNV;
extern __attribute__ ((visibility("default"))) PFNGLCOMBINEROUTPUTNVPROC __glewCombinerOutputNV;
extern __attribute__ ((visibility("default"))) PFNGLCOMBINERPARAMETERFNVPROC __glewCombinerParameterfNV;
extern __attribute__ ((visibility("default"))) PFNGLCOMBINERPARAMETERFVNVPROC __glewCombinerParameterfvNV;
extern __attribute__ ((visibility("default"))) PFNGLCOMBINERPARAMETERINVPROC __glewCombinerParameteriNV;
extern __attribute__ ((visibility("default"))) PFNGLCOMBINERPARAMETERIVNVPROC __glewCombinerParameterivNV;
extern __attribute__ ((visibility("default"))) PFNGLFINALCOMBINERINPUTNVPROC __glewFinalCombinerInputNV;
extern __attribute__ ((visibility("default"))) PFNGLGETCOMBINERINPUTPARAMETERFVNVPROC __glewGetCombinerInputParameterfvNV;
extern __attribute__ ((visibility("default"))) PFNGLGETCOMBINERINPUTPARAMETERIVNVPROC __glewGetCombinerInputParameterivNV;
extern __attribute__ ((visibility("default"))) PFNGLGETCOMBINEROUTPUTPARAMETERFVNVPROC __glewGetCombinerOutputParameterfvNV;
extern __attribute__ ((visibility("default"))) PFNGLGETCOMBINEROUTPUTPARAMETERIVNVPROC __glewGetCombinerOutputParameterivNV;
extern __attribute__ ((visibility("default"))) PFNGLGETFINALCOMBINERINPUTPARAMETERFVNVPROC __glewGetFinalCombinerInputParameterfvNV;
extern __attribute__ ((visibility("default"))) PFNGLGETFINALCOMBINERINPUTPARAMETERIVNVPROC __glewGetFinalCombinerInputParameterivNV;

extern __attribute__ ((visibility("default"))) PFNGLCOMBINERSTAGEPARAMETERFVNVPROC __glewCombinerStageParameterfvNV;
extern __attribute__ ((visibility("default"))) PFNGLGETCOMBINERSTAGEPARAMETERFVNVPROC __glewGetCombinerStageParameterfvNV;

extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERSAMPLELOCATIONSFVNVPROC __glewFramebufferSampleLocationsfvNV;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDFRAMEBUFFERSAMPLELOCATIONSFVNVPROC __glewNamedFramebufferSampleLocationsfvNV;
extern __attribute__ ((visibility("default"))) PFNGLRESOLVEDEPTHVALUESNVPROC __glewResolveDepthValuesNV;

extern __attribute__ ((visibility("default"))) PFNGLSCISSOREXCLUSIVEARRAYVNVPROC __glewScissorExclusiveArrayvNV;
extern __attribute__ ((visibility("default"))) PFNGLSCISSOREXCLUSIVENVPROC __glewScissorExclusiveNV;

extern __attribute__ ((visibility("default"))) PFNGLGETBUFFERPARAMETERUI64VNVPROC __glewGetBufferParameterui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLGETINTEGERUI64VNVPROC __glewGetIntegerui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLGETNAMEDBUFFERPARAMETERUI64VNVPROC __glewGetNamedBufferParameterui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLISBUFFERRESIDENTNVPROC __glewIsBufferResidentNV;
extern __attribute__ ((visibility("default"))) PFNGLISNAMEDBUFFERRESIDENTNVPROC __glewIsNamedBufferResidentNV;
extern __attribute__ ((visibility("default"))) PFNGLMAKEBUFFERNONRESIDENTNVPROC __glewMakeBufferNonResidentNV;
extern __attribute__ ((visibility("default"))) PFNGLMAKEBUFFERRESIDENTNVPROC __glewMakeBufferResidentNV;
extern __attribute__ ((visibility("default"))) PFNGLMAKENAMEDBUFFERNONRESIDENTNVPROC __glewMakeNamedBufferNonResidentNV;
extern __attribute__ ((visibility("default"))) PFNGLMAKENAMEDBUFFERRESIDENTNVPROC __glewMakeNamedBufferResidentNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMUI64NVPROC __glewProgramUniformui64NV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMUNIFORMUI64VNVPROC __glewProgramUniformui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMUI64NVPROC __glewUniformui64NV;
extern __attribute__ ((visibility("default"))) PFNGLUNIFORMUI64VNVPROC __glewUniformui64vNV;

extern __attribute__ ((visibility("default"))) PFNGLBINDSHADINGRATEIMAGENVPROC __glewBindShadingRateImageNV;
extern __attribute__ ((visibility("default"))) PFNGLGETSHADINGRATEIMAGEPALETTENVPROC __glewGetShadingRateImagePaletteNV;
extern __attribute__ ((visibility("default"))) PFNGLGETSHADINGRATESAMPLELOCATIONIVNVPROC __glewGetShadingRateSampleLocationivNV;
extern __attribute__ ((visibility("default"))) PFNGLSHADINGRATEIMAGEBARRIERNVPROC __glewShadingRateImageBarrierNV;
extern __attribute__ ((visibility("default"))) PFNGLSHADINGRATEIMAGEPALETTENVPROC __glewShadingRateImagePaletteNV;
extern __attribute__ ((visibility("default"))) PFNGLSHADINGRATESAMPLEORDERCUSTOMNVPROC __glewShadingRateSampleOrderCustomNV;

extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXIMAGE3DNVPROC __glewCompressedTexImage3DNV;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXSUBIMAGE3DNVPROC __glewCompressedTexSubImage3DNV;
extern __attribute__ ((visibility("default"))) PFNGLCOPYTEXSUBIMAGE3DNVPROC __glewCopyTexSubImage3DNV;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTURELAYERNVPROC __glewFramebufferTextureLayerNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXIMAGE3DNVPROC __glewTexImage3DNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXSUBIMAGE3DNVPROC __glewTexSubImage3DNV;

extern __attribute__ ((visibility("default"))) PFNGLTEXTUREBARRIERNVPROC __glewTextureBarrierNV;

extern __attribute__ ((visibility("default"))) PFNGLTEXIMAGE2DMULTISAMPLECOVERAGENVPROC __glewTexImage2DMultisampleCoverageNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXIMAGE3DMULTISAMPLECOVERAGENVPROC __glewTexImage3DMultisampleCoverageNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREIMAGE2DMULTISAMPLECOVERAGENVPROC __glewTextureImage2DMultisampleCoverageNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREIMAGE2DMULTISAMPLENVPROC __glewTextureImage2DMultisampleNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREIMAGE3DMULTISAMPLECOVERAGENVPROC __glewTextureImage3DMultisampleCoverageNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXTUREIMAGE3DMULTISAMPLENVPROC __glewTextureImage3DMultisampleNV;

extern __attribute__ ((visibility("default"))) PFNGLACTIVEVARYINGNVPROC __glewActiveVaryingNV;
extern __attribute__ ((visibility("default"))) PFNGLBEGINTRANSFORMFEEDBACKNVPROC __glewBeginTransformFeedbackNV;
extern __attribute__ ((visibility("default"))) PFNGLBINDBUFFERBASENVPROC __glewBindBufferBaseNV;
extern __attribute__ ((visibility("default"))) PFNGLBINDBUFFEROFFSETNVPROC __glewBindBufferOffsetNV;
extern __attribute__ ((visibility("default"))) PFNGLBINDBUFFERRANGENVPROC __glewBindBufferRangeNV;
extern __attribute__ ((visibility("default"))) PFNGLENDTRANSFORMFEEDBACKNVPROC __glewEndTransformFeedbackNV;
extern __attribute__ ((visibility("default"))) PFNGLGETACTIVEVARYINGNVPROC __glewGetActiveVaryingNV;
extern __attribute__ ((visibility("default"))) PFNGLGETTRANSFORMFEEDBACKVARYINGNVPROC __glewGetTransformFeedbackVaryingNV;
extern __attribute__ ((visibility("default"))) PFNGLGETVARYINGLOCATIONNVPROC __glewGetVaryingLocationNV;
extern __attribute__ ((visibility("default"))) PFNGLTRANSFORMFEEDBACKATTRIBSNVPROC __glewTransformFeedbackAttribsNV;
extern __attribute__ ((visibility("default"))) PFNGLTRANSFORMFEEDBACKVARYINGSNVPROC __glewTransformFeedbackVaryingsNV;

extern __attribute__ ((visibility("default"))) PFNGLBINDTRANSFORMFEEDBACKNVPROC __glewBindTransformFeedbackNV;
extern __attribute__ ((visibility("default"))) PFNGLDELETETRANSFORMFEEDBACKSNVPROC __glewDeleteTransformFeedbacksNV;
extern __attribute__ ((visibility("default"))) PFNGLDRAWTRANSFORMFEEDBACKNVPROC __glewDrawTransformFeedbackNV;
extern __attribute__ ((visibility("default"))) PFNGLGENTRANSFORMFEEDBACKSNVPROC __glewGenTransformFeedbacksNV;
extern __attribute__ ((visibility("default"))) PFNGLISTRANSFORMFEEDBACKNVPROC __glewIsTransformFeedbackNV;
extern __attribute__ ((visibility("default"))) PFNGLPAUSETRANSFORMFEEDBACKNVPROC __glewPauseTransformFeedbackNV;
extern __attribute__ ((visibility("default"))) PFNGLRESUMETRANSFORMFEEDBACKNVPROC __glewResumeTransformFeedbackNV;

extern __attribute__ ((visibility("default"))) PFNGLVDPAUFININVPROC __glewVDPAUFiniNV;
extern __attribute__ ((visibility("default"))) PFNGLVDPAUGETSURFACEIVNVPROC __glewVDPAUGetSurfaceivNV;
extern __attribute__ ((visibility("default"))) PFNGLVDPAUINITNVPROC __glewVDPAUInitNV;
extern __attribute__ ((visibility("default"))) PFNGLVDPAUISSURFACENVPROC __glewVDPAUIsSurfaceNV;
extern __attribute__ ((visibility("default"))) PFNGLVDPAUMAPSURFACESNVPROC __glewVDPAUMapSurfacesNV;
extern __attribute__ ((visibility("default"))) PFNGLVDPAUREGISTEROUTPUTSURFACENVPROC __glewVDPAURegisterOutputSurfaceNV;
extern __attribute__ ((visibility("default"))) PFNGLVDPAUREGISTERVIDEOSURFACENVPROC __glewVDPAURegisterVideoSurfaceNV;
extern __attribute__ ((visibility("default"))) PFNGLVDPAUSURFACEACCESSNVPROC __glewVDPAUSurfaceAccessNV;
extern __attribute__ ((visibility("default"))) PFNGLVDPAUUNMAPSURFACESNVPROC __glewVDPAUUnmapSurfacesNV;
extern __attribute__ ((visibility("default"))) PFNGLVDPAUUNREGISTERSURFACENVPROC __glewVDPAUUnregisterSurfaceNV;

extern __attribute__ ((visibility("default"))) PFNGLVDPAUREGISTERVIDEOSURFACEWITHPICTURESTRUCTURENVPROC __glewVDPAURegisterVideoSurfaceWithPictureStructureNV;

extern __attribute__ ((visibility("default"))) PFNGLFLUSHVERTEXARRAYRANGENVPROC __glewFlushVertexArrayRangeNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXARRAYRANGENVPROC __glewVertexArrayRangeNV;

extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBLI64VNVPROC __glewGetVertexAttribLi64vNV;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBLUI64VNVPROC __glewGetVertexAttribLui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL1I64NVPROC __glewVertexAttribL1i64NV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL1I64VNVPROC __glewVertexAttribL1i64vNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL1UI64NVPROC __glewVertexAttribL1ui64NV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL1UI64VNVPROC __glewVertexAttribL1ui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL2I64NVPROC __glewVertexAttribL2i64NV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL2I64VNVPROC __glewVertexAttribL2i64vNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL2UI64NVPROC __glewVertexAttribL2ui64NV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL2UI64VNVPROC __glewVertexAttribL2ui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL3I64NVPROC __glewVertexAttribL3i64NV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL3I64VNVPROC __glewVertexAttribL3i64vNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL3UI64NVPROC __glewVertexAttribL3ui64NV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL3UI64VNVPROC __glewVertexAttribL3ui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL4I64NVPROC __glewVertexAttribL4i64NV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL4I64VNVPROC __glewVertexAttribL4i64vNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL4UI64NVPROC __glewVertexAttribL4ui64NV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBL4UI64VNVPROC __glewVertexAttribL4ui64vNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBLFORMATNVPROC __glewVertexAttribLFormatNV;

extern __attribute__ ((visibility("default"))) PFNGLBUFFERADDRESSRANGENVPROC __glewBufferAddressRangeNV;
extern __attribute__ ((visibility("default"))) PFNGLCOLORFORMATNVPROC __glewColorFormatNV;
extern __attribute__ ((visibility("default"))) PFNGLEDGEFLAGFORMATNVPROC __glewEdgeFlagFormatNV;
extern __attribute__ ((visibility("default"))) PFNGLFOGCOORDFORMATNVPROC __glewFogCoordFormatNV;
extern __attribute__ ((visibility("default"))) PFNGLGETINTEGERUI64I_VNVPROC __glewGetIntegerui64i_vNV;
extern __attribute__ ((visibility("default"))) PFNGLINDEXFORMATNVPROC __glewIndexFormatNV;
extern __attribute__ ((visibility("default"))) PFNGLNORMALFORMATNVPROC __glewNormalFormatNV;
extern __attribute__ ((visibility("default"))) PFNGLSECONDARYCOLORFORMATNVPROC __glewSecondaryColorFormatNV;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORDFORMATNVPROC __glewTexCoordFormatNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBFORMATNVPROC __glewVertexAttribFormatNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBIFORMATNVPROC __glewVertexAttribIFormatNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXFORMATNVPROC __glewVertexFormatNV;

extern __attribute__ ((visibility("default"))) PFNGLAREPROGRAMSRESIDENTNVPROC __glewAreProgramsResidentNV;
extern __attribute__ ((visibility("default"))) PFNGLBINDPROGRAMNVPROC __glewBindProgramNV;
extern __attribute__ ((visibility("default"))) PFNGLDELETEPROGRAMSNVPROC __glewDeleteProgramsNV;
extern __attribute__ ((visibility("default"))) PFNGLEXECUTEPROGRAMNVPROC __glewExecuteProgramNV;
extern __attribute__ ((visibility("default"))) PFNGLGENPROGRAMSNVPROC __glewGenProgramsNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMPARAMETERDVNVPROC __glewGetProgramParameterdvNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMPARAMETERFVNVPROC __glewGetProgramParameterfvNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMSTRINGNVPROC __glewGetProgramStringNV;
extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMIVNVPROC __glewGetProgramivNV;
extern __attribute__ ((visibility("default"))) PFNGLGETTRACKMATRIXIVNVPROC __glewGetTrackMatrixivNV;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBPOINTERVNVPROC __glewGetVertexAttribPointervNV;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBDVNVPROC __glewGetVertexAttribdvNV;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBFVNVPROC __glewGetVertexAttribfvNV;
extern __attribute__ ((visibility("default"))) PFNGLGETVERTEXATTRIBIVNVPROC __glewGetVertexAttribivNV;
extern __attribute__ ((visibility("default"))) PFNGLISPROGRAMNVPROC __glewIsProgramNV;
extern __attribute__ ((visibility("default"))) PFNGLLOADPROGRAMNVPROC __glewLoadProgramNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMPARAMETER4DNVPROC __glewProgramParameter4dNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMPARAMETER4DVNVPROC __glewProgramParameter4dvNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMPARAMETER4FNVPROC __glewProgramParameter4fNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMPARAMETER4FVNVPROC __glewProgramParameter4fvNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMPARAMETERS4DVNVPROC __glewProgramParameters4dvNV;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMPARAMETERS4FVNVPROC __glewProgramParameters4fvNV;
extern __attribute__ ((visibility("default"))) PFNGLREQUESTRESIDENTPROGRAMSNVPROC __glewRequestResidentProgramsNV;
extern __attribute__ ((visibility("default"))) PFNGLTRACKMATRIXNVPROC __glewTrackMatrixNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1DNVPROC __glewVertexAttrib1dNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1DVNVPROC __glewVertexAttrib1dvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1FNVPROC __glewVertexAttrib1fNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1FVNVPROC __glewVertexAttrib1fvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1SNVPROC __glewVertexAttrib1sNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB1SVNVPROC __glewVertexAttrib1svNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2DNVPROC __glewVertexAttrib2dNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2DVNVPROC __glewVertexAttrib2dvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2FNVPROC __glewVertexAttrib2fNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2FVNVPROC __glewVertexAttrib2fvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2SNVPROC __glewVertexAttrib2sNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB2SVNVPROC __glewVertexAttrib2svNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3DNVPROC __glewVertexAttrib3dNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3DVNVPROC __glewVertexAttrib3dvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3FNVPROC __glewVertexAttrib3fNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3FVNVPROC __glewVertexAttrib3fvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3SNVPROC __glewVertexAttrib3sNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB3SVNVPROC __glewVertexAttrib3svNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4DNVPROC __glewVertexAttrib4dNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4DVNVPROC __glewVertexAttrib4dvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4FNVPROC __glewVertexAttrib4fNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4FVNVPROC __glewVertexAttrib4fvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4SNVPROC __glewVertexAttrib4sNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4SVNVPROC __glewVertexAttrib4svNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4UBNVPROC __glewVertexAttrib4ubNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIB4UBVNVPROC __glewVertexAttrib4ubvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBPOINTERNVPROC __glewVertexAttribPointerNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS1DVNVPROC __glewVertexAttribs1dvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS1FVNVPROC __glewVertexAttribs1fvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS1SVNVPROC __glewVertexAttribs1svNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS2DVNVPROC __glewVertexAttribs2dvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS2FVNVPROC __glewVertexAttribs2fvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS2SVNVPROC __glewVertexAttribs2svNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS3DVNVPROC __glewVertexAttribs3dvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS3FVNVPROC __glewVertexAttribs3fvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS3SVNVPROC __glewVertexAttribs3svNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS4DVNVPROC __glewVertexAttribs4dvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS4FVNVPROC __glewVertexAttribs4fvNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS4SVNVPROC __glewVertexAttribs4svNV;
extern __attribute__ ((visibility("default"))) PFNGLVERTEXATTRIBS4UBVNVPROC __glewVertexAttribs4ubvNV;

extern __attribute__ ((visibility("default"))) PFNGLBEGINVIDEOCAPTURENVPROC __glewBeginVideoCaptureNV;
extern __attribute__ ((visibility("default"))) PFNGLBINDVIDEOCAPTURESTREAMBUFFERNVPROC __glewBindVideoCaptureStreamBufferNV;
extern __attribute__ ((visibility("default"))) PFNGLBINDVIDEOCAPTURESTREAMTEXTURENVPROC __glewBindVideoCaptureStreamTextureNV;
extern __attribute__ ((visibility("default"))) PFNGLENDVIDEOCAPTURENVPROC __glewEndVideoCaptureNV;
extern __attribute__ ((visibility("default"))) PFNGLGETVIDEOCAPTURESTREAMDVNVPROC __glewGetVideoCaptureStreamdvNV;
extern __attribute__ ((visibility("default"))) PFNGLGETVIDEOCAPTURESTREAMFVNVPROC __glewGetVideoCaptureStreamfvNV;
extern __attribute__ ((visibility("default"))) PFNGLGETVIDEOCAPTURESTREAMIVNVPROC __glewGetVideoCaptureStreamivNV;
extern __attribute__ ((visibility("default"))) PFNGLGETVIDEOCAPTUREIVNVPROC __glewGetVideoCaptureivNV;
extern __attribute__ ((visibility("default"))) PFNGLVIDEOCAPTURENVPROC __glewVideoCaptureNV;
extern __attribute__ ((visibility("default"))) PFNGLVIDEOCAPTURESTREAMPARAMETERDVNVPROC __glewVideoCaptureStreamParameterdvNV;
extern __attribute__ ((visibility("default"))) PFNGLVIDEOCAPTURESTREAMPARAMETERFVNVPROC __glewVideoCaptureStreamParameterfvNV;
extern __attribute__ ((visibility("default"))) PFNGLVIDEOCAPTURESTREAMPARAMETERIVNVPROC __glewVideoCaptureStreamParameterivNV;

extern __attribute__ ((visibility("default"))) PFNGLDEPTHRANGEARRAYFVNVPROC __glewDepthRangeArrayfvNV;
extern __attribute__ ((visibility("default"))) PFNGLDEPTHRANGEINDEXEDFNVPROC __glewDepthRangeIndexedfNV;
extern __attribute__ ((visibility("default"))) PFNGLDISABLEINVPROC __glewDisableiNV;
extern __attribute__ ((visibility("default"))) PFNGLENABLEINVPROC __glewEnableiNV;
extern __attribute__ ((visibility("default"))) PFNGLGETFLOATI_VNVPROC __glewGetFloati_vNV;
extern __attribute__ ((visibility("default"))) PFNGLISENABLEDINVPROC __glewIsEnablediNV;
extern __attribute__ ((visibility("default"))) PFNGLSCISSORARRAYVNVPROC __glewScissorArrayvNV;
extern __attribute__ ((visibility("default"))) PFNGLSCISSORINDEXEDNVPROC __glewScissorIndexedNV;
extern __attribute__ ((visibility("default"))) PFNGLSCISSORINDEXEDVNVPROC __glewScissorIndexedvNV;
extern __attribute__ ((visibility("default"))) PFNGLVIEWPORTARRAYVNVPROC __glewViewportArrayvNV;
extern __attribute__ ((visibility("default"))) PFNGLVIEWPORTINDEXEDFNVPROC __glewViewportIndexedfNV;
extern __attribute__ ((visibility("default"))) PFNGLVIEWPORTINDEXEDFVNVPROC __glewViewportIndexedfvNV;

extern __attribute__ ((visibility("default"))) PFNGLVIEWPORTSWIZZLENVPROC __glewViewportSwizzleNV;

extern __attribute__ ((visibility("default"))) PFNGLEGLIMAGETARGETRENDERBUFFERSTORAGEOESPROC __glewEGLImageTargetRenderbufferStorageOES;
extern __attribute__ ((visibility("default"))) PFNGLEGLIMAGETARGETTEXTURE2DOESPROC __glewEGLImageTargetTexture2DOES;

extern __attribute__ ((visibility("default"))) PFNGLBLENDEQUATIONSEPARATEOESPROC __glewBlendEquationSeparateOES;

extern __attribute__ ((visibility("default"))) PFNGLBLENDFUNCSEPARATEOESPROC __glewBlendFuncSeparateOES;

extern __attribute__ ((visibility("default"))) PFNGLBLENDEQUATIONOESPROC __glewBlendEquationOES;

extern __attribute__ ((visibility("default"))) PFNGLCOPYIMAGESUBDATAOESPROC __glewCopyImageSubDataOES;

extern __attribute__ ((visibility("default"))) PFNGLBLENDEQUATIONSEPARATEIOESPROC __glewBlendEquationSeparateiOES;
extern __attribute__ ((visibility("default"))) PFNGLBLENDEQUATIONIOESPROC __glewBlendEquationiOES;
extern __attribute__ ((visibility("default"))) PFNGLBLENDFUNCSEPARATEIOESPROC __glewBlendFuncSeparateiOES;
extern __attribute__ ((visibility("default"))) PFNGLBLENDFUNCIOESPROC __glewBlendFunciOES;
extern __attribute__ ((visibility("default"))) PFNGLCOLORMASKIOESPROC __glewColorMaskiOES;
extern __attribute__ ((visibility("default"))) PFNGLDISABLEIOESPROC __glewDisableiOES;
extern __attribute__ ((visibility("default"))) PFNGLENABLEIOESPROC __glewEnableiOES;
extern __attribute__ ((visibility("default"))) PFNGLISENABLEDIOESPROC __glewIsEnablediOES;

extern __attribute__ ((visibility("default"))) PFNGLBINDFRAMEBUFFEROESPROC __glewBindFramebufferOES;
extern __attribute__ ((visibility("default"))) PFNGLBINDRENDERBUFFEROESPROC __glewBindRenderbufferOES;
extern __attribute__ ((visibility("default"))) PFNGLCHECKFRAMEBUFFERSTATUSOESPROC __glewCheckFramebufferStatusOES;
extern __attribute__ ((visibility("default"))) PFNGLDELETEFRAMEBUFFERSOESPROC __glewDeleteFramebuffersOES;
extern __attribute__ ((visibility("default"))) PFNGLDELETERENDERBUFFERSOESPROC __glewDeleteRenderbuffersOES;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERRENDERBUFFEROESPROC __glewFramebufferRenderbufferOES;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTURE2DOESPROC __glewFramebufferTexture2DOES;
extern __attribute__ ((visibility("default"))) PFNGLGENFRAMEBUFFERSOESPROC __glewGenFramebuffersOES;
extern __attribute__ ((visibility("default"))) PFNGLGENRENDERBUFFERSOESPROC __glewGenRenderbuffersOES;
extern __attribute__ ((visibility("default"))) PFNGLGENERATEMIPMAPOESPROC __glewGenerateMipmapOES;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVOESPROC __glewGetFramebufferAttachmentParameterivOES;
extern __attribute__ ((visibility("default"))) PFNGLGETRENDERBUFFERPARAMETERIVOESPROC __glewGetRenderbufferParameterivOES;
extern __attribute__ ((visibility("default"))) PFNGLISFRAMEBUFFEROESPROC __glewIsFramebufferOES;
extern __attribute__ ((visibility("default"))) PFNGLISRENDERBUFFEROESPROC __glewIsRenderbufferOES;
extern __attribute__ ((visibility("default"))) PFNGLRENDERBUFFERSTORAGEOESPROC __glewRenderbufferStorageOES;

extern __attribute__ ((visibility("default"))) PFNGLGETPROGRAMBINARYOESPROC __glewGetProgramBinaryOES;
extern __attribute__ ((visibility("default"))) PFNGLPROGRAMBINARYOESPROC __glewProgramBinaryOES;

extern __attribute__ ((visibility("default"))) PFNGLGETBUFFERPOINTERVOESPROC __glewGetBufferPointervOES;
extern __attribute__ ((visibility("default"))) PFNGLMAPBUFFEROESPROC __glewMapBufferOES;
extern __attribute__ ((visibility("default"))) PFNGLUNMAPBUFFEROESPROC __glewUnmapBufferOES;

extern __attribute__ ((visibility("default"))) PFNGLCURRENTPALETTEMATRIXOESPROC __glewCurrentPaletteMatrixOES;
extern __attribute__ ((visibility("default"))) PFNGLMATRIXINDEXPOINTEROESPROC __glewMatrixIndexPointerOES;
extern __attribute__ ((visibility("default"))) PFNGLWEIGHTPOINTEROESPROC __glewWeightPointerOES;

extern __attribute__ ((visibility("default"))) PFNGLMINSAMPLESHADINGOESPROC __glewMinSampleShadingOES;

extern __attribute__ ((visibility("default"))) PFNGLCLEARDEPTHFOESPROC __glewClearDepthfOES;
extern __attribute__ ((visibility("default"))) PFNGLCLIPPLANEFOESPROC __glewClipPlanefOES;
extern __attribute__ ((visibility("default"))) PFNGLDEPTHRANGEFOESPROC __glewDepthRangefOES;
extern __attribute__ ((visibility("default"))) PFNGLFRUSTUMFOESPROC __glewFrustumfOES;
extern __attribute__ ((visibility("default"))) PFNGLGETCLIPPLANEFOESPROC __glewGetClipPlanefOES;
extern __attribute__ ((visibility("default"))) PFNGLORTHOFOESPROC __glewOrthofOES;

extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXIMAGE3DOESPROC __glewCompressedTexImage3DOES;
extern __attribute__ ((visibility("default"))) PFNGLCOMPRESSEDTEXSUBIMAGE3DOESPROC __glewCompressedTexSubImage3DOES;
extern __attribute__ ((visibility("default"))) PFNGLCOPYTEXSUBIMAGE3DOESPROC __glewCopyTexSubImage3DOES;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTURE3DOESPROC __glewFramebufferTexture3DOES;
extern __attribute__ ((visibility("default"))) PFNGLTEXIMAGE3DOESPROC __glewTexImage3DOES;
extern __attribute__ ((visibility("default"))) PFNGLTEXSUBIMAGE3DOESPROC __glewTexSubImage3DOES;

extern __attribute__ ((visibility("default"))) PFNGLGETSAMPLERPARAMETERIIVOESPROC __glewGetSamplerParameterIivOES;
extern __attribute__ ((visibility("default"))) PFNGLGETSAMPLERPARAMETERIUIVOESPROC __glewGetSamplerParameterIuivOES;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXPARAMETERIIVOESPROC __glewGetTexParameterIivOES;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXPARAMETERIUIVOESPROC __glewGetTexParameterIuivOES;
extern __attribute__ ((visibility("default"))) PFNGLSAMPLERPARAMETERIIVOESPROC __glewSamplerParameterIivOES;
extern __attribute__ ((visibility("default"))) PFNGLSAMPLERPARAMETERIUIVOESPROC __glewSamplerParameterIuivOES;
extern __attribute__ ((visibility("default"))) PFNGLTEXPARAMETERIIVOESPROC __glewTexParameterIivOES;
extern __attribute__ ((visibility("default"))) PFNGLTEXPARAMETERIUIVOESPROC __glewTexParameterIuivOES;

extern __attribute__ ((visibility("default"))) PFNGLTEXBUFFEROESPROC __glewTexBufferOES;
extern __attribute__ ((visibility("default"))) PFNGLTEXBUFFERRANGEOESPROC __glewTexBufferRangeOES;

extern __attribute__ ((visibility("default"))) PFNGLGETTEXGENFVOESPROC __glewGetTexGenfvOES;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXGENIVOESPROC __glewGetTexGenivOES;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXGENXVOESPROC __glewGetTexGenxvOES;
extern __attribute__ ((visibility("default"))) PFNGLTEXGENFOESPROC __glewTexGenfOES;
extern __attribute__ ((visibility("default"))) PFNGLTEXGENFVOESPROC __glewTexGenfvOES;
extern __attribute__ ((visibility("default"))) PFNGLTEXGENIOESPROC __glewTexGeniOES;
extern __attribute__ ((visibility("default"))) PFNGLTEXGENIVOESPROC __glewTexGenivOES;
extern __attribute__ ((visibility("default"))) PFNGLTEXGENXOESPROC __glewTexGenxOES;
extern __attribute__ ((visibility("default"))) PFNGLTEXGENXVOESPROC __glewTexGenxvOES;

extern __attribute__ ((visibility("default"))) PFNGLTEXSTORAGE3DMULTISAMPLEOESPROC __glewTexStorage3DMultisampleOES;

extern __attribute__ ((visibility("default"))) PFNGLTEXTUREVIEWOESPROC __glewTextureViewOES;

extern __attribute__ ((visibility("default"))) PFNGLBINDVERTEXARRAYOESPROC __glewBindVertexArrayOES;
extern __attribute__ ((visibility("default"))) PFNGLDELETEVERTEXARRAYSOESPROC __glewDeleteVertexArraysOES;
extern __attribute__ ((visibility("default"))) PFNGLGENVERTEXARRAYSOESPROC __glewGenVertexArraysOES;
extern __attribute__ ((visibility("default"))) PFNGLISVERTEXARRAYOESPROC __glewIsVertexArrayOES;

extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTUREMULTIVIEWOVRPROC __glewFramebufferTextureMultiviewOVR;
extern __attribute__ ((visibility("default"))) PFNGLNAMEDFRAMEBUFFERTEXTUREMULTIVIEWOVRPROC __glewNamedFramebufferTextureMultiviewOVR;

extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERTEXTUREMULTISAMPLEMULTIVIEWOVRPROC __glewFramebufferTextureMultisampleMultiviewOVR;

extern __attribute__ ((visibility("default"))) PFNGLALPHAFUNCQCOMPROC __glewAlphaFuncQCOM;

extern __attribute__ ((visibility("default"))) PFNGLDISABLEDRIVERCONTROLQCOMPROC __glewDisableDriverControlQCOM;
extern __attribute__ ((visibility("default"))) PFNGLENABLEDRIVERCONTROLQCOMPROC __glewEnableDriverControlQCOM;
extern __attribute__ ((visibility("default"))) PFNGLGETDRIVERCONTROLSTRINGQCOMPROC __glewGetDriverControlStringQCOM;
extern __attribute__ ((visibility("default"))) PFNGLGETDRIVERCONTROLSQCOMPROC __glewGetDriverControlsQCOM;

extern __attribute__ ((visibility("default"))) PFNGLEXTGETBUFFERPOINTERVQCOMPROC __glewExtGetBufferPointervQCOM;
extern __attribute__ ((visibility("default"))) PFNGLEXTGETBUFFERSQCOMPROC __glewExtGetBuffersQCOM;
extern __attribute__ ((visibility("default"))) PFNGLEXTGETFRAMEBUFFERSQCOMPROC __glewExtGetFramebuffersQCOM;
extern __attribute__ ((visibility("default"))) PFNGLEXTGETRENDERBUFFERSQCOMPROC __glewExtGetRenderbuffersQCOM;
extern __attribute__ ((visibility("default"))) PFNGLEXTGETTEXLEVELPARAMETERIVQCOMPROC __glewExtGetTexLevelParameterivQCOM;
extern __attribute__ ((visibility("default"))) PFNGLEXTGETTEXSUBIMAGEQCOMPROC __glewExtGetTexSubImageQCOM;
extern __attribute__ ((visibility("default"))) PFNGLEXTGETTEXTURESQCOMPROC __glewExtGetTexturesQCOM;
extern __attribute__ ((visibility("default"))) PFNGLEXTTEXOBJECTSTATEOVERRIDEIQCOMPROC __glewExtTexObjectStateOverrideiQCOM;

extern __attribute__ ((visibility("default"))) PFNGLEXTGETPROGRAMBINARYSOURCEQCOMPROC __glewExtGetProgramBinarySourceQCOM;
extern __attribute__ ((visibility("default"))) PFNGLEXTGETPROGRAMSQCOMPROC __glewExtGetProgramsQCOM;
extern __attribute__ ((visibility("default"))) PFNGLEXTGETSHADERSQCOMPROC __glewExtGetShadersQCOM;
extern __attribute__ ((visibility("default"))) PFNGLEXTISPROGRAMBINARYQCOMPROC __glewExtIsProgramBinaryQCOM;

extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERFOVEATIONCONFIGQCOMPROC __glewFramebufferFoveationConfigQCOM;
extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERFOVEATIONPARAMETERSQCOMPROC __glewFramebufferFoveationParametersQCOM;

extern __attribute__ ((visibility("default"))) PFNGLFRAMEBUFFERFETCHBARRIERQCOMPROC __glewFramebufferFetchBarrierQCOM;

extern __attribute__ ((visibility("default"))) PFNGLTEXTUREFOVEATIONPARAMETERSQCOMPROC __glewTextureFoveationParametersQCOM;

extern __attribute__ ((visibility("default"))) PFNGLENDTILINGQCOMPROC __glewEndTilingQCOM;
extern __attribute__ ((visibility("default"))) PFNGLSTARTTILINGQCOMPROC __glewStartTilingQCOM;

extern __attribute__ ((visibility("default"))) PFNGLALPHAFUNCXPROC __glewAlphaFuncx;
extern __attribute__ ((visibility("default"))) PFNGLCLEARCOLORXPROC __glewClearColorx;
extern __attribute__ ((visibility("default"))) PFNGLCLEARDEPTHXPROC __glewClearDepthx;
extern __attribute__ ((visibility("default"))) PFNGLCOLOR4XPROC __glewColor4x;
extern __attribute__ ((visibility("default"))) PFNGLDEPTHRANGEXPROC __glewDepthRangex;
extern __attribute__ ((visibility("default"))) PFNGLFOGXPROC __glewFogx;
extern __attribute__ ((visibility("default"))) PFNGLFOGXVPROC __glewFogxv;
extern __attribute__ ((visibility("default"))) PFNGLFRUSTUMFPROC __glewFrustumf;
extern __attribute__ ((visibility("default"))) PFNGLFRUSTUMXPROC __glewFrustumx;
extern __attribute__ ((visibility("default"))) PFNGLLIGHTMODELXPROC __glewLightModelx;
extern __attribute__ ((visibility("default"))) PFNGLLIGHTMODELXVPROC __glewLightModelxv;
extern __attribute__ ((visibility("default"))) PFNGLLIGHTXPROC __glewLightx;
extern __attribute__ ((visibility("default"))) PFNGLLIGHTXVPROC __glewLightxv;
extern __attribute__ ((visibility("default"))) PFNGLLINEWIDTHXPROC __glewLineWidthx;
extern __attribute__ ((visibility("default"))) PFNGLLOADMATRIXXPROC __glewLoadMatrixx;
extern __attribute__ ((visibility("default"))) PFNGLMATERIALXPROC __glewMaterialx;
extern __attribute__ ((visibility("default"))) PFNGLMATERIALXVPROC __glewMaterialxv;
extern __attribute__ ((visibility("default"))) PFNGLMULTMATRIXXPROC __glewMultMatrixx;
extern __attribute__ ((visibility("default"))) PFNGLMULTITEXCOORD4XPROC __glewMultiTexCoord4x;
extern __attribute__ ((visibility("default"))) PFNGLNORMAL3XPROC __glewNormal3x;
extern __attribute__ ((visibility("default"))) PFNGLORTHOFPROC __glewOrthof;
extern __attribute__ ((visibility("default"))) PFNGLORTHOXPROC __glewOrthox;
extern __attribute__ ((visibility("default"))) PFNGLPOINTSIZEXPROC __glewPointSizex;
extern __attribute__ ((visibility("default"))) PFNGLPOLYGONOFFSETXPROC __glewPolygonOffsetx;
extern __attribute__ ((visibility("default"))) PFNGLROTATEXPROC __glewRotatex;
extern __attribute__ ((visibility("default"))) PFNGLSAMPLECOVERAGEXPROC __glewSampleCoveragex;
extern __attribute__ ((visibility("default"))) PFNGLSCALEXPROC __glewScalex;
extern __attribute__ ((visibility("default"))) PFNGLTEXENVXPROC __glewTexEnvx;
extern __attribute__ ((visibility("default"))) PFNGLTEXENVXVPROC __glewTexEnvxv;
extern __attribute__ ((visibility("default"))) PFNGLTEXPARAMETERXPROC __glewTexParameterx;
extern __attribute__ ((visibility("default"))) PFNGLTRANSLATEXPROC __glewTranslatex;

extern __attribute__ ((visibility("default"))) PFNGLCLIPPLANEFPROC __glewClipPlanef;
extern __attribute__ ((visibility("default"))) PFNGLCLIPPLANEXPROC __glewClipPlanex;
extern __attribute__ ((visibility("default"))) PFNGLGETCLIPPLANEFPROC __glewGetClipPlanef;
extern __attribute__ ((visibility("default"))) PFNGLGETCLIPPLANEXPROC __glewGetClipPlanex;
extern __attribute__ ((visibility("default"))) PFNGLGETFIXEDVPROC __glewGetFixedv;
extern __attribute__ ((visibility("default"))) PFNGLGETLIGHTXVPROC __glewGetLightxv;
extern __attribute__ ((visibility("default"))) PFNGLGETMATERIALXVPROC __glewGetMaterialxv;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXENVXVPROC __glewGetTexEnvxv;
extern __attribute__ ((visibility("default"))) PFNGLGETTEXPARAMETERXVPROC __glewGetTexParameterxv;
extern __attribute__ ((visibility("default"))) PFNGLPOINTPARAMETERXPROC __glewPointParameterx;
extern __attribute__ ((visibility("default"))) PFNGLPOINTPARAMETERXVPROC __glewPointParameterxv;
extern __attribute__ ((visibility("default"))) PFNGLPOINTSIZEPOINTEROESPROC __glewPointSizePointerOES;
extern __attribute__ ((visibility("default"))) PFNGLTEXPARAMETERXVPROC __glewTexParameterxv;

extern __attribute__ ((visibility("default"))) PFNGLERRORSTRINGREGALPROC __glewErrorStringREGAL;

extern __attribute__ ((visibility("default"))) PFNGLGETEXTENSIONREGALPROC __glewGetExtensionREGAL;
extern __attribute__ ((visibility("default"))) PFNGLISSUPPORTEDREGALPROC __glewIsSupportedREGAL;

extern __attribute__ ((visibility("default"))) PFNGLLOGMESSAGECALLBACKREGALPROC __glewLogMessageCallbackREGAL;

extern __attribute__ ((visibility("default"))) PFNGLGETPROCADDRESSREGALPROC __glewGetProcAddressREGAL;

extern __attribute__ ((visibility("default"))) PFNGLDETAILTEXFUNCSGISPROC __glewDetailTexFuncSGIS;
extern __attribute__ ((visibility("default"))) PFNGLGETDETAILTEXFUNCSGISPROC __glewGetDetailTexFuncSGIS;

extern __attribute__ ((visibility("default"))) PFNGLFOGFUNCSGISPROC __glewFogFuncSGIS;
extern __attribute__ ((visibility("default"))) PFNGLGETFOGFUNCSGISPROC __glewGetFogFuncSGIS;

extern __attribute__ ((visibility("default"))) PFNGLSAMPLEMASKSGISPROC __glewSampleMaskSGIS;
extern __attribute__ ((visibility("default"))) PFNGLSAMPLEPATTERNSGISPROC __glewSamplePatternSGIS;

extern __attribute__ ((visibility("default"))) PFNGLINTERLEAVEDTEXTURECOORDSETSSGISPROC __glewInterleavedTextureCoordSetsSGIS;
extern __attribute__ ((visibility("default"))) PFNGLSELECTTEXTURECOORDSETSGISPROC __glewSelectTextureCoordSetSGIS;
extern __attribute__ ((visibility("default"))) PFNGLSELECTTEXTURESGISPROC __glewSelectTextureSGIS;
extern __attribute__ ((visibility("default"))) PFNGLSELECTTEXTURETRANSFORMSGISPROC __glewSelectTextureTransformSGIS;

extern __attribute__ ((visibility("default"))) PFNGLMULTISAMPLESUBRECTPOSSGISPROC __glewMultisampleSubRectPosSGIS;

extern __attribute__ ((visibility("default"))) PFNGLGETSHARPENTEXFUNCSGISPROC __glewGetSharpenTexFuncSGIS;
extern __attribute__ ((visibility("default"))) PFNGLSHARPENTEXFUNCSGISPROC __glewSharpenTexFuncSGIS;

extern __attribute__ ((visibility("default"))) PFNGLTEXIMAGE4DSGISPROC __glewTexImage4DSGIS;
extern __attribute__ ((visibility("default"))) PFNGLTEXSUBIMAGE4DSGISPROC __glewTexSubImage4DSGIS;

extern __attribute__ ((visibility("default"))) PFNGLGETTEXFILTERFUNCSGISPROC __glewGetTexFilterFuncSGIS;
extern __attribute__ ((visibility("default"))) PFNGLTEXFILTERFUNCSGISPROC __glewTexFilterFuncSGIS;

extern __attribute__ ((visibility("default"))) PFNGLASYNCMARKERSGIXPROC __glewAsyncMarkerSGIX;
extern __attribute__ ((visibility("default"))) PFNGLDELETEASYNCMARKERSSGIXPROC __glewDeleteAsyncMarkersSGIX;
extern __attribute__ ((visibility("default"))) PFNGLFINISHASYNCSGIXPROC __glewFinishAsyncSGIX;
extern __attribute__ ((visibility("default"))) PFNGLGENASYNCMARKERSSGIXPROC __glewGenAsyncMarkersSGIX;
extern __attribute__ ((visibility("default"))) PFNGLISASYNCMARKERSGIXPROC __glewIsAsyncMarkerSGIX;
extern __attribute__ ((visibility("default"))) PFNGLPOLLASYNCSGIXPROC __glewPollAsyncSGIX;

extern __attribute__ ((visibility("default"))) PFNGLADDRESSSPACEPROC __glewAddressSpace;
extern __attribute__ ((visibility("default"))) PFNGLDATAPIPEPROC __glewDataPipe;

extern __attribute__ ((visibility("default"))) PFNGLFLUSHRASTERSGIXPROC __glewFlushRasterSGIX;

extern __attribute__ ((visibility("default"))) PFNGLFOGLAYERSSGIXPROC __glewFogLayersSGIX;
extern __attribute__ ((visibility("default"))) PFNGLGETFOGLAYERSSGIXPROC __glewGetFogLayersSGIX;

extern __attribute__ ((visibility("default"))) PFNGLTEXTUREFOGSGIXPROC __glewTextureFogSGIX;

extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTCOLORMATERIALSGIXPROC __glewFragmentColorMaterialSGIX;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTLIGHTMODELFSGIXPROC __glewFragmentLightModelfSGIX;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTLIGHTMODELFVSGIXPROC __glewFragmentLightModelfvSGIX;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTLIGHTMODELISGIXPROC __glewFragmentLightModeliSGIX;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTLIGHTMODELIVSGIXPROC __glewFragmentLightModelivSGIX;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTLIGHTFSGIXPROC __glewFragmentLightfSGIX;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTLIGHTFVSGIXPROC __glewFragmentLightfvSGIX;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTLIGHTISGIXPROC __glewFragmentLightiSGIX;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTLIGHTIVSGIXPROC __glewFragmentLightivSGIX;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTMATERIALFSGIXPROC __glewFragmentMaterialfSGIX;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTMATERIALFVSGIXPROC __glewFragmentMaterialfvSGIX;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTMATERIALISGIXPROC __glewFragmentMaterialiSGIX;
extern __attribute__ ((visibility("default"))) PFNGLFRAGMENTMATERIALIVSGIXPROC __glewFragmentMaterialivSGIX;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAGMENTLIGHTFVSGIXPROC __glewGetFragmentLightfvSGIX;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAGMENTLIGHTIVSGIXPROC __glewGetFragmentLightivSGIX;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAGMENTMATERIALFVSGIXPROC __glewGetFragmentMaterialfvSGIX;
extern __attribute__ ((visibility("default"))) PFNGLGETFRAGMENTMATERIALIVSGIXPROC __glewGetFragmentMaterialivSGIX;

extern __attribute__ ((visibility("default"))) PFNGLFRAMEZOOMSGIXPROC __glewFrameZoomSGIX;

extern __attribute__ ((visibility("default"))) PFNGLIGLOOINTERFACESGIXPROC __glewIglooInterfaceSGIX;

extern __attribute__ ((visibility("default"))) PFNGLALLOCMPEGPREDICTORSSGIXPROC __glewAllocMPEGPredictorsSGIX;
extern __attribute__ ((visibility("default"))) PFNGLDELETEMPEGPREDICTORSSGIXPROC __glewDeleteMPEGPredictorsSGIX;
extern __attribute__ ((visibility("default"))) PFNGLGENMPEGPREDICTORSSGIXPROC __glewGenMPEGPredictorsSGIX;
extern __attribute__ ((visibility("default"))) PFNGLGETMPEGPARAMETERFVSGIXPROC __glewGetMPEGParameterfvSGIX;
extern __attribute__ ((visibility("default"))) PFNGLGETMPEGPARAMETERIVSGIXPROC __glewGetMPEGParameterivSGIX;
extern __attribute__ ((visibility("default"))) PFNGLGETMPEGPREDICTORSGIXPROC __glewGetMPEGPredictorSGIX;
extern __attribute__ ((visibility("default"))) PFNGLGETMPEGQUANTTABLEUBVPROC __glewGetMPEGQuantTableubv;
extern __attribute__ ((visibility("default"))) PFNGLISMPEGPREDICTORSGIXPROC __glewIsMPEGPredictorSGIX;
extern __attribute__ ((visibility("default"))) PFNGLMPEGPREDICTORSGIXPROC __glewMPEGPredictorSGIX;
extern __attribute__ ((visibility("default"))) PFNGLMPEGQUANTTABLEUBVPROC __glewMPEGQuantTableubv;
extern __attribute__ ((visibility("default"))) PFNGLSWAPMPEGPREDICTORSSGIXPROC __glewSwapMPEGPredictorsSGIX;

extern __attribute__ ((visibility("default"))) PFNGLGETNONLINLIGHTFVSGIXPROC __glewGetNonlinLightfvSGIX;
extern __attribute__ ((visibility("default"))) PFNGLGETNONLINMATERIALFVSGIXPROC __glewGetNonlinMaterialfvSGIX;
extern __attribute__ ((visibility("default"))) PFNGLNONLINLIGHTFVSGIXPROC __glewNonlinLightfvSGIX;
extern __attribute__ ((visibility("default"))) PFNGLNONLINMATERIALFVSGIXPROC __glewNonlinMaterialfvSGIX;

extern __attribute__ ((visibility("default"))) PFNGLPIXELTEXGENSGIXPROC __glewPixelTexGenSGIX;

extern __attribute__ ((visibility("default"))) PFNGLDEFORMSGIXPROC __glewDeformSGIX;
extern __attribute__ ((visibility("default"))) PFNGLLOADIDENTITYDEFORMATIONMAPSGIXPROC __glewLoadIdentityDeformationMapSGIX;

extern __attribute__ ((visibility("default"))) PFNGLMESHBREADTHSGIXPROC __glewMeshBreadthSGIX;
extern __attribute__ ((visibility("default"))) PFNGLMESHSTRIDESGIXPROC __glewMeshStrideSGIX;

extern __attribute__ ((visibility("default"))) PFNGLREFERENCEPLANESGIXPROC __glewReferencePlaneSGIX;

extern __attribute__ ((visibility("default"))) PFNGLSPRITEPARAMETERFSGIXPROC __glewSpriteParameterfSGIX;
extern __attribute__ ((visibility("default"))) PFNGLSPRITEPARAMETERFVSGIXPROC __glewSpriteParameterfvSGIX;
extern __attribute__ ((visibility("default"))) PFNGLSPRITEPARAMETERISGIXPROC __glewSpriteParameteriSGIX;
extern __attribute__ ((visibility("default"))) PFNGLSPRITEPARAMETERIVSGIXPROC __glewSpriteParameterivSGIX;

extern __attribute__ ((visibility("default"))) PFNGLTAGSAMPLEBUFFERSGIXPROC __glewTagSampleBufferSGIX;

extern __attribute__ ((visibility("default"))) PFNGLGETVECTOROPERATIONSGIXPROC __glewGetVectorOperationSGIX;
extern __attribute__ ((visibility("default"))) PFNGLVECTOROPERATIONSGIXPROC __glewVectorOperationSGIX;

extern __attribute__ ((visibility("default"))) PFNGLAREVERTEXARRAYSRESIDENTSGIXPROC __glewAreVertexArraysResidentSGIX;
extern __attribute__ ((visibility("default"))) PFNGLBINDVERTEXARRAYSGIXPROC __glewBindVertexArraySGIX;
extern __attribute__ ((visibility("default"))) PFNGLDELETEVERTEXARRAYSSGIXPROC __glewDeleteVertexArraysSGIX;
extern __attribute__ ((visibility("default"))) PFNGLGENVERTEXARRAYSSGIXPROC __glewGenVertexArraysSGIX;
extern __attribute__ ((visibility("default"))) PFNGLISVERTEXARRAYSGIXPROC __glewIsVertexArraySGIX;
extern __attribute__ ((visibility("default"))) PFNGLPRIORITIZEVERTEXARRAYSSGIXPROC __glewPrioritizeVertexArraysSGIX;

extern __attribute__ ((visibility("default"))) PFNGLCOLORTABLEPARAMETERFVSGIPROC __glewColorTableParameterfvSGI;
extern __attribute__ ((visibility("default"))) PFNGLCOLORTABLEPARAMETERIVSGIPROC __glewColorTableParameterivSGI;
extern __attribute__ ((visibility("default"))) PFNGLCOLORTABLESGIPROC __glewColorTableSGI;
extern __attribute__ ((visibility("default"))) PFNGLCOPYCOLORTABLESGIPROC __glewCopyColorTableSGI;
extern __attribute__ ((visibility("default"))) PFNGLGETCOLORTABLEPARAMETERFVSGIPROC __glewGetColorTableParameterfvSGI;
extern __attribute__ ((visibility("default"))) PFNGLGETCOLORTABLEPARAMETERIVSGIPROC __glewGetColorTableParameterivSGI;
extern __attribute__ ((visibility("default"))) PFNGLGETCOLORTABLESGIPROC __glewGetColorTableSGI;

extern __attribute__ ((visibility("default"))) PFNGLGETPIXELTRANSFORMPARAMETERFVSGIPROC __glewGetPixelTransformParameterfvSGI;
extern __attribute__ ((visibility("default"))) PFNGLGETPIXELTRANSFORMPARAMETERIVSGIPROC __glewGetPixelTransformParameterivSGI;
extern __attribute__ ((visibility("default"))) PFNGLPIXELTRANSFORMPARAMETERFSGIPROC __glewPixelTransformParameterfSGI;
extern __attribute__ ((visibility("default"))) PFNGLPIXELTRANSFORMPARAMETERFVSGIPROC __glewPixelTransformParameterfvSGI;
extern __attribute__ ((visibility("default"))) PFNGLPIXELTRANSFORMPARAMETERISGIPROC __glewPixelTransformParameteriSGI;
extern __attribute__ ((visibility("default"))) PFNGLPIXELTRANSFORMPARAMETERIVSGIPROC __glewPixelTransformParameterivSGI;
extern __attribute__ ((visibility("default"))) PFNGLPIXELTRANSFORMSGIPROC __glewPixelTransformSGI;

extern __attribute__ ((visibility("default"))) PFNGLFINISHTEXTURESUNXPROC __glewFinishTextureSUNX;

extern __attribute__ ((visibility("default"))) PFNGLGLOBALALPHAFACTORBSUNPROC __glewGlobalAlphaFactorbSUN;
extern __attribute__ ((visibility("default"))) PFNGLGLOBALALPHAFACTORDSUNPROC __glewGlobalAlphaFactordSUN;
extern __attribute__ ((visibility("default"))) PFNGLGLOBALALPHAFACTORFSUNPROC __glewGlobalAlphaFactorfSUN;
extern __attribute__ ((visibility("default"))) PFNGLGLOBALALPHAFACTORISUNPROC __glewGlobalAlphaFactoriSUN;
extern __attribute__ ((visibility("default"))) PFNGLGLOBALALPHAFACTORSSUNPROC __glewGlobalAlphaFactorsSUN;
extern __attribute__ ((visibility("default"))) PFNGLGLOBALALPHAFACTORUBSUNPROC __glewGlobalAlphaFactorubSUN;
extern __attribute__ ((visibility("default"))) PFNGLGLOBALALPHAFACTORUISUNPROC __glewGlobalAlphaFactoruiSUN;
extern __attribute__ ((visibility("default"))) PFNGLGLOBALALPHAFACTORUSSUNPROC __glewGlobalAlphaFactorusSUN;

extern __attribute__ ((visibility("default"))) PFNGLREADVIDEOPIXELSSUNPROC __glewReadVideoPixelsSUN;

extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEPOINTERSUNPROC __glewReplacementCodePointerSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUBSUNPROC __glewReplacementCodeubSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUBVSUNPROC __glewReplacementCodeubvSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUISUNPROC __glewReplacementCodeuiSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUIVSUNPROC __glewReplacementCodeuivSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUSSUNPROC __glewReplacementCodeusSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUSVSUNPROC __glewReplacementCodeusvSUN;

extern __attribute__ ((visibility("default"))) PFNGLCOLOR3FVERTEX3FSUNPROC __glewColor3fVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLCOLOR3FVERTEX3FVSUNPROC __glewColor3fVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLCOLOR4FNORMAL3FVERTEX3FSUNPROC __glewColor4fNormal3fVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLCOLOR4FNORMAL3FVERTEX3FVSUNPROC __glewColor4fNormal3fVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLCOLOR4UBVERTEX2FSUNPROC __glewColor4ubVertex2fSUN;
extern __attribute__ ((visibility("default"))) PFNGLCOLOR4UBVERTEX2FVSUNPROC __glewColor4ubVertex2fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLCOLOR4UBVERTEX3FSUNPROC __glewColor4ubVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLCOLOR4UBVERTEX3FVSUNPROC __glewColor4ubVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLNORMAL3FVERTEX3FSUNPROC __glewNormal3fVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLNORMAL3FVERTEX3FVSUNPROC __glewNormal3fVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FSUNPROC __glewReplacementCodeuiColor3fVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FVSUNPROC __glewReplacementCodeuiColor3fVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FSUNPROC __glewReplacementCodeuiColor4fNormal3fVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FVSUNPROC __glewReplacementCodeuiColor4fNormal3fVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FSUNPROC __glewReplacementCodeuiColor4ubVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FVSUNPROC __glewReplacementCodeuiColor4ubVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FSUNPROC __glewReplacementCodeuiNormal3fVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FVSUNPROC __glewReplacementCodeuiNormal3fVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC __glewReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC __glewReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FSUNPROC __glewReplacementCodeuiTexCoord2fNormal3fVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FVSUNPROC __glewReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FSUNPROC __glewReplacementCodeuiTexCoord2fVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FVSUNPROC __glewReplacementCodeuiTexCoord2fVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUIVERTEX3FSUNPROC __glewReplacementCodeuiVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLREPLACEMENTCODEUIVERTEX3FVSUNPROC __glewReplacementCodeuiVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD2FCOLOR3FVERTEX3FSUNPROC __glewTexCoord2fColor3fVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD2FCOLOR3FVERTEX3FVSUNPROC __glewTexCoord2fColor3fVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC __glewTexCoord2fColor4fNormal3fVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC __glewTexCoord2fColor4fNormal3fVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD2FCOLOR4UBVERTEX3FSUNPROC __glewTexCoord2fColor4ubVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD2FCOLOR4UBVERTEX3FVSUNPROC __glewTexCoord2fColor4ubVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD2FNORMAL3FVERTEX3FSUNPROC __glewTexCoord2fNormal3fVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD2FNORMAL3FVERTEX3FVSUNPROC __glewTexCoord2fNormal3fVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD2FVERTEX3FSUNPROC __glewTexCoord2fVertex3fSUN;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD2FVERTEX3FVSUNPROC __glewTexCoord2fVertex3fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FSUNPROC __glewTexCoord4fColor4fNormal3fVertex4fSUN;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FVSUNPROC __glewTexCoord4fColor4fNormal3fVertex4fvSUN;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD4FVERTEX4FSUNPROC __glewTexCoord4fVertex4fSUN;
extern __attribute__ ((visibility("default"))) PFNGLTEXCOORD4FVERTEX4FVSUNPROC __glewTexCoord4fVertex4fvSUN;

extern __attribute__ ((visibility("default"))) PFNGLADDSWAPHINTRECTWINPROC __glewAddSwapHintRectWIN;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_1_1;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_1_2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_1_2_1;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_1_3;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_1_4;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_1_5;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_2_0;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_2_1;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_3_0;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_3_1;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_3_2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_3_3;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_4_0;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_4_1;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_4_2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_4_3;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_4_4;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_4_5;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VERSION_4_6;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_3DFX_multisample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_3DFX_tbuffer;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_3DFX_texture_compression_FXT1;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_blend_minmax_factor;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_compressed_3DC_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_compressed_ATC_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_conservative_depth;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_debug_output;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_depth_clamp_separate;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_draw_buffers_blend;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_framebuffer_multisample_advanced;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_framebuffer_sample_positions;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_gcn_shader;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_gpu_shader_half_float;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_gpu_shader_half_float_fetch;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_gpu_shader_int16;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_gpu_shader_int64;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_interleaved_elements;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_multi_draw_indirect;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_name_gen_delete;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_occlusion_query_event;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_performance_monitor;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_pinned_memory;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_program_binary_Z400;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_query_buffer_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_sample_positions;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_seamless_cubemap_per_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_shader_atomic_counter_ops;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_shader_ballot;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_shader_explicit_vertex_parameter;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_shader_image_load_store_lod;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_shader_stencil_export;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_shader_stencil_value_export;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_shader_trinary_minmax;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_sparse_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_stencil_operation_extended;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_texture_gather_bias_lod;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_texture_texture4;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_transform_feedback3_lines_triangles;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_transform_feedback4;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_vertex_shader_layer;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_vertex_shader_tessellator;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_AMD_vertex_shader_viewport_index;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ANDROID_extension_pack_es31a;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ANGLE_depth_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ANGLE_framebuffer_blit;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ANGLE_framebuffer_multisample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ANGLE_instanced_arrays;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ANGLE_pack_reverse_row_order;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ANGLE_program_binary;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ANGLE_texture_compression_dxt1;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ANGLE_texture_compression_dxt3;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ANGLE_texture_compression_dxt5;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ANGLE_texture_usage;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ANGLE_timer_query;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ANGLE_translated_shader_source;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_aux_depth_stencil;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_client_storage;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_clip_distance;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_color_buffer_packed_float;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_copy_texture_levels;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_element_array;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_fence;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_float_pixels;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_flush_buffer_range;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_framebuffer_multisample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_object_purgeable;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_pixel_buffer;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_rgb_422;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_row_bytes;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_specular_vector;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_sync;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_texture_2D_limited_npot;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_texture_format_BGRA8888;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_texture_max_level;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_texture_packed_float;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_texture_range;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_transform_hint;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_vertex_array_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_vertex_array_range;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_vertex_program_evaluators;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_APPLE_ycbcr_422;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_ES2_compatibility;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_ES3_1_compatibility;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_ES3_2_compatibility;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_ES3_compatibility;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_arrays_of_arrays;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_base_instance;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_bindless_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_blend_func_extended;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_buffer_storage;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_cl_event;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_clear_buffer_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_clear_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_clip_control;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_color_buffer_float;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_compatibility;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_compressed_texture_pixel_storage;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_compute_shader;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_compute_variable_group_size;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_conditional_render_inverted;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_conservative_depth;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_copy_buffer;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_copy_image;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_cull_distance;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_debug_output;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_depth_buffer_float;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_depth_clamp;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_depth_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_derivative_control;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_direct_state_access;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_draw_buffers;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_draw_buffers_blend;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_draw_elements_base_vertex;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_draw_indirect;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_draw_instanced;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_enhanced_layouts;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_explicit_attrib_location;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_explicit_uniform_location;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_fragment_coord_conventions;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_fragment_layer_viewport;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_fragment_program;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_fragment_program_shadow;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_fragment_shader;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_fragment_shader_interlock;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_framebuffer_no_attachments;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_framebuffer_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_framebuffer_sRGB;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_geometry_shader4;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_get_program_binary;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_get_texture_sub_image;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_gl_spirv;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_gpu_shader5;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_gpu_shader_fp64;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_gpu_shader_int64;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_half_float_pixel;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_half_float_vertex;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_imaging;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_indirect_parameters;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_instanced_arrays;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_internalformat_query;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_internalformat_query2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_invalidate_subdata;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_map_buffer_alignment;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_map_buffer_range;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_matrix_palette;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_multi_bind;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_multi_draw_indirect;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_multisample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_multitexture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_occlusion_query;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_occlusion_query2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_parallel_shader_compile;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_pipeline_statistics_query;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_pixel_buffer_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_point_parameters;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_point_sprite;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_polygon_offset_clamp;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_post_depth_coverage;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_program_interface_query;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_provoking_vertex;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_query_buffer_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_robust_buffer_access_behavior;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_robustness;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_robustness_application_isolation;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_robustness_share_group_isolation;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_sample_locations;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_sample_shading;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_sampler_objects;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_seamless_cube_map;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_seamless_cubemap_per_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_separate_shader_objects;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shader_atomic_counter_ops;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shader_atomic_counters;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shader_ballot;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shader_bit_encoding;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shader_clock;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shader_draw_parameters;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shader_group_vote;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shader_image_load_store;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shader_image_size;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shader_objects;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shader_precision;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shader_stencil_export;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shader_storage_buffer_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shader_subroutine;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shader_texture_image_samples;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shader_texture_lod;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shader_viewport_layer_array;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shading_language_100;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shading_language_420pack;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shading_language_include;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shading_language_packing;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shadow;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_shadow_ambient;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_sparse_buffer;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_sparse_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_sparse_texture2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_sparse_texture_clamp;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_spirv_extensions;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_stencil_texturing;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_sync;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_tessellation_shader;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_barrier;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_border_clamp;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_buffer_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_buffer_object_rgb32;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_buffer_range;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_compression;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_compression_bptc;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_compression_rgtc;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_cube_map;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_cube_map_array;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_env_add;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_env_combine;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_env_crossbar;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_env_dot3;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_filter_anisotropic;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_filter_minmax;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_float;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_gather;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_mirror_clamp_to_edge;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_mirrored_repeat;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_multisample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_non_power_of_two;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_query_levels;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_query_lod;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_rectangle;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_rg;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_rgb10_a2ui;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_stencil8;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_storage;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_storage_multisample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_swizzle;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_texture_view;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_timer_query;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_transform_feedback2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_transform_feedback3;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_transform_feedback_instanced;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_transform_feedback_overflow_query;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_transpose_matrix;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_uniform_buffer_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_vertex_array_bgra;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_vertex_array_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_vertex_attrib_64bit;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_vertex_attrib_binding;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_vertex_blend;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_vertex_buffer_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_vertex_program;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_vertex_shader;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_vertex_type_10f_11f_11f_rev;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_vertex_type_2_10_10_10_rev;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_viewport_array;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARB_window_pos;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARM_mali_program_binary;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARM_mali_shader_binary;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARM_rgba8;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARM_shader_framebuffer_fetch;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARM_shader_framebuffer_fetch_depth_stencil;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ARM_texture_unnormalized_coordinates;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATIX_point_sprites;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATIX_texture_env_combine3;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATIX_texture_env_route;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATIX_vertex_shader_output_point_size;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_draw_buffers;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_element_array;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_envmap_bumpmap;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_fragment_shader;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_map_object_buffer;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_meminfo;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_pn_triangles;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_separate_stencil;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_shader_texture_lod;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_text_fragment_shader;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_texture_compression_3dc;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_texture_env_combine3;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_texture_float;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_texture_mirror_once;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_vertex_array_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_vertex_attrib_array_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_ATI_vertex_streams;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_DMP_program_binary;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_DMP_shader_binary;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_422_pixels;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_Cg_shader;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_EGL_image_array;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_EGL_image_external_wrap_modes;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_EGL_image_storage;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_EGL_sync;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_YUV_target;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_abgr;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_base_instance;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_bgra;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_bindable_uniform;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_blend_color;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_blend_equation_separate;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_blend_func_extended;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_blend_func_separate;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_blend_logic_op;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_blend_minmax;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_blend_subtract;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_buffer_storage;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_clear_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_clip_control;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_clip_cull_distance;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_clip_volume_hint;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_cmyka;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_color_buffer_float;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_color_buffer_half_float;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_color_subtable;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_compiled_vertex_array;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_compressed_ETC1_RGB8_sub_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_conservative_depth;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_convolution;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_coordinate_frame;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_copy_image;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_copy_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_cull_vertex;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_debug_label;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_debug_marker;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_depth_bounds_test;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_depth_clamp;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_direct_state_access;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_discard_framebuffer;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_disjoint_timer_query;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_draw_buffers;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_draw_buffers2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_draw_buffers_indexed;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_draw_elements_base_vertex;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_draw_instanced;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_draw_range_elements;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_draw_transform_feedback;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_external_buffer;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_float_blend;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_fog_coord;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_frag_depth;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_fragment_lighting;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_framebuffer_blit;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_framebuffer_multisample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_framebuffer_multisample_blit_scaled;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_framebuffer_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_framebuffer_sRGB;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_geometry_point_size;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_geometry_shader;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_geometry_shader4;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_gpu_program_parameters;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_gpu_shader4;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_gpu_shader5;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_histogram;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_index_array_formats;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_index_func;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_index_material;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_index_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_instanced_arrays;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_light_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_map_buffer_range;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_memory_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_memory_object_fd;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_memory_object_win32;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_misc_attribute;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_multi_draw_arrays;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_multi_draw_indirect;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_multiple_textures;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_multisample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_multisample_compatibility;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_multisampled_render_to_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_multisampled_render_to_texture2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_multiview_draw_buffers;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_multiview_tessellation_geometry_shader;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_multiview_texture_multisample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_multiview_timer_query;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_occlusion_query_boolean;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_packed_depth_stencil;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_packed_float;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_packed_pixels;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_paletted_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_pixel_buffer_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_pixel_transform;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_pixel_transform_color_table;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_point_parameters;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_polygon_offset;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_polygon_offset_clamp;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_post_depth_coverage;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_primitive_bounding_box;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_protected_textures;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_provoking_vertex;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_pvrtc_sRGB;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_raster_multisample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_read_format_bgra;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_render_snorm;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_rescale_normal;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_robustness;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_sRGB;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_sRGB_write_control;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_scene_marker;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_secondary_color;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_semaphore;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_semaphore_fd;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_semaphore_win32;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_separate_shader_objects;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_separate_specular_color;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_shader_framebuffer_fetch;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_shader_framebuffer_fetch_non_coherent;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_shader_group_vote;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_shader_image_load_formatted;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_shader_image_load_store;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_shader_implicit_conversions;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_shader_integer_mix;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_shader_io_blocks;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_shader_non_constant_global_initializers;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_shader_pixel_local_storage;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_shader_pixel_local_storage2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_shader_texture_lod;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_shadow_funcs;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_shadow_samplers;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_shared_texture_palette;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_sparse_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_sparse_texture2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_static_vertex_array;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_stencil_clear_tag;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_stencil_two_side;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_stencil_wrap;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_subtexture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_tessellation_point_size;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_tessellation_shader;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture3D;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_array;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_border_clamp;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_buffer;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_buffer_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_compression_astc_decode_mode;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_compression_astc_decode_mode_rgb9e5;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_compression_bptc;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_compression_dxt1;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_compression_latc;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_compression_rgtc;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_compression_s3tc;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_compression_s3tc_srgb;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_cube_map;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_cube_map_array;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_edge_clamp;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_env;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_env_add;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_env_combine;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_env_dot3;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_filter_anisotropic;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_filter_minmax;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_format_BGRA8888;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_format_sRGB_override;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_integer;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_lod_bias;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_mirror_clamp;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_mirror_clamp_to_edge;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_norm16;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_perturb_normal;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_query_lod;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_rectangle;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_rg;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_sRGB;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_sRGB_R8;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_sRGB_RG8;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_sRGB_decode;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_shadow_lod;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_shared_exponent;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_snorm;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_storage;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_swizzle;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_type_2_10_10_10_REV;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_texture_view;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_timer_query;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_transform_feedback;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_unpack_subimage;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_vertex_array;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_vertex_array_bgra;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_vertex_array_setXXX;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_vertex_attrib_64bit;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_vertex_shader;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_vertex_weighting;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_win32_keyed_mutex;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_window_rectangles;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_EXT_x11_sync_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_FJ_shader_binary_GCCSO;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_GREMEDY_frame_terminator;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_GREMEDY_string_marker;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_HP_convolution_border_modes;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_HP_image_transform;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_HP_occlusion_test;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_HP_texture_lighting;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_IBM_cull_vertex;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_IBM_multimode_draw_arrays;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_IBM_rasterpos_clip;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_IBM_static_data;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_IBM_texture_mirrored_repeat;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_IBM_vertex_array_lists;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_IMG_bindless_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_IMG_framebuffer_downsample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_IMG_multisampled_render_to_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_IMG_program_binary;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_IMG_read_format;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_IMG_shader_binary;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_IMG_texture_compression_pvrtc;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_IMG_texture_compression_pvrtc2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_IMG_texture_env_enhanced_fixed_function;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_IMG_texture_filter_cubic;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_INGR_color_clamp;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_INGR_interlace_read;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_INTEL_blackhole_render;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_INTEL_conservative_rasterization;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_INTEL_fragment_shader_ordering;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_INTEL_framebuffer_CMAA;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_INTEL_map_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_INTEL_parallel_arrays;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_INTEL_performance_query;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_INTEL_shader_integer_functions2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_INTEL_texture_scissor;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_KHR_blend_equation_advanced;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_KHR_blend_equation_advanced_coherent;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_KHR_context_flush_control;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_KHR_debug;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_KHR_no_error;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_KHR_parallel_shader_compile;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_KHR_robust_buffer_access_behavior;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_KHR_robustness;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_KHR_shader_subgroup;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_KHR_texture_compression_astc_hdr;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_KHR_texture_compression_astc_ldr;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_KHR_texture_compression_astc_sliced_3d;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_KTX_buffer_region;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_MESAX_texture_stack;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_MESA_framebuffer_flip_y;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_MESA_pack_invert;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_MESA_program_binary_formats;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_MESA_resize_buffers;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_MESA_shader_integer_functions;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_MESA_tile_raster_order;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_MESA_window_pos;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_MESA_ycbcr_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NVX_blend_equation_advanced_multi_draw_buffers;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NVX_conditional_render;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NVX_gpu_memory_info;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NVX_gpu_multicast2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NVX_linked_gpu_multicast;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NVX_progress_fence;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_3dvision_settings;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_EGL_stream_consumer_external;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_alpha_to_coverage_dither_control;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_bgr;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_bindless_multi_draw_indirect;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_bindless_multi_draw_indirect_count;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_bindless_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_blend_equation_advanced;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_blend_equation_advanced_coherent;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_blend_minmax_factor;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_blend_square;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_clip_space_w_scaling;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_command_list;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_compute_program5;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_compute_shader_derivatives;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_conditional_render;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_conservative_raster;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_conservative_raster_dilate;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_conservative_raster_pre_snap;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_conservative_raster_pre_snap_triangles;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_conservative_raster_underestimation;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_copy_buffer;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_copy_depth_to_color;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_copy_image;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_deep_texture3D;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_depth_buffer_float;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_depth_clamp;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_depth_nonlinear;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_depth_range_unclamped;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_draw_buffers;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_draw_instanced;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_draw_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_draw_vulkan_image;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_evaluators;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_explicit_attrib_location;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_explicit_multisample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_fbo_color_attachments;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_fence;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_fill_rectangle;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_float_buffer;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_fog_distance;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_fragment_coverage_to_color;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_fragment_program;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_fragment_program2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_fragment_program4;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_fragment_program_option;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_fragment_shader_barycentric;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_fragment_shader_interlock;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_framebuffer_blit;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_framebuffer_mixed_samples;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_framebuffer_multisample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_framebuffer_multisample_coverage;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_generate_mipmap_sRGB;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_geometry_program4;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_geometry_shader4;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_geometry_shader_passthrough;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_gpu_multicast;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_gpu_program4;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_gpu_program5;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_gpu_program5_mem_extended;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_gpu_program_fp64;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_gpu_shader5;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_half_float;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_image_formats;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_instanced_arrays;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_internalformat_sample_query;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_light_max_exponent;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_memory_attachment;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_mesh_shader;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_multisample_coverage;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_multisample_filter_hint;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_non_square_matrices;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_occlusion_query;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_pack_subimage;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_packed_depth_stencil;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_packed_float;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_packed_float_linear;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_parameter_buffer_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_parameter_buffer_object2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_path_rendering;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_path_rendering_shared_edge;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_pixel_buffer_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_pixel_data_range;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_platform_binary;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_point_sprite;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_polygon_mode;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_present_video;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_primitive_restart;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_query_resource_tag;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_read_buffer;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_read_buffer_front;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_read_depth;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_read_depth_stencil;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_read_stencil;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_register_combiners;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_register_combiners2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_representative_fragment_test;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_robustness_video_memory_purge;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_sRGB_formats;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_sample_locations;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_sample_mask_override_coverage;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_scissor_exclusive;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_shader_atomic_counters;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_shader_atomic_float;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_shader_atomic_float64;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_shader_atomic_fp16_vector;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_shader_atomic_int64;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_shader_buffer_load;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_shader_noperspective_interpolation;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_shader_storage_buffer_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_shader_subgroup_partitioned;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_shader_texture_footprint;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_shader_thread_group;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_shader_thread_shuffle;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_shading_rate_image;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_shadow_samplers_array;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_shadow_samplers_cube;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_stereo_view_rendering;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_tessellation_program5;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_texgen_emboss;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_texgen_reflection;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_texture_array;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_texture_barrier;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_texture_border_clamp;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_texture_compression_latc;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_texture_compression_s3tc;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_texture_compression_s3tc_update;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_texture_compression_vtc;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_texture_env_combine4;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_texture_expand_normal;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_texture_multisample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_texture_npot_2D_mipmap;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_texture_rectangle;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_texture_rectangle_compressed;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_texture_shader;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_texture_shader2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_texture_shader3;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_transform_feedback;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_transform_feedback2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_uniform_buffer_unified_memory;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_vdpau_interop;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_vdpau_interop2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_vertex_array_range;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_vertex_array_range2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_vertex_attrib_integer_64bit;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_vertex_buffer_unified_memory;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_vertex_program;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_vertex_program1_1;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_vertex_program2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_vertex_program2_option;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_vertex_program3;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_vertex_program4;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_video_capture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_viewport_array;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_viewport_array2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_NV_viewport_swizzle;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_EGL_image;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_EGL_image_external;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_EGL_image_external_essl3;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_blend_equation_separate;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_blend_func_separate;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_blend_subtract;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_byte_coordinates;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_compressed_ETC1_RGB8_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_compressed_paletted_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_copy_image;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_depth24;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_depth32;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_depth_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_depth_texture_cube_map;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_draw_buffers_indexed;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_draw_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_element_index_uint;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_extended_matrix_palette;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_fbo_render_mipmap;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_fragment_precision_high;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_framebuffer_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_geometry_point_size;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_geometry_shader;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_get_program_binary;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_gpu_shader5;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_mapbuffer;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_matrix_get;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_matrix_palette;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_packed_depth_stencil;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_point_size_array;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_point_sprite;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_read_format;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_required_internalformat;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_rgb8_rgba8;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_sample_shading;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_sample_variables;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_shader_image_atomic;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_shader_io_blocks;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_shader_multisample_interpolation;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_single_precision;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_standard_derivatives;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_stencil1;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_stencil4;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_stencil8;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_surfaceless_context;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_tessellation_point_size;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_tessellation_shader;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_texture_3D;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_texture_border_clamp;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_texture_buffer;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_texture_compression_astc;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_texture_cube_map;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_texture_cube_map_array;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_texture_env_crossbar;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_texture_mirrored_repeat;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_texture_npot;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_texture_stencil8;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_texture_storage_multisample_2d_array;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_texture_view;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_vertex_array_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_vertex_half_float;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OES_vertex_type_10_10_10_2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OML_interlace;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OML_resample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OML_subsample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OVR_multiview;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OVR_multiview2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_OVR_multiview_multisampled_render_to_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_PGI_misc_hints;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_PGI_vertex_hints;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_QCOM_YUV_texture_gather;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_QCOM_alpha_test;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_QCOM_binning_control;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_QCOM_driver_control;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_QCOM_extended_get;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_QCOM_extended_get2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_QCOM_framebuffer_foveated;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_QCOM_perfmon_global_mode;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_QCOM_shader_framebuffer_fetch_noncoherent;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_QCOM_shader_framebuffer_fetch_rate;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_QCOM_texture_foveated;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_QCOM_texture_foveated_subsampled_layout;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_QCOM_tiled_rendering;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_QCOM_writeonly_rendering;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_REGAL_ES1_0_compatibility;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_REGAL_ES1_1_compatibility;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_REGAL_enable;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_REGAL_error_string;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_REGAL_extension_query;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_REGAL_log;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_REGAL_proc_address;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_REND_screen_coordinates;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_S3_s3tc;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIS_clip_band_hint;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIS_color_range;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIS_detail_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIS_fog_function;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIS_generate_mipmap;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIS_line_texgen;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIS_multisample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIS_multitexture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIS_pixel_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIS_point_line_texgen;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIS_shared_multisample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIS_sharpen_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIS_texture4D;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIS_texture_border_clamp;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIS_texture_edge_clamp;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIS_texture_filter4;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIS_texture_lod;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIS_texture_select;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_async;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_async_histogram;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_async_pixel;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_bali_g_instruments;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_bali_r_instruments;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_bali_timer_instruments;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_blend_alpha_minmax;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_blend_cadd;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_blend_cmultiply;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_calligraphic_fragment;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_clipmap;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_color_matrix_accuracy;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_color_table_index_mode;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_complex_polar;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_convolution_accuracy;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_cube_map;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_cylinder_texgen;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_datapipe;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_decimation;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_depth_pass_instrument;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_depth_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_dvc;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_flush_raster;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_fog_blend;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_fog_factor_to_alpha;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_fog_layers;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_fog_offset;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_fog_patchy;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_fog_scale;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_fog_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_fragment_lighting_space;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_fragment_specular_lighting;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_fragments_instrument;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_framezoom;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_icc_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_igloo_interface;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_image_compression;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_impact_pixel_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_instrument_error;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_interlace;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_ir_instrument1;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_line_quality_hint;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_list_priority;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_mpeg1;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_mpeg2;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_nonlinear_lighting_pervertex;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_nurbs_eval;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_occlusion_instrument;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_packed_6bytes;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_pixel_texture;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_pixel_texture_bits;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_pixel_texture_lod;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_pixel_tiles;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_polynomial_ffd;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_quad_mesh;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_reference_plane;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_resample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_scalebias_hint;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_shadow;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_shadow_ambient;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_slim;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_spotlight_cutoff;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_sprite;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_subdiv_patch;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_subsample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_tag_sample_buffer;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_texture_add_env;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_texture_coordinate_clamp;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_texture_lod_bias;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_texture_mipmap_anisotropic;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_texture_multi_buffer;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_texture_phase;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_texture_range;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_texture_scale_bias;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_texture_supersample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_vector_ops;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_vertex_array_object;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_vertex_preclip;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_vertex_preclip_hint;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_ycrcb;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_ycrcb_subsample;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGIX_ycrcba;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGI_color_matrix;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGI_color_table;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGI_complex;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGI_complex_type;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGI_fft;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SGI_texture_color_table;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SUNX_constant_data;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SUN_convolution_border_modes;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SUN_global_alpha;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SUN_mesh_array;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SUN_read_video_pixels;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SUN_slice_accum;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SUN_triangle_list;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_SUN_vertex;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_VIV_shader_binary;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_WIN_phong_shading;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_WIN_scene_markerXXX;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_WIN_specular_fog;
extern __attribute__ ((visibility("default"))) GLboolean __GLEW_WIN_swap_hint;
# 26388 "/usr/include/GL/glew.h" 3 4
extern __attribute__ ((visibility("default"))) GLenum glewInit (void);
extern __attribute__ ((visibility("default"))) GLboolean glewIsSupported (const char *name);
# 26400 "/usr/include/GL/glew.h" 3 4
extern __attribute__ ((visibility("default"))) GLboolean glewExperimental;
extern __attribute__ ((visibility("default"))) GLboolean glewGetExtension (const char *name);
extern __attribute__ ((visibility("default"))) const GLubyte * glewGetErrorString (GLenum error);
extern __attribute__ ((visibility("default"))) const GLubyte * glewGetString (GLenum name);


}
# 2 "/home/devkon/CLionProjects/VertexLab/main.cpp" 2
# 1 "/usr/include/GLFW/glfw3.h" 1 3 4
# 33 "/usr/include/GLFW/glfw3.h" 3 4
extern "C" {
# 103 "/usr/include/GLFW/glfw3.h" 3 4
# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/stddef.h" 1 3 4
# 104 "/usr/include/GLFW/glfw3.h" 2 3 4
# 1365 "/usr/include/GLFW/glfw3.h" 3 4
typedef void (*GLFWglproc)(void);
# 1379 "/usr/include/GLFW/glfw3.h" 3 4
typedef void (*GLFWvkproc)(void);
# 1391 "/usr/include/GLFW/glfw3.h" 3 4
typedef struct GLFWmonitor GLFWmonitor;
# 1403 "/usr/include/GLFW/glfw3.h" 3 4
typedef struct GLFWwindow GLFWwindow;
# 1415 "/usr/include/GLFW/glfw3.h" 3 4
typedef struct GLFWcursor GLFWcursor;
# 1468 "/usr/include/GLFW/glfw3.h" 3 4
typedef void* (* GLFWallocatefun)(size_t size, void* user);
# 1524 "/usr/include/GLFW/glfw3.h" 3 4
typedef void* (* GLFWreallocatefun)(void* block, size_t size, void* user);
# 1566 "/usr/include/GLFW/glfw3.h" 3 4
typedef void (* GLFWdeallocatefun)(void* block, void* user);
# 1590 "/usr/include/GLFW/glfw3.h" 3 4
typedef void (* GLFWerrorfun)(int error_code, const char* description);
# 1613 "/usr/include/GLFW/glfw3.h" 3 4
typedef void (* GLFWwindowposfun)(GLFWwindow* window, int xpos, int ypos);
# 1635 "/usr/include/GLFW/glfw3.h" 3 4
typedef void (* GLFWwindowsizefun)(GLFWwindow* window, int width, int height);
# 1655 "/usr/include/GLFW/glfw3.h" 3 4
typedef void (* GLFWwindowclosefun)(GLFWwindow* window);
# 1675 "/usr/include/GLFW/glfw3.h" 3 4
typedef void (* GLFWwindowrefreshfun)(GLFWwindow* window);
# 1696 "/usr/include/GLFW/glfw3.h" 3 4
typedef void (* GLFWwindowfocusfun)(GLFWwindow* window, int focused);
# 1717 "/usr/include/GLFW/glfw3.h" 3 4
typedef void (* GLFWwindowiconifyfun)(GLFWwindow* window, int iconified);
# 1738 "/usr/include/GLFW/glfw3.h" 3 4
typedef void (* GLFWwindowmaximizefun)(GLFWwindow* window, int maximized);
# 1759 "/usr/include/GLFW/glfw3.h" 3 4
typedef void (* GLFWframebuffersizefun)(GLFWwindow* window, int width, int height);
# 1780 "/usr/include/GLFW/glfw3.h" 3 4
typedef void (* GLFWwindowcontentscalefun)(GLFWwindow* window, float xscale, float yscale);
# 1806 "/usr/include/GLFW/glfw3.h" 3 4
typedef void (* GLFWmousebuttonfun)(GLFWwindow* window, int button, int action, int mods);
# 1829 "/usr/include/GLFW/glfw3.h" 3 4
typedef void (* GLFWcursorposfun)(GLFWwindow* window, double xpos, double ypos);
# 1850 "/usr/include/GLFW/glfw3.h" 3 4
typedef void (* GLFWcursorenterfun)(GLFWwindow* window, int entered);
# 1871 "/usr/include/GLFW/glfw3.h" 3 4
typedef void (* GLFWscrollfun)(GLFWwindow* window, double xoffset, double yoffset);
# 1897 "/usr/include/GLFW/glfw3.h" 3 4
typedef void (* GLFWkeyfun)(GLFWwindow* window, int key, int scancode, int action, int mods);
# 1918 "/usr/include/GLFW/glfw3.h" 3 4
typedef void (* GLFWcharfun)(GLFWwindow* window, unsigned int codepoint);
# 1945 "/usr/include/GLFW/glfw3.h" 3 4
typedef void (* GLFWcharmodsfun)(GLFWwindow* window, unsigned int codepoint, int mods);
# 1969 "/usr/include/GLFW/glfw3.h" 3 4
typedef void (* GLFWdropfun)(GLFWwindow* window, int path_count, const char* paths[]);
# 1990 "/usr/include/GLFW/glfw3.h" 3 4
typedef void (* GLFWmonitorfun)(GLFWmonitor* monitor, int event);
# 2011 "/usr/include/GLFW/glfw3.h" 3 4
typedef void (* GLFWjoystickfun)(int jid, int event);
# 2026 "/usr/include/GLFW/glfw3.h" 3 4
typedef struct GLFWvidmode
{


    int width;


    int height;


    int redBits;


    int greenBits;


    int blueBits;


    int refreshRate;
} GLFWvidmode;
# 2060 "/usr/include/GLFW/glfw3.h" 3 4
typedef struct GLFWgammaramp
{


    unsigned short* red;


    unsigned short* green;


    unsigned short* blue;


    unsigned int size;
} GLFWgammaramp;
# 2089 "/usr/include/GLFW/glfw3.h" 3 4
typedef struct GLFWimage
{


    int width;


    int height;


    unsigned char* pixels;
} GLFWimage;
# 2113 "/usr/include/GLFW/glfw3.h" 3 4
typedef struct GLFWgamepadstate
{



    unsigned char buttons[15];



    float axes[6];
} GLFWgamepadstate;
# 2137 "/usr/include/GLFW/glfw3.h" 3 4
typedef struct GLFWallocator
{



    GLFWallocatefun allocate;



    GLFWreallocatefun reallocate;



    GLFWdeallocatefun deallocate;



    void* user;
} GLFWallocator;
# 2220 "/usr/include/GLFW/glfw3.h" 3 4
 int glfwInit(void);
# 2254 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwTerminate(void);
# 2286 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwInitHint(int hint, int value);
# 2317 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwInitAllocator(const GLFWallocator* allocator);
# 2392 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwGetVersion(int* major, int* minor, int* rev);
# 2426 "/usr/include/GLFW/glfw3.h" 3 4
 const char* glfwGetVersionString(void);
# 2457 "/usr/include/GLFW/glfw3.h" 3 4
 int glfwGetError(const char** description);
# 2503 "/usr/include/GLFW/glfw3.h" 3 4
 GLFWerrorfun glfwSetErrorCallback(GLFWerrorfun callback);
# 2524 "/usr/include/GLFW/glfw3.h" 3 4
 int glfwGetPlatform(void);
# 2548 "/usr/include/GLFW/glfw3.h" 3 4
 int glfwPlatformSupported(int platform);
# 2577 "/usr/include/GLFW/glfw3.h" 3 4
 GLFWmonitor** glfwGetMonitors(int* count);
# 2601 "/usr/include/GLFW/glfw3.h" 3 4
 GLFWmonitor* glfwGetPrimaryMonitor(void);
# 2626 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwGetMonitorPos(GLFWmonitor* monitor, int* xpos, int* ypos);
# 2657 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwGetMonitorWorkarea(GLFWmonitor* monitor, int* xpos, int* ypos, int* width, int* height);
# 2692 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwGetMonitorPhysicalSize(GLFWmonitor* monitor, int* widthMM, int* heightMM);
# 2727 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwGetMonitorContentScale(GLFWmonitor* monitor, float* xscale, float* yscale);
# 2753 "/usr/include/GLFW/glfw3.h" 3 4
 const char* glfwGetMonitorName(GLFWmonitor* monitor);
# 2779 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwSetMonitorUserPointer(GLFWmonitor* monitor, void* pointer);
# 2803 "/usr/include/GLFW/glfw3.h" 3 4
 void* glfwGetMonitorUserPointer(GLFWmonitor* monitor);
# 2833 "/usr/include/GLFW/glfw3.h" 3 4
 GLFWmonitorfun glfwSetMonitorCallback(GLFWmonitorfun callback);
# 2867 "/usr/include/GLFW/glfw3.h" 3 4
 const GLFWvidmode* glfwGetVideoModes(GLFWmonitor* monitor, int* count);
# 2895 "/usr/include/GLFW/glfw3.h" 3 4
 const GLFWvidmode* glfwGetVideoMode(GLFWmonitor* monitor);
# 2928 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwSetGamma(GLFWmonitor* monitor, float gamma);
# 2958 "/usr/include/GLFW/glfw3.h" 3 4
 const GLFWgammaramp* glfwGetGammaRamp(GLFWmonitor* monitor);
# 2999 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwSetGammaRamp(GLFWmonitor* monitor, const GLFWgammaramp* ramp);
# 3018 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwDefaultWindowHints(void);
# 3053 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwWindowHint(int hint, int value);
# 3091 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwWindowHintString(int hint, const char* value);
# 3235 "/usr/include/GLFW/glfw3.h" 3 4
 GLFWwindow* glfwCreateWindow(int width, int height, const char* title, GLFWmonitor* monitor, GLFWwindow* share);
# 3264 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwDestroyWindow(GLFWwindow* window);
# 3284 "/usr/include/GLFW/glfw3.h" 3 4
 int glfwWindowShouldClose(GLFWwindow* window);
# 3306 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwSetWindowShouldClose(GLFWwindow* window, int value);
# 3338 "/usr/include/GLFW/glfw3.h" 3 4
 const char* glfwGetWindowTitle(GLFWwindow* window);
# 3364 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwSetWindowTitle(GLFWwindow* window, const char* title);
# 3413 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwSetWindowIcon(GLFWwindow* window, int count, const GLFWimage* images);
# 3445 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwGetWindowPos(GLFWwindow* window, int* xpos, int* ypos);
# 3480 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwSetWindowPos(GLFWwindow* window, int xpos, int ypos);
# 3510 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwGetWindowSize(GLFWwindow* window, int* width, int* height);
# 3553 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwSetWindowSizeLimits(GLFWwindow* window, int minwidth, int minheight, int maxwidth, int maxheight);
# 3596 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwSetWindowAspectRatio(GLFWwindow* window, int numer, int denom);
# 3634 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwSetWindowSize(GLFWwindow* window, int width, int height);
# 3663 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwGetFramebufferSize(GLFWwindow* window, int* width, int* height);
# 3700 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwGetWindowFrameSize(GLFWwindow* window, int* left, int* top, int* right, int* bottom);
# 3733 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwGetWindowContentScale(GLFWwindow* window, float* xscale, float* yscale);
# 3760 "/usr/include/GLFW/glfw3.h" 3 4
 float glfwGetWindowOpacity(GLFWwindow* window);
# 3792 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwSetWindowOpacity(GLFWwindow* window, float opacity);
# 3824 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwIconifyWindow(GLFWwindow* window);
# 3851 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwRestoreWindow(GLFWwindow* window);
# 3876 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwMaximizeWindow(GLFWwindow* window);
# 3908 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwShowWindow(GLFWwindow* window);
# 3930 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwHideWindow(GLFWwindow* window);
# 3969 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwFocusWindow(GLFWwindow* window);
# 3996 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwRequestWindowAttention(GLFWwindow* window);
# 4018 "/usr/include/GLFW/glfw3.h" 3 4
 GLFWmonitor* glfwGetWindowMonitor(GLFWwindow* window);
# 4074 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwSetWindowMonitor(GLFWwindow* window, GLFWmonitor* monitor, int xpos, int ypos, int width, int height, int refreshRate);
# 4111 "/usr/include/GLFW/glfw3.h" 3 4
 int glfwGetWindowAttrib(GLFWwindow* window, int attrib);
# 4153 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwSetWindowAttrib(GLFWwindow* window, int attrib, int value);
# 4176 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwSetWindowUserPointer(GLFWwindow* window, void* pointer);
# 4197 "/usr/include/GLFW/glfw3.h" 3 4
 void* glfwGetWindowUserPointer(GLFWwindow* window);
# 4232 "/usr/include/GLFW/glfw3.h" 3 4
 GLFWwindowposfun glfwSetWindowPosCallback(GLFWwindow* window, GLFWwindowposfun callback);
# 4264 "/usr/include/GLFW/glfw3.h" 3 4
 GLFWwindowsizefun glfwSetWindowSizeCallback(GLFWwindow* window, GLFWwindowsizefun callback);
# 4304 "/usr/include/GLFW/glfw3.h" 3 4
 GLFWwindowclosefun glfwSetWindowCloseCallback(GLFWwindow* window, GLFWwindowclosefun callback);
# 4340 "/usr/include/GLFW/glfw3.h" 3 4
 GLFWwindowrefreshfun glfwSetWindowRefreshCallback(GLFWwindow* window, GLFWwindowrefreshfun callback);
# 4375 "/usr/include/GLFW/glfw3.h" 3 4
 GLFWwindowfocusfun glfwSetWindowFocusCallback(GLFWwindow* window, GLFWwindowfocusfun callback);
# 4405 "/usr/include/GLFW/glfw3.h" 3 4
 GLFWwindowiconifyfun glfwSetWindowIconifyCallback(GLFWwindow* window, GLFWwindowiconifyfun callback);
# 4435 "/usr/include/GLFW/glfw3.h" 3 4
 GLFWwindowmaximizefun glfwSetWindowMaximizeCallback(GLFWwindow* window, GLFWwindowmaximizefun callback);
# 4465 "/usr/include/GLFW/glfw3.h" 3 4
 GLFWframebuffersizefun glfwSetFramebufferSizeCallback(GLFWwindow* window, GLFWframebuffersizefun callback);
# 4496 "/usr/include/GLFW/glfw3.h" 3 4
 GLFWwindowcontentscalefun glfwSetWindowContentScaleCallback(GLFWwindow* window, GLFWwindowcontentscalefun callback);
# 4534 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwPollEvents(void);
# 4579 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwWaitEvents(void);
# 4628 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwWaitEventsTimeout(double timeout);
# 4648 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwPostEmptyEvent(void);
# 4673 "/usr/include/GLFW/glfw3.h" 3 4
 int glfwGetInputMode(GLFWwindow* window, int mode);
# 4738 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwSetInputMode(GLFWwindow* window, int mode, int value);
# 4767 "/usr/include/GLFW/glfw3.h" 3 4
 int glfwRawMouseMotionSupported(void);
# 4835 "/usr/include/GLFW/glfw3.h" 3 4
 const char* glfwGetKeyName(int key, int scancode);
# 4862 "/usr/include/GLFW/glfw3.h" 3 4
 int glfwGetKeyScancode(int key);
# 4901 "/usr/include/GLFW/glfw3.h" 3 4
 int glfwGetKey(GLFWwindow* window, int key);
# 4930 "/usr/include/GLFW/glfw3.h" 3 4
 int glfwGetMouseButton(GLFWwindow* window, int button);
# 4968 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwGetCursorPos(GLFWwindow* window, double* xpos, double* ypos);
# 5008 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwSetCursorPos(GLFWwindow* window, double xpos, double ypos);
# 5046 "/usr/include/GLFW/glfw3.h" 3 4
 GLFWcursor* glfwCreateCursor(const GLFWimage* image, int xhot, int yhot);
# 5094 "/usr/include/GLFW/glfw3.h" 3 4
 GLFWcursor* glfwCreateStandardCursor(int shape);
# 5121 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwDestroyCursor(GLFWcursor* cursor);
# 5148 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwSetCursor(GLFWwindow* window, GLFWcursor* cursor);
# 5198 "/usr/include/GLFW/glfw3.h" 3 4
 GLFWkeyfun glfwSetKeyCallback(GLFWwindow* window, GLFWkeyfun callback);
# 5241 "/usr/include/GLFW/glfw3.h" 3 4
 GLFWcharfun glfwSetCharCallback(GLFWwindow* window, GLFWcharfun callback);
# 5283 "/usr/include/GLFW/glfw3.h" 3 4
 GLFWcharmodsfun glfwSetCharModsCallback(GLFWwindow* window, GLFWcharmodsfun callback);
# 5320 "/usr/include/GLFW/glfw3.h" 3 4
 GLFWmousebuttonfun glfwSetMouseButtonCallback(GLFWwindow* window, GLFWmousebuttonfun callback);
# 5352 "/usr/include/GLFW/glfw3.h" 3 4
 GLFWcursorposfun glfwSetCursorPosCallback(GLFWwindow* window, GLFWcursorposfun callback);
# 5383 "/usr/include/GLFW/glfw3.h" 3 4
 GLFWcursorenterfun glfwSetCursorEnterCallback(GLFWwindow* window, GLFWcursorenterfun callback);
# 5417 "/usr/include/GLFW/glfw3.h" 3 4
 GLFWscrollfun glfwSetScrollCallback(GLFWwindow* window, GLFWscrollfun callback);
# 5452 "/usr/include/GLFW/glfw3.h" 3 4
 GLFWdropfun glfwSetDropCallback(GLFWwindow* window, GLFWdropfun callback);
# 5476 "/usr/include/GLFW/glfw3.h" 3 4
 int glfwJoystickPresent(int jid);
# 5509 "/usr/include/GLFW/glfw3.h" 3 4
 const float* glfwGetJoystickAxes(int jid, int* count);
# 5550 "/usr/include/GLFW/glfw3.h" 3 4
 const unsigned char* glfwGetJoystickButtons(int jid, int* count);
# 5607 "/usr/include/GLFW/glfw3.h" 3 4
 const unsigned char* glfwGetJoystickHats(int jid, int* count);
# 5638 "/usr/include/GLFW/glfw3.h" 3 4
 const char* glfwGetJoystickName(int jid);
# 5679 "/usr/include/GLFW/glfw3.h" 3 4
 const char* glfwGetJoystickGUID(int jid);
# 5705 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwSetJoystickUserPointer(int jid, void* pointer);
# 5729 "/usr/include/GLFW/glfw3.h" 3 4
 void* glfwGetJoystickUserPointer(int jid);
# 5757 "/usr/include/GLFW/glfw3.h" 3 4
 int glfwJoystickIsGamepad(int jid);
# 5793 "/usr/include/GLFW/glfw3.h" 3 4
 GLFWjoystickfun glfwSetJoystickCallback(GLFWjoystickfun callback);
# 5827 "/usr/include/GLFW/glfw3.h" 3 4
 int glfwUpdateGamepadMappings(const char* string);
# 5859 "/usr/include/GLFW/glfw3.h" 3 4
 const char* glfwGetGamepadName(int jid);
# 5897 "/usr/include/GLFW/glfw3.h" 3 4
 int glfwGetGamepadState(int jid, GLFWgamepadstate* state);
# 5927 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwSetClipboardString(GLFWwindow* window, const char* string);
# 5962 "/usr/include/GLFW/glfw3.h" 3 4
 const char* glfwGetClipboardString(GLFWwindow* window);
# 5992 "/usr/include/GLFW/glfw3.h" 3 4
 double glfwGetTime(void);
# 6022 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwSetTime(double time);
# 6044 "/usr/include/GLFW/glfw3.h" 3 4
 uint64_t glfwGetTimerValue(void);
# 6064 "/usr/include/GLFW/glfw3.h" 3 4
 uint64_t glfwGetTimerFrequency(void);
# 6109 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwMakeContextCurrent(GLFWwindow* window);
# 6130 "/usr/include/GLFW/glfw3.h" 3 4
 GLFWwindow* glfwGetCurrentContext(void);
# 6164 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwSwapBuffers(GLFWwindow* window);
# 6210 "/usr/include/GLFW/glfw3.h" 3 4
 void glfwSwapInterval(int interval);
# 6248 "/usr/include/GLFW/glfw3.h" 3 4
 int glfwExtensionSupported(const char* extension);
# 6290 "/usr/include/GLFW/glfw3.h" 3 4
 GLFWglproc glfwGetProcAddress(const char* procname);
# 6316 "/usr/include/GLFW/glfw3.h" 3 4
 int glfwVulkanSupported(void);
# 6360 "/usr/include/GLFW/glfw3.h" 3 4
 const char** glfwGetRequiredInstanceExtensions(uint32_t* count);
# 6543 "/usr/include/GLFW/glfw3.h" 3 4
}
# 3 "/home/devkon/CLionProjects/VertexLab/main.cpp" 2
# 1 "/usr/include/glm/glm.hpp" 1 3 4
# 104 "/usr/include/glm/glm.hpp" 3 4
# 1 "/usr/include/glm/detail/_fixes.hpp" 1 3 4
# 1 "/usr/include/c++/14.2.1/cmath" 1 3 4
# 39 "/usr/include/c++/14.2.1/cmath" 3 4
       
# 40 "/usr/include/c++/14.2.1/cmath" 3

# 1 "/usr/include/c++/14.2.1/bits/requires_hosted.h" 1 3
# 42 "/usr/include/c++/14.2.1/cmath" 2 3


# 1 "/usr/include/c++/14.2.1/bits/cpp_type_traits.h" 1 3
# 35 "/usr/include/c++/14.2.1/bits/cpp_type_traits.h" 3
       
# 36 "/usr/include/c++/14.2.1/bits/cpp_type_traits.h" 3
# 67 "/usr/include/c++/14.2.1/bits/cpp_type_traits.h" 3
extern "C++" {

namespace std __attribute__ ((__visibility__ ("default")))
{


  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };





  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



  template<>
    struct __is_integer<char8_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



  template<>
    struct __is_integer<char16_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char32_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 272 "/usr/include/c++/14.2.1/bits/cpp_type_traits.h" 3
__extension__ template<> struct __is_integer<__int128> { enum { __value = 1 }; typedef __true_type __type; }; __extension__ template<> struct __is_integer<unsigned __int128> { enum { __value = 1 }; typedef __true_type __type; };
# 289 "/usr/include/c++/14.2.1/bits/cpp_type_traits.h" 3
  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 366 "/usr/include/c++/14.2.1/bits/cpp_type_traits.h" 3
  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  enum class byte : unsigned char;

  template<>
    struct __is_byte<byte>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



  template<>
    struct __is_byte<char8_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename> struct iterator_traits;


  template<typename _Tp>
    struct __is_nonvolatile_trivially_copyable
    {
      enum { __value = __is_trivially_copyable(_Tp) };
    };




  template<typename _Tp>
    struct __is_nonvolatile_trivially_copyable<volatile _Tp>
    {
      enum { __value = 0 };
    };


  template<typename _OutputIter, typename _InputIter>
    struct __memcpyable
    {
      enum { __value = 0 };
    };

  template<typename _Tp>
    struct __memcpyable<_Tp*, _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };

  template<typename _Tp>
    struct __memcpyable<_Tp*, const _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };






  template<typename _Iter1, typename _Iter2>
    struct __memcmpable
    {
      enum { __value = 0 };
    };


  template<typename _Tp>
    struct __memcmpable<_Tp*, _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };

  template<typename _Tp>
    struct __memcmpable<const _Tp*, _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };

  template<typename _Tp>
    struct __memcmpable<_Tp*, const _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };







  template<typename _Tp, bool _TreatAsBytes =



 __is_byte<_Tp>::__value

    >
    struct __is_memcmp_ordered
    {
      static const bool __value = _Tp(-1) > _Tp(1);
    };

  template<typename _Tp>
    struct __is_memcmp_ordered<_Tp, false>
    {
      static const bool __value = false;
    };


  template<typename _Tp, typename _Up, bool = sizeof(_Tp) == sizeof(_Up)>
    struct __is_memcmp_ordered_with
    {
      static const bool __value = __is_memcmp_ordered<_Tp>::__value
 && __is_memcmp_ordered<_Up>::__value;
    };

  template<typename _Tp, typename _Up>
    struct __is_memcmp_ordered_with<_Tp, _Up, false>
    {
      static const bool __value = false;
    };
# 579 "/usr/include/c++/14.2.1/bits/cpp_type_traits.h" 3
  template<>
    struct __is_memcmp_ordered_with<std::byte, std::byte, true>
    { static constexpr bool __value = true; };

  template<typename _Tp, bool _SameSize>
    struct __is_memcmp_ordered_with<_Tp, std::byte, _SameSize>
    { static constexpr bool __value = false; };

  template<typename _Up, bool _SameSize>
    struct __is_memcmp_ordered_with<std::byte, _Up, _SameSize>
    { static constexpr bool __value = false; };





  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };



  template<typename _Iterator>
    constexpr
    inline _Iterator
    __miter_base(_Iterator __it)
    { return __it; }


}
}
# 45 "/usr/include/c++/14.2.1/cmath" 2 3
# 1 "/usr/include/c++/14.2.1/ext/type_traits.h" 1 3
# 32 "/usr/include/c++/14.2.1/ext/type_traits.h" 3
       
# 33 "/usr/include/c++/14.2.1/ext/type_traits.h" 3




extern "C++" {

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    constexpr
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    constexpr
    inline bool
    __is_null_pointer(_Type)
    { return false; }


  constexpr bool
  __is_null_pointer(std::nullptr_t)
  { return true; }




  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };




  template<typename _Tp>
    struct __promote<_Tp, false>
    { };

  template<>
    struct __promote<long double>
    { typedef long double __type; };

  template<>
    struct __promote<double>
    { typedef double __type; };

  template<>
    struct __promote<float>
    { typedef float __type; };
# 225 "/usr/include/c++/14.2.1/ext/type_traits.h" 3
  template<typename... _Tp>
    using __promoted_t = decltype((typename __promote<_Tp>::__type(0) + ...));



  template<typename _Tp, typename _Up>
    using __promote_2 = __promote<__promoted_t<_Tp, _Up>>;

  template<typename _Tp, typename _Up, typename _Vp>
    using __promote_3 = __promote<__promoted_t<_Tp, _Up, _Vp>>;

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp>
    using __promote_4 = __promote<__promoted_t<_Tp, _Up, _Vp, _Wp>>;
# 269 "/usr/include/c++/14.2.1/ext/type_traits.h" 3

}
}
# 46 "/usr/include/c++/14.2.1/cmath" 2 3

# 1 "/usr/include/math.h" 1 3 4
# 27 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/math.h" 2 3 4






extern "C" {





# 1 "/usr/include/bits/math-vector.h" 1 3 4
# 25 "/usr/include/bits/math-vector.h" 3 4
# 1 "/usr/include/bits/libm-simd-decl-stubs.h" 1 3 4
# 26 "/usr/include/bits/math-vector.h" 2 3 4
# 41 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/bits/floatn.h" 1 3 4
# 119 "/usr/include/bits/floatn.h" 3 4
# 1 "/usr/include/bits/floatn-common.h" 1 3 4
# 24 "/usr/include/bits/floatn-common.h" 3 4
# 1 "/usr/include/bits/long-double.h" 1 3 4
# 25 "/usr/include/bits/floatn-common.h" 2 3 4
# 120 "/usr/include/bits/floatn.h" 2 3 4
# 44 "/usr/include/math.h" 2 3 4
# 152 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/flt-eval-method.h" 1 3 4
# 153 "/usr/include/math.h" 2 3 4
# 163 "/usr/include/math.h" 3 4
typedef float float_t;
typedef double double_t;
# 204 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/fp-logb.h" 1 3 4
# 205 "/usr/include/math.h" 2 3 4
# 247 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/fp-fast.h" 1 3 4
# 248 "/usr/include/math.h" 2 3 4



enum
  {
    FP_INT_UPWARD =

      0,
    FP_INT_DOWNWARD =

      1,
    FP_INT_TOWARDZERO =

      2,
    FP_INT_TONEARESTFROMZERO =

      3,
    FP_INT_TONEAREST =

      4,
  };
# 312 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassify (double __value) noexcept (true)
     __attribute__ ((__const__));


extern int __signbit (double __value) noexcept (true)
     __attribute__ ((__const__));



extern int __isinf (double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __finite (double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __isnan (double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __iseqsig (double __x, double __y) noexcept (true);


extern int __issignaling (double __value) noexcept (true)
     __attribute__ ((__const__));
# 313 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4
 extern double acos (double __x) noexcept (true); extern double __acos (double __x) noexcept (true);

 extern double asin (double __x) noexcept (true); extern double __asin (double __x) noexcept (true);

 extern double atan (double __x) noexcept (true); extern double __atan (double __x) noexcept (true);

 extern double atan2 (double __y, double __x) noexcept (true); extern double __atan2 (double __y, double __x) noexcept (true);


 extern double cos (double __x) noexcept (true); extern double __cos (double __x) noexcept (true);

 extern double sin (double __x) noexcept (true); extern double __sin (double __x) noexcept (true);

 extern double tan (double __x) noexcept (true); extern double __tan (double __x) noexcept (true);




 extern double cosh (double __x) noexcept (true); extern double __cosh (double __x) noexcept (true);

 extern double sinh (double __x) noexcept (true); extern double __sinh (double __x) noexcept (true);

 extern double tanh (double __x) noexcept (true); extern double __tanh (double __x) noexcept (true);



 extern void sincos (double __x, double *__sinx, double *__cosx) noexcept (true); extern void __sincos (double __x, double *__sinx, double *__cosx) noexcept (true)
                                                        ;




 extern double acosh (double __x) noexcept (true); extern double __acosh (double __x) noexcept (true);

 extern double asinh (double __x) noexcept (true); extern double __asinh (double __x) noexcept (true);

 extern double atanh (double __x) noexcept (true); extern double __atanh (double __x) noexcept (true);





 extern double exp (double __x) noexcept (true); extern double __exp (double __x) noexcept (true);


extern double frexp (double __x, int *__exponent) noexcept (true); extern double __frexp (double __x, int *__exponent) noexcept (true);


extern double ldexp (double __x, int __exponent) noexcept (true); extern double __ldexp (double __x, int __exponent) noexcept (true);


 extern double log (double __x) noexcept (true); extern double __log (double __x) noexcept (true);


 extern double log10 (double __x) noexcept (true); extern double __log10 (double __x) noexcept (true);


extern double modf (double __x, double *__iptr) noexcept (true); extern double __modf (double __x, double *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern double exp10 (double __x) noexcept (true); extern double __exp10 (double __x) noexcept (true);


extern double exp2m1 (double __x) noexcept (true); extern double __exp2m1 (double __x) noexcept (true);


extern double exp10m1 (double __x) noexcept (true); extern double __exp10m1 (double __x) noexcept (true);


extern double log2p1 (double __x) noexcept (true); extern double __log2p1 (double __x) noexcept (true);


extern double log10p1 (double __x) noexcept (true); extern double __log10p1 (double __x) noexcept (true);


extern double logp1 (double __x) noexcept (true); extern double __logp1 (double __x) noexcept (true);




 extern double expm1 (double __x) noexcept (true); extern double __expm1 (double __x) noexcept (true);


 extern double log1p (double __x) noexcept (true); extern double __log1p (double __x) noexcept (true);


extern double logb (double __x) noexcept (true); extern double __logb (double __x) noexcept (true);




 extern double exp2 (double __x) noexcept (true); extern double __exp2 (double __x) noexcept (true);


 extern double log2 (double __x) noexcept (true); extern double __log2 (double __x) noexcept (true);






 extern double pow (double __x, double __y) noexcept (true); extern double __pow (double __x, double __y) noexcept (true);


extern double sqrt (double __x) noexcept (true); extern double __sqrt (double __x) noexcept (true);



 extern double hypot (double __x, double __y) noexcept (true); extern double __hypot (double __x, double __y) noexcept (true);




 extern double cbrt (double __x) noexcept (true); extern double __cbrt (double __x) noexcept (true);






extern double ceil (double __x) noexcept (true) __attribute__ ((__const__)); extern double __ceil (double __x) noexcept (true) __attribute__ ((__const__));


extern double fabs (double __x) noexcept (true) __attribute__ ((__const__)); extern double __fabs (double __x) noexcept (true) __attribute__ ((__const__));


extern double floor (double __x) noexcept (true) __attribute__ ((__const__)); extern double __floor (double __x) noexcept (true) __attribute__ ((__const__));


extern double fmod (double __x, double __y) noexcept (true); extern double __fmod (double __x, double __y) noexcept (true);
# 198 "/usr/include/bits/mathcalls.h" 3 4
extern int finite (double __value) noexcept (true)
  __attribute__ ((__const__));


extern double drem (double __x, double __y) noexcept (true); extern double __drem (double __x, double __y) noexcept (true);



extern double significand (double __x) noexcept (true); extern double __significand (double __x) noexcept (true);






extern double copysign (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __copysign (double __x, double __y) noexcept (true) __attribute__ ((__const__));




extern double nan (const char *__tagb) noexcept (true); extern double __nan (const char *__tagb) noexcept (true);
# 235 "/usr/include/bits/mathcalls.h" 3 4
extern double j0 (double) noexcept (true); extern double __j0 (double) noexcept (true);
extern double j1 (double) noexcept (true); extern double __j1 (double) noexcept (true);
extern double jn (int, double) noexcept (true); extern double __jn (int, double) noexcept (true);
extern double y0 (double) noexcept (true); extern double __y0 (double) noexcept (true);
extern double y1 (double) noexcept (true); extern double __y1 (double) noexcept (true);
extern double yn (int, double) noexcept (true); extern double __yn (int, double) noexcept (true);





 extern double erf (double) noexcept (true); extern double __erf (double) noexcept (true);
 extern double erfc (double) noexcept (true); extern double __erfc (double) noexcept (true);
extern double lgamma (double) noexcept (true); extern double __lgamma (double) noexcept (true);




extern double tgamma (double) noexcept (true); extern double __tgamma (double) noexcept (true);





extern double gamma (double) noexcept (true); extern double __gamma (double) noexcept (true);







extern double lgamma_r (double, int *__signgamp) noexcept (true); extern double __lgamma_r (double, int *__signgamp) noexcept (true);






extern double rint (double __x) noexcept (true); extern double __rint (double __x) noexcept (true);


extern double nextafter (double __x, double __y) noexcept (true); extern double __nextafter (double __x, double __y) noexcept (true);

extern double nexttoward (double __x, long double __y) noexcept (true); extern double __nexttoward (double __x, long double __y) noexcept (true);




extern double nextdown (double __x) noexcept (true); extern double __nextdown (double __x) noexcept (true);

extern double nextup (double __x) noexcept (true); extern double __nextup (double __x) noexcept (true);



extern double remainder (double __x, double __y) noexcept (true); extern double __remainder (double __x, double __y) noexcept (true);



extern double scalbn (double __x, int __n) noexcept (true); extern double __scalbn (double __x, int __n) noexcept (true);



extern int ilogb (double __x) noexcept (true); extern int __ilogb (double __x) noexcept (true);




extern long int llogb (double __x) noexcept (true); extern long int __llogb (double __x) noexcept (true);




extern double scalbln (double __x, long int __n) noexcept (true); extern double __scalbln (double __x, long int __n) noexcept (true);



extern double nearbyint (double __x) noexcept (true); extern double __nearbyint (double __x) noexcept (true);



extern double round (double __x) noexcept (true) __attribute__ ((__const__)); extern double __round (double __x) noexcept (true) __attribute__ ((__const__));



extern double trunc (double __x) noexcept (true) __attribute__ ((__const__)); extern double __trunc (double __x) noexcept (true) __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) noexcept (true); extern double __remquo (double __x, double __y, int *__quo) noexcept (true);






extern long int lrint (double __x) noexcept (true); extern long int __lrint (double __x) noexcept (true);
__extension__
extern long long int llrint (double __x) noexcept (true); extern long long int __llrint (double __x) noexcept (true);



extern long int lround (double __x) noexcept (true); extern long int __lround (double __x) noexcept (true);
__extension__
extern long long int llround (double __x) noexcept (true); extern long long int __llround (double __x) noexcept (true);



extern double fdim (double __x, double __y) noexcept (true); extern double __fdim (double __x, double __y) noexcept (true);



extern double fmax (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmax (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fmin (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmin (double __x, double __y) noexcept (true) __attribute__ ((__const__));



extern double fma (double __x, double __y, double __z) noexcept (true); extern double __fma (double __x, double __y, double __z) noexcept (true);




extern double roundeven (double __x) noexcept (true) __attribute__ ((__const__)); extern double __roundeven (double __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfp (double __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfp (double __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfp (double __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfp (double __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpx (double __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpx (double __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpx (double __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpx (double __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern int canonicalize (double *__cx, const double *__x) noexcept (true);






extern double fmaxmag (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmaxmag (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fminmag (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fminmag (double __x, double __y) noexcept (true) __attribute__ ((__const__));




extern double fmaximum (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmaximum (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fminimum (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fminimum (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fmaximum_num (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmaximum_num (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fminimum_num (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fminimum_num (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fmaximum_mag (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmaximum_mag (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fminimum_mag (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fminimum_mag (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fmaximum_mag_num (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmaximum_mag_num (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fminimum_mag_num (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fminimum_mag_num (double __x, double __y) noexcept (true) __attribute__ ((__const__));




extern int totalorder (const double *__x, const double *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermag (const double *__x, const double *__y) noexcept (true)

     __attribute__ ((__pure__));


extern double getpayload (const double *__x) noexcept (true); extern double __getpayload (const double *__x) noexcept (true);


extern int setpayload (double *__x, double __payload) noexcept (true);


extern int setpayloadsig (double *__x, double __payload) noexcept (true);







extern double scalb (double __x, double __n) noexcept (true); extern double __scalb (double __x, double __n) noexcept (true);
# 314 "/usr/include/math.h" 2 3 4
# 329 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyf (float __value) noexcept (true)
     __attribute__ ((__const__));


extern int __signbitf (float __value) noexcept (true)
     __attribute__ ((__const__));



extern int __isinff (float __value) noexcept (true)
  __attribute__ ((__const__));


extern int __finitef (float __value) noexcept (true)
  __attribute__ ((__const__));


extern int __isnanf (float __value) noexcept (true)
  __attribute__ ((__const__));


extern int __iseqsigf (float __x, float __y) noexcept (true);


extern int __issignalingf (float __value) noexcept (true)
     __attribute__ ((__const__));
# 330 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4
 extern float acosf (float __x) noexcept (true); extern float __acosf (float __x) noexcept (true);

 extern float asinf (float __x) noexcept (true); extern float __asinf (float __x) noexcept (true);

 extern float atanf (float __x) noexcept (true); extern float __atanf (float __x) noexcept (true);

 extern float atan2f (float __y, float __x) noexcept (true); extern float __atan2f (float __y, float __x) noexcept (true);


 extern float cosf (float __x) noexcept (true); extern float __cosf (float __x) noexcept (true);

 extern float sinf (float __x) noexcept (true); extern float __sinf (float __x) noexcept (true);

 extern float tanf (float __x) noexcept (true); extern float __tanf (float __x) noexcept (true);




 extern float coshf (float __x) noexcept (true); extern float __coshf (float __x) noexcept (true);

 extern float sinhf (float __x) noexcept (true); extern float __sinhf (float __x) noexcept (true);

 extern float tanhf (float __x) noexcept (true); extern float __tanhf (float __x) noexcept (true);



 extern void sincosf (float __x, float *__sinx, float *__cosx) noexcept (true); extern void __sincosf (float __x, float *__sinx, float *__cosx) noexcept (true)
                                                        ;




 extern float acoshf (float __x) noexcept (true); extern float __acoshf (float __x) noexcept (true);

 extern float asinhf (float __x) noexcept (true); extern float __asinhf (float __x) noexcept (true);

 extern float atanhf (float __x) noexcept (true); extern float __atanhf (float __x) noexcept (true);





 extern float expf (float __x) noexcept (true); extern float __expf (float __x) noexcept (true);


extern float frexpf (float __x, int *__exponent) noexcept (true); extern float __frexpf (float __x, int *__exponent) noexcept (true);


extern float ldexpf (float __x, int __exponent) noexcept (true); extern float __ldexpf (float __x, int __exponent) noexcept (true);


 extern float logf (float __x) noexcept (true); extern float __logf (float __x) noexcept (true);


 extern float log10f (float __x) noexcept (true); extern float __log10f (float __x) noexcept (true);


extern float modff (float __x, float *__iptr) noexcept (true); extern float __modff (float __x, float *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern float exp10f (float __x) noexcept (true); extern float __exp10f (float __x) noexcept (true);


extern float exp2m1f (float __x) noexcept (true); extern float __exp2m1f (float __x) noexcept (true);


extern float exp10m1f (float __x) noexcept (true); extern float __exp10m1f (float __x) noexcept (true);


extern float log2p1f (float __x) noexcept (true); extern float __log2p1f (float __x) noexcept (true);


extern float log10p1f (float __x) noexcept (true); extern float __log10p1f (float __x) noexcept (true);


extern float logp1f (float __x) noexcept (true); extern float __logp1f (float __x) noexcept (true);




 extern float expm1f (float __x) noexcept (true); extern float __expm1f (float __x) noexcept (true);


 extern float log1pf (float __x) noexcept (true); extern float __log1pf (float __x) noexcept (true);


extern float logbf (float __x) noexcept (true); extern float __logbf (float __x) noexcept (true);




 extern float exp2f (float __x) noexcept (true); extern float __exp2f (float __x) noexcept (true);


 extern float log2f (float __x) noexcept (true); extern float __log2f (float __x) noexcept (true);






 extern float powf (float __x, float __y) noexcept (true); extern float __powf (float __x, float __y) noexcept (true);


extern float sqrtf (float __x) noexcept (true); extern float __sqrtf (float __x) noexcept (true);



 extern float hypotf (float __x, float __y) noexcept (true); extern float __hypotf (float __x, float __y) noexcept (true);




 extern float cbrtf (float __x) noexcept (true); extern float __cbrtf (float __x) noexcept (true);






extern float ceilf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __ceilf (float __x) noexcept (true) __attribute__ ((__const__));


extern float fabsf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __fabsf (float __x) noexcept (true) __attribute__ ((__const__));


extern float floorf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __floorf (float __x) noexcept (true) __attribute__ ((__const__));


extern float fmodf (float __x, float __y) noexcept (true); extern float __fmodf (float __x, float __y) noexcept (true);
# 192 "/usr/include/bits/mathcalls.h" 3 4
extern int isinff (float __value) noexcept (true)
  __attribute__ ((__const__));




extern int finitef (float __value) noexcept (true)
  __attribute__ ((__const__));


extern float dremf (float __x, float __y) noexcept (true); extern float __dremf (float __x, float __y) noexcept (true);



extern float significandf (float __x) noexcept (true); extern float __significandf (float __x) noexcept (true);






extern float copysignf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) noexcept (true) __attribute__ ((__const__));




extern float nanf (const char *__tagb) noexcept (true); extern float __nanf (const char *__tagb) noexcept (true);
# 228 "/usr/include/bits/mathcalls.h" 3 4
extern int isnanf (float __value) noexcept (true)
  __attribute__ ((__const__));





extern float j0f (float) noexcept (true); extern float __j0f (float) noexcept (true);
extern float j1f (float) noexcept (true); extern float __j1f (float) noexcept (true);
extern float jnf (int, float) noexcept (true); extern float __jnf (int, float) noexcept (true);
extern float y0f (float) noexcept (true); extern float __y0f (float) noexcept (true);
extern float y1f (float) noexcept (true); extern float __y1f (float) noexcept (true);
extern float ynf (int, float) noexcept (true); extern float __ynf (int, float) noexcept (true);





 extern float erff (float) noexcept (true); extern float __erff (float) noexcept (true);
 extern float erfcf (float) noexcept (true); extern float __erfcf (float) noexcept (true);
extern float lgammaf (float) noexcept (true); extern float __lgammaf (float) noexcept (true);




extern float tgammaf (float) noexcept (true); extern float __tgammaf (float) noexcept (true);





extern float gammaf (float) noexcept (true); extern float __gammaf (float) noexcept (true);







extern float lgammaf_r (float, int *__signgamp) noexcept (true); extern float __lgammaf_r (float, int *__signgamp) noexcept (true);






extern float rintf (float __x) noexcept (true); extern float __rintf (float __x) noexcept (true);


extern float nextafterf (float __x, float __y) noexcept (true); extern float __nextafterf (float __x, float __y) noexcept (true);

extern float nexttowardf (float __x, long double __y) noexcept (true); extern float __nexttowardf (float __x, long double __y) noexcept (true);




extern float nextdownf (float __x) noexcept (true); extern float __nextdownf (float __x) noexcept (true);

extern float nextupf (float __x) noexcept (true); extern float __nextupf (float __x) noexcept (true);



extern float remainderf (float __x, float __y) noexcept (true); extern float __remainderf (float __x, float __y) noexcept (true);



extern float scalbnf (float __x, int __n) noexcept (true); extern float __scalbnf (float __x, int __n) noexcept (true);



extern int ilogbf (float __x) noexcept (true); extern int __ilogbf (float __x) noexcept (true);




extern long int llogbf (float __x) noexcept (true); extern long int __llogbf (float __x) noexcept (true);




extern float scalblnf (float __x, long int __n) noexcept (true); extern float __scalblnf (float __x, long int __n) noexcept (true);



extern float nearbyintf (float __x) noexcept (true); extern float __nearbyintf (float __x) noexcept (true);



extern float roundf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __roundf (float __x) noexcept (true) __attribute__ ((__const__));



extern float truncf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __truncf (float __x) noexcept (true) __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) noexcept (true); extern float __remquof (float __x, float __y, int *__quo) noexcept (true);






extern long int lrintf (float __x) noexcept (true); extern long int __lrintf (float __x) noexcept (true);
__extension__
extern long long int llrintf (float __x) noexcept (true); extern long long int __llrintf (float __x) noexcept (true);



extern long int lroundf (float __x) noexcept (true); extern long int __lroundf (float __x) noexcept (true);
__extension__
extern long long int llroundf (float __x) noexcept (true); extern long long int __llroundf (float __x) noexcept (true);



extern float fdimf (float __x, float __y) noexcept (true); extern float __fdimf (float __x, float __y) noexcept (true);



extern float fmaxf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fmaxf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fminf (float __x, float __y) noexcept (true) __attribute__ ((__const__));



extern float fmaf (float __x, float __y, float __z) noexcept (true); extern float __fmaf (float __x, float __y, float __z) noexcept (true);




extern float roundevenf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __roundevenf (float __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf (float __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf (float __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfpf (float __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf (float __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpxf (float __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf (float __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpxf (float __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf (float __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern int canonicalizef (float *__cx, const float *__x) noexcept (true);






extern float fmaxmagf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fmaxmagf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminmagf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fminmagf (float __x, float __y) noexcept (true) __attribute__ ((__const__));




extern float fmaximumf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fmaximumf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminimumf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fminimumf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fmaximum_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fmaximum_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminimum_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fminimum_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fmaximum_magf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fmaximum_magf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminimum_magf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fminimum_magf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fmaximum_mag_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fmaximum_mag_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminimum_mag_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fminimum_mag_numf (float __x, float __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf (const float *__x, const float *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf (const float *__x, const float *__y) noexcept (true)

     __attribute__ ((__pure__));


extern float getpayloadf (const float *__x) noexcept (true); extern float __getpayloadf (const float *__x) noexcept (true);


extern int setpayloadf (float *__x, float __payload) noexcept (true);


extern int setpayloadsigf (float *__x, float __payload) noexcept (true);







extern float scalbf (float __x, float __n) noexcept (true); extern float __scalbf (float __x, float __n) noexcept (true);
# 331 "/usr/include/math.h" 2 3 4
# 398 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyl (long double __value) noexcept (true)
     __attribute__ ((__const__));


extern int __signbitl (long double __value) noexcept (true)
     __attribute__ ((__const__));



extern int __isinfl (long double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __finitel (long double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __isnanl (long double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __iseqsigl (long double __x, long double __y) noexcept (true);


extern int __issignalingl (long double __value) noexcept (true)
     __attribute__ ((__const__));
# 399 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4
 extern long double acosl (long double __x) noexcept (true); extern long double __acosl (long double __x) noexcept (true);

 extern long double asinl (long double __x) noexcept (true); extern long double __asinl (long double __x) noexcept (true);

 extern long double atanl (long double __x) noexcept (true); extern long double __atanl (long double __x) noexcept (true);

 extern long double atan2l (long double __y, long double __x) noexcept (true); extern long double __atan2l (long double __y, long double __x) noexcept (true);


 extern long double cosl (long double __x) noexcept (true); extern long double __cosl (long double __x) noexcept (true);

 extern long double sinl (long double __x) noexcept (true); extern long double __sinl (long double __x) noexcept (true);

 extern long double tanl (long double __x) noexcept (true); extern long double __tanl (long double __x) noexcept (true);




 extern long double coshl (long double __x) noexcept (true); extern long double __coshl (long double __x) noexcept (true);

 extern long double sinhl (long double __x) noexcept (true); extern long double __sinhl (long double __x) noexcept (true);

 extern long double tanhl (long double __x) noexcept (true); extern long double __tanhl (long double __x) noexcept (true);



 extern void sincosl (long double __x, long double *__sinx, long double *__cosx) noexcept (true); extern void __sincosl (long double __x, long double *__sinx, long double *__cosx) noexcept (true)
                                                        ;




 extern long double acoshl (long double __x) noexcept (true); extern long double __acoshl (long double __x) noexcept (true);

 extern long double asinhl (long double __x) noexcept (true); extern long double __asinhl (long double __x) noexcept (true);

 extern long double atanhl (long double __x) noexcept (true); extern long double __atanhl (long double __x) noexcept (true);





 extern long double expl (long double __x) noexcept (true); extern long double __expl (long double __x) noexcept (true);


extern long double frexpl (long double __x, int *__exponent) noexcept (true); extern long double __frexpl (long double __x, int *__exponent) noexcept (true);


extern long double ldexpl (long double __x, int __exponent) noexcept (true); extern long double __ldexpl (long double __x, int __exponent) noexcept (true);


 extern long double logl (long double __x) noexcept (true); extern long double __logl (long double __x) noexcept (true);


 extern long double log10l (long double __x) noexcept (true); extern long double __log10l (long double __x) noexcept (true);


extern long double modfl (long double __x, long double *__iptr) noexcept (true); extern long double __modfl (long double __x, long double *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern long double exp10l (long double __x) noexcept (true); extern long double __exp10l (long double __x) noexcept (true);


extern long double exp2m1l (long double __x) noexcept (true); extern long double __exp2m1l (long double __x) noexcept (true);


extern long double exp10m1l (long double __x) noexcept (true); extern long double __exp10m1l (long double __x) noexcept (true);


extern long double log2p1l (long double __x) noexcept (true); extern long double __log2p1l (long double __x) noexcept (true);


extern long double log10p1l (long double __x) noexcept (true); extern long double __log10p1l (long double __x) noexcept (true);


extern long double logp1l (long double __x) noexcept (true); extern long double __logp1l (long double __x) noexcept (true);




 extern long double expm1l (long double __x) noexcept (true); extern long double __expm1l (long double __x) noexcept (true);


 extern long double log1pl (long double __x) noexcept (true); extern long double __log1pl (long double __x) noexcept (true);


extern long double logbl (long double __x) noexcept (true); extern long double __logbl (long double __x) noexcept (true);




 extern long double exp2l (long double __x) noexcept (true); extern long double __exp2l (long double __x) noexcept (true);


 extern long double log2l (long double __x) noexcept (true); extern long double __log2l (long double __x) noexcept (true);






 extern long double powl (long double __x, long double __y) noexcept (true); extern long double __powl (long double __x, long double __y) noexcept (true);


extern long double sqrtl (long double __x) noexcept (true); extern long double __sqrtl (long double __x) noexcept (true);



 extern long double hypotl (long double __x, long double __y) noexcept (true); extern long double __hypotl (long double __x, long double __y) noexcept (true);




 extern long double cbrtl (long double __x) noexcept (true); extern long double __cbrtl (long double __x) noexcept (true);






extern long double ceill (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __ceill (long double __x) noexcept (true) __attribute__ ((__const__));


extern long double fabsl (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __fabsl (long double __x) noexcept (true) __attribute__ ((__const__));


extern long double floorl (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __floorl (long double __x) noexcept (true) __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) noexcept (true); extern long double __fmodl (long double __x, long double __y) noexcept (true);
# 192 "/usr/include/bits/mathcalls.h" 3 4
extern int isinfl (long double __value) noexcept (true)
  __attribute__ ((__const__));




extern int finitel (long double __value) noexcept (true)
  __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) noexcept (true); extern long double __dreml (long double __x, long double __y) noexcept (true);



extern long double significandl (long double __x) noexcept (true); extern long double __significandl (long double __x) noexcept (true);






extern long double copysignl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));




extern long double nanl (const char *__tagb) noexcept (true); extern long double __nanl (const char *__tagb) noexcept (true);
# 228 "/usr/include/bits/mathcalls.h" 3 4
extern int isnanl (long double __value) noexcept (true)
  __attribute__ ((__const__));





extern long double j0l (long double) noexcept (true); extern long double __j0l (long double) noexcept (true);
extern long double j1l (long double) noexcept (true); extern long double __j1l (long double) noexcept (true);
extern long double jnl (int, long double) noexcept (true); extern long double __jnl (int, long double) noexcept (true);
extern long double y0l (long double) noexcept (true); extern long double __y0l (long double) noexcept (true);
extern long double y1l (long double) noexcept (true); extern long double __y1l (long double) noexcept (true);
extern long double ynl (int, long double) noexcept (true); extern long double __ynl (int, long double) noexcept (true);





 extern long double erfl (long double) noexcept (true); extern long double __erfl (long double) noexcept (true);
 extern long double erfcl (long double) noexcept (true); extern long double __erfcl (long double) noexcept (true);
extern long double lgammal (long double) noexcept (true); extern long double __lgammal (long double) noexcept (true);




extern long double tgammal (long double) noexcept (true); extern long double __tgammal (long double) noexcept (true);





extern long double gammal (long double) noexcept (true); extern long double __gammal (long double) noexcept (true);







extern long double lgammal_r (long double, int *__signgamp) noexcept (true); extern long double __lgammal_r (long double, int *__signgamp) noexcept (true);






extern long double rintl (long double __x) noexcept (true); extern long double __rintl (long double __x) noexcept (true);


extern long double nextafterl (long double __x, long double __y) noexcept (true); extern long double __nextafterl (long double __x, long double __y) noexcept (true);

extern long double nexttowardl (long double __x, long double __y) noexcept (true); extern long double __nexttowardl (long double __x, long double __y) noexcept (true);




extern long double nextdownl (long double __x) noexcept (true); extern long double __nextdownl (long double __x) noexcept (true);

extern long double nextupl (long double __x) noexcept (true); extern long double __nextupl (long double __x) noexcept (true);



extern long double remainderl (long double __x, long double __y) noexcept (true); extern long double __remainderl (long double __x, long double __y) noexcept (true);



extern long double scalbnl (long double __x, int __n) noexcept (true); extern long double __scalbnl (long double __x, int __n) noexcept (true);



extern int ilogbl (long double __x) noexcept (true); extern int __ilogbl (long double __x) noexcept (true);




extern long int llogbl (long double __x) noexcept (true); extern long int __llogbl (long double __x) noexcept (true);




extern long double scalblnl (long double __x, long int __n) noexcept (true); extern long double __scalblnl (long double __x, long int __n) noexcept (true);



extern long double nearbyintl (long double __x) noexcept (true); extern long double __nearbyintl (long double __x) noexcept (true);



extern long double roundl (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __roundl (long double __x) noexcept (true) __attribute__ ((__const__));



extern long double truncl (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __truncl (long double __x) noexcept (true) __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) noexcept (true); extern long double __remquol (long double __x, long double __y, int *__quo) noexcept (true);






extern long int lrintl (long double __x) noexcept (true); extern long int __lrintl (long double __x) noexcept (true);
__extension__
extern long long int llrintl (long double __x) noexcept (true); extern long long int __llrintl (long double __x) noexcept (true);



extern long int lroundl (long double __x) noexcept (true); extern long int __lroundl (long double __x) noexcept (true);
__extension__
extern long long int llroundl (long double __x) noexcept (true); extern long long int __llroundl (long double __x) noexcept (true);



extern long double fdiml (long double __x, long double __y) noexcept (true); extern long double __fdiml (long double __x, long double __y) noexcept (true);



extern long double fmaxl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fmaxl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fminl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));



extern long double fmal (long double __x, long double __y, long double __z) noexcept (true); extern long double __fmal (long double __x, long double __y, long double __z) noexcept (true);




extern long double roundevenl (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __roundevenl (long double __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpl (long double __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpl (long double __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfpl (long double __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpl (long double __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpxl (long double __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxl (long double __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpxl (long double __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxl (long double __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern int canonicalizel (long double *__cx, const long double *__x) noexcept (true);






extern long double fmaxmagl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fmaxmagl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminmagl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fminmagl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));




extern long double fmaximuml (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fmaximuml (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminimuml (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fminimuml (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fmaximum_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fmaximum_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminimum_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fminimum_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fmaximum_magl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fmaximum_magl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminimum_magl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fminimum_magl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fmaximum_mag_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fmaximum_mag_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminimum_mag_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fminimum_mag_numl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderl (const long double *__x, const long double *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagl (const long double *__x, const long double *__y) noexcept (true)

     __attribute__ ((__pure__));


extern long double getpayloadl (const long double *__x) noexcept (true); extern long double __getpayloadl (const long double *__x) noexcept (true);


extern int setpayloadl (long double *__x, long double __payload) noexcept (true);


extern int setpayloadsigl (long double *__x, long double __payload) noexcept (true);







extern long double scalbl (long double __x, long double __n) noexcept (true); extern long double __scalbl (long double __x, long double __n) noexcept (true);
# 400 "/usr/include/math.h" 2 3 4
# 450 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4
 extern _Float32 acosf32 (_Float32 __x) noexcept (true); extern _Float32 __acosf32 (_Float32 __x) noexcept (true);

 extern _Float32 asinf32 (_Float32 __x) noexcept (true); extern _Float32 __asinf32 (_Float32 __x) noexcept (true);

 extern _Float32 atanf32 (_Float32 __x) noexcept (true); extern _Float32 __atanf32 (_Float32 __x) noexcept (true);

 extern _Float32 atan2f32 (_Float32 __y, _Float32 __x) noexcept (true); extern _Float32 __atan2f32 (_Float32 __y, _Float32 __x) noexcept (true);


 extern _Float32 cosf32 (_Float32 __x) noexcept (true); extern _Float32 __cosf32 (_Float32 __x) noexcept (true);

 extern _Float32 sinf32 (_Float32 __x) noexcept (true); extern _Float32 __sinf32 (_Float32 __x) noexcept (true);

 extern _Float32 tanf32 (_Float32 __x) noexcept (true); extern _Float32 __tanf32 (_Float32 __x) noexcept (true);




 extern _Float32 coshf32 (_Float32 __x) noexcept (true); extern _Float32 __coshf32 (_Float32 __x) noexcept (true);

 extern _Float32 sinhf32 (_Float32 __x) noexcept (true); extern _Float32 __sinhf32 (_Float32 __x) noexcept (true);

 extern _Float32 tanhf32 (_Float32 __x) noexcept (true); extern _Float32 __tanhf32 (_Float32 __x) noexcept (true);



 extern void sincosf32 (_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) noexcept (true); extern void __sincosf32 (_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) noexcept (true)
                                                        ;




 extern _Float32 acoshf32 (_Float32 __x) noexcept (true); extern _Float32 __acoshf32 (_Float32 __x) noexcept (true);

 extern _Float32 asinhf32 (_Float32 __x) noexcept (true); extern _Float32 __asinhf32 (_Float32 __x) noexcept (true);

 extern _Float32 atanhf32 (_Float32 __x) noexcept (true); extern _Float32 __atanhf32 (_Float32 __x) noexcept (true);





 extern _Float32 expf32 (_Float32 __x) noexcept (true); extern _Float32 __expf32 (_Float32 __x) noexcept (true);


extern _Float32 frexpf32 (_Float32 __x, int *__exponent) noexcept (true); extern _Float32 __frexpf32 (_Float32 __x, int *__exponent) noexcept (true);


extern _Float32 ldexpf32 (_Float32 __x, int __exponent) noexcept (true); extern _Float32 __ldexpf32 (_Float32 __x, int __exponent) noexcept (true);


 extern _Float32 logf32 (_Float32 __x) noexcept (true); extern _Float32 __logf32 (_Float32 __x) noexcept (true);


 extern _Float32 log10f32 (_Float32 __x) noexcept (true); extern _Float32 __log10f32 (_Float32 __x) noexcept (true);


extern _Float32 modff32 (_Float32 __x, _Float32 *__iptr) noexcept (true); extern _Float32 __modff32 (_Float32 __x, _Float32 *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern _Float32 exp10f32 (_Float32 __x) noexcept (true); extern _Float32 __exp10f32 (_Float32 __x) noexcept (true);


extern _Float32 exp2m1f32 (_Float32 __x) noexcept (true); extern _Float32 __exp2m1f32 (_Float32 __x) noexcept (true);


extern _Float32 exp10m1f32 (_Float32 __x) noexcept (true); extern _Float32 __exp10m1f32 (_Float32 __x) noexcept (true);


extern _Float32 log2p1f32 (_Float32 __x) noexcept (true); extern _Float32 __log2p1f32 (_Float32 __x) noexcept (true);


extern _Float32 log10p1f32 (_Float32 __x) noexcept (true); extern _Float32 __log10p1f32 (_Float32 __x) noexcept (true);


extern _Float32 logp1f32 (_Float32 __x) noexcept (true); extern _Float32 __logp1f32 (_Float32 __x) noexcept (true);




 extern _Float32 expm1f32 (_Float32 __x) noexcept (true); extern _Float32 __expm1f32 (_Float32 __x) noexcept (true);


 extern _Float32 log1pf32 (_Float32 __x) noexcept (true); extern _Float32 __log1pf32 (_Float32 __x) noexcept (true);


extern _Float32 logbf32 (_Float32 __x) noexcept (true); extern _Float32 __logbf32 (_Float32 __x) noexcept (true);




 extern _Float32 exp2f32 (_Float32 __x) noexcept (true); extern _Float32 __exp2f32 (_Float32 __x) noexcept (true);


 extern _Float32 log2f32 (_Float32 __x) noexcept (true); extern _Float32 __log2f32 (_Float32 __x) noexcept (true);






 extern _Float32 powf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __powf32 (_Float32 __x, _Float32 __y) noexcept (true);


extern _Float32 sqrtf32 (_Float32 __x) noexcept (true); extern _Float32 __sqrtf32 (_Float32 __x) noexcept (true);



 extern _Float32 hypotf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __hypotf32 (_Float32 __x, _Float32 __y) noexcept (true);




 extern _Float32 cbrtf32 (_Float32 __x) noexcept (true); extern _Float32 __cbrtf32 (_Float32 __x) noexcept (true);






extern _Float32 ceilf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __ceilf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));


extern _Float32 fabsf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fabsf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));


extern _Float32 floorf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __floorf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));


extern _Float32 fmodf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __fmodf32 (_Float32 __x, _Float32 __y) noexcept (true);
# 213 "/usr/include/bits/mathcalls.h" 3 4
extern _Float32 copysignf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __copysignf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));




extern _Float32 nanf32 (const char *__tagb) noexcept (true); extern _Float32 __nanf32 (const char *__tagb) noexcept (true);
# 235 "/usr/include/bits/mathcalls.h" 3 4
extern _Float32 j0f32 (_Float32) noexcept (true); extern _Float32 __j0f32 (_Float32) noexcept (true);
extern _Float32 j1f32 (_Float32) noexcept (true); extern _Float32 __j1f32 (_Float32) noexcept (true);
extern _Float32 jnf32 (int, _Float32) noexcept (true); extern _Float32 __jnf32 (int, _Float32) noexcept (true);
extern _Float32 y0f32 (_Float32) noexcept (true); extern _Float32 __y0f32 (_Float32) noexcept (true);
extern _Float32 y1f32 (_Float32) noexcept (true); extern _Float32 __y1f32 (_Float32) noexcept (true);
extern _Float32 ynf32 (int, _Float32) noexcept (true); extern _Float32 __ynf32 (int, _Float32) noexcept (true);





 extern _Float32 erff32 (_Float32) noexcept (true); extern _Float32 __erff32 (_Float32) noexcept (true);
 extern _Float32 erfcf32 (_Float32) noexcept (true); extern _Float32 __erfcf32 (_Float32) noexcept (true);
extern _Float32 lgammaf32 (_Float32) noexcept (true); extern _Float32 __lgammaf32 (_Float32) noexcept (true);




extern _Float32 tgammaf32 (_Float32) noexcept (true); extern _Float32 __tgammaf32 (_Float32) noexcept (true);
# 267 "/usr/include/bits/mathcalls.h" 3 4
extern _Float32 lgammaf32_r (_Float32, int *__signgamp) noexcept (true); extern _Float32 __lgammaf32_r (_Float32, int *__signgamp) noexcept (true);






extern _Float32 rintf32 (_Float32 __x) noexcept (true); extern _Float32 __rintf32 (_Float32 __x) noexcept (true);


extern _Float32 nextafterf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __nextafterf32 (_Float32 __x, _Float32 __y) noexcept (true);






extern _Float32 nextdownf32 (_Float32 __x) noexcept (true); extern _Float32 __nextdownf32 (_Float32 __x) noexcept (true);

extern _Float32 nextupf32 (_Float32 __x) noexcept (true); extern _Float32 __nextupf32 (_Float32 __x) noexcept (true);



extern _Float32 remainderf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __remainderf32 (_Float32 __x, _Float32 __y) noexcept (true);



extern _Float32 scalbnf32 (_Float32 __x, int __n) noexcept (true); extern _Float32 __scalbnf32 (_Float32 __x, int __n) noexcept (true);



extern int ilogbf32 (_Float32 __x) noexcept (true); extern int __ilogbf32 (_Float32 __x) noexcept (true);




extern long int llogbf32 (_Float32 __x) noexcept (true); extern long int __llogbf32 (_Float32 __x) noexcept (true);




extern _Float32 scalblnf32 (_Float32 __x, long int __n) noexcept (true); extern _Float32 __scalblnf32 (_Float32 __x, long int __n) noexcept (true);



extern _Float32 nearbyintf32 (_Float32 __x) noexcept (true); extern _Float32 __nearbyintf32 (_Float32 __x) noexcept (true);



extern _Float32 roundf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __roundf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));



extern _Float32 truncf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __truncf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));




extern _Float32 remquof32 (_Float32 __x, _Float32 __y, int *__quo) noexcept (true); extern _Float32 __remquof32 (_Float32 __x, _Float32 __y, int *__quo) noexcept (true);






extern long int lrintf32 (_Float32 __x) noexcept (true); extern long int __lrintf32 (_Float32 __x) noexcept (true);
__extension__
extern long long int llrintf32 (_Float32 __x) noexcept (true); extern long long int __llrintf32 (_Float32 __x) noexcept (true);



extern long int lroundf32 (_Float32 __x) noexcept (true); extern long int __lroundf32 (_Float32 __x) noexcept (true);
__extension__
extern long long int llroundf32 (_Float32 __x) noexcept (true); extern long long int __llroundf32 (_Float32 __x) noexcept (true);



extern _Float32 fdimf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __fdimf32 (_Float32 __x, _Float32 __y) noexcept (true);



extern _Float32 fmaxf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fmaxf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fminf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));



extern _Float32 fmaf32 (_Float32 __x, _Float32 __y, _Float32 __z) noexcept (true); extern _Float32 __fmaf32 (_Float32 __x, _Float32 __y, _Float32 __z) noexcept (true);




extern _Float32 roundevenf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __roundevenf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfpf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpxf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpxf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern int canonicalizef32 (_Float32 *__cx, const _Float32 *__x) noexcept (true);






extern _Float32 fmaxmagf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fmaxmagf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminmagf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fminmagf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));




extern _Float32 fmaximumf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fmaximumf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminimumf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fminimumf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fmaximum_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fmaximum_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminimum_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fminimum_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fmaximum_magf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fmaximum_magf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminimum_magf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fminimum_magf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fmaximum_mag_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fmaximum_mag_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminimum_mag_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fminimum_mag_numf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf32 (const _Float32 *__x, const _Float32 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf32 (const _Float32 *__x, const _Float32 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern _Float32 getpayloadf32 (const _Float32 *__x) noexcept (true); extern _Float32 __getpayloadf32 (const _Float32 *__x) noexcept (true);


extern int setpayloadf32 (_Float32 *__x, _Float32 __payload) noexcept (true);


extern int setpayloadsigf32 (_Float32 *__x, _Float32 __payload) noexcept (true);
# 451 "/usr/include/math.h" 2 3 4
# 467 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4
 extern _Float64 acosf64 (_Float64 __x) noexcept (true); extern _Float64 __acosf64 (_Float64 __x) noexcept (true);

 extern _Float64 asinf64 (_Float64 __x) noexcept (true); extern _Float64 __asinf64 (_Float64 __x) noexcept (true);

 extern _Float64 atanf64 (_Float64 __x) noexcept (true); extern _Float64 __atanf64 (_Float64 __x) noexcept (true);

 extern _Float64 atan2f64 (_Float64 __y, _Float64 __x) noexcept (true); extern _Float64 __atan2f64 (_Float64 __y, _Float64 __x) noexcept (true);


 extern _Float64 cosf64 (_Float64 __x) noexcept (true); extern _Float64 __cosf64 (_Float64 __x) noexcept (true);

 extern _Float64 sinf64 (_Float64 __x) noexcept (true); extern _Float64 __sinf64 (_Float64 __x) noexcept (true);

 extern _Float64 tanf64 (_Float64 __x) noexcept (true); extern _Float64 __tanf64 (_Float64 __x) noexcept (true);




 extern _Float64 coshf64 (_Float64 __x) noexcept (true); extern _Float64 __coshf64 (_Float64 __x) noexcept (true);

 extern _Float64 sinhf64 (_Float64 __x) noexcept (true); extern _Float64 __sinhf64 (_Float64 __x) noexcept (true);

 extern _Float64 tanhf64 (_Float64 __x) noexcept (true); extern _Float64 __tanhf64 (_Float64 __x) noexcept (true);



 extern void sincosf64 (_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) noexcept (true); extern void __sincosf64 (_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) noexcept (true)
                                                        ;




 extern _Float64 acoshf64 (_Float64 __x) noexcept (true); extern _Float64 __acoshf64 (_Float64 __x) noexcept (true);

 extern _Float64 asinhf64 (_Float64 __x) noexcept (true); extern _Float64 __asinhf64 (_Float64 __x) noexcept (true);

 extern _Float64 atanhf64 (_Float64 __x) noexcept (true); extern _Float64 __atanhf64 (_Float64 __x) noexcept (true);





 extern _Float64 expf64 (_Float64 __x) noexcept (true); extern _Float64 __expf64 (_Float64 __x) noexcept (true);


extern _Float64 frexpf64 (_Float64 __x, int *__exponent) noexcept (true); extern _Float64 __frexpf64 (_Float64 __x, int *__exponent) noexcept (true);


extern _Float64 ldexpf64 (_Float64 __x, int __exponent) noexcept (true); extern _Float64 __ldexpf64 (_Float64 __x, int __exponent) noexcept (true);


 extern _Float64 logf64 (_Float64 __x) noexcept (true); extern _Float64 __logf64 (_Float64 __x) noexcept (true);


 extern _Float64 log10f64 (_Float64 __x) noexcept (true); extern _Float64 __log10f64 (_Float64 __x) noexcept (true);


extern _Float64 modff64 (_Float64 __x, _Float64 *__iptr) noexcept (true); extern _Float64 __modff64 (_Float64 __x, _Float64 *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern _Float64 exp10f64 (_Float64 __x) noexcept (true); extern _Float64 __exp10f64 (_Float64 __x) noexcept (true);


extern _Float64 exp2m1f64 (_Float64 __x) noexcept (true); extern _Float64 __exp2m1f64 (_Float64 __x) noexcept (true);


extern _Float64 exp10m1f64 (_Float64 __x) noexcept (true); extern _Float64 __exp10m1f64 (_Float64 __x) noexcept (true);


extern _Float64 log2p1f64 (_Float64 __x) noexcept (true); extern _Float64 __log2p1f64 (_Float64 __x) noexcept (true);


extern _Float64 log10p1f64 (_Float64 __x) noexcept (true); extern _Float64 __log10p1f64 (_Float64 __x) noexcept (true);


extern _Float64 logp1f64 (_Float64 __x) noexcept (true); extern _Float64 __logp1f64 (_Float64 __x) noexcept (true);




 extern _Float64 expm1f64 (_Float64 __x) noexcept (true); extern _Float64 __expm1f64 (_Float64 __x) noexcept (true);


 extern _Float64 log1pf64 (_Float64 __x) noexcept (true); extern _Float64 __log1pf64 (_Float64 __x) noexcept (true);


extern _Float64 logbf64 (_Float64 __x) noexcept (true); extern _Float64 __logbf64 (_Float64 __x) noexcept (true);




 extern _Float64 exp2f64 (_Float64 __x) noexcept (true); extern _Float64 __exp2f64 (_Float64 __x) noexcept (true);


 extern _Float64 log2f64 (_Float64 __x) noexcept (true); extern _Float64 __log2f64 (_Float64 __x) noexcept (true);






 extern _Float64 powf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __powf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float64 sqrtf64 (_Float64 __x) noexcept (true); extern _Float64 __sqrtf64 (_Float64 __x) noexcept (true);



 extern _Float64 hypotf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __hypotf64 (_Float64 __x, _Float64 __y) noexcept (true);




 extern _Float64 cbrtf64 (_Float64 __x) noexcept (true); extern _Float64 __cbrtf64 (_Float64 __x) noexcept (true);






extern _Float64 ceilf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __ceilf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));


extern _Float64 fabsf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fabsf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));


extern _Float64 floorf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __floorf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));


extern _Float64 fmodf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __fmodf64 (_Float64 __x, _Float64 __y) noexcept (true);
# 213 "/usr/include/bits/mathcalls.h" 3 4
extern _Float64 copysignf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __copysignf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));




extern _Float64 nanf64 (const char *__tagb) noexcept (true); extern _Float64 __nanf64 (const char *__tagb) noexcept (true);
# 235 "/usr/include/bits/mathcalls.h" 3 4
extern _Float64 j0f64 (_Float64) noexcept (true); extern _Float64 __j0f64 (_Float64) noexcept (true);
extern _Float64 j1f64 (_Float64) noexcept (true); extern _Float64 __j1f64 (_Float64) noexcept (true);
extern _Float64 jnf64 (int, _Float64) noexcept (true); extern _Float64 __jnf64 (int, _Float64) noexcept (true);
extern _Float64 y0f64 (_Float64) noexcept (true); extern _Float64 __y0f64 (_Float64) noexcept (true);
extern _Float64 y1f64 (_Float64) noexcept (true); extern _Float64 __y1f64 (_Float64) noexcept (true);
extern _Float64 ynf64 (int, _Float64) noexcept (true); extern _Float64 __ynf64 (int, _Float64) noexcept (true);





 extern _Float64 erff64 (_Float64) noexcept (true); extern _Float64 __erff64 (_Float64) noexcept (true);
 extern _Float64 erfcf64 (_Float64) noexcept (true); extern _Float64 __erfcf64 (_Float64) noexcept (true);
extern _Float64 lgammaf64 (_Float64) noexcept (true); extern _Float64 __lgammaf64 (_Float64) noexcept (true);




extern _Float64 tgammaf64 (_Float64) noexcept (true); extern _Float64 __tgammaf64 (_Float64) noexcept (true);
# 267 "/usr/include/bits/mathcalls.h" 3 4
extern _Float64 lgammaf64_r (_Float64, int *__signgamp) noexcept (true); extern _Float64 __lgammaf64_r (_Float64, int *__signgamp) noexcept (true);






extern _Float64 rintf64 (_Float64 __x) noexcept (true); extern _Float64 __rintf64 (_Float64 __x) noexcept (true);


extern _Float64 nextafterf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __nextafterf64 (_Float64 __x, _Float64 __y) noexcept (true);






extern _Float64 nextdownf64 (_Float64 __x) noexcept (true); extern _Float64 __nextdownf64 (_Float64 __x) noexcept (true);

extern _Float64 nextupf64 (_Float64 __x) noexcept (true); extern _Float64 __nextupf64 (_Float64 __x) noexcept (true);



extern _Float64 remainderf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __remainderf64 (_Float64 __x, _Float64 __y) noexcept (true);



extern _Float64 scalbnf64 (_Float64 __x, int __n) noexcept (true); extern _Float64 __scalbnf64 (_Float64 __x, int __n) noexcept (true);



extern int ilogbf64 (_Float64 __x) noexcept (true); extern int __ilogbf64 (_Float64 __x) noexcept (true);




extern long int llogbf64 (_Float64 __x) noexcept (true); extern long int __llogbf64 (_Float64 __x) noexcept (true);




extern _Float64 scalblnf64 (_Float64 __x, long int __n) noexcept (true); extern _Float64 __scalblnf64 (_Float64 __x, long int __n) noexcept (true);



extern _Float64 nearbyintf64 (_Float64 __x) noexcept (true); extern _Float64 __nearbyintf64 (_Float64 __x) noexcept (true);



extern _Float64 roundf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __roundf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));



extern _Float64 truncf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __truncf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));




extern _Float64 remquof64 (_Float64 __x, _Float64 __y, int *__quo) noexcept (true); extern _Float64 __remquof64 (_Float64 __x, _Float64 __y, int *__quo) noexcept (true);






extern long int lrintf64 (_Float64 __x) noexcept (true); extern long int __lrintf64 (_Float64 __x) noexcept (true);
__extension__
extern long long int llrintf64 (_Float64 __x) noexcept (true); extern long long int __llrintf64 (_Float64 __x) noexcept (true);



extern long int lroundf64 (_Float64 __x) noexcept (true); extern long int __lroundf64 (_Float64 __x) noexcept (true);
__extension__
extern long long int llroundf64 (_Float64 __x) noexcept (true); extern long long int __llroundf64 (_Float64 __x) noexcept (true);



extern _Float64 fdimf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __fdimf64 (_Float64 __x, _Float64 __y) noexcept (true);



extern _Float64 fmaxf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fmaxf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fminf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));



extern _Float64 fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) noexcept (true); extern _Float64 __fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) noexcept (true);




extern _Float64 roundevenf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __roundevenf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfpf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpxf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpxf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern int canonicalizef64 (_Float64 *__cx, const _Float64 *__x) noexcept (true);






extern _Float64 fmaxmagf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fmaxmagf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminmagf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fminmagf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));




extern _Float64 fmaximumf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fmaximumf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminimumf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fminimumf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fmaximum_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fmaximum_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminimum_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fminimum_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fmaximum_magf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fmaximum_magf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminimum_magf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fminimum_magf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fmaximum_mag_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fmaximum_mag_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminimum_mag_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fminimum_mag_numf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf64 (const _Float64 *__x, const _Float64 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf64 (const _Float64 *__x, const _Float64 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern _Float64 getpayloadf64 (const _Float64 *__x) noexcept (true); extern _Float64 __getpayloadf64 (const _Float64 *__x) noexcept (true);


extern int setpayloadf64 (_Float64 *__x, _Float64 __payload) noexcept (true);


extern int setpayloadsigf64 (_Float64 *__x, _Float64 __payload) noexcept (true);
# 468 "/usr/include/math.h" 2 3 4
# 481 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyf128 (_Float128 __value) noexcept (true)
     __attribute__ ((__const__));


extern int __signbitf128 (_Float128 __value) noexcept (true)
     __attribute__ ((__const__));



extern int __isinff128 (_Float128 __value) noexcept (true)
  __attribute__ ((__const__));


extern int __finitef128 (_Float128 __value) noexcept (true)
  __attribute__ ((__const__));


extern int __isnanf128 (_Float128 __value) noexcept (true)
  __attribute__ ((__const__));


extern int __iseqsigf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern int __issignalingf128 (_Float128 __value) noexcept (true)
     __attribute__ ((__const__));
# 482 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4
 extern _Float128 acosf128 (_Float128 __x) noexcept (true); extern _Float128 __acosf128 (_Float128 __x) noexcept (true);

 extern _Float128 asinf128 (_Float128 __x) noexcept (true); extern _Float128 __asinf128 (_Float128 __x) noexcept (true);

 extern _Float128 atanf128 (_Float128 __x) noexcept (true); extern _Float128 __atanf128 (_Float128 __x) noexcept (true);

 extern _Float128 atan2f128 (_Float128 __y, _Float128 __x) noexcept (true); extern _Float128 __atan2f128 (_Float128 __y, _Float128 __x) noexcept (true);


 extern _Float128 cosf128 (_Float128 __x) noexcept (true); extern _Float128 __cosf128 (_Float128 __x) noexcept (true);

 extern _Float128 sinf128 (_Float128 __x) noexcept (true); extern _Float128 __sinf128 (_Float128 __x) noexcept (true);

 extern _Float128 tanf128 (_Float128 __x) noexcept (true); extern _Float128 __tanf128 (_Float128 __x) noexcept (true);




 extern _Float128 coshf128 (_Float128 __x) noexcept (true); extern _Float128 __coshf128 (_Float128 __x) noexcept (true);

 extern _Float128 sinhf128 (_Float128 __x) noexcept (true); extern _Float128 __sinhf128 (_Float128 __x) noexcept (true);

 extern _Float128 tanhf128 (_Float128 __x) noexcept (true); extern _Float128 __tanhf128 (_Float128 __x) noexcept (true);



 extern void sincosf128 (_Float128 __x, _Float128 *__sinx, _Float128 *__cosx) noexcept (true); extern void __sincosf128 (_Float128 __x, _Float128 *__sinx, _Float128 *__cosx) noexcept (true)
                                                        ;




 extern _Float128 acoshf128 (_Float128 __x) noexcept (true); extern _Float128 __acoshf128 (_Float128 __x) noexcept (true);

 extern _Float128 asinhf128 (_Float128 __x) noexcept (true); extern _Float128 __asinhf128 (_Float128 __x) noexcept (true);

 extern _Float128 atanhf128 (_Float128 __x) noexcept (true); extern _Float128 __atanhf128 (_Float128 __x) noexcept (true);





 extern _Float128 expf128 (_Float128 __x) noexcept (true); extern _Float128 __expf128 (_Float128 __x) noexcept (true);


extern _Float128 frexpf128 (_Float128 __x, int *__exponent) noexcept (true); extern _Float128 __frexpf128 (_Float128 __x, int *__exponent) noexcept (true);


extern _Float128 ldexpf128 (_Float128 __x, int __exponent) noexcept (true); extern _Float128 __ldexpf128 (_Float128 __x, int __exponent) noexcept (true);


 extern _Float128 logf128 (_Float128 __x) noexcept (true); extern _Float128 __logf128 (_Float128 __x) noexcept (true);


 extern _Float128 log10f128 (_Float128 __x) noexcept (true); extern _Float128 __log10f128 (_Float128 __x) noexcept (true);


extern _Float128 modff128 (_Float128 __x, _Float128 *__iptr) noexcept (true); extern _Float128 __modff128 (_Float128 __x, _Float128 *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern _Float128 exp10f128 (_Float128 __x) noexcept (true); extern _Float128 __exp10f128 (_Float128 __x) noexcept (true);


extern _Float128 exp2m1f128 (_Float128 __x) noexcept (true); extern _Float128 __exp2m1f128 (_Float128 __x) noexcept (true);


extern _Float128 exp10m1f128 (_Float128 __x) noexcept (true); extern _Float128 __exp10m1f128 (_Float128 __x) noexcept (true);


extern _Float128 log2p1f128 (_Float128 __x) noexcept (true); extern _Float128 __log2p1f128 (_Float128 __x) noexcept (true);


extern _Float128 log10p1f128 (_Float128 __x) noexcept (true); extern _Float128 __log10p1f128 (_Float128 __x) noexcept (true);


extern _Float128 logp1f128 (_Float128 __x) noexcept (true); extern _Float128 __logp1f128 (_Float128 __x) noexcept (true);




 extern _Float128 expm1f128 (_Float128 __x) noexcept (true); extern _Float128 __expm1f128 (_Float128 __x) noexcept (true);


 extern _Float128 log1pf128 (_Float128 __x) noexcept (true); extern _Float128 __log1pf128 (_Float128 __x) noexcept (true);


extern _Float128 logbf128 (_Float128 __x) noexcept (true); extern _Float128 __logbf128 (_Float128 __x) noexcept (true);




 extern _Float128 exp2f128 (_Float128 __x) noexcept (true); extern _Float128 __exp2f128 (_Float128 __x) noexcept (true);


 extern _Float128 log2f128 (_Float128 __x) noexcept (true); extern _Float128 __log2f128 (_Float128 __x) noexcept (true);






 extern _Float128 powf128 (_Float128 __x, _Float128 __y) noexcept (true); extern _Float128 __powf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float128 sqrtf128 (_Float128 __x) noexcept (true); extern _Float128 __sqrtf128 (_Float128 __x) noexcept (true);



 extern _Float128 hypotf128 (_Float128 __x, _Float128 __y) noexcept (true); extern _Float128 __hypotf128 (_Float128 __x, _Float128 __y) noexcept (true);




 extern _Float128 cbrtf128 (_Float128 __x) noexcept (true); extern _Float128 __cbrtf128 (_Float128 __x) noexcept (true);






extern _Float128 ceilf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__)); extern _Float128 __ceilf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__));


extern _Float128 fabsf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fabsf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__));


extern _Float128 floorf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__)); extern _Float128 __floorf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__));


extern _Float128 fmodf128 (_Float128 __x, _Float128 __y) noexcept (true); extern _Float128 __fmodf128 (_Float128 __x, _Float128 __y) noexcept (true);
# 213 "/usr/include/bits/mathcalls.h" 3 4
extern _Float128 copysignf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __copysignf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));




extern _Float128 nanf128 (const char *__tagb) noexcept (true); extern _Float128 __nanf128 (const char *__tagb) noexcept (true);
# 235 "/usr/include/bits/mathcalls.h" 3 4
extern _Float128 j0f128 (_Float128) noexcept (true); extern _Float128 __j0f128 (_Float128) noexcept (true);
extern _Float128 j1f128 (_Float128) noexcept (true); extern _Float128 __j1f128 (_Float128) noexcept (true);
extern _Float128 jnf128 (int, _Float128) noexcept (true); extern _Float128 __jnf128 (int, _Float128) noexcept (true);
extern _Float128 y0f128 (_Float128) noexcept (true); extern _Float128 __y0f128 (_Float128) noexcept (true);
extern _Float128 y1f128 (_Float128) noexcept (true); extern _Float128 __y1f128 (_Float128) noexcept (true);
extern _Float128 ynf128 (int, _Float128) noexcept (true); extern _Float128 __ynf128 (int, _Float128) noexcept (true);





 extern _Float128 erff128 (_Float128) noexcept (true); extern _Float128 __erff128 (_Float128) noexcept (true);
 extern _Float128 erfcf128 (_Float128) noexcept (true); extern _Float128 __erfcf128 (_Float128) noexcept (true);
extern _Float128 lgammaf128 (_Float128) noexcept (true); extern _Float128 __lgammaf128 (_Float128) noexcept (true);




extern _Float128 tgammaf128 (_Float128) noexcept (true); extern _Float128 __tgammaf128 (_Float128) noexcept (true);
# 267 "/usr/include/bits/mathcalls.h" 3 4
extern _Float128 lgammaf128_r (_Float128, int *__signgamp) noexcept (true); extern _Float128 __lgammaf128_r (_Float128, int *__signgamp) noexcept (true);






extern _Float128 rintf128 (_Float128 __x) noexcept (true); extern _Float128 __rintf128 (_Float128 __x) noexcept (true);


extern _Float128 nextafterf128 (_Float128 __x, _Float128 __y) noexcept (true); extern _Float128 __nextafterf128 (_Float128 __x, _Float128 __y) noexcept (true);






extern _Float128 nextdownf128 (_Float128 __x) noexcept (true); extern _Float128 __nextdownf128 (_Float128 __x) noexcept (true);

extern _Float128 nextupf128 (_Float128 __x) noexcept (true); extern _Float128 __nextupf128 (_Float128 __x) noexcept (true);



extern _Float128 remainderf128 (_Float128 __x, _Float128 __y) noexcept (true); extern _Float128 __remainderf128 (_Float128 __x, _Float128 __y) noexcept (true);



extern _Float128 scalbnf128 (_Float128 __x, int __n) noexcept (true); extern _Float128 __scalbnf128 (_Float128 __x, int __n) noexcept (true);



extern int ilogbf128 (_Float128 __x) noexcept (true); extern int __ilogbf128 (_Float128 __x) noexcept (true);




extern long int llogbf128 (_Float128 __x) noexcept (true); extern long int __llogbf128 (_Float128 __x) noexcept (true);




extern _Float128 scalblnf128 (_Float128 __x, long int __n) noexcept (true); extern _Float128 __scalblnf128 (_Float128 __x, long int __n) noexcept (true);



extern _Float128 nearbyintf128 (_Float128 __x) noexcept (true); extern _Float128 __nearbyintf128 (_Float128 __x) noexcept (true);



extern _Float128 roundf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__)); extern _Float128 __roundf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__));



extern _Float128 truncf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__)); extern _Float128 __truncf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__));




extern _Float128 remquof128 (_Float128 __x, _Float128 __y, int *__quo) noexcept (true); extern _Float128 __remquof128 (_Float128 __x, _Float128 __y, int *__quo) noexcept (true);






extern long int lrintf128 (_Float128 __x) noexcept (true); extern long int __lrintf128 (_Float128 __x) noexcept (true);
__extension__
extern long long int llrintf128 (_Float128 __x) noexcept (true); extern long long int __llrintf128 (_Float128 __x) noexcept (true);



extern long int lroundf128 (_Float128 __x) noexcept (true); extern long int __lroundf128 (_Float128 __x) noexcept (true);
__extension__
extern long long int llroundf128 (_Float128 __x) noexcept (true); extern long long int __llroundf128 (_Float128 __x) noexcept (true);



extern _Float128 fdimf128 (_Float128 __x, _Float128 __y) noexcept (true); extern _Float128 __fdimf128 (_Float128 __x, _Float128 __y) noexcept (true);



extern _Float128 fmaxf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fmaxf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fminf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fminf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));



extern _Float128 fmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) noexcept (true); extern _Float128 __fmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) noexcept (true);




extern _Float128 roundevenf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__)); extern _Float128 __roundevenf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfpf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpxf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpxf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern int canonicalizef128 (_Float128 *__cx, const _Float128 *__x) noexcept (true);






extern _Float128 fmaxmagf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fmaxmagf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fminmagf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fminmagf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));




extern _Float128 fmaximumf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fmaximumf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fminimumf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fminimumf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fmaximum_numf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fmaximum_numf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fminimum_numf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fminimum_numf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fmaximum_magf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fmaximum_magf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fminimum_magf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fminimum_magf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fmaximum_mag_numf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fmaximum_mag_numf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fminimum_mag_numf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fminimum_mag_numf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf128 (const _Float128 *__x, const _Float128 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf128 (const _Float128 *__x, const _Float128 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern _Float128 getpayloadf128 (const _Float128 *__x) noexcept (true); extern _Float128 __getpayloadf128 (const _Float128 *__x) noexcept (true);


extern int setpayloadf128 (_Float128 *__x, _Float128 __payload) noexcept (true);


extern int setpayloadsigf128 (_Float128 *__x, _Float128 __payload) noexcept (true);
# 485 "/usr/include/math.h" 2 3 4
# 501 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4
 extern _Float32x acosf32x (_Float32x __x) noexcept (true); extern _Float32x __acosf32x (_Float32x __x) noexcept (true);

 extern _Float32x asinf32x (_Float32x __x) noexcept (true); extern _Float32x __asinf32x (_Float32x __x) noexcept (true);

 extern _Float32x atanf32x (_Float32x __x) noexcept (true); extern _Float32x __atanf32x (_Float32x __x) noexcept (true);

 extern _Float32x atan2f32x (_Float32x __y, _Float32x __x) noexcept (true); extern _Float32x __atan2f32x (_Float32x __y, _Float32x __x) noexcept (true);


 extern _Float32x cosf32x (_Float32x __x) noexcept (true); extern _Float32x __cosf32x (_Float32x __x) noexcept (true);

 extern _Float32x sinf32x (_Float32x __x) noexcept (true); extern _Float32x __sinf32x (_Float32x __x) noexcept (true);

 extern _Float32x tanf32x (_Float32x __x) noexcept (true); extern _Float32x __tanf32x (_Float32x __x) noexcept (true);




 extern _Float32x coshf32x (_Float32x __x) noexcept (true); extern _Float32x __coshf32x (_Float32x __x) noexcept (true);

 extern _Float32x sinhf32x (_Float32x __x) noexcept (true); extern _Float32x __sinhf32x (_Float32x __x) noexcept (true);

 extern _Float32x tanhf32x (_Float32x __x) noexcept (true); extern _Float32x __tanhf32x (_Float32x __x) noexcept (true);



 extern void sincosf32x (_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) noexcept (true); extern void __sincosf32x (_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) noexcept (true)
                                                        ;




 extern _Float32x acoshf32x (_Float32x __x) noexcept (true); extern _Float32x __acoshf32x (_Float32x __x) noexcept (true);

 extern _Float32x asinhf32x (_Float32x __x) noexcept (true); extern _Float32x __asinhf32x (_Float32x __x) noexcept (true);

 extern _Float32x atanhf32x (_Float32x __x) noexcept (true); extern _Float32x __atanhf32x (_Float32x __x) noexcept (true);





 extern _Float32x expf32x (_Float32x __x) noexcept (true); extern _Float32x __expf32x (_Float32x __x) noexcept (true);


extern _Float32x frexpf32x (_Float32x __x, int *__exponent) noexcept (true); extern _Float32x __frexpf32x (_Float32x __x, int *__exponent) noexcept (true);


extern _Float32x ldexpf32x (_Float32x __x, int __exponent) noexcept (true); extern _Float32x __ldexpf32x (_Float32x __x, int __exponent) noexcept (true);


 extern _Float32x logf32x (_Float32x __x) noexcept (true); extern _Float32x __logf32x (_Float32x __x) noexcept (true);


 extern _Float32x log10f32x (_Float32x __x) noexcept (true); extern _Float32x __log10f32x (_Float32x __x) noexcept (true);


extern _Float32x modff32x (_Float32x __x, _Float32x *__iptr) noexcept (true); extern _Float32x __modff32x (_Float32x __x, _Float32x *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern _Float32x exp10f32x (_Float32x __x) noexcept (true); extern _Float32x __exp10f32x (_Float32x __x) noexcept (true);


extern _Float32x exp2m1f32x (_Float32x __x) noexcept (true); extern _Float32x __exp2m1f32x (_Float32x __x) noexcept (true);


extern _Float32x exp10m1f32x (_Float32x __x) noexcept (true); extern _Float32x __exp10m1f32x (_Float32x __x) noexcept (true);


extern _Float32x log2p1f32x (_Float32x __x) noexcept (true); extern _Float32x __log2p1f32x (_Float32x __x) noexcept (true);


extern _Float32x log10p1f32x (_Float32x __x) noexcept (true); extern _Float32x __log10p1f32x (_Float32x __x) noexcept (true);


extern _Float32x logp1f32x (_Float32x __x) noexcept (true); extern _Float32x __logp1f32x (_Float32x __x) noexcept (true);




 extern _Float32x expm1f32x (_Float32x __x) noexcept (true); extern _Float32x __expm1f32x (_Float32x __x) noexcept (true);


 extern _Float32x log1pf32x (_Float32x __x) noexcept (true); extern _Float32x __log1pf32x (_Float32x __x) noexcept (true);


extern _Float32x logbf32x (_Float32x __x) noexcept (true); extern _Float32x __logbf32x (_Float32x __x) noexcept (true);




 extern _Float32x exp2f32x (_Float32x __x) noexcept (true); extern _Float32x __exp2f32x (_Float32x __x) noexcept (true);


 extern _Float32x log2f32x (_Float32x __x) noexcept (true); extern _Float32x __log2f32x (_Float32x __x) noexcept (true);






 extern _Float32x powf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __powf32x (_Float32x __x, _Float32x __y) noexcept (true);


extern _Float32x sqrtf32x (_Float32x __x) noexcept (true); extern _Float32x __sqrtf32x (_Float32x __x) noexcept (true);



 extern _Float32x hypotf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __hypotf32x (_Float32x __x, _Float32x __y) noexcept (true);




 extern _Float32x cbrtf32x (_Float32x __x) noexcept (true); extern _Float32x __cbrtf32x (_Float32x __x) noexcept (true);






extern _Float32x ceilf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __ceilf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));


extern _Float32x fabsf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fabsf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));


extern _Float32x floorf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __floorf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));


extern _Float32x fmodf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __fmodf32x (_Float32x __x, _Float32x __y) noexcept (true);
# 213 "/usr/include/bits/mathcalls.h" 3 4
extern _Float32x copysignf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __copysignf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));




extern _Float32x nanf32x (const char *__tagb) noexcept (true); extern _Float32x __nanf32x (const char *__tagb) noexcept (true);
# 235 "/usr/include/bits/mathcalls.h" 3 4
extern _Float32x j0f32x (_Float32x) noexcept (true); extern _Float32x __j0f32x (_Float32x) noexcept (true);
extern _Float32x j1f32x (_Float32x) noexcept (true); extern _Float32x __j1f32x (_Float32x) noexcept (true);
extern _Float32x jnf32x (int, _Float32x) noexcept (true); extern _Float32x __jnf32x (int, _Float32x) noexcept (true);
extern _Float32x y0f32x (_Float32x) noexcept (true); extern _Float32x __y0f32x (_Float32x) noexcept (true);
extern _Float32x y1f32x (_Float32x) noexcept (true); extern _Float32x __y1f32x (_Float32x) noexcept (true);
extern _Float32x ynf32x (int, _Float32x) noexcept (true); extern _Float32x __ynf32x (int, _Float32x) noexcept (true);





 extern _Float32x erff32x (_Float32x) noexcept (true); extern _Float32x __erff32x (_Float32x) noexcept (true);
 extern _Float32x erfcf32x (_Float32x) noexcept (true); extern _Float32x __erfcf32x (_Float32x) noexcept (true);
extern _Float32x lgammaf32x (_Float32x) noexcept (true); extern _Float32x __lgammaf32x (_Float32x) noexcept (true);




extern _Float32x tgammaf32x (_Float32x) noexcept (true); extern _Float32x __tgammaf32x (_Float32x) noexcept (true);
# 267 "/usr/include/bits/mathcalls.h" 3 4
extern _Float32x lgammaf32x_r (_Float32x, int *__signgamp) noexcept (true); extern _Float32x __lgammaf32x_r (_Float32x, int *__signgamp) noexcept (true);






extern _Float32x rintf32x (_Float32x __x) noexcept (true); extern _Float32x __rintf32x (_Float32x __x) noexcept (true);


extern _Float32x nextafterf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __nextafterf32x (_Float32x __x, _Float32x __y) noexcept (true);






extern _Float32x nextdownf32x (_Float32x __x) noexcept (true); extern _Float32x __nextdownf32x (_Float32x __x) noexcept (true);

extern _Float32x nextupf32x (_Float32x __x) noexcept (true); extern _Float32x __nextupf32x (_Float32x __x) noexcept (true);



extern _Float32x remainderf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __remainderf32x (_Float32x __x, _Float32x __y) noexcept (true);



extern _Float32x scalbnf32x (_Float32x __x, int __n) noexcept (true); extern _Float32x __scalbnf32x (_Float32x __x, int __n) noexcept (true);



extern int ilogbf32x (_Float32x __x) noexcept (true); extern int __ilogbf32x (_Float32x __x) noexcept (true);




extern long int llogbf32x (_Float32x __x) noexcept (true); extern long int __llogbf32x (_Float32x __x) noexcept (true);




extern _Float32x scalblnf32x (_Float32x __x, long int __n) noexcept (true); extern _Float32x __scalblnf32x (_Float32x __x, long int __n) noexcept (true);



extern _Float32x nearbyintf32x (_Float32x __x) noexcept (true); extern _Float32x __nearbyintf32x (_Float32x __x) noexcept (true);



extern _Float32x roundf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __roundf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));



extern _Float32x truncf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __truncf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));




extern _Float32x remquof32x (_Float32x __x, _Float32x __y, int *__quo) noexcept (true); extern _Float32x __remquof32x (_Float32x __x, _Float32x __y, int *__quo) noexcept (true);






extern long int lrintf32x (_Float32x __x) noexcept (true); extern long int __lrintf32x (_Float32x __x) noexcept (true);
__extension__
extern long long int llrintf32x (_Float32x __x) noexcept (true); extern long long int __llrintf32x (_Float32x __x) noexcept (true);



extern long int lroundf32x (_Float32x __x) noexcept (true); extern long int __lroundf32x (_Float32x __x) noexcept (true);
__extension__
extern long long int llroundf32x (_Float32x __x) noexcept (true); extern long long int __llroundf32x (_Float32x __x) noexcept (true);



extern _Float32x fdimf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __fdimf32x (_Float32x __x, _Float32x __y) noexcept (true);



extern _Float32x fmaxf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fmaxf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fminf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));



extern _Float32x fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) noexcept (true); extern _Float32x __fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) noexcept (true);




extern _Float32x roundevenf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __roundevenf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfpf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpxf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpxf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern int canonicalizef32x (_Float32x *__cx, const _Float32x *__x) noexcept (true);






extern _Float32x fmaxmagf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fmaxmagf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminmagf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fminmagf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));




extern _Float32x fmaximumf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fmaximumf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminimumf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fminimumf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fmaximum_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fmaximum_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminimum_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fminimum_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fmaximum_magf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fmaximum_magf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminimum_magf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fminimum_magf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fmaximum_mag_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fmaximum_mag_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminimum_mag_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fminimum_mag_numf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf32x (const _Float32x *__x, const _Float32x *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf32x (const _Float32x *__x, const _Float32x *__y) noexcept (true)

     __attribute__ ((__pure__));


extern _Float32x getpayloadf32x (const _Float32x *__x) noexcept (true); extern _Float32x __getpayloadf32x (const _Float32x *__x) noexcept (true);


extern int setpayloadf32x (_Float32x *__x, _Float32x __payload) noexcept (true);


extern int setpayloadsigf32x (_Float32x *__x, _Float32x __payload) noexcept (true);
# 502 "/usr/include/math.h" 2 3 4
# 518 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4
 extern _Float64x acosf64x (_Float64x __x) noexcept (true); extern _Float64x __acosf64x (_Float64x __x) noexcept (true);

 extern _Float64x asinf64x (_Float64x __x) noexcept (true); extern _Float64x __asinf64x (_Float64x __x) noexcept (true);

 extern _Float64x atanf64x (_Float64x __x) noexcept (true); extern _Float64x __atanf64x (_Float64x __x) noexcept (true);

 extern _Float64x atan2f64x (_Float64x __y, _Float64x __x) noexcept (true); extern _Float64x __atan2f64x (_Float64x __y, _Float64x __x) noexcept (true);


 extern _Float64x cosf64x (_Float64x __x) noexcept (true); extern _Float64x __cosf64x (_Float64x __x) noexcept (true);

 extern _Float64x sinf64x (_Float64x __x) noexcept (true); extern _Float64x __sinf64x (_Float64x __x) noexcept (true);

 extern _Float64x tanf64x (_Float64x __x) noexcept (true); extern _Float64x __tanf64x (_Float64x __x) noexcept (true);




 extern _Float64x coshf64x (_Float64x __x) noexcept (true); extern _Float64x __coshf64x (_Float64x __x) noexcept (true);

 extern _Float64x sinhf64x (_Float64x __x) noexcept (true); extern _Float64x __sinhf64x (_Float64x __x) noexcept (true);

 extern _Float64x tanhf64x (_Float64x __x) noexcept (true); extern _Float64x __tanhf64x (_Float64x __x) noexcept (true);



 extern void sincosf64x (_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) noexcept (true); extern void __sincosf64x (_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) noexcept (true)
                                                        ;




 extern _Float64x acoshf64x (_Float64x __x) noexcept (true); extern _Float64x __acoshf64x (_Float64x __x) noexcept (true);

 extern _Float64x asinhf64x (_Float64x __x) noexcept (true); extern _Float64x __asinhf64x (_Float64x __x) noexcept (true);

 extern _Float64x atanhf64x (_Float64x __x) noexcept (true); extern _Float64x __atanhf64x (_Float64x __x) noexcept (true);





 extern _Float64x expf64x (_Float64x __x) noexcept (true); extern _Float64x __expf64x (_Float64x __x) noexcept (true);


extern _Float64x frexpf64x (_Float64x __x, int *__exponent) noexcept (true); extern _Float64x __frexpf64x (_Float64x __x, int *__exponent) noexcept (true);


extern _Float64x ldexpf64x (_Float64x __x, int __exponent) noexcept (true); extern _Float64x __ldexpf64x (_Float64x __x, int __exponent) noexcept (true);


 extern _Float64x logf64x (_Float64x __x) noexcept (true); extern _Float64x __logf64x (_Float64x __x) noexcept (true);


 extern _Float64x log10f64x (_Float64x __x) noexcept (true); extern _Float64x __log10f64x (_Float64x __x) noexcept (true);


extern _Float64x modff64x (_Float64x __x, _Float64x *__iptr) noexcept (true); extern _Float64x __modff64x (_Float64x __x, _Float64x *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



 extern _Float64x exp10f64x (_Float64x __x) noexcept (true); extern _Float64x __exp10f64x (_Float64x __x) noexcept (true);


extern _Float64x exp2m1f64x (_Float64x __x) noexcept (true); extern _Float64x __exp2m1f64x (_Float64x __x) noexcept (true);


extern _Float64x exp10m1f64x (_Float64x __x) noexcept (true); extern _Float64x __exp10m1f64x (_Float64x __x) noexcept (true);


extern _Float64x log2p1f64x (_Float64x __x) noexcept (true); extern _Float64x __log2p1f64x (_Float64x __x) noexcept (true);


extern _Float64x log10p1f64x (_Float64x __x) noexcept (true); extern _Float64x __log10p1f64x (_Float64x __x) noexcept (true);


extern _Float64x logp1f64x (_Float64x __x) noexcept (true); extern _Float64x __logp1f64x (_Float64x __x) noexcept (true);




 extern _Float64x expm1f64x (_Float64x __x) noexcept (true); extern _Float64x __expm1f64x (_Float64x __x) noexcept (true);


 extern _Float64x log1pf64x (_Float64x __x) noexcept (true); extern _Float64x __log1pf64x (_Float64x __x) noexcept (true);


extern _Float64x logbf64x (_Float64x __x) noexcept (true); extern _Float64x __logbf64x (_Float64x __x) noexcept (true);




 extern _Float64x exp2f64x (_Float64x __x) noexcept (true); extern _Float64x __exp2f64x (_Float64x __x) noexcept (true);


 extern _Float64x log2f64x (_Float64x __x) noexcept (true); extern _Float64x __log2f64x (_Float64x __x) noexcept (true);






 extern _Float64x powf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __powf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float64x sqrtf64x (_Float64x __x) noexcept (true); extern _Float64x __sqrtf64x (_Float64x __x) noexcept (true);



 extern _Float64x hypotf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __hypotf64x (_Float64x __x, _Float64x __y) noexcept (true);




 extern _Float64x cbrtf64x (_Float64x __x) noexcept (true); extern _Float64x __cbrtf64x (_Float64x __x) noexcept (true);






extern _Float64x ceilf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __ceilf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));


extern _Float64x fabsf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fabsf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));


extern _Float64x floorf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __floorf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));


extern _Float64x fmodf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __fmodf64x (_Float64x __x, _Float64x __y) noexcept (true);
# 213 "/usr/include/bits/mathcalls.h" 3 4
extern _Float64x copysignf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __copysignf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));




extern _Float64x nanf64x (const char *__tagb) noexcept (true); extern _Float64x __nanf64x (const char *__tagb) noexcept (true);
# 235 "/usr/include/bits/mathcalls.h" 3 4
extern _Float64x j0f64x (_Float64x) noexcept (true); extern _Float64x __j0f64x (_Float64x) noexcept (true);
extern _Float64x j1f64x (_Float64x) noexcept (true); extern _Float64x __j1f64x (_Float64x) noexcept (true);
extern _Float64x jnf64x (int, _Float64x) noexcept (true); extern _Float64x __jnf64x (int, _Float64x) noexcept (true);
extern _Float64x y0f64x (_Float64x) noexcept (true); extern _Float64x __y0f64x (_Float64x) noexcept (true);
extern _Float64x y1f64x (_Float64x) noexcept (true); extern _Float64x __y1f64x (_Float64x) noexcept (true);
extern _Float64x ynf64x (int, _Float64x) noexcept (true); extern _Float64x __ynf64x (int, _Float64x) noexcept (true);





 extern _Float64x erff64x (_Float64x) noexcept (true); extern _Float64x __erff64x (_Float64x) noexcept (true);
 extern _Float64x erfcf64x (_Float64x) noexcept (true); extern _Float64x __erfcf64x (_Float64x) noexcept (true);
extern _Float64x lgammaf64x (_Float64x) noexcept (true); extern _Float64x __lgammaf64x (_Float64x) noexcept (true);




extern _Float64x tgammaf64x (_Float64x) noexcept (true); extern _Float64x __tgammaf64x (_Float64x) noexcept (true);
# 267 "/usr/include/bits/mathcalls.h" 3 4
extern _Float64x lgammaf64x_r (_Float64x, int *__signgamp) noexcept (true); extern _Float64x __lgammaf64x_r (_Float64x, int *__signgamp) noexcept (true);






extern _Float64x rintf64x (_Float64x __x) noexcept (true); extern _Float64x __rintf64x (_Float64x __x) noexcept (true);


extern _Float64x nextafterf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __nextafterf64x (_Float64x __x, _Float64x __y) noexcept (true);






extern _Float64x nextdownf64x (_Float64x __x) noexcept (true); extern _Float64x __nextdownf64x (_Float64x __x) noexcept (true);

extern _Float64x nextupf64x (_Float64x __x) noexcept (true); extern _Float64x __nextupf64x (_Float64x __x) noexcept (true);



extern _Float64x remainderf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __remainderf64x (_Float64x __x, _Float64x __y) noexcept (true);



extern _Float64x scalbnf64x (_Float64x __x, int __n) noexcept (true); extern _Float64x __scalbnf64x (_Float64x __x, int __n) noexcept (true);



extern int ilogbf64x (_Float64x __x) noexcept (true); extern int __ilogbf64x (_Float64x __x) noexcept (true);




extern long int llogbf64x (_Float64x __x) noexcept (true); extern long int __llogbf64x (_Float64x __x) noexcept (true);




extern _Float64x scalblnf64x (_Float64x __x, long int __n) noexcept (true); extern _Float64x __scalblnf64x (_Float64x __x, long int __n) noexcept (true);



extern _Float64x nearbyintf64x (_Float64x __x) noexcept (true); extern _Float64x __nearbyintf64x (_Float64x __x) noexcept (true);



extern _Float64x roundf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __roundf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));



extern _Float64x truncf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __truncf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));




extern _Float64x remquof64x (_Float64x __x, _Float64x __y, int *__quo) noexcept (true); extern _Float64x __remquof64x (_Float64x __x, _Float64x __y, int *__quo) noexcept (true);






extern long int lrintf64x (_Float64x __x) noexcept (true); extern long int __lrintf64x (_Float64x __x) noexcept (true);
__extension__
extern long long int llrintf64x (_Float64x __x) noexcept (true); extern long long int __llrintf64x (_Float64x __x) noexcept (true);



extern long int lroundf64x (_Float64x __x) noexcept (true); extern long int __lroundf64x (_Float64x __x) noexcept (true);
__extension__
extern long long int llroundf64x (_Float64x __x) noexcept (true); extern long long int __llroundf64x (_Float64x __x) noexcept (true);



extern _Float64x fdimf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __fdimf64x (_Float64x __x, _Float64x __y) noexcept (true);



extern _Float64x fmaxf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fmaxf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fminf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));



extern _Float64x fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) noexcept (true); extern _Float64x __fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) noexcept (true);




extern _Float64x roundevenf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __roundevenf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfpf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpxf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpxf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern int canonicalizef64x (_Float64x *__cx, const _Float64x *__x) noexcept (true);






extern _Float64x fmaxmagf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fmaxmagf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminmagf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fminmagf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));




extern _Float64x fmaximumf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fmaximumf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminimumf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fminimumf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fmaximum_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fmaximum_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminimum_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fminimum_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fmaximum_magf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fmaximum_magf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminimum_magf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fminimum_magf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fmaximum_mag_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fmaximum_mag_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminimum_mag_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fminimum_mag_numf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));




extern int totalorderf64x (const _Float64x *__x, const _Float64x *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf64x (const _Float64x *__x, const _Float64x *__y) noexcept (true)

     __attribute__ ((__pure__));


extern _Float64x getpayloadf64x (const _Float64x *__x) noexcept (true); extern _Float64x __getpayloadf64x (const _Float64x *__x) noexcept (true);


extern int setpayloadf64x (_Float64x *__x, _Float64x __payload) noexcept (true);


extern int setpayloadsigf64x (_Float64x *__x, _Float64x __payload) noexcept (true);
# 519 "/usr/include/math.h" 2 3 4
# 566 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern float fadd (double __x, double __y) noexcept (true);


extern float fdiv (double __x, double __y) noexcept (true);


extern float ffma (double __x, double __y, double __z) noexcept (true);


extern float fmul (double __x, double __y) noexcept (true);


extern float fsqrt (double __x) noexcept (true);


extern float fsub (double __x, double __y) noexcept (true);
# 567 "/usr/include/math.h" 2 3 4
# 587 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern float faddl (long double __x, long double __y) noexcept (true);


extern float fdivl (long double __x, long double __y) noexcept (true);


extern float ffmal (long double __x, long double __y, long double __z) noexcept (true);


extern float fmull (long double __x, long double __y) noexcept (true);


extern float fsqrtl (long double __x) noexcept (true);


extern float fsubl (long double __x, long double __y) noexcept (true);
# 588 "/usr/include/math.h" 2 3 4
# 616 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern double daddl (long double __x, long double __y) noexcept (true);


extern double ddivl (long double __x, long double __y) noexcept (true);


extern double dfmal (long double __x, long double __y, long double __z) noexcept (true);


extern double dmull (long double __x, long double __y) noexcept (true);


extern double dsqrtl (long double __x) noexcept (true);


extern double dsubl (long double __x, long double __y) noexcept (true);
# 617 "/usr/include/math.h" 2 3 4
# 697 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf32x (_Float32x __x, _Float32x __y) noexcept (true);


extern _Float32 f32divf32x (_Float32x __x, _Float32x __y) noexcept (true);


extern _Float32 f32fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) noexcept (true);


extern _Float32 f32mulf32x (_Float32x __x, _Float32x __y) noexcept (true);


extern _Float32 f32sqrtf32x (_Float32x __x) noexcept (true);


extern _Float32 f32subf32x (_Float32x __x, _Float32x __y) noexcept (true);
# 698 "/usr/include/math.h" 2 3 4
# 707 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32 f32divf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32 f32fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) noexcept (true);


extern _Float32 f32mulf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32 f32sqrtf64 (_Float64 __x) noexcept (true);


extern _Float32 f32subf64 (_Float64 __x, _Float64 __y) noexcept (true);
# 708 "/usr/include/math.h" 2 3 4
# 717 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32 f32divf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32 f32fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) noexcept (true);


extern _Float32 f32mulf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32 f32sqrtf64x (_Float64x __x) noexcept (true);


extern _Float32 f32subf64x (_Float64x __x, _Float64x __y) noexcept (true);
# 718 "/usr/include/math.h" 2 3 4
# 727 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float32 f32divf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float32 f32fmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) noexcept (true);


extern _Float32 f32mulf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float32 f32sqrtf128 (_Float128 __x) noexcept (true);


extern _Float32 f32subf128 (_Float128 __x, _Float128 __y) noexcept (true);
# 728 "/usr/include/math.h" 2 3 4
# 747 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float32x f32xaddf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32x f32xdivf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32x f32xfmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) noexcept (true);


extern _Float32x f32xmulf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32x f32xsqrtf64 (_Float64 __x) noexcept (true);


extern _Float32x f32xsubf64 (_Float64 __x, _Float64 __y) noexcept (true);
# 748 "/usr/include/math.h" 2 3 4
# 757 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float32x f32xaddf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32x f32xdivf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32x f32xfmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) noexcept (true);


extern _Float32x f32xmulf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32x f32xsqrtf64x (_Float64x __x) noexcept (true);


extern _Float32x f32xsubf64x (_Float64x __x, _Float64x __y) noexcept (true);
# 758 "/usr/include/math.h" 2 3 4
# 767 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float32x f32xaddf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float32x f32xdivf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float32x f32xfmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) noexcept (true);


extern _Float32x f32xmulf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float32x f32xsqrtf128 (_Float128 __x) noexcept (true);


extern _Float32x f32xsubf128 (_Float128 __x, _Float128 __y) noexcept (true);
# 768 "/usr/include/math.h" 2 3 4
# 787 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float64 f64addf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float64 f64divf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float64 f64fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) noexcept (true);


extern _Float64 f64mulf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float64 f64sqrtf64x (_Float64x __x) noexcept (true);


extern _Float64 f64subf64x (_Float64x __x, _Float64x __y) noexcept (true);
# 788 "/usr/include/math.h" 2 3 4
# 797 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float64 f64addf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float64 f64divf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float64 f64fmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) noexcept (true);


extern _Float64 f64mulf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float64 f64sqrtf128 (_Float128 __x) noexcept (true);


extern _Float64 f64subf128 (_Float128 __x, _Float128 __y) noexcept (true);
# 798 "/usr/include/math.h" 2 3 4
# 817 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float64x f64xaddf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float64x f64xdivf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float64x f64xfmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) noexcept (true);


extern _Float64x f64xmulf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float64x f64xsqrtf128 (_Float128 __x) noexcept (true);


extern _Float64x f64xsubf128 (_Float128 __x, _Float128 __y) noexcept (true);
# 818 "/usr/include/math.h" 2 3 4
# 854 "/usr/include/math.h" 3 4
extern int signgam;
# 934 "/usr/include/math.h" 3 4
enum
  {
    FP_NAN =

      0,
    FP_INFINITE =

      1,
    FP_ZERO =

      2,
    FP_SUBNORMAL =

      3,
    FP_NORMAL =

      4
  };
# 1055 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/iscanonical.h" 1 3 4
# 23 "/usr/include/bits/iscanonical.h" 3 4
extern int __iscanonicall (long double __x)
     noexcept (true) __attribute__ ((__const__));
# 46 "/usr/include/bits/iscanonical.h" 3 4
extern "C++" {
inline int iscanonical (float __val) { return ((void) (__typeof (__val)) (__val), 1); }
inline int iscanonical (double __val) { return ((void) (__typeof (__val)) (__val), 1); }
inline int iscanonical (long double __val) { return __iscanonicall (__val); }

inline int iscanonical (_Float128 __val) { return ((void) (__typeof (__val)) (__val), 1); }

}
# 1056 "/usr/include/math.h" 2 3 4
# 1067 "/usr/include/math.h" 3 4
extern "C++" {
inline int issignaling (float __val) { return __issignalingf (__val); }
inline int issignaling (double __val) { return __issignaling (__val); }
inline int
issignaling (long double __val)
{



  return __issignalingl (__val);

}



inline int issignaling (_Float128 __val) { return __issignalingf128 (__val); }

}
# 1098 "/usr/include/math.h" 3 4
extern "C++" {
# 1129 "/usr/include/math.h" 3 4
template <class __T> inline bool
iszero (__T __val)
{
  return __val == 0;
}

}
# 1364 "/usr/include/math.h" 3 4
extern "C++" {
template<typename> struct __iseqsig_type;

template<> struct __iseqsig_type<float>
{
  static int __call (float __x, float __y) throw ()
  {
    return __iseqsigf (__x, __y);
  }
};

template<> struct __iseqsig_type<double>
{
  static int __call (double __x, double __y) throw ()
  {
    return __iseqsig (__x, __y);
  }
};

template<> struct __iseqsig_type<long double>
{
  static int __call (long double __x, long double __y) throw ()
  {

    return __iseqsigl (__x, __y);



  }
};


template<> struct __iseqsig_type<_Float32>
{
  static int __call (_Float32 __x, _Float32 __y) throw ()
  {
    return __iseqsigf (__x, __y);
  }
};



template<> struct __iseqsig_type<_Float64>
{
  static int __call (_Float64 __x, _Float64 __y) throw ()
  {
    return __iseqsig (__x, __y);
  }
};





template<> struct __iseqsig_type<_Float128>
{
  static int __call (_Float128 __x, _Float128 __y) throw ()
  {

    return __iseqsigf128 (__x, __y);



  }
};



template<> struct __iseqsig_type<_Float32x>
{
  static int __call (_Float32x __x, _Float32x __y) throw ()
  {
    return __iseqsig (__x, __y);
  }
};



template<> struct __iseqsig_type<_Float64x>
{
  static int __call (_Float64x __x, _Float64x __y) throw ()
  {

    return __iseqsigl (__x, __y);



  }
};


template<typename _T1, typename _T2>
inline int
iseqsig (_T1 __x, _T2 __y) throw ()
{

  typedef decltype (((__x) + (__y) + 0.0f)) _T3;



  return __iseqsig_type<_T3>::__call (__x, __y);
}

}




}
# 48 "/usr/include/c++/14.2.1/cmath" 2 3

# 1 "/usr/include/c++/14.2.1/bits/std_abs.h" 1 3
# 33 "/usr/include/c++/14.2.1/bits/std_abs.h" 3
       
# 34 "/usr/include/c++/14.2.1/bits/std_abs.h" 3




# 1 "/usr/include/stdlib.h" 1 3 4
# 26 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/stdlib.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/stddef.h" 1 3 4
# 33 "/usr/include/stdlib.h" 2 3 4

extern "C" {





# 1 "/usr/include/bits/waitflags.h" 1 3 4
# 41 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/bits/waitstatus.h" 1 3 4
# 42 "/usr/include/stdlib.h" 2 3 4
# 59 "/usr/include/stdlib.h" 3 4
typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;





__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 98 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) noexcept (true) ;



extern double atof (const char *__nptr)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



__extension__ extern long long int atoll (const char *__nptr)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) noexcept (true) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));
# 141 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32 (const char *__restrict __nptr,
     char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern _Float64 strtof64 (const char *__restrict __nptr,
     char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern _Float128 strtof128 (const char *__restrict __nptr,
       char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern _Float32x strtof32x (const char *__restrict __nptr,
       char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern _Float64x strtof64x (const char *__restrict __nptr,
       char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));
# 177 "/usr/include/stdlib.h" 3 4
extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));






extern long int strtol (const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept (true) __asm__ ("" "__isoc23_strtol")


     __attribute__ ((__nonnull__ (1)));
extern unsigned long int strtoul (const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept (true) __asm__ ("" "__isoc23_strtoul")



     __attribute__ ((__nonnull__ (1)));

__extension__
extern long long int strtoq (const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept (true) __asm__ ("" "__isoc23_strtoll")


     __attribute__ ((__nonnull__ (1)));
__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept (true) __asm__ ("" "__isoc23_strtoull")



     __attribute__ ((__nonnull__ (1)));

__extension__
extern long long int strtoll (const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept (true) __asm__ ("" "__isoc23_strtoll")


     __attribute__ ((__nonnull__ (1)));
__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr, char **__restrict __endptr, int __base) noexcept (true) __asm__ ("" "__isoc23_strtoull")



     __attribute__ ((__nonnull__ (1)));
# 278 "/usr/include/stdlib.h" 3 4
extern int strfromd (char *__dest, size_t __size, const char *__format,
       double __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));

extern int strfromf (char *__dest, size_t __size, const char *__format,
       float __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));

extern int strfroml (char *__dest, size_t __size, const char *__format,
       long double __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));
# 298 "/usr/include/stdlib.h" 3 4
extern int strfromf32 (char *__dest, size_t __size, const char * __format,
         _Float32 __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));



extern int strfromf64 (char *__dest, size_t __size, const char * __format,
         _Float64 __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));



extern int strfromf128 (char *__dest, size_t __size, const char * __format,
   _Float128 __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));



extern int strfromf32x (char *__dest, size_t __size, const char * __format,
   _Float32x __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));



extern int strfromf64x (char *__dest, size_t __size, const char * __format,
   _Float64x __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));
# 338 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/bits/types/locale_t.h" 1 3 4
# 22 "/usr/include/bits/types/locale_t.h" 3 4
# 1 "/usr/include/bits/types/__locale_t.h" 1 3 4
# 27 "/usr/include/bits/types/__locale_t.h" 3 4
struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
};

typedef struct __locale_struct *__locale_t;
# 23 "/usr/include/bits/types/locale_t.h" 2 3 4

typedef __locale_t locale_t;
# 339 "/usr/include/stdlib.h" 2 3 4

extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     locale_t __loc) noexcept (true) __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 4)));





extern long int strtol_l (const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) noexcept (true) __asm__ ("" "__isoc23_strtol_l")



     __attribute__ ((__nonnull__ (1, 4)));
extern unsigned long int strtoul_l (const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) noexcept (true) __asm__ ("" "__isoc23_strtoul_l")




     __attribute__ ((__nonnull__ (1, 4)));
__extension__
extern long long int strtoll_l (const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) noexcept (true) __asm__ ("" "__isoc23_strtoll_l")




     __attribute__ ((__nonnull__ (1, 4)));
__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr, char **__restrict __endptr, int __base, locale_t __loc) noexcept (true) __asm__ ("" "__isoc23_strtoull_l")




     __attribute__ ((__nonnull__ (1, 4)));
# 415 "/usr/include/stdlib.h" 3 4
extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));
# 436 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));



extern _Float64 strtof64_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));



extern _Float128 strtof128_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));



extern _Float32x strtof32x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));



extern _Float64x strtof64x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));
# 505 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) noexcept (true) ;


extern long int a64l (const char *__s)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




# 1 "/usr/include/sys/types.h" 1 3 4
# 27 "/usr/include/sys/types.h" 3 4
extern "C" {





typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;


typedef __loff_t loff_t;




typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;





typedef __off_t off_t;






typedef __off64_t off64_t;




typedef __pid_t pid_t;





typedef __id_t id_t;




typedef __ssize_t ssize_t;





typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;




# 1 "/usr/include/bits/types/clock_t.h" 1 3 4






typedef __clock_t clock_t;
# 127 "/usr/include/sys/types.h" 2 3 4

# 1 "/usr/include/bits/types/clockid_t.h" 1 3 4






typedef __clockid_t clockid_t;
# 129 "/usr/include/sys/types.h" 2 3 4
# 1 "/usr/include/bits/types/time_t.h" 1 3 4
# 10 "/usr/include/bits/types/time_t.h" 3 4
typedef __time_t time_t;
# 130 "/usr/include/sys/types.h" 2 3 4
# 1 "/usr/include/bits/types/timer_t.h" 1 3 4






typedef __timer_t timer_t;
# 131 "/usr/include/sys/types.h" 2 3 4



typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/stddef.h" 1 3 4
# 145 "/usr/include/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;







typedef __uint8_t u_int8_t;
typedef __uint16_t u_int16_t;
typedef __uint32_t u_int32_t;
typedef __uint64_t u_int64_t;


typedef int register_t __attribute__ ((__mode__ (__word__)));
# 176 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 24 "/usr/include/endian.h" 3 4
# 1 "/usr/include/bits/endian.h" 1 3 4
# 35 "/usr/include/bits/endian.h" 3 4
# 1 "/usr/include/bits/endianness.h" 1 3 4
# 36 "/usr/include/bits/endian.h" 2 3 4
# 25 "/usr/include/endian.h" 2 3 4
# 35 "/usr/include/endian.h" 3 4
# 1 "/usr/include/bits/byteswap.h" 1 3 4
# 33 "/usr/include/bits/byteswap.h" 3 4
static __inline __uint16_t
__bswap_16 (__uint16_t __bsx)
{

  return __builtin_bswap16 (__bsx);



}






static __inline __uint32_t
__bswap_32 (__uint32_t __bsx)
{

  return __builtin_bswap32 (__bsx);



}
# 69 "/usr/include/bits/byteswap.h" 3 4
__extension__ static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{

  return __builtin_bswap64 (__bsx);



}
# 36 "/usr/include/endian.h" 2 3 4
# 1 "/usr/include/bits/uintn-identity.h" 1 3 4
# 32 "/usr/include/bits/uintn-identity.h" 3 4
static __inline __uint16_t
__uint16_identity (__uint16_t __x)
{
  return __x;
}

static __inline __uint32_t
__uint32_identity (__uint32_t __x)
{
  return __x;
}

static __inline __uint64_t
__uint64_identity (__uint64_t __x)
{
  return __x;
}
# 37 "/usr/include/endian.h" 2 3 4
# 177 "/usr/include/sys/types.h" 2 3 4


# 1 "/usr/include/sys/select.h" 1 3 4
# 30 "/usr/include/sys/select.h" 3 4
# 1 "/usr/include/bits/select.h" 1 3 4
# 31 "/usr/include/sys/select.h" 2 3 4


# 1 "/usr/include/bits/types/sigset_t.h" 1 3 4



# 1 "/usr/include/bits/types/__sigset_t.h" 1 3 4




typedef struct
{
  unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;
# 5 "/usr/include/bits/types/sigset_t.h" 2 3 4


typedef __sigset_t sigset_t;
# 34 "/usr/include/sys/select.h" 2 3 4



# 1 "/usr/include/bits/types/struct_timeval.h" 1 3 4







struct timeval
{




  __time_t tv_sec;
  __suseconds_t tv_usec;

};
# 38 "/usr/include/sys/select.h" 2 3 4

# 1 "/usr/include/bits/types/struct_timespec.h" 1 3 4
# 11 "/usr/include/bits/types/struct_timespec.h" 3 4
struct timespec
{



  __time_t tv_sec;




  __syscall_slong_t tv_nsec;
# 31 "/usr/include/bits/types/struct_timespec.h" 3 4
};
# 40 "/usr/include/sys/select.h" 2 3 4
# 49 "/usr/include/sys/select.h" 3 4
typedef long int __fd_mask;
# 59 "/usr/include/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 91 "/usr/include/sys/select.h" 3 4
extern "C" {
# 102 "/usr/include/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 127 "/usr/include/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 153 "/usr/include/sys/select.h" 3 4
}
# 180 "/usr/include/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 219 "/usr/include/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;





# 1 "/usr/include/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/bits/thread-shared-types.h" 1 3 4
# 44 "/usr/include/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/bits/pthreadtypes-arch.h" 1 3 4
# 21 "/usr/include/bits/pthreadtypes-arch.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 22 "/usr/include/bits/pthreadtypes-arch.h" 2 3 4
# 45 "/usr/include/bits/thread-shared-types.h" 2 3 4

# 1 "/usr/include/bits/atomic_wide_counter.h" 1 3 4
# 25 "/usr/include/bits/atomic_wide_counter.h" 3 4
typedef union
{
  __extension__ unsigned long long int __value64;
  struct
  {
    unsigned int __low;
    unsigned int __high;
  } __value32;
} __atomic_wide_counter;
# 47 "/usr/include/bits/thread-shared-types.h" 2 3 4




typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;

typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;
# 76 "/usr/include/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/bits/struct_mutex.h" 1 3 4
# 22 "/usr/include/bits/struct_mutex.h" 3 4
struct __pthread_mutex_s
{
  int __lock;
  unsigned int __count;
  int __owner;

  unsigned int __nusers;



  int __kind;

  short __spins;
  short __elision;
  __pthread_list_t __list;
# 53 "/usr/include/bits/struct_mutex.h" 3 4
};
# 77 "/usr/include/bits/thread-shared-types.h" 2 3 4
# 89 "/usr/include/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/bits/struct_rwlock.h" 1 3 4
# 23 "/usr/include/bits/struct_rwlock.h" 3 4
struct __pthread_rwlock_arch_t
{
  unsigned int __readers;
  unsigned int __writers;
  unsigned int __wrphase_futex;
  unsigned int __writers_futex;
  unsigned int __pad3;
  unsigned int __pad4;

  int __cur_writer;
  int __shared;
  signed char __rwelision;




  unsigned char __pad1[7];


  unsigned long int __pad2;


  unsigned int __flags;
# 55 "/usr/include/bits/struct_rwlock.h" 3 4
};
# 90 "/usr/include/bits/thread-shared-types.h" 2 3 4




struct __pthread_cond_s
{
  __atomic_wide_counter __wseq;
  __atomic_wide_counter __g1_start;
  unsigned int __g_refs[2] ;
  unsigned int __g_size[2];
  unsigned int __g1_orig_size;
  unsigned int __wrefs;
  unsigned int __g_signals[2];
};

typedef unsigned int __tss_t;
typedef unsigned long int __thrd_t;

typedef struct
{
  int __data ;
} __once_flag;
# 24 "/usr/include/bits/pthreadtypes.h" 2 3 4



typedef unsigned long int pthread_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;




typedef union
{
  struct __pthread_mutex_s __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;


typedef union
{
  struct __pthread_cond_s __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;





typedef union
{
  struct __pthread_rwlock_arch_t __data;
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 228 "/usr/include/sys/types.h" 2 3 4


}
# 515 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) noexcept (true);


extern void srandom (unsigned int __seed) noexcept (true);





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) noexcept (true) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) noexcept (true) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     noexcept (true) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     noexcept (true) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));





extern int rand (void) noexcept (true);

extern void srand (unsigned int __seed) noexcept (true);



extern int rand_r (unsigned int *__seed) noexcept (true);







extern double drand48 (void) noexcept (true);
extern double erand48 (unsigned short int __xsubi[3]) noexcept (true) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) noexcept (true);
extern long int nrand48 (unsigned short int __xsubi[3])
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) noexcept (true);
extern long int jrand48 (unsigned short int __xsubi[3])
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) noexcept (true);
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     noexcept (true) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) noexcept (true) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     noexcept (true) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern __uint32_t arc4random (void)
     noexcept (true) ;


extern void arc4random_buf (void *__buf, size_t __size)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern __uint32_t arc4random_uniform (__uint32_t __upper_bound)
     noexcept (true) ;




extern void *malloc (size_t __size) noexcept (true) __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) ;

extern void *calloc (size_t __nmemb, size_t __size)
     noexcept (true) __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (1, 2))) ;






extern void *realloc (void *__ptr, size_t __size)
     noexcept (true) __attribute__ ((__warn_unused_result__)) __attribute__ ((__alloc_size__ (2)));


extern void free (void *__ptr) noexcept (true);







extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     noexcept (true) __attribute__ ((__warn_unused_result__))
     __attribute__ ((__alloc_size__ (2, 3)))
    __attribute__ ((__malloc__ (__builtin_free, 1)));


extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     noexcept (true) __attribute__ ((__malloc__ (reallocarray, 1)));



# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4

extern "C" {





extern void *alloca (size_t __size) noexcept (true);





}
# 707 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) noexcept (true) __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     noexcept (true) __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     noexcept (true) __attribute__ ((__malloc__)) __attribute__ ((__alloc_align__ (1)))
     __attribute__ ((__alloc_size__ (2))) ;



extern void abort (void) noexcept (true) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) noexcept (true) __attribute__ ((__nonnull__ (1)));




extern "C++" int at_quick_exit (void (*__func) (void))
     noexcept (true) __asm ("at_quick_exit") __attribute__ ((__nonnull__ (1)));
# 749 "/usr/include/stdlib.h" 3 4
extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     noexcept (true) __attribute__ ((__nonnull__ (1)));





extern void exit (int __status) noexcept (true) __attribute__ ((__noreturn__));





extern void quick_exit (int __status) noexcept (true) __attribute__ ((__noreturn__));





extern void _Exit (int __status) noexcept (true) __attribute__ ((__noreturn__));




extern char *getenv (const char *__name) noexcept (true) __attribute__ ((__nonnull__ (1))) ;




extern char *secure_getenv (const char *__name)
     noexcept (true) __attribute__ ((__nonnull__ (1))) ;






extern int putenv (char *__string) noexcept (true) __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     noexcept (true) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) noexcept (true) __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) noexcept (true);
# 814 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) noexcept (true) __attribute__ ((__nonnull__ (1)));
# 827 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 837 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 849 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 859 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 870 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) noexcept (true) __attribute__ ((__nonnull__ (1))) ;
# 881 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 891 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 901 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 913 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 923 "/usr/include/stdlib.h" 3 4
extern int system (const char *__command) ;





extern char *canonicalize_file_name (const char *__name)
     noexcept (true) __attribute__ ((__nonnull__ (1))) __attribute__ ((__malloc__))
     __attribute__ ((__malloc__ (__builtin_free, 1))) ;
# 940 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) noexcept (true) ;






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);




extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;







extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) noexcept (true) __attribute__ ((__const__)) ;
extern long int labs (long int __x) noexcept (true) __attribute__ ((__const__)) ;


__extension__ extern long long int llabs (long long int __x)
     noexcept (true) __attribute__ ((__const__)) ;






extern div_t div (int __numer, int __denom)
     noexcept (true) __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     noexcept (true) __attribute__ ((__const__)) ;


__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     noexcept (true) __attribute__ ((__const__)) ;
# 1012 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) noexcept (true) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) noexcept (true) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     noexcept (true) __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     noexcept (true) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     noexcept (true) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     noexcept (true) __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) noexcept (true) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) noexcept (true) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     noexcept (true) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     noexcept (true) __attribute__ ((__nonnull__ (3, 4, 5)));





extern int mblen (const char *__s, size_t __n) noexcept (true);


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) noexcept (true);


extern int wctomb (char *__s, wchar_t __wchar) noexcept (true);



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) noexcept (true)
    __attribute__ ((__access__ (__read_only__, 2)));

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     noexcept (true)
  __attribute__ ((__access__ (__write_only__, 1, 3)))
  __attribute__ ((__access__ (__read_only__, 2)));






extern int rpmatch (const char *__response) noexcept (true) __attribute__ ((__nonnull__ (1))) ;
# 1099 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2, 3))) ;







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) noexcept (true);



extern int unlockpt (int __fd) noexcept (true);




extern char *ptsname (int __fd) noexcept (true) ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     noexcept (true) __attribute__ ((__nonnull__ (2))) __attribute__ ((__access__ (__write_only__, 2, 3)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     noexcept (true) __attribute__ ((__nonnull__ (1)));
# 1155 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/bits/stdlib-float.h" 1 3 4
# 1156 "/usr/include/stdlib.h" 2 3 4
# 1167 "/usr/include/stdlib.h" 3 4
}
# 39 "/usr/include/c++/14.2.1/bits/std_abs.h" 2 3







extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::abs;


  inline long
  abs(long __i) { return __builtin_labs(__i); }



  inline long long
  abs(long long __x) { return __builtin_llabs (__x); }
# 70 "/usr/include/c++/14.2.1/bits/std_abs.h" 3
  inline constexpr double
  abs(double __x)
  { return __builtin_fabs(__x); }

  inline constexpr float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }



  __extension__ inline constexpr __int128
  abs(__int128 __x) { return __x >= 0 ? __x : -__x; }
# 135 "/usr/include/c++/14.2.1/bits/std_abs.h" 3
  __extension__ inline constexpr
  __float128
  abs(__float128 __x)
  {



    return __builtin_fabsf128(__x);




  }



}
}
# 50 "/usr/include/c++/14.2.1/cmath" 2 3






# 1 "/usr/include/c++/14.2.1/bits/version.h" 1 3
# 47 "/usr/include/c++/14.2.1/bits/version.h" 3
       
# 48 "/usr/include/c++/14.2.1/bits/version.h" 3
# 57 "/usr/include/c++/14.2.1/cmath" 2 3
# 83 "/usr/include/c++/14.2.1/cmath" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::acos;


  inline constexpr float
  acos(float __x)
  { return __builtin_acosf(__x); }

  inline constexpr long double
  acos(long double __x)
  { return __builtin_acosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    acos(_Tp __x)
    { return __builtin_acos(__x); }

  using ::asin;


  inline constexpr float
  asin(float __x)
  { return __builtin_asinf(__x); }

  inline constexpr long double
  asin(long double __x)
  { return __builtin_asinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    asin(_Tp __x)
    { return __builtin_asin(__x); }

  using ::atan;


  inline constexpr float
  atan(float __x)
  { return __builtin_atanf(__x); }

  inline constexpr long double
  atan(long double __x)
  { return __builtin_atanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    atan(_Tp __x)
    { return __builtin_atan(__x); }

  using ::atan2;


  inline constexpr float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }

  inline constexpr long double
  atan2(long double __y, long double __x)
  { return __builtin_atan2l(__y, __x); }


  using ::ceil;


  inline constexpr float
  ceil(float __x)
  { return __builtin_ceilf(__x); }

  inline constexpr long double
  ceil(long double __x)
  { return __builtin_ceill(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ceil(_Tp __x)
    { return __builtin_ceil(__x); }

  using ::cos;


  inline constexpr float
  cos(float __x)
  { return __builtin_cosf(__x); }

  inline constexpr long double
  cos(long double __x)
  { return __builtin_cosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cos(_Tp __x)
    { return __builtin_cos(__x); }

  using ::cosh;


  inline constexpr float
  cosh(float __x)
  { return __builtin_coshf(__x); }

  inline constexpr long double
  cosh(long double __x)
  { return __builtin_coshl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cosh(_Tp __x)
    { return __builtin_cosh(__x); }

  using ::exp;


  inline constexpr float
  exp(float __x)
  { return __builtin_expf(__x); }

  inline constexpr long double
  exp(long double __x)
  { return __builtin_expl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    exp(_Tp __x)
    { return __builtin_exp(__x); }

  using ::fabs;


  inline constexpr float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    fabs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::floor;


  inline constexpr float
  floor(float __x)
  { return __builtin_floorf(__x); }

  inline constexpr long double
  floor(long double __x)
  { return __builtin_floorl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    floor(_Tp __x)
    { return __builtin_floor(__x); }

  using ::fmod;


  inline constexpr float
  fmod(float __x, float __y)
  { return __builtin_fmodf(__x, __y); }

  inline constexpr long double
  fmod(long double __x, long double __y)
  { return __builtin_fmodl(__x, __y); }


  using ::frexp;


  inline float
  frexp(float __x, int* __exp)
  { return __builtin_frexpf(__x, __exp); }

  inline long double
  frexp(long double __x, int* __exp)
  { return __builtin_frexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    frexp(_Tp __x, int* __exp)
    { return __builtin_frexp(__x, __exp); }

  using ::ldexp;


  inline constexpr float
  ldexp(float __x, int __exp)
  { return __builtin_ldexpf(__x, __exp); }

  inline constexpr long double
  ldexp(long double __x, int __exp)
  { return __builtin_ldexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ldexp(_Tp __x, int __exp)
    { return __builtin_ldexp(__x, __exp); }

  using ::log;


  inline constexpr float
  log(float __x)
  { return __builtin_logf(__x); }

  inline constexpr long double
  log(long double __x)
  { return __builtin_logl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log(_Tp __x)
    { return __builtin_log(__x); }

  using ::log10;


  inline constexpr float
  log10(float __x)
  { return __builtin_log10f(__x); }

  inline constexpr long double
  log10(long double __x)
  { return __builtin_log10l(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log10(_Tp __x)
    { return __builtin_log10(__x); }

  using ::modf;


  inline float
  modf(float __x, float* __iptr)
  { return __builtin_modff(__x, __iptr); }

  inline long double
  modf(long double __x, long double* __iptr)
  { return __builtin_modfl(__x, __iptr); }


  using ::pow;


  inline constexpr float
  pow(float __x, float __y)
  { return __builtin_powf(__x, __y); }

  inline constexpr long double
  pow(long double __x, long double __y)
  { return __builtin_powl(__x, __y); }
# 400 "/usr/include/c++/14.2.1/cmath" 3
  using ::sin;


  inline constexpr float
  sin(float __x)
  { return __builtin_sinf(__x); }

  inline constexpr long double
  sin(long double __x)
  { return __builtin_sinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sin(_Tp __x)
    { return __builtin_sin(__x); }

  using ::sinh;


  inline constexpr float
  sinh(float __x)
  { return __builtin_sinhf(__x); }

  inline constexpr long double
  sinh(long double __x)
  { return __builtin_sinhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sinh(_Tp __x)
    { return __builtin_sinh(__x); }

  using ::sqrt;


  inline constexpr float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }

  inline constexpr long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sqrt(_Tp __x)
    { return __builtin_sqrt(__x); }

  using ::tan;


  inline constexpr float
  tan(float __x)
  { return __builtin_tanf(__x); }

  inline constexpr long double
  tan(long double __x)
  { return __builtin_tanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tan(_Tp __x)
    { return __builtin_tan(__x); }

  using ::tanh;


  inline constexpr float
  tanh(float __x)
  { return __builtin_tanhf(__x); }

  inline constexpr long double
  tanh(long double __x)
  { return __builtin_tanhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tanh(_Tp __x)
    { return __builtin_tanh(__x); }
# 1053 "/usr/include/c++/14.2.1/cmath" 3
  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    atan2(_Tp __y, _Up __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return atan2(__type(__y), __type(__x));
    }

  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmod(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmod(__type(__x), __type(__y));
    }

  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    pow(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return pow(__type(__x), __type(__y));
    }
# 1100 "/usr/include/c++/14.2.1/cmath" 3
  constexpr int
  fpclassify(float __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }

  constexpr int
  fpclassify(double __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }

  constexpr int
  fpclassify(long double __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              int>::__type
    fpclassify(_Tp __x)
    { return __x != 0 ? 4 : 2; }



  constexpr bool
  isfinite(float __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(double __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(long double __x)
  { return __builtin_isfinite(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isfinite(_Tp)
    { return true; }



  constexpr bool
  isinf(float __x)
  { return __builtin_isinf(__x); }





  constexpr bool
  isinf(double __x)
  { return __builtin_isinf(__x); }


  constexpr bool
  isinf(long double __x)
  { return __builtin_isinf(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isinf(_Tp)
    { return false; }



  constexpr bool
  isnan(float __x)
  { return __builtin_isnan(__x); }





  constexpr bool
  isnan(double __x)
  { return __builtin_isnan(__x); }


  constexpr bool
  isnan(long double __x)
  { return __builtin_isnan(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnan(_Tp)
    { return false; }



  constexpr bool
  isnormal(float __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(double __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(long double __x)
  { return __builtin_isnormal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnormal(_Tp __x)
    { return __x != 0 ? true : false; }




  constexpr bool
  signbit(float __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(double __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(long double __x)
  { return __builtin_signbit(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    signbit(_Tp __x)
    { return __x < 0 ? true : false; }



  constexpr bool
  isgreater(float __x, float __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(double __x, double __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(long double __x, long double __y)
  { return __builtin_isgreater(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreater(__type(__x), __type(__y));
    }



  constexpr bool
  isgreaterequal(float __x, float __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(double __x, double __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(long double __x, long double __y)
  { return __builtin_isgreaterequal(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreaterequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreaterequal(__type(__x), __type(__y));
    }



  constexpr bool
  isless(float __x, float __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(double __x, double __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(long double __x, long double __y)
  { return __builtin_isless(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isless(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isless(__type(__x), __type(__y));
    }



  constexpr bool
  islessequal(float __x, float __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(double __x, double __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(long double __x, long double __y)
  { return __builtin_islessequal(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessequal(__type(__x), __type(__y));
    }



  constexpr bool
  islessgreater(float __x, float __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(double __x, double __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(long double __x, long double __y)
  { return __builtin_islessgreater(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessgreater(__type(__x), __type(__y));
    }



  constexpr bool
  isunordered(float __x, float __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(double __x, double __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(long double __x, long double __y)
  { return __builtin_isunordered(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isunordered(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isunordered(__type(__x), __type(__y));
    }
# 1820 "/usr/include/c++/14.2.1/cmath" 3
  using ::acosf;


  using ::acosl;



  using ::asinf;


  using ::asinl;



  using ::atanf;


  using ::atanl;



  using ::atan2f;


  using ::atan2l;



  using ::ceilf;


  using ::ceill;



  using ::cosf;


  using ::cosl;



  using ::coshf;


  using ::coshl;



  using ::expf;


  using ::expl;



  using ::fabsf;


  using ::fabsl;



  using ::floorf;


  using ::floorl;



  using ::fmodf;


  using ::fmodl;



  using ::frexpf;


  using ::frexpl;



  using ::ldexpf;


  using ::ldexpl;



  using ::logf;


  using ::logl;



  using ::log10f;


  using ::log10l;



  using ::modff;


  using ::modfl;



  using ::powf;


  using ::powl;



  using ::sinf;


  using ::sinl;



  using ::sinhf;


  using ::sinhl;



  using ::sqrtf;


  using ::sqrtl;



  using ::tanf;


  using ::tanl;



  using ::tanhf;


  using ::tanhl;
# 2085 "/usr/include/c++/14.2.1/cmath" 3
  using ::double_t;
  using ::float_t;



  using ::acosh;
  using ::acoshf;
  using ::acoshl;

  using ::asinh;
  using ::asinhf;
  using ::asinhl;

  using ::atanh;
  using ::atanhf;
  using ::atanhl;

  using ::cbrt;
  using ::cbrtf;
  using ::cbrtl;

  using ::copysign;
  using ::copysignf;
  using ::copysignl;

  using ::erf;
  using ::erff;
  using ::erfl;

  using ::erfc;
  using ::erfcf;
  using ::erfcl;

  using ::exp2;
  using ::exp2f;
  using ::exp2l;

  using ::expm1;
  using ::expm1f;
  using ::expm1l;

  using ::fdim;
  using ::fdimf;
  using ::fdiml;

  using ::fma;
  using ::fmaf;
  using ::fmal;

  using ::fmax;
  using ::fmaxf;
  using ::fmaxl;

  using ::fmin;
  using ::fminf;
  using ::fminl;

  using ::hypot;
  using ::hypotf;
  using ::hypotl;

  using ::ilogb;
  using ::ilogbf;
  using ::ilogbl;

  using ::lgamma;
  using ::lgammaf;
  using ::lgammal;


  using ::llrint;
  using ::llrintf;
  using ::llrintl;

  using ::llround;
  using ::llroundf;
  using ::llroundl;


  using ::log1p;
  using ::log1pf;
  using ::log1pl;

  using ::log2;
  using ::log2f;
  using ::log2l;

  using ::logb;
  using ::logbf;
  using ::logbl;

  using ::lrint;
  using ::lrintf;
  using ::lrintl;

  using ::lround;
  using ::lroundf;
  using ::lroundl;

  using ::nan;
  using ::nanf;
  using ::nanl;

  using ::nearbyint;
  using ::nearbyintf;
  using ::nearbyintl;

  using ::nextafter;
  using ::nextafterf;
  using ::nextafterl;

  using ::nexttoward;
  using ::nexttowardf;
  using ::nexttowardl;

  using ::remainder;
  using ::remainderf;
  using ::remainderl;

  using ::remquo;
  using ::remquof;
  using ::remquol;

  using ::rint;
  using ::rintf;
  using ::rintl;

  using ::round;
  using ::roundf;
  using ::roundl;

  using ::scalbln;
  using ::scalblnf;
  using ::scalblnl;

  using ::scalbn;
  using ::scalbnf;
  using ::scalbnl;

  using ::tgamma;
  using ::tgammaf;
  using ::tgammal;

  using ::trunc;
  using ::truncf;
  using ::truncl;



  constexpr float
  acosh(float __x)
  { return __builtin_acoshf(__x); }

  constexpr long double
  acosh(long double __x)
  { return __builtin_acoshl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    acosh(_Tp __x)
    { return __builtin_acosh(__x); }



  constexpr float
  asinh(float __x)
  { return __builtin_asinhf(__x); }

  constexpr long double
  asinh(long double __x)
  { return __builtin_asinhl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    asinh(_Tp __x)
    { return __builtin_asinh(__x); }



  constexpr float
  atanh(float __x)
  { return __builtin_atanhf(__x); }

  constexpr long double
  atanh(long double __x)
  { return __builtin_atanhl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    atanh(_Tp __x)
    { return __builtin_atanh(__x); }



  constexpr float
  cbrt(float __x)
  { return __builtin_cbrtf(__x); }

  constexpr long double
  cbrt(long double __x)
  { return __builtin_cbrtl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    cbrt(_Tp __x)
    { return __builtin_cbrt(__x); }



  constexpr float
  copysign(float __x, float __y)
  { return __builtin_copysignf(__x, __y); }

  constexpr long double
  copysign(long double __x, long double __y)
  { return __builtin_copysignl(__x, __y); }



  constexpr float
  erf(float __x)
  { return __builtin_erff(__x); }

  constexpr long double
  erf(long double __x)
  { return __builtin_erfl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erf(_Tp __x)
    { return __builtin_erf(__x); }



  constexpr float
  erfc(float __x)
  { return __builtin_erfcf(__x); }

  constexpr long double
  erfc(long double __x)
  { return __builtin_erfcl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erfc(_Tp __x)
    { return __builtin_erfc(__x); }



  constexpr float
  exp2(float __x)
  { return __builtin_exp2f(__x); }

  constexpr long double
  exp2(long double __x)
  { return __builtin_exp2l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    exp2(_Tp __x)
    { return __builtin_exp2(__x); }



  constexpr float
  expm1(float __x)
  { return __builtin_expm1f(__x); }

  constexpr long double
  expm1(long double __x)
  { return __builtin_expm1l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    expm1(_Tp __x)
    { return __builtin_expm1(__x); }



  constexpr float
  fdim(float __x, float __y)
  { return __builtin_fdimf(__x, __y); }

  constexpr long double
  fdim(long double __x, long double __y)
  { return __builtin_fdiml(__x, __y); }



  constexpr float
  fma(float __x, float __y, float __z)
  { return __builtin_fmaf(__x, __y, __z); }

  constexpr long double
  fma(long double __x, long double __y, long double __z)
  { return __builtin_fmal(__x, __y, __z); }



  constexpr float
  fmax(float __x, float __y)
  { return __builtin_fmaxf(__x, __y); }

  constexpr long double
  fmax(long double __x, long double __y)
  { return __builtin_fmaxl(__x, __y); }



  constexpr float
  fmin(float __x, float __y)
  { return __builtin_fminf(__x, __y); }

  constexpr long double
  fmin(long double __x, long double __y)
  { return __builtin_fminl(__x, __y); }



  constexpr float
  hypot(float __x, float __y)
  { return __builtin_hypotf(__x, __y); }

  constexpr long double
  hypot(long double __x, long double __y)
  { return __builtin_hypotl(__x, __y); }



  constexpr int
  ilogb(float __x)
  { return __builtin_ilogbf(__x); }

  constexpr int
  ilogb(long double __x)
  { return __builtin_ilogbl(__x); }



  template<typename _Tp>
    constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    int>::__type
    ilogb(_Tp __x)
    { return __builtin_ilogb(__x); }



  constexpr float
  lgamma(float __x)
  { return __builtin_lgammaf(__x); }

  constexpr long double
  lgamma(long double __x)
  { return __builtin_lgammal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    lgamma(_Tp __x)
    { return __builtin_lgamma(__x); }



  constexpr long long
  llrint(float __x)
  { return __builtin_llrintf(__x); }

  constexpr long long
  llrint(long double __x)
  { return __builtin_llrintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llrint(_Tp __x)
    { return __builtin_llrint(__x); }



  constexpr long long
  llround(float __x)
  { return __builtin_llroundf(__x); }

  constexpr long long
  llround(long double __x)
  { return __builtin_llroundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llround(_Tp __x)
    { return __builtin_llround(__x); }



  constexpr float
  log1p(float __x)
  { return __builtin_log1pf(__x); }

  constexpr long double
  log1p(long double __x)
  { return __builtin_log1pl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log1p(_Tp __x)
    { return __builtin_log1p(__x); }




  constexpr float
  log2(float __x)
  { return __builtin_log2f(__x); }

  constexpr long double
  log2(long double __x)
  { return __builtin_log2l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log2(_Tp __x)
    { return __builtin_log2(__x); }



  constexpr float
  logb(float __x)
  { return __builtin_logbf(__x); }

  constexpr long double
  logb(long double __x)
  { return __builtin_logbl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    logb(_Tp __x)
    { return __builtin_logb(__x); }



  constexpr long
  lrint(float __x)
  { return __builtin_lrintf(__x); }

  constexpr long
  lrint(long double __x)
  { return __builtin_lrintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lrint(_Tp __x)
    { return __builtin_lrint(__x); }



  constexpr long
  lround(float __x)
  { return __builtin_lroundf(__x); }

  constexpr long
  lround(long double __x)
  { return __builtin_lroundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lround(_Tp __x)
    { return __builtin_lround(__x); }



  constexpr float
  nearbyint(float __x)
  { return __builtin_nearbyintf(__x); }

  constexpr long double
  nearbyint(long double __x)
  { return __builtin_nearbyintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nearbyint(_Tp __x)
    { return __builtin_nearbyint(__x); }



  constexpr float
  nextafter(float __x, float __y)
  { return __builtin_nextafterf(__x, __y); }

  constexpr long double
  nextafter(long double __x, long double __y)
  { return __builtin_nextafterl(__x, __y); }



  constexpr float
  nexttoward(float __x, long double __y)
  { return __builtin_nexttowardf(__x, __y); }

  constexpr long double
  nexttoward(long double __x, long double __y)
  { return __builtin_nexttowardl(__x, __y); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nexttoward(_Tp __x, long double __y)
    { return __builtin_nexttoward(__x, __y); }



  constexpr float
  remainder(float __x, float __y)
  { return __builtin_remainderf(__x, __y); }

  constexpr long double
  remainder(long double __x, long double __y)
  { return __builtin_remainderl(__x, __y); }



  inline float
  remquo(float __x, float __y, int* __pquo)
  { return __builtin_remquof(__x, __y, __pquo); }

  inline long double
  remquo(long double __x, long double __y, int* __pquo)
  { return __builtin_remquol(__x, __y, __pquo); }



  constexpr float
  rint(float __x)
  { return __builtin_rintf(__x); }

  constexpr long double
  rint(long double __x)
  { return __builtin_rintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    rint(_Tp __x)
    { return __builtin_rint(__x); }



  constexpr float
  round(float __x)
  { return __builtin_roundf(__x); }

  constexpr long double
  round(long double __x)
  { return __builtin_roundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    round(_Tp __x)
    { return __builtin_round(__x); }



  constexpr float
  scalbln(float __x, long __ex)
  { return __builtin_scalblnf(__x, __ex); }

  constexpr long double
  scalbln(long double __x, long __ex)
  { return __builtin_scalblnl(__x, __ex); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbln(_Tp __x, long __ex)
    { return __builtin_scalbln(__x, __ex); }



  constexpr float
  scalbn(float __x, int __ex)
  { return __builtin_scalbnf(__x, __ex); }

  constexpr long double
  scalbn(long double __x, int __ex)
  { return __builtin_scalbnl(__x, __ex); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbn(_Tp __x, int __ex)
    { return __builtin_scalbn(__x, __ex); }



  constexpr float
  tgamma(float __x)
  { return __builtin_tgammaf(__x); }

  constexpr long double
  tgamma(long double __x)
  { return __builtin_tgammal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    tgamma(_Tp __x)
    { return __builtin_tgamma(__x); }



  constexpr float
  trunc(float __x)
  { return __builtin_truncf(__x); }

  constexpr long double
  trunc(long double __x)
  { return __builtin_truncl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    trunc(_Tp __x)
    { return __builtin_trunc(__x); }
# 3674 "/usr/include/c++/14.2.1/cmath" 3
  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    copysign(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return copysign(__type(__x), __type(__y));
    }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fdim(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fdim(__type(__x), __type(__y));
    }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmax(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmax(__type(__x), __type(__y));
    }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmin(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmin(__type(__x), __type(__y));
    }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    hypot(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return hypot(__type(__x), __type(__y));
    }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    nextafter(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return nextafter(__type(__x), __type(__y));
    }

  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remainder(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remainder(__type(__x), __type(__y));
    }

  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remquo(_Tp __x, _Up __y, int* __pquo)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remquo(__type(__x), __type(__y), __pquo);
    }

  template<typename _Tp, typename _Up, typename _Vp>
    constexpr typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type
    fma(_Tp __x, _Up __y, _Vp __z)
    {
      typedef typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type __type;
      return fma(__type(__x), __type(__y), __type(__z));
    }







  template<typename _Tp>
    inline _Tp
    __hypot3(_Tp __x, _Tp __y, _Tp __z)
    {
      __x = std::abs(__x);
      __y = std::abs(__y);
      __z = std::abs(__z);
      if (_Tp __a = __x < __y ? __y < __z ? __z : __y : __x < __z ? __z : __x)
 return __a * std::sqrt((__x / __a) * (__x / __a)
          + (__y / __a) * (__y / __a)
          + (__z / __a) * (__z / __a));
      else
 return {};
    }

  inline float
  hypot(float __x, float __y, float __z)
  { return std::__hypot3<float>(__x, __y, __z); }

  inline double
  hypot(double __x, double __y, double __z)
  { return std::__hypot3<double>(__x, __y, __z); }

  inline long double
  hypot(long double __x, long double __y, long double __z)
  { return std::__hypot3<long double>(__x, __y, __z); }

  template<typename _Tp, typename _Up, typename _Vp>
    __gnu_cxx::__promoted_t<_Tp, _Up, _Vp>
    hypot(_Tp __x, _Up __y, _Vp __z)
    {
      using __type = __gnu_cxx::__promoted_t<_Tp, _Up, _Vp>;
      return std::__hypot3<__type>(__x, __y, __z);
    }
# 3823 "/usr/include/c++/14.2.1/cmath" 3
  template<typename _Fp>
    constexpr _Fp
    __lerp(_Fp __a, _Fp __b, _Fp __t) noexcept
    {
      if ((__a <= 0 && __b >= 0) || (__a >= 0 && __b <= 0))
 return __t * __b + (1 - __t) * __a;

      if (__t == 1)
 return __b;



      const _Fp __x = __a + __t * (__b - __a);
      return (__t > 1) == (__b > __a)
 ? (__b < __x ? __x : __b)
 : (__b > __x ? __x : __b);
    }

  constexpr float
  lerp(float __a, float __b, float __t) noexcept
  { return std::__lerp(__a, __b, __t); }

  constexpr double
  lerp(double __a, double __b, double __t) noexcept
  { return std::__lerp(__a, __b, __t); }

  constexpr long double
  lerp(long double __a, long double __b, long double __t) noexcept
  { return std::__lerp(__a, __b, __t); }

  template<typename _Tp, typename _Up, typename _Vp>
    constexpr __gnu_cxx::__promoted_t<_Tp, _Up, _Vp>
    lerp(_Tp __x, _Up __y, _Vp __z) noexcept
    {
      using __type = __gnu_cxx::__promoted_t<_Tp, _Up, _Vp>;
      return std::__lerp<__type>(__x, __y, __z);
    }
# 3894 "/usr/include/c++/14.2.1/cmath" 3

}


# 1 "/usr/include/c++/14.2.1/bits/specfun.h" 1 3
# 37 "/usr/include/c++/14.2.1/bits/specfun.h" 3
# 1 "/usr/include/c++/14.2.1/bits/version.h" 1 3
# 47 "/usr/include/c++/14.2.1/bits/version.h" 3
       
# 48 "/usr/include/c++/14.2.1/bits/version.h" 3
# 38 "/usr/include/c++/14.2.1/bits/specfun.h" 2 3





# 1 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 1 3
# 60 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
# 1 "/usr/include/c++/14.2.1/bits/functexcept.h" 1 3
# 40 "/usr/include/c++/14.2.1/bits/functexcept.h" 3
# 1 "/usr/include/c++/14.2.1/bits/exception_defines.h" 1 3
# 41 "/usr/include/c++/14.2.1/bits/functexcept.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{




  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));

  void
  __throw_bad_array_new_length(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__,__cold__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__,__cold__));


  void
  __throw_logic_error(const char*) __attribute__((__noreturn__,__cold__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__,__cold__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__,__cold__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__,__cold__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__,__cold__));

  void
  __throw_out_of_range_fmt(const char*, ...) __attribute__((__noreturn__,__cold__))
    __attribute__((__format__(__gnu_printf__, 1, 2)));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__,__cold__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__,__cold__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__,__cold__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__,__cold__));


  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__,__cold__));

  void
  __throw_ios_failure(const char*, int) __attribute__((__noreturn__,__cold__));


  void
  __throw_system_error(int) __attribute__((__noreturn__,__cold__));


  void
  __throw_future_error(int) __attribute__((__noreturn__,__cold__));


  void
  __throw_bad_function_call() __attribute__((__noreturn__,__cold__));
# 140 "/usr/include/c++/14.2.1/bits/functexcept.h" 3

}
# 61 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 2 3


# 1 "/usr/include/c++/14.2.1/ext/numeric_traits.h" 1 3
# 32 "/usr/include/c++/14.2.1/ext/numeric_traits.h" 3
       
# 33 "/usr/include/c++/14.2.1/ext/numeric_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 50 "/usr/include/c++/14.2.1/ext/numeric_traits.h" 3
  template<typename _Tp>
    struct __is_integer_nonstrict
    : public std::__is_integer<_Tp>
    {
      using std::__is_integer<_Tp>::__value;


      enum { __width = __value ? sizeof(_Tp) * 8 : 0 };
    };

  template<typename _Value>
    struct __numeric_traits_integer
    {

      static_assert(__is_integer_nonstrict<_Value>::__value,
      "invalid specialization");




      static const bool __is_signed = (_Value)(-1) < 0;
      static const int __digits
 = __is_integer_nonstrict<_Value>::__width - __is_signed;


      static const _Value __max = __is_signed
 ? (((((_Value)1 << (__digits - 1)) - 1) << 1) + 1)
 : ~(_Value)0;
      static const _Value __min = __is_signed ? -__max - 1 : (_Value)0;
    };

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__min;

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__max;

  template<typename _Value>
    const bool __numeric_traits_integer<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_integer<_Value>::__digits;
# 137 "/usr/include/c++/14.2.1/ext/numeric_traits.h" 3
  template<typename _Tp>
    using __int_traits = __numeric_traits_integer<_Tp>;
# 157 "/usr/include/c++/14.2.1/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_floating
    {

      static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 643L / 2136);


      static const bool __is_signed = true;
      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);
      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);
    };

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_digits10;

  template<typename _Value>
    const bool __numeric_traits_floating<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__digits10;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_exponent10;






  template<typename _Value>
    struct __numeric_traits
    : public __numeric_traits_integer<_Value>
    { };

  template<>
    struct __numeric_traits<float>
    : public __numeric_traits_floating<float>
    { };

  template<>
    struct __numeric_traits<double>
    : public __numeric_traits_floating<double>
    { };

  template<>
    struct __numeric_traits<long double>
    : public __numeric_traits_floating<long double>
    { };
# 238 "/usr/include/c++/14.2.1/ext/numeric_traits.h" 3

}
# 64 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/14.2.1/bits/stl_pair.h" 1 3
# 60 "/usr/include/c++/14.2.1/bits/stl_pair.h" 3
# 1 "/usr/include/c++/14.2.1/type_traits" 1 3
# 32 "/usr/include/c++/14.2.1/type_traits" 3
       
# 33 "/usr/include/c++/14.2.1/type_traits" 3
# 63 "/usr/include/c++/14.2.1/type_traits" 3
# 1 "/usr/include/c++/14.2.1/bits/version.h" 1 3
# 47 "/usr/include/c++/14.2.1/bits/version.h" 3
       
# 48 "/usr/include/c++/14.2.1/bits/version.h" 3
# 64 "/usr/include/c++/14.2.1/type_traits" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp>
    class reference_wrapper;
# 86 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _Tp, _Tp __v>
    struct integral_constant
    {
      static constexpr _Tp value = __v;
      using value_type = _Tp;
      using type = integral_constant<_Tp, __v>;
      constexpr operator value_type() const noexcept { return value; }


      constexpr value_type operator()() const noexcept { return value; }

    };
# 106 "/usr/include/c++/14.2.1/type_traits" 3
  template<bool __v>
    using __bool_constant = integral_constant<bool, __v>;



  using true_type = __bool_constant<true>;


  using false_type = __bool_constant<false>;




  template<bool __v>
    using bool_constant = __bool_constant<__v>;






  template<bool, typename _Tp = void>
    struct enable_if
    { };


  template<typename _Tp>
    struct enable_if<true, _Tp>
    { using type = _Tp; };


  template<bool _Cond, typename _Tp = void>
    using __enable_if_t = typename enable_if<_Cond, _Tp>::type;

  template<bool>
    struct __conditional
    {
      template<typename _Tp, typename>
 using type = _Tp;
    };

  template<>
    struct __conditional<false>
    {
      template<typename, typename _Up>
 using type = _Up;
    };


  template<bool _Cond, typename _If, typename _Else>
    using __conditional_t
      = typename __conditional<_Cond>::template type<_If, _Else>;


  template <typename _Type>
    struct __type_identity
    { using type = _Type; };

  template<typename _Tp>
    using __type_identity_t = typename __type_identity<_Tp>::type;

  namespace __detail
  {

    template<typename _Tp, typename...>
      using __first_t = _Tp;


    template<typename... _Bn>
      auto __or_fn(int) -> __first_t<false_type,
         __enable_if_t<!bool(_Bn::value)>...>;

    template<typename... _Bn>
      auto __or_fn(...) -> true_type;

    template<typename... _Bn>
      auto __and_fn(int) -> __first_t<true_type,
          __enable_if_t<bool(_Bn::value)>...>;

    template<typename... _Bn>
      auto __and_fn(...) -> false_type;
  }




  template<typename... _Bn>
    struct __or_
    : decltype(__detail::__or_fn<_Bn...>(0))
    { };

  template<typename... _Bn>
    struct __and_
    : decltype(__detail::__and_fn<_Bn...>(0))
    { };

  template<typename _Pp>
    struct __not_
    : __bool_constant<!bool(_Pp::value)>
    { };





  template<typename... _Bn>
    inline constexpr bool __or_v = __or_<_Bn...>::value;
  template<typename... _Bn>
    inline constexpr bool __and_v = __and_<_Bn...>::value;

  namespace __detail
  {
    template<typename , typename _B1, typename... _Bn>
      struct __disjunction_impl
      { using type = _B1; };

    template<typename _B1, typename _B2, typename... _Bn>
      struct __disjunction_impl<__enable_if_t<!bool(_B1::value)>, _B1, _B2, _Bn...>
      { using type = typename __disjunction_impl<void, _B2, _Bn...>::type; };

    template<typename , typename _B1, typename... _Bn>
      struct __conjunction_impl
      { using type = _B1; };

    template<typename _B1, typename _B2, typename... _Bn>
      struct __conjunction_impl<__enable_if_t<bool(_B1::value)>, _B1, _B2, _Bn...>
      { using type = typename __conjunction_impl<void, _B2, _Bn...>::type; };
  }


  template<typename... _Bn>
    struct conjunction
    : __detail::__conjunction_impl<void, _Bn...>::type
    { };

  template<>
    struct conjunction<>
    : true_type
    { };

  template<typename... _Bn>
    struct disjunction
    : __detail::__disjunction_impl<void, _Bn...>::type
    { };

  template<>
    struct disjunction<>
    : false_type
    { };

  template<typename _Pp>
    struct negation
    : __not_<_Pp>::type
    { };




  template<typename... _Bn>
    inline constexpr bool conjunction_v = conjunction<_Bn...>::value;

  template<typename... _Bn>
    inline constexpr bool disjunction_v = disjunction<_Bn...>::value;

  template<typename _Pp>
    inline constexpr bool negation_v = negation<_Pp>::value;





  template<typename>
    struct is_reference;
  template<typename>
    struct is_function;
  template<typename>
    struct is_void;
  template<typename>
    struct remove_cv;
  template<typename>
    struct is_const;


  template<typename>
    struct __is_array_unknown_bounds;




  template <typename _Tp, size_t = sizeof(_Tp)>
    constexpr true_type __is_complete_or_unbounded(__type_identity<_Tp>)
    { return {}; }

  template <typename _TypeIdentity,
      typename _NestedType = typename _TypeIdentity::type>
    constexpr typename __or_<
      is_reference<_NestedType>,
      is_function<_NestedType>,
      is_void<_NestedType>,
      __is_array_unknown_bounds<_NestedType>
    >::type __is_complete_or_unbounded(_TypeIdentity)
    { return {}; }


  template<typename _Tp>
    using __remove_cv_t = typename remove_cv<_Tp>::type;





  template<typename _Tp>
    struct is_void
    : public false_type { };

  template<>
    struct is_void<void>
    : public true_type { };

  template<>
    struct is_void<const void>
    : public true_type { };

  template<>
    struct is_void<volatile void>
    : public true_type { };

  template<>
    struct is_void<const volatile void>
    : public true_type { };


  template<typename>
    struct __is_integral_helper
    : public false_type { };

  template<>
    struct __is_integral_helper<bool>
    : public true_type { };

  template<>
    struct __is_integral_helper<char>
    : public true_type { };

  template<>
    struct __is_integral_helper<signed char>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned char>
    : public true_type { };




  template<>
    struct __is_integral_helper<wchar_t>
    : public true_type { };


  template<>
    struct __is_integral_helper<char8_t>
    : public true_type { };


  template<>
    struct __is_integral_helper<char16_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<char32_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<short>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned short>
    : public true_type { };

  template<>
    struct __is_integral_helper<int>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned int>
    : public true_type { };

  template<>
    struct __is_integral_helper<long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long>
    : public true_type { };

  template<>
    struct __is_integral_helper<long long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long long>
    : public true_type { };




  __extension__
  template<>
    struct __is_integral_helper<__int128>
    : public true_type { };

  __extension__
  template<>
    struct __is_integral_helper<unsigned __int128>
    : public true_type { };
# 460 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _Tp>
    struct is_integral
    : public __is_integral_helper<__remove_cv_t<_Tp>>::type
    { };


  template<typename>
    struct __is_floating_point_helper
    : public false_type { };

  template<>
    struct __is_floating_point_helper<float>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<double>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<long double>
    : public true_type { };
# 513 "/usr/include/c++/14.2.1/type_traits" 3
  template<>
    struct __is_floating_point_helper<__float128>
    : public true_type { };




  template<typename _Tp>
    struct is_floating_point
    : public __is_floating_point_helper<__remove_cv_t<_Tp>>::type
    { };



  template<typename _Tp>
    struct is_array
    : public __bool_constant<__is_array(_Tp)>
    { };
# 545 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename>
    struct __is_pointer_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_pointer_helper<_Tp*>
    : public true_type { };


  template<typename _Tp>
    struct is_pointer
    : public __is_pointer_helper<__remove_cv_t<_Tp>>::type
    { };


  template<typename>
    struct is_lvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_lvalue_reference<_Tp&>
    : public true_type { };


  template<typename>
    struct is_rvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_rvalue_reference<_Tp&&>
    : public true_type { };



  template<typename _Tp>
    struct is_member_object_pointer
    : public __bool_constant<__is_member_object_pointer(_Tp)>
    { };
# 601 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _Tp>
    struct is_member_function_pointer
    : public __bool_constant<__is_member_function_pointer(_Tp)>
    { };
# 622 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _Tp>
    struct is_enum
    : public __bool_constant<__is_enum(_Tp)>
    { };


  template<typename _Tp>
    struct is_union
    : public __bool_constant<__is_union(_Tp)>
    { };


  template<typename _Tp>
    struct is_class
    : public __bool_constant<__is_class(_Tp)>
    { };



  template<typename _Tp>
    struct is_function
    : public __bool_constant<__is_function(_Tp)>
    { };
# 661 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _Tp>
    struct is_null_pointer
    : public false_type { };

  template<>
    struct is_null_pointer<std::nullptr_t>
    : public true_type { };

  template<>
    struct is_null_pointer<const std::nullptr_t>
    : public true_type { };

  template<>
    struct is_null_pointer<volatile std::nullptr_t>
    : public true_type { };

  template<>
    struct is_null_pointer<const volatile std::nullptr_t>
    : public true_type { };



  template<typename _Tp>
    struct __is_nullptr_t
    : public is_null_pointer<_Tp>
    { } __attribute__ ((__deprecated__ ("use '" "std::is_null_pointer" "' instead")));






  template<typename _Tp>
    struct is_reference
    : public __bool_constant<__is_reference(_Tp)>
    { };
# 715 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _Tp>
    struct is_arithmetic
    : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_fundamental
    : public __or_<is_arithmetic<_Tp>, is_void<_Tp>,
     is_null_pointer<_Tp>>::type
    { };



  template<typename _Tp>
    struct is_object
    : public __bool_constant<__is_object(_Tp)>
    { };
# 741 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename>
    struct is_member_pointer;


  template<typename _Tp>
    struct is_scalar
    : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>,
                   is_member_pointer<_Tp>, is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_compound
    : public __bool_constant<!is_fundamental<_Tp>::value> { };



  template<typename _Tp>
    struct is_member_pointer
    : public __bool_constant<__is_member_pointer(_Tp)>
    { };
# 779 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename, typename>
    struct is_same;


  template<typename _Tp, typename... _Types>
    using __is_one_of = __or_<is_same<_Tp, _Types>...>;


  __extension__
  template<typename _Tp>
    using __is_signed_integer = __is_one_of<__remove_cv_t<_Tp>,
   signed char, signed short, signed int, signed long,
   signed long long

   , signed __int128
# 804 "/usr/include/c++/14.2.1/type_traits" 3
   >;


  __extension__
  template<typename _Tp>
    using __is_unsigned_integer = __is_one_of<__remove_cv_t<_Tp>,
   unsigned char, unsigned short, unsigned int, unsigned long,
   unsigned long long

   , unsigned __int128
# 824 "/usr/include/c++/14.2.1/type_traits" 3
   >;


  template<typename _Tp>
    using __is_standard_integer
      = __or_<__is_signed_integer<_Tp>, __is_unsigned_integer<_Tp>>;


  template<typename...> using __void_t = void;





  template<typename>
    struct is_const
    : public false_type { };

  template<typename _Tp>
    struct is_const<_Tp const>
    : public true_type { };


  template<typename>
    struct is_volatile
    : public false_type { };

  template<typename _Tp>
    struct is_volatile<_Tp volatile>
    : public true_type { };


  template<typename _Tp>
    struct is_trivial
    : public __bool_constant<__is_trivial(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_copyable
    : public __bool_constant<__is_trivially_copyable(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_standard_layout
    : public __bool_constant<__is_standard_layout(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };






  template<typename _Tp>
    struct
    __attribute__ ((__deprecated__ ("use '" "is_standard_layout && is_trivial" "' instead")))
    is_pod
    : public __bool_constant<__is_pod(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };





  template<typename _Tp>
    struct
    [[__deprecated__]]
    is_literal_type
    : public __bool_constant<__is_literal_type(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_empty
    : public __bool_constant<__is_empty(_Tp)>
    { };


  template<typename _Tp>
    struct is_polymorphic
    : public __bool_constant<__is_polymorphic(_Tp)>
    { };




  template<typename _Tp>
    struct is_final
    : public __bool_constant<__is_final(_Tp)>
    { };



  template<typename _Tp>
    struct is_abstract
    : public __bool_constant<__is_abstract(_Tp)>
    { };


  template<typename _Tp,
    bool = is_arithmetic<_Tp>::value>
    struct __is_signed_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_signed_helper<_Tp, true>
    : public __bool_constant<_Tp(-1) < _Tp(0)>
    { };



  template<typename _Tp>
    struct is_signed
    : public __is_signed_helper<_Tp>::type
    { };


  template<typename _Tp>
    struct is_unsigned
    : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>::type
    { };


  template<typename _Tp, typename _Up = _Tp&&>
    _Up
    __declval(int);

  template<typename _Tp>
    _Tp
    __declval(long);


  template<typename _Tp>
    auto declval() noexcept -> decltype(__declval<_Tp>(0));

  template<typename>
    struct remove_all_extents;


  template<typename _Tp>
    struct __is_array_known_bounds
    : public false_type
    { };

  template<typename _Tp, size_t _Size>
    struct __is_array_known_bounds<_Tp[_Size]>
    : public true_type
    { };

  template<typename _Tp>
    struct __is_array_unknown_bounds
    : public false_type
    { };

  template<typename _Tp>
    struct __is_array_unknown_bounds<_Tp[]>
    : public true_type
    { };
# 1006 "/usr/include/c++/14.2.1/type_traits" 3
  struct __do_is_destructible_impl
  {
    template<typename _Tp, typename = decltype(declval<_Tp&>().~_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_destructible_impl
    : public __do_is_destructible_impl
    {
      using type = decltype(__test<_Tp>(0));
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_destructible_safe;

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, false>
    : public __is_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, true>
    : public true_type { };



  template<typename _Tp>
    struct is_destructible
    : public __is_destructible_safe<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };







  struct __do_is_nt_destructible_impl
  {
    template<typename _Tp>
      static __bool_constant<noexcept(declval<_Tp&>().~_Tp())>
      __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_nt_destructible_impl
    : public __do_is_nt_destructible_impl
    {
      using type = decltype(__test<_Tp>(0));
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_nt_destructible_safe;

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, false>
    : public __is_nt_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, true>
    : public true_type { };



  template<typename _Tp>
    struct is_nothrow_destructible
    : public __is_nt_destructible_safe<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename... _Args>
    using __is_constructible_impl
      = __bool_constant<__is_constructible(_Tp, _Args...)>;



  template<typename _Tp, typename... _Args>
    struct is_constructible
      : public __is_constructible_impl<_Tp, _Args...>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_default_constructible
    : public __is_constructible_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename = void>
    struct __add_lvalue_reference_helper
    { using type = _Tp; };

  template<typename _Tp>
    struct __add_lvalue_reference_helper<_Tp, __void_t<_Tp&>>
    { using type = _Tp&; };

  template<typename _Tp>
    using __add_lval_ref_t = typename __add_lvalue_reference_helper<_Tp>::type;



  template<typename _Tp>
    struct is_copy_constructible
    : public __is_constructible_impl<_Tp, __add_lval_ref_t<const _Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename = void>
    struct __add_rvalue_reference_helper
    { using type = _Tp; };

  template<typename _Tp>
    struct __add_rvalue_reference_helper<_Tp, __void_t<_Tp&&>>
    { using type = _Tp&&; };

  template<typename _Tp>
    using __add_rval_ref_t = typename __add_rvalue_reference_helper<_Tp>::type;



  template<typename _Tp>
    struct is_move_constructible
    : public __is_constructible_impl<_Tp, __add_rval_ref_t<_Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename... _Args>
    using __is_nothrow_constructible_impl
      = __bool_constant<__is_nothrow_constructible(_Tp, _Args...)>;



  template<typename _Tp, typename... _Args>
    struct is_nothrow_constructible
    : public __is_nothrow_constructible_impl<_Tp, _Args...>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_nothrow_default_constructible
    : public __is_nothrow_constructible_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_nothrow_copy_constructible
    : public __is_nothrow_constructible_impl<_Tp, __add_lval_ref_t<const _Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_nothrow_move_constructible
    : public __is_nothrow_constructible_impl<_Tp, __add_rval_ref_t<_Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename _Up>
    using __is_assignable_impl = __bool_constant<__is_assignable(_Tp, _Up)>;



  template<typename _Tp, typename _Up>
    struct is_assignable
    : public __is_assignable_impl<_Tp, _Up>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_copy_assignable
    : public __is_assignable_impl<__add_lval_ref_t<_Tp>,
      __add_lval_ref_t<const _Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_move_assignable
    : public __is_assignable_impl<__add_lval_ref_t<_Tp>, __add_rval_ref_t<_Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename _Up>
    using __is_nothrow_assignable_impl
      = __bool_constant<__is_nothrow_assignable(_Tp, _Up)>;



  template<typename _Tp, typename _Up>
    struct is_nothrow_assignable
    : public __is_nothrow_assignable_impl<_Tp, _Up>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_nothrow_copy_assignable
    : public __is_nothrow_assignable_impl<__add_lval_ref_t<_Tp>,
       __add_lval_ref_t<const _Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_nothrow_move_assignable
    : public __is_nothrow_assignable_impl<__add_lval_ref_t<_Tp>,
       __add_rval_ref_t<_Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename... _Args>
    using __is_trivially_constructible_impl
      = __bool_constant<__is_trivially_constructible(_Tp, _Args...)>;



  template<typename _Tp, typename... _Args>
    struct is_trivially_constructible
    : public __is_trivially_constructible_impl<_Tp, _Args...>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_default_constructible
    : public __is_trivially_constructible_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    constexpr bool __is_implicitly_default_constructible_v
      = requires (void(&__f)(_Tp)) { __f({}); };

  template<typename _Tp>
    struct __is_implicitly_default_constructible
    : __bool_constant<__is_implicitly_default_constructible_v<_Tp>>
    { };
# 1351 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _Tp>
    struct is_trivially_copy_constructible
    : public __is_trivially_constructible_impl<_Tp, __add_lval_ref_t<const _Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_move_constructible
    : public __is_trivially_constructible_impl<_Tp, __add_rval_ref_t<_Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename _Up>
    using __is_trivially_assignable_impl
      = __bool_constant<__is_trivially_assignable(_Tp, _Up)>;



  template<typename _Tp, typename _Up>
    struct is_trivially_assignable
    : public __is_trivially_assignable_impl<_Tp, _Up>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_copy_assignable
    : public __is_trivially_assignable_impl<__add_lval_ref_t<_Tp>,
         __add_lval_ref_t<const _Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_move_assignable
    : public __is_trivially_assignable_impl<__add_lval_ref_t<_Tp>,
         __add_rval_ref_t<_Tp>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_destructible
    : public __and_<__is_destructible_safe<_Tp>,
      __bool_constant<__has_trivial_destructor(_Tp)>>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };



  template<typename _Tp>
    struct has_virtual_destructor
    : public __bool_constant<__has_virtual_destructor(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };





  template<typename _Tp>
    struct alignment_of
    : public integral_constant<std::size_t, alignof(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename>
    struct rank
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, std::size_t _Size>
    struct rank<_Tp[_Size]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };

  template<typename _Tp>
    struct rank<_Tp[]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };


  template<typename, unsigned _Uint = 0>
    struct extent
    : public integral_constant<size_t, 0> { };

  template<typename _Tp, size_t _Size>
    struct extent<_Tp[_Size], 0>
    : public integral_constant<size_t, _Size> { };

  template<typename _Tp, unsigned _Uint, size_t _Size>
    struct extent<_Tp[_Size], _Uint>
    : public extent<_Tp, _Uint - 1>::type { };

  template<typename _Tp>
    struct extent<_Tp[], 0>
    : public integral_constant<size_t, 0> { };

  template<typename _Tp, unsigned _Uint>
    struct extent<_Tp[], _Uint>
    : public extent<_Tp, _Uint - 1>::type { };






  template<typename _Tp, typename _Up>
    struct is_same
    : public __bool_constant<__is_same(_Tp, _Up)>
    { };
# 1491 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _Base, typename _Derived>
    struct is_base_of
    : public __bool_constant<__is_base_of(_Base, _Derived)>
    { };


  template<typename _From, typename _To>
    struct is_convertible
    : public __bool_constant<__is_convertible(_From, _To)>
    { };
# 1540 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _ToElementType, typename _FromElementType>
    using __is_array_convertible
      = is_convertible<_FromElementType(*)[], _ToElementType(*)[]>;





  template<typename _From, typename _To>
    inline constexpr bool is_nothrow_convertible_v
      = __is_nothrow_convertible(_From, _To);


  template<typename _From, typename _To>
    struct is_nothrow_convertible
    : public bool_constant<is_nothrow_convertible_v<_From, _To>>
    { };
# 1603 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _Tp>
    struct remove_const
    { using type = _Tp; };

  template<typename _Tp>
    struct remove_const<_Tp const>
    { using type = _Tp; };


  template<typename _Tp>
    struct remove_volatile
    { using type = _Tp; };

  template<typename _Tp>
    struct remove_volatile<_Tp volatile>
    { using type = _Tp; };



  template<typename _Tp>
    struct remove_cv
    { using type = __remove_cv(_Tp); };
# 1644 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _Tp>
    struct add_const
    { using type = _Tp const; };


  template<typename _Tp>
    struct add_volatile
    { using type = _Tp volatile; };


  template<typename _Tp>
    struct add_cv
    { using type = _Tp const volatile; };



  template<typename _Tp>
    using remove_const_t = typename remove_const<_Tp>::type;


  template<typename _Tp>
    using remove_volatile_t = typename remove_volatile<_Tp>::type;


  template<typename _Tp>
    using remove_cv_t = typename remove_cv<_Tp>::type;


  template<typename _Tp>
    using add_const_t = typename add_const<_Tp>::type;


  template<typename _Tp>
    using add_volatile_t = typename add_volatile<_Tp>::type;


  template<typename _Tp>
    using add_cv_t = typename add_cv<_Tp>::type;






  template<typename _Tp>
    struct remove_reference
    { using type = __remove_reference(_Tp); };
# 1706 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _Tp>
    struct add_lvalue_reference
    { using type = __add_lval_ref_t<_Tp>; };


  template<typename _Tp>
    struct add_rvalue_reference
    { using type = __add_rval_ref_t<_Tp>; };



  template<typename _Tp>
    using remove_reference_t = typename remove_reference<_Tp>::type;


  template<typename _Tp>
    using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;


  template<typename _Tp>
    using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;







  template<typename _Unqualified, bool _IsConst, bool _IsVol>
    struct __cv_selector;

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, false>
    { using __type = _Unqualified; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, true>
    { using __type = volatile _Unqualified; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, false>
    { using __type = const _Unqualified; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, true>
    { using __type = const volatile _Unqualified; };

  template<typename _Qualified, typename _Unqualified,
    bool _IsConst = is_const<_Qualified>::value,
    bool _IsVol = is_volatile<_Qualified>::value>
    class __match_cv_qualifiers
    {
      using __match = __cv_selector<_Unqualified, _IsConst, _IsVol>;

    public:
      using __type = typename __match::__type;
    };


  template<typename _Tp>
    struct __make_unsigned
    { using __type = _Tp; };

  template<>
    struct __make_unsigned<char>
    { using __type = unsigned char; };

  template<>
    struct __make_unsigned<signed char>
    { using __type = unsigned char; };

  template<>
    struct __make_unsigned<short>
    { using __type = unsigned short; };

  template<>
    struct __make_unsigned<int>
    { using __type = unsigned int; };

  template<>
    struct __make_unsigned<long>
    { using __type = unsigned long; };

  template<>
    struct __make_unsigned<long long>
    { using __type = unsigned long long; };


  __extension__
  template<>
    struct __make_unsigned<__int128>
    { using __type = unsigned __int128; };
# 1819 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = __is_enum(_Tp)>
    class __make_unsigned_selector;

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, true, false>
    {
      using __unsigned_type
 = typename __make_unsigned<__remove_cv_t<_Tp>>::__type;

    public:
      using __type
 = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
    };

  class __make_unsigned_selector_base
  {
  protected:
    template<typename...> struct _List { };

    template<typename _Tp, typename... _Up>
      struct _List<_Tp, _Up...> : _List<_Up...>
      { static constexpr size_t __size = sizeof(_Tp); };

    template<size_t _Sz, typename _Tp, bool = (_Sz <= _Tp::__size)>
      struct __select;

    template<size_t _Sz, typename _Uint, typename... _UInts>
      struct __select<_Sz, _List<_Uint, _UInts...>, true>
      { using __type = _Uint; };

    template<size_t _Sz, typename _Uint, typename... _UInts>
      struct __select<_Sz, _List<_Uint, _UInts...>, false>
      : __select<_Sz, _List<_UInts...>>
      { };
  };


  template<typename _Tp>
    class __make_unsigned_selector<_Tp, false, true>
    : __make_unsigned_selector_base
    {

      using _UInts = _List<unsigned char, unsigned short, unsigned int,
      unsigned long, unsigned long long>;

      using __unsigned_type = typename __select<sizeof(_Tp), _UInts>::__type;

    public:
      using __type
 = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
    };





  template<>
    struct __make_unsigned<wchar_t>
    {
      using __type
 = typename __make_unsigned_selector<wchar_t, false, true>::__type;
    };


  template<>
    struct __make_unsigned<char8_t>
    {
      using __type
 = typename __make_unsigned_selector<char8_t, false, true>::__type;
    };


  template<>
    struct __make_unsigned<char16_t>
    {
      using __type
 = typename __make_unsigned_selector<char16_t, false, true>::__type;
    };

  template<>
    struct __make_unsigned<char32_t>
    {
      using __type
 = typename __make_unsigned_selector<char32_t, false, true>::__type;
    };






  template<typename _Tp>
    struct make_unsigned
    { using type = typename __make_unsigned_selector<_Tp>::__type; };


  template<> struct make_unsigned<bool>;
  template<> struct make_unsigned<bool const>;
  template<> struct make_unsigned<bool volatile>;
  template<> struct make_unsigned<bool const volatile>;




  template<typename _Tp>
    struct __make_signed
    { using __type = _Tp; };

  template<>
    struct __make_signed<char>
    { using __type = signed char; };

  template<>
    struct __make_signed<unsigned char>
    { using __type = signed char; };

  template<>
    struct __make_signed<unsigned short>
    { using __type = signed short; };

  template<>
    struct __make_signed<unsigned int>
    { using __type = signed int; };

  template<>
    struct __make_signed<unsigned long>
    { using __type = signed long; };

  template<>
    struct __make_signed<unsigned long long>
    { using __type = signed long long; };


  __extension__
  template<>
    struct __make_signed<unsigned __int128>
    { using __type = __int128; };
# 1979 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = __is_enum(_Tp)>
    class __make_signed_selector;

  template<typename _Tp>
    class __make_signed_selector<_Tp, true, false>
    {
      using __signed_type
 = typename __make_signed<__remove_cv_t<_Tp>>::__type;

    public:
      using __type
 = typename __match_cv_qualifiers<_Tp, __signed_type>::__type;
    };


  template<typename _Tp>
    class __make_signed_selector<_Tp, false, true>
    {
      using __unsigned_type = typename __make_unsigned_selector<_Tp>::__type;

    public:
      using __type = typename __make_signed_selector<__unsigned_type>::__type;
    };





  template<>
    struct __make_signed<wchar_t>
    {
      using __type
 = typename __make_signed_selector<wchar_t, false, true>::__type;
    };


  template<>
    struct __make_signed<char8_t>
    {
      using __type
 = typename __make_signed_selector<char8_t, false, true>::__type;
    };


  template<>
    struct __make_signed<char16_t>
    {
      using __type
 = typename __make_signed_selector<char16_t, false, true>::__type;
    };

  template<>
    struct __make_signed<char32_t>
    {
      using __type
 = typename __make_signed_selector<char32_t, false, true>::__type;
    };






  template<typename _Tp>
    struct make_signed
    { using type = typename __make_signed_selector<_Tp>::__type; };


  template<> struct make_signed<bool>;
  template<> struct make_signed<bool const>;
  template<> struct make_signed<bool volatile>;
  template<> struct make_signed<bool const volatile>;



  template<typename _Tp>
    using make_signed_t = typename make_signed<_Tp>::type;


  template<typename _Tp>
    using make_unsigned_t = typename make_unsigned<_Tp>::type;





  template<typename _Tp>
    struct remove_extent
    { using type = _Tp; };

  template<typename _Tp, std::size_t _Size>
    struct remove_extent<_Tp[_Size]>
    { using type = _Tp; };

  template<typename _Tp>
    struct remove_extent<_Tp[]>
    { using type = _Tp; };


  template<typename _Tp>
    struct remove_all_extents
    { using type = _Tp; };

  template<typename _Tp, std::size_t _Size>
    struct remove_all_extents<_Tp[_Size]>
    { using type = typename remove_all_extents<_Tp>::type; };

  template<typename _Tp>
    struct remove_all_extents<_Tp[]>
    { using type = typename remove_all_extents<_Tp>::type; };



  template<typename _Tp>
    using remove_extent_t = typename remove_extent<_Tp>::type;


  template<typename _Tp>
    using remove_all_extents_t = typename remove_all_extents<_Tp>::type;






  template<typename _Tp>
    struct remove_pointer
    { using type = __remove_pointer(_Tp); };
# 2124 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _Tp, typename = void>
    struct __add_pointer_helper
    { using type = _Tp; };

  template<typename _Tp>
    struct __add_pointer_helper<_Tp, __void_t<_Tp*>>
    { using type = _Tp*; };


  template<typename _Tp>
    struct add_pointer
    : public __add_pointer_helper<_Tp>
    { };

  template<typename _Tp>
    struct add_pointer<_Tp&>
    { using type = _Tp*; };

  template<typename _Tp>
    struct add_pointer<_Tp&&>
    { using type = _Tp*; };



  template<typename _Tp>
    using remove_pointer_t = typename remove_pointer<_Tp>::type;


  template<typename _Tp>
    using add_pointer_t = typename add_pointer<_Tp>::type;


  template<std::size_t _Len>
    struct __aligned_storage_msa
    {
      union __type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__)) { } __align;
      };
    };
# 2179 "/usr/include/c++/14.2.1/type_traits" 3
  template<std::size_t _Len, std::size_t _Align =
    __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    struct
   
    aligned_storage
    {
      union type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__((_Align)))) { } __align;
      };
    };

  template <typename... _Types>
    struct __strictest_alignment
    {
      static const size_t _S_alignment = 0;
      static const size_t _S_size = 0;
    };

  template <typename _Tp, typename... _Types>
    struct __strictest_alignment<_Tp, _Types...>
    {
      static const size_t _S_alignment =
        alignof(_Tp) > __strictest_alignment<_Types...>::_S_alignment
 ? alignof(_Tp) : __strictest_alignment<_Types...>::_S_alignment;
      static const size_t _S_size =
        sizeof(_Tp) > __strictest_alignment<_Types...>::_S_size
 ? sizeof(_Tp) : __strictest_alignment<_Types...>::_S_size;
    };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
# 2225 "/usr/include/c++/14.2.1/type_traits" 3
  template <size_t _Len, typename... _Types>
    struct
   
    aligned_union
    {
    private:
      static_assert(sizeof...(_Types) != 0, "At least one type is required");

      using __strictest = __strictest_alignment<_Types...>;
      static const size_t _S_len = _Len > __strictest::_S_size
 ? _Len : __strictest::_S_size;
    public:

      static const size_t alignment_value = __strictest::_S_alignment;

      using type = typename aligned_storage<_S_len, alignment_value>::type;
    };

  template <size_t _Len, typename... _Types>
    const size_t aligned_union<_Len, _Types...>::alignment_value;
#pragma GCC diagnostic pop





  template<typename _Up>
    struct __decay_selector
    : __conditional_t<is_const<const _Up>::value,
        remove_cv<_Up>,
        add_pointer<_Up>>
    { };

  template<typename _Up, size_t _Nm>
    struct __decay_selector<_Up[_Nm]>
    { using type = _Up*; };

  template<typename _Up>
    struct __decay_selector<_Up[]>
    { using type = _Up*; };




  template<typename _Tp>
    struct decay
    { using type = typename __decay_selector<_Tp>::type; };

  template<typename _Tp>
    struct decay<_Tp&>
    { using type = typename __decay_selector<_Tp>::type; };

  template<typename _Tp>
    struct decay<_Tp&&>
    { using type = typename __decay_selector<_Tp>::type; };




  template<typename _Tp>
    struct __strip_reference_wrapper
    {
      using __type = _Tp;
    };

  template<typename _Tp>
    struct __strip_reference_wrapper<reference_wrapper<_Tp> >
    {
      using __type = _Tp&;
    };


  template<typename _Tp>
    using __decay_t = typename decay<_Tp>::type;

  template<typename _Tp>
    using __decay_and_strip = __strip_reference_wrapper<__decay_t<_Tp>>;





  template<typename... _Cond>
    using _Require = __enable_if_t<__and_<_Cond...>::value>;


  template<typename _Tp>
    using __remove_cvref_t
     = typename remove_cv<typename remove_reference<_Tp>::type>::type;




  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct conditional
    { using type = _Iftrue; };


  template<typename _Iftrue, typename _Iffalse>
    struct conditional<false, _Iftrue, _Iffalse>
    { using type = _Iffalse; };


  template<typename... _Tp>
    struct common_type;
# 2340 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _Tp>
    struct __success_type
    { using type = _Tp; };

  struct __failure_type
  { };

  struct __do_common_type_impl
  {
    template<typename _Tp, typename _Up>
      using __cond_t
 = decltype(true ? std::declval<_Tp>() : std::declval<_Up>());



    template<typename _Tp, typename _Up>
      static __success_type<__decay_t<__cond_t<_Tp, _Up>>>
      _S_test(int);




    template<typename _Tp, typename _Up>
      static __success_type<__remove_cvref_t<__cond_t<const _Tp&, const _Up&>>>
      _S_test_2(int);


    template<typename, typename>
      static __failure_type
      _S_test_2(...);

    template<typename _Tp, typename _Up>
      static decltype(_S_test_2<_Tp, _Up>(0))
      _S_test(...);
  };


  template<>
    struct common_type<>
    { };


  template<typename _Tp0>
    struct common_type<_Tp0>
    : public common_type<_Tp0, _Tp0>
    { };


  template<typename _Tp1, typename _Tp2,
    typename _Dp1 = __decay_t<_Tp1>, typename _Dp2 = __decay_t<_Tp2>>
    struct __common_type_impl
    {


      using type = common_type<_Dp1, _Dp2>;
    };

  template<typename _Tp1, typename _Tp2>
    struct __common_type_impl<_Tp1, _Tp2, _Tp1, _Tp2>
    : private __do_common_type_impl
    {


      using type = decltype(_S_test<_Tp1, _Tp2>(0));
    };


  template<typename _Tp1, typename _Tp2>
    struct common_type<_Tp1, _Tp2>
    : public __common_type_impl<_Tp1, _Tp2>::type
    { };

  template<typename...>
    struct __common_type_pack
    { };

  template<typename, typename, typename = void>
    struct __common_type_fold;


  template<typename _Tp1, typename _Tp2, typename... _Rp>
    struct common_type<_Tp1, _Tp2, _Rp...>
    : public __common_type_fold<common_type<_Tp1, _Tp2>,
    __common_type_pack<_Rp...>>
    { };




  template<typename _CTp, typename... _Rp>
    struct __common_type_fold<_CTp, __common_type_pack<_Rp...>,
         __void_t<typename _CTp::type>>
    : public common_type<typename _CTp::type, _Rp...>
    { };


  template<typename _CTp, typename _Rp>
    struct __common_type_fold<_CTp, _Rp, void>
    { };

  template<typename _Tp, bool = __is_enum(_Tp)>
    struct __underlying_type_impl
    {
      using type = __underlying_type(_Tp);
    };

  template<typename _Tp>
    struct __underlying_type_impl<_Tp, false>
    { };



  template<typename _Tp>
    struct underlying_type
    : public __underlying_type_impl<_Tp>
    { };


  template<typename _Tp>
    struct __declval_protector
    {
      static const bool __stop = false;
    };






  template<typename _Tp>
    auto declval() noexcept -> decltype(__declval<_Tp>(0))
    {
      static_assert(__declval_protector<_Tp>::__stop,
      "declval() must not be used!");
      return __declval<_Tp>(0);
    }


  template<typename _Signature>
    struct result_of;




  struct __invoke_memfun_ref { };
  struct __invoke_memfun_deref { };
  struct __invoke_memobj_ref { };
  struct __invoke_memobj_deref { };
  struct __invoke_other { };


  template<typename _Tp, typename _Tag>
    struct __result_of_success : __success_type<_Tp>
    { using __invoke_type = _Tag; };


  struct __result_of_memfun_ref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      (std::declval<_Tp1>().*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_ref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_ref
    : private __result_of_memfun_ref_impl
    {
      using type = decltype(_S_test<_MemPtr, _Arg, _Args...>(0));
    };


  struct __result_of_memfun_deref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      ((*std::declval<_Tp1>()).*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_deref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_deref
    : private __result_of_memfun_deref_impl
    {
      using type = decltype(_S_test<_MemPtr, _Arg, _Args...>(0));
    };


  struct __result_of_memobj_ref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      std::declval<_Tp1>().*std::declval<_Fp>()
      ), __invoke_memobj_ref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_ref
    : private __result_of_memobj_ref_impl
    {
      using type = decltype(_S_test<_MemPtr, _Arg>(0));
    };


  struct __result_of_memobj_deref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      (*std::declval<_Tp1>()).*std::declval<_Fp>()
      ), __invoke_memobj_deref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_deref
    : private __result_of_memobj_deref_impl
    {
      using type = decltype(_S_test<_MemPtr, _Arg>(0));
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj;

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, _Arg>
    {
      using _Argval = __remove_cvref_t<_Arg>;
      using _MemPtr = _Res _Class::*;
      using type = typename __conditional_t<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memobj_ref<_MemPtr, _Arg>,
        __result_of_memobj_deref<_MemPtr, _Arg>
      >::type;
    };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun;

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, _Arg, _Args...>
    {
      using _Argval = typename remove_reference<_Arg>::type;
      using _MemPtr = _Res _Class::*;
      using type = typename __conditional_t<is_base_of<_Class, _Argval>::value,
        __result_of_memfun_ref<_MemPtr, _Arg, _Args...>,
        __result_of_memfun_deref<_MemPtr, _Arg, _Args...>
      >::type;
    };






  template<typename _Tp, typename _Up = __remove_cvref_t<_Tp>>
    struct __inv_unwrap
    {
      using type = _Tp;
    };

  template<typename _Tp, typename _Up>
    struct __inv_unwrap<_Tp, reference_wrapper<_Up>>
    {
      using type = _Up&;
    };

  template<bool, bool, typename _Functor, typename... _ArgTypes>
    struct __result_of_impl
    {
      using type = __failure_type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_impl<true, false, _MemPtr, _Arg>
    : public __result_of_memobj<__decay_t<_MemPtr>,
    typename __inv_unwrap<_Arg>::type>
    { };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...>
    : public __result_of_memfun<__decay_t<_MemPtr>,
    typename __inv_unwrap<_Arg>::type, _Args...>
    { };


  struct __result_of_other_impl
  {
    template<typename _Fn, typename... _Args>
      static __result_of_success<decltype(
      std::declval<_Fn>()(std::declval<_Args>()...)
      ), __invoke_other> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _Functor, typename... _ArgTypes>
    struct __result_of_impl<false, false, _Functor, _ArgTypes...>
    : private __result_of_other_impl
    {
      using type = decltype(_S_test<_Functor, _ArgTypes...>(0));
    };


  template<typename _Functor, typename... _ArgTypes>
    struct __invoke_result
    : public __result_of_impl<
        is_member_object_pointer<
          typename remove_reference<_Functor>::type
        >::value,
        is_member_function_pointer<
          typename remove_reference<_Functor>::type
        >::value,
 _Functor, _ArgTypes...
      >::type
    { };


  template<typename _Fn, typename... _Args>
    using __invoke_result_t = typename __invoke_result<_Fn, _Args...>::type;


  template<typename _Functor, typename... _ArgTypes>
    struct result_of<_Functor(_ArgTypes...)>
    : public __invoke_result<_Functor, _ArgTypes...>
    { } __attribute__ ((__deprecated__ ("use '" "std::invoke_result" "' instead")));


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

  template<size_t _Len, size_t _Align =
     __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;

  template <size_t _Len, typename... _Types>
    using aligned_union_t = typename aligned_union<_Len, _Types...>::type;
#pragma GCC diagnostic pop


  template<typename _Tp>
    using decay_t = typename decay<_Tp>::type;


  template<bool _Cond, typename _Tp = void>
    using enable_if_t = typename enable_if<_Cond, _Tp>::type;


  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    using conditional_t = typename conditional<_Cond, _Iftrue, _Iffalse>::type;


  template<typename... _Tp>
    using common_type_t = typename common_type<_Tp...>::type;


  template<typename _Tp>
    using underlying_type_t = typename underlying_type<_Tp>::type;


  template<typename _Tp>
    using result_of_t = typename result_of<_Tp>::type;




  template<typename...> using void_t = void;
# 2727 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _Def, template<typename...> class _Op, typename... _Args>
    struct __detected_or
    {
      using type = _Def;
      using __is_detected = false_type;
    };


  template<typename _Def, template<typename...> class _Op, typename... _Args>
    requires requires { typename _Op<_Args...>; }
    struct __detected_or<_Def, _Op, _Args...>
    {
      using type = _Op<_Args...>;
      using __is_detected = true_type;
    };
# 2767 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or_t
      = typename __detected_or<_Default, _Op, _Args...>::type;
# 2786 "/usr/include/c++/14.2.1/type_traits" 3
  template <typename _Tp>
    struct __is_swappable;

  template <typename _Tp>
    struct __is_nothrow_swappable;

  template<typename>
    struct __is_tuple_like_impl : false_type
    { };


  template<typename _Tp>
    struct __is_tuple_like
    : public __is_tuple_like_impl<__remove_cvref_t<_Tp>>::type
    { };


  template<typename _Tp>
    constexpr
    inline
    _Require<__not_<__is_tuple_like<_Tp>>,
      is_move_constructible<_Tp>,
      is_move_assignable<_Tp>>
    swap(_Tp&, _Tp&)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value);

  template<typename _Tp, size_t _Nm>
    constexpr
    inline
    __enable_if_t<__is_swappable<_Tp>::value>
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value);


  namespace __swappable_details {
    using std::swap;

    struct __do_is_swappable_impl
    {
      template<typename _Tp, typename
               = decltype(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))>
        static true_type __test(int);

      template<typename>
        static false_type __test(...);
    };

    struct __do_is_nothrow_swappable_impl
    {
      template<typename _Tp>
        static __bool_constant<
          noexcept(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))
        > __test(int);

      template<typename>
        static false_type __test(...);
    };

  }

  template<typename _Tp>
    struct __is_swappable_impl
    : public __swappable_details::__do_is_swappable_impl
    {
      using type = decltype(__test<_Tp>(0));
    };

  template<typename _Tp>
    struct __is_nothrow_swappable_impl
    : public __swappable_details::__do_is_nothrow_swappable_impl
    {
      using type = decltype(__test<_Tp>(0));
    };

  template<typename _Tp>
    struct __is_swappable
    : public __is_swappable_impl<_Tp>::type
    { };

  template<typename _Tp>
    struct __is_nothrow_swappable
    : public __is_nothrow_swappable_impl<_Tp>::type
    { };






  template<typename _Tp>
    struct is_swappable
    : public __is_swappable_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_nothrow_swappable
    : public __is_nothrow_swappable_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };



  template<typename _Tp>
    inline constexpr bool is_swappable_v =
      is_swappable<_Tp>::value;


  template<typename _Tp>
    inline constexpr bool is_nothrow_swappable_v =
      is_nothrow_swappable<_Tp>::value;



  namespace __swappable_with_details {
    using std::swap;

    struct __do_is_swappable_with_impl
    {
      template<typename _Tp, typename _Up, typename
               = decltype(swap(std::declval<_Tp>(), std::declval<_Up>())),
               typename
               = decltype(swap(std::declval<_Up>(), std::declval<_Tp>()))>
        static true_type __test(int);

      template<typename, typename>
        static false_type __test(...);
    };

    struct __do_is_nothrow_swappable_with_impl
    {
      template<typename _Tp, typename _Up>
        static __bool_constant<
          noexcept(swap(std::declval<_Tp>(), std::declval<_Up>()))
          &&
          noexcept(swap(std::declval<_Up>(), std::declval<_Tp>()))
        > __test(int);

      template<typename, typename>
        static false_type __test(...);
    };

  }

  template<typename _Tp, typename _Up>
    struct __is_swappable_with_impl
    : public __swappable_with_details::__do_is_swappable_with_impl
    {
      using type = decltype(__test<_Tp, _Up>(0));
    };


  template<typename _Tp>
    struct __is_swappable_with_impl<_Tp&, _Tp&>
    : public __swappable_details::__do_is_swappable_impl
    {
      using type = decltype(__test<_Tp&>(0));
    };

  template<typename _Tp, typename _Up>
    struct __is_nothrow_swappable_with_impl
    : public __swappable_with_details::__do_is_nothrow_swappable_with_impl
    {
      using type = decltype(__test<_Tp, _Up>(0));
    };


  template<typename _Tp>
    struct __is_nothrow_swappable_with_impl<_Tp&, _Tp&>
    : public __swappable_details::__do_is_nothrow_swappable_impl
    {
      using type = decltype(__test<_Tp&>(0));
    };



  template<typename _Tp, typename _Up>
    struct is_swappable_with
    : public __is_swappable_with_impl<_Tp, _Up>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "first template argument must be a complete class or an unbounded array");
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Up>{}),
 "second template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename _Up>
    struct is_nothrow_swappable_with
    : public __is_nothrow_swappable_with_impl<_Tp, _Up>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "first template argument must be a complete class or an unbounded array");
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Up>{}),
 "second template argument must be a complete class or an unbounded array");
    };



  template<typename _Tp, typename _Up>
    inline constexpr bool is_swappable_with_v =
      is_swappable_with<_Tp, _Up>::value;


  template<typename _Tp, typename _Up>
    inline constexpr bool is_nothrow_swappable_with_v =
      is_nothrow_swappable_with<_Tp, _Up>::value;
# 3008 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _Result, typename _Ret,
    bool = is_void<_Ret>::value, typename = void>
    struct __is_invocable_impl
    : false_type
    {
      using __nothrow_conv = false_type;
    };


  template<typename _Result, typename _Ret>
    struct __is_invocable_impl<_Result, _Ret,
                                true,
          __void_t<typename _Result::type>>
    : true_type
    {
      using __nothrow_conv = true_type;
    };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"

  template<typename _Result, typename _Ret>
    struct __is_invocable_impl<_Result, _Ret,
                                false,
          __void_t<typename _Result::type>>
    {
    private:

      using _Res_t = typename _Result::type;



      static _Res_t _S_get() noexcept;


      template<typename _Tp>
 static void _S_conv(__type_identity_t<_Tp>) noexcept;


      template<typename _Tp,
        bool _Nothrow = noexcept(_S_conv<_Tp>(_S_get())),
        typename = decltype(_S_conv<_Tp>(_S_get())),

        bool _Dangle = __reference_converts_from_temporary(_Tp, _Res_t)



       >
 static __bool_constant<_Nothrow && !_Dangle>
 _S_test(int);

      template<typename _Tp, bool = false>
 static false_type
 _S_test(...);

    public:

      using type = decltype(_S_test<_Ret, true>(1));


      using __nothrow_conv = decltype(_S_test<_Ret>(1));
    };
#pragma GCC diagnostic pop

  template<typename _Fn, typename... _ArgTypes>
    struct __is_invocable
    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type
    { };

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept((std::declval<_Up>().*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_deref)
    {
      return noexcept(((*std::declval<_Tp>()).*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept(std::declval<_Up>().*std::declval<_Fn>());
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_deref)
    {
      return noexcept((*std::declval<_Tp>()).*std::declval<_Fn>());
    }

  template<typename _Fn, typename... _Args>
    constexpr bool __call_is_nt(__invoke_other)
    {
      return noexcept(std::declval<_Fn>()(std::declval<_Args>()...));
    }

  template<typename _Result, typename _Fn, typename... _Args>
    struct __call_is_nothrow
    : __bool_constant<
 std::__call_is_nt<_Fn, _Args...>(typename _Result::__invoke_type{})
      >
    { };

  template<typename _Fn, typename... _Args>
    using __call_is_nothrow_
      = __call_is_nothrow<__invoke_result<_Fn, _Args...>, _Fn, _Args...>;


  template<typename _Fn, typename... _Args>
    struct __is_nothrow_invocable
    : __and_<__is_invocable<_Fn, _Args...>,
             __call_is_nothrow_<_Fn, _Args...>>::type
    { };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"
  struct __nonesuchbase {};
  struct __nonesuch : private __nonesuchbase {
    ~__nonesuch() = delete;
    __nonesuch(__nonesuch const&) = delete;
    void operator=(__nonesuch const&) = delete;
  };
#pragma GCC diagnostic pop




  template<typename _Functor, typename... _ArgTypes>
    struct invoke_result
    : public __invoke_result<_Functor, _ArgTypes...>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Functor>{}),
 "_Functor must be a complete class or an unbounded array");
      static_assert((std::__is_complete_or_unbounded(
 __type_identity<_ArgTypes>{}) && ...),
 "each argument type must be a complete class or an unbounded array");
    };


  template<typename _Fn, typename... _Args>
    using invoke_result_t = typename invoke_result<_Fn, _Args...>::type;


  template<typename _Fn, typename... _ArgTypes>
    struct is_invocable
    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
 "_Fn must be a complete class or an unbounded array");
      static_assert((std::__is_complete_or_unbounded(
 __type_identity<_ArgTypes>{}) && ...),
 "each argument type must be a complete class or an unbounded array");
    };


  template<typename _Ret, typename _Fn, typename... _ArgTypes>
    struct is_invocable_r
    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, _Ret>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
 "_Fn must be a complete class or an unbounded array");
      static_assert((std::__is_complete_or_unbounded(
 __type_identity<_ArgTypes>{}) && ...),
 "each argument type must be a complete class or an unbounded array");
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Ret>{}),
 "_Ret must be a complete class or an unbounded array");
    };


  template<typename _Fn, typename... _ArgTypes>
    struct is_nothrow_invocable
    : __and_<__is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>,
      __call_is_nothrow_<_Fn, _ArgTypes...>>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
 "_Fn must be a complete class or an unbounded array");
      static_assert((std::__is_complete_or_unbounded(
 __type_identity<_ArgTypes>{}) && ...),
 "each argument type must be a complete class or an unbounded array");
    };





  template<typename _Result, typename _Ret>
    using __is_nt_invocable_impl
      = typename __is_invocable_impl<_Result, _Ret>::__nothrow_conv;



  template<typename _Ret, typename _Fn, typename... _ArgTypes>
    struct is_nothrow_invocable_r
    : __and_<__is_nt_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, _Ret>,
             __call_is_nothrow_<_Fn, _ArgTypes...>>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Fn>{}),
 "_Fn must be a complete class or an unbounded array");
      static_assert((std::__is_complete_or_unbounded(
 __type_identity<_ArgTypes>{}) && ...),
 "each argument type must be a complete class or an unbounded array");
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Ret>{}),
 "_Ret must be a complete class or an unbounded array");
    };
# 3236 "/usr/include/c++/14.2.1/type_traits" 3
template <typename _Tp>
  inline constexpr bool is_void_v = is_void<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_null_pointer_v = is_null_pointer<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_integral_v = is_integral<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_floating_point_v = is_floating_point<_Tp>::value;


template <typename _Tp>
  inline constexpr bool is_array_v = __is_array(_Tp);
# 3257 "/usr/include/c++/14.2.1/type_traits" 3
template <typename _Tp>
  inline constexpr bool is_pointer_v = is_pointer<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_lvalue_reference_v = false;
template <typename _Tp>
  inline constexpr bool is_lvalue_reference_v<_Tp&> = true;
template <typename _Tp>
  inline constexpr bool is_rvalue_reference_v = false;
template <typename _Tp>
  inline constexpr bool is_rvalue_reference_v<_Tp&&> = true;


template <typename _Tp>
  inline constexpr bool is_member_object_pointer_v =
    __is_member_object_pointer(_Tp);







template <typename _Tp>
  inline constexpr bool is_member_function_pointer_v =
    __is_member_function_pointer(_Tp);






template <typename _Tp>
  inline constexpr bool is_enum_v = __is_enum(_Tp);
template <typename _Tp>
  inline constexpr bool is_union_v = __is_union(_Tp);
template <typename _Tp>
  inline constexpr bool is_class_v = __is_class(_Tp);



template <typename _Tp>
  inline constexpr bool is_reference_v = __is_reference(_Tp);
# 3308 "/usr/include/c++/14.2.1/type_traits" 3
template <typename _Tp>
  inline constexpr bool is_arithmetic_v = is_arithmetic<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_fundamental_v = is_fundamental<_Tp>::value;


template <typename _Tp>
  inline constexpr bool is_object_v = __is_object(_Tp);





template <typename _Tp>
  inline constexpr bool is_scalar_v = is_scalar<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_compound_v = !is_fundamental_v<_Tp>;


template <typename _Tp>
  inline constexpr bool is_member_pointer_v = __is_member_pointer(_Tp);





template <typename _Tp>
  inline constexpr bool is_const_v = false;
template <typename _Tp>
  inline constexpr bool is_const_v<const _Tp> = true;


template <typename _Tp>
  inline constexpr bool is_function_v = __is_function(_Tp);
# 3351 "/usr/include/c++/14.2.1/type_traits" 3
template <typename _Tp>
  inline constexpr bool is_volatile_v = false;
template <typename _Tp>
  inline constexpr bool is_volatile_v<volatile _Tp> = true;

template <typename _Tp>
  inline constexpr bool is_trivial_v = __is_trivial(_Tp);
template <typename _Tp>
  inline constexpr bool is_trivially_copyable_v = __is_trivially_copyable(_Tp);
template <typename _Tp>
  inline constexpr bool is_standard_layout_v = __is_standard_layout(_Tp);
template <typename _Tp>
  __attribute__ ((__deprecated__ ("use '" "is_standard_layout_v && is_trivial_v" "' instead")))
  inline constexpr bool is_pod_v = __is_pod(_Tp);
template <typename _Tp>
  [[__deprecated__]]
  inline constexpr bool is_literal_type_v = __is_literal_type(_Tp);
template <typename _Tp>
  inline constexpr bool is_empty_v = __is_empty(_Tp);
template <typename _Tp>
  inline constexpr bool is_polymorphic_v = __is_polymorphic(_Tp);
template <typename _Tp>
  inline constexpr bool is_abstract_v = __is_abstract(_Tp);
template <typename _Tp>
  inline constexpr bool is_final_v = __is_final(_Tp);

template <typename _Tp>
  inline constexpr bool is_signed_v = is_signed<_Tp>::value;
template <typename _Tp>
  inline constexpr bool is_unsigned_v = is_unsigned<_Tp>::value;

template <typename _Tp, typename... _Args>
  inline constexpr bool is_constructible_v = __is_constructible(_Tp, _Args...);
template <typename _Tp>
  inline constexpr bool is_default_constructible_v = __is_constructible(_Tp);
template <typename _Tp>
  inline constexpr bool is_copy_constructible_v
    = __is_constructible(_Tp, __add_lval_ref_t<const _Tp>);
template <typename _Tp>
  inline constexpr bool is_move_constructible_v
    = __is_constructible(_Tp, __add_rval_ref_t<_Tp>);

template <typename _Tp, typename _Up>
  inline constexpr bool is_assignable_v = __is_assignable(_Tp, _Up);
template <typename _Tp>
  inline constexpr bool is_copy_assignable_v
    = __is_assignable(__add_lval_ref_t<_Tp>, __add_lval_ref_t<const _Tp>);
template <typename _Tp>
  inline constexpr bool is_move_assignable_v
    = __is_assignable(__add_lval_ref_t<_Tp>, __add_rval_ref_t<_Tp>);

template <typename _Tp>
  inline constexpr bool is_destructible_v = is_destructible<_Tp>::value;

template <typename _Tp, typename... _Args>
  inline constexpr bool is_trivially_constructible_v
    = __is_trivially_constructible(_Tp, _Args...);
template <typename _Tp>
  inline constexpr bool is_trivially_default_constructible_v
    = __is_trivially_constructible(_Tp);
template <typename _Tp>
  inline constexpr bool is_trivially_copy_constructible_v
    = __is_trivially_constructible(_Tp, __add_lval_ref_t<const _Tp>);
template <typename _Tp>
  inline constexpr bool is_trivially_move_constructible_v
    = __is_trivially_constructible(_Tp, __add_rval_ref_t<_Tp>);

template <typename _Tp, typename _Up>
  inline constexpr bool is_trivially_assignable_v
    = __is_trivially_assignable(_Tp, _Up);
template <typename _Tp>
  inline constexpr bool is_trivially_copy_assignable_v
    = __is_trivially_assignable(__add_lval_ref_t<_Tp>,
    __add_lval_ref_t<const _Tp>);
template <typename _Tp>
  inline constexpr bool is_trivially_move_assignable_v
    = __is_trivially_assignable(__add_lval_ref_t<_Tp>,
    __add_rval_ref_t<_Tp>);


template <typename _Tp>
  inline constexpr bool is_trivially_destructible_v = false;

template <typename _Tp>
  requires (!is_reference_v<_Tp>) && requires (_Tp& __t) { __t.~_Tp(); }
  inline constexpr bool is_trivially_destructible_v<_Tp>
    = __has_trivial_destructor(_Tp);
template <typename _Tp>
  inline constexpr bool is_trivially_destructible_v<_Tp&> = true;
template <typename _Tp>
  inline constexpr bool is_trivially_destructible_v<_Tp&&> = true;
template <typename _Tp, size_t _Nm>
  inline constexpr bool is_trivially_destructible_v<_Tp[_Nm]>
    = is_trivially_destructible_v<_Tp>;






template <typename _Tp, typename... _Args>
  inline constexpr bool is_nothrow_constructible_v
    = __is_nothrow_constructible(_Tp, _Args...);
template <typename _Tp>
  inline constexpr bool is_nothrow_default_constructible_v
    = __is_nothrow_constructible(_Tp);
template <typename _Tp>
  inline constexpr bool is_nothrow_copy_constructible_v
    = __is_nothrow_constructible(_Tp, __add_lval_ref_t<const _Tp>);
template <typename _Tp>
  inline constexpr bool is_nothrow_move_constructible_v
    = __is_nothrow_constructible(_Tp, __add_rval_ref_t<_Tp>);

template <typename _Tp, typename _Up>
  inline constexpr bool is_nothrow_assignable_v
    = __is_nothrow_assignable(_Tp, _Up);
template <typename _Tp>
  inline constexpr bool is_nothrow_copy_assignable_v
    = __is_nothrow_assignable(__add_lval_ref_t<_Tp>,
         __add_lval_ref_t<const _Tp>);
template <typename _Tp>
  inline constexpr bool is_nothrow_move_assignable_v
    = __is_nothrow_assignable(__add_lval_ref_t<_Tp>, __add_rval_ref_t<_Tp>);

template <typename _Tp>
  inline constexpr bool is_nothrow_destructible_v =
    is_nothrow_destructible<_Tp>::value;

template <typename _Tp>
  inline constexpr bool has_virtual_destructor_v
    = __has_virtual_destructor(_Tp);

template <typename _Tp>
  inline constexpr size_t alignment_of_v = alignment_of<_Tp>::value;

template <typename _Tp>
  inline constexpr size_t rank_v = 0;
template <typename _Tp, size_t _Size>
  inline constexpr size_t rank_v<_Tp[_Size]> = 1 + rank_v<_Tp>;
template <typename _Tp>
  inline constexpr size_t rank_v<_Tp[]> = 1 + rank_v<_Tp>;

template <typename _Tp, unsigned _Idx = 0>
  inline constexpr size_t extent_v = 0;
template <typename _Tp, size_t _Size>
  inline constexpr size_t extent_v<_Tp[_Size], 0> = _Size;
template <typename _Tp, unsigned _Idx, size_t _Size>
  inline constexpr size_t extent_v<_Tp[_Size], _Idx> = extent_v<_Tp, _Idx - 1>;
template <typename _Tp>
  inline constexpr size_t extent_v<_Tp[], 0> = 0;
template <typename _Tp, unsigned _Idx>
  inline constexpr size_t extent_v<_Tp[], _Idx> = extent_v<_Tp, _Idx - 1>;


template <typename _Tp, typename _Up>
  inline constexpr bool is_same_v = __is_same(_Tp, _Up);






template <typename _Base, typename _Derived>
  inline constexpr bool is_base_of_v = __is_base_of(_Base, _Derived);

template <typename _From, typename _To>
  inline constexpr bool is_convertible_v = __is_convertible(_From, _To);




template<typename _Fn, typename... _Args>
  inline constexpr bool is_invocable_v = is_invocable<_Fn, _Args...>::value;
template<typename _Fn, typename... _Args>
  inline constexpr bool is_nothrow_invocable_v
    = is_nothrow_invocable<_Fn, _Args...>::value;
template<typename _Ret, typename _Fn, typename... _Args>
  inline constexpr bool is_invocable_r_v
    = is_invocable_r<_Ret, _Fn, _Args...>::value;
template<typename _Ret, typename _Fn, typename... _Args>
  inline constexpr bool is_nothrow_invocable_r_v
    = is_nothrow_invocable_r<_Ret, _Fn, _Args...>::value;






  template<typename _Tp>
    struct has_unique_object_representations
    : bool_constant<__has_unique_object_representations(
      remove_cv_t<remove_all_extents_t<_Tp>>
      )>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };



  template<typename _Tp>
    inline constexpr bool has_unique_object_representations_v
      = has_unique_object_representations<_Tp>::value;






  template<typename _Tp>
    struct is_aggregate
    : bool_constant<__is_aggregate(remove_cv_t<_Tp>)>
    { };






  template<typename _Tp>
    inline constexpr bool is_aggregate_v = __is_aggregate(remove_cv_t<_Tp>);
# 3581 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _Tp>
    struct remove_cvref
    { using type = __remove_cvref(_Tp); };
# 3598 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _Tp>
    using remove_cvref_t = typename remove_cvref<_Tp>::type;
# 3608 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _Tp>
    struct type_identity { using type = _Tp; };

  template<typename _Tp>
    using type_identity_t = typename type_identity<_Tp>::type;
# 3621 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _Tp>
    struct unwrap_reference { using type = _Tp; };

  template<typename _Tp>
    struct unwrap_reference<reference_wrapper<_Tp>> { using type = _Tp&; };

  template<typename _Tp>
    using unwrap_reference_t = typename unwrap_reference<_Tp>::type;






  template<typename _Tp>
    struct unwrap_ref_decay { using type = unwrap_reference_t<decay_t<_Tp>>; };

  template<typename _Tp>
    using unwrap_ref_decay_t = typename unwrap_ref_decay<_Tp>::type;
# 3648 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _Tp>
    inline constexpr bool is_bounded_array_v = __is_bounded_array(_Tp);
# 3661 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _Tp>
    inline constexpr bool is_unbounded_array_v = false;

  template<typename _Tp>
    inline constexpr bool is_unbounded_array_v<_Tp[]> = true;



  template<typename _Tp>
    struct is_bounded_array
    : public bool_constant<is_bounded_array_v<_Tp>>
    { };



  template<typename _Tp>
    struct is_unbounded_array
    : public bool_constant<is_unbounded_array_v<_Tp>>
    { };





  template<typename _Tp, typename _Up>
    struct is_layout_compatible
    : bool_constant<__is_layout_compatible(_Tp, _Up)>
    { };



  template<typename _Tp, typename _Up>
    constexpr bool is_layout_compatible_v
      = __is_layout_compatible(_Tp, _Up);







  template<typename _S1, typename _S2, typename _M1, typename _M2>
    constexpr bool
    is_corresponding_member(_M1 _S1::*__m1, _M2 _S2::*__m2) noexcept
    { return __builtin_is_corresponding_member(__m1, __m2); }







  template<typename _Base, typename _Derived>
    struct is_pointer_interconvertible_base_of
    : bool_constant<__is_pointer_interconvertible_base_of(_Base, _Derived)>
    { };



  template<typename _Base, typename _Derived>
    constexpr bool is_pointer_interconvertible_base_of_v
      = __is_pointer_interconvertible_base_of(_Base, _Derived);
# 3732 "/usr/include/c++/14.2.1/type_traits" 3
  template<typename _Tp, typename _Mem>
    constexpr bool
    is_pointer_interconvertible_with_class(_Mem _Tp::*__mp) noexcept
    { return __builtin_is_pointer_interconvertible_with_class(__mp); }
# 3816 "/usr/include/c++/14.2.1/type_traits" 3
  constexpr inline bool
  is_constant_evaluated() noexcept
  {



    return __builtin_is_constant_evaluated();

  }




  template<typename _From, typename _To>
    using __copy_cv = typename __match_cv_qualifiers<_From, _To>::__type;

  template<typename _Xp, typename _Yp>
    using __cond_res
      = decltype(false ? declval<_Xp(&)()>()() : declval<_Yp(&)()>()());

  template<typename _Ap, typename _Bp, typename = void>
    struct __common_ref_impl
    { };


  template<typename _Ap, typename _Bp>
    using __common_ref = typename __common_ref_impl<_Ap, _Bp>::type;


  template<typename _Xp, typename _Yp>
    using __condres_cvref
      = __cond_res<__copy_cv<_Xp, _Yp>&, __copy_cv<_Yp, _Xp>&>;


  template<typename _Xp, typename _Yp>
    struct __common_ref_impl<_Xp&, _Yp&, __void_t<__condres_cvref<_Xp, _Yp>>>
    : enable_if<is_reference_v<__condres_cvref<_Xp, _Yp>>,
  __condres_cvref<_Xp, _Yp>>
    { };


  template<typename _Xp, typename _Yp>
    using __common_ref_C = remove_reference_t<__common_ref<_Xp&, _Yp&>>&&;


  template<typename _Xp, typename _Yp>
    struct __common_ref_impl<_Xp&&, _Yp&&,
      _Require<is_convertible<_Xp&&, __common_ref_C<_Xp, _Yp>>,
        is_convertible<_Yp&&, __common_ref_C<_Xp, _Yp>>>>
    { using type = __common_ref_C<_Xp, _Yp>; };


  template<typename _Xp, typename _Yp>
    using __common_ref_D = __common_ref<const _Xp&, _Yp&>;


  template<typename _Xp, typename _Yp>
    struct __common_ref_impl<_Xp&&, _Yp&,
      _Require<is_convertible<_Xp&&, __common_ref_D<_Xp, _Yp>>>>
    { using type = __common_ref_D<_Xp, _Yp>; };


  template<typename _Xp, typename _Yp>
    struct __common_ref_impl<_Xp&, _Yp&&>
    : __common_ref_impl<_Yp&&, _Xp&>
    { };


  template<typename _Tp, typename _Up,
    template<typename> class _TQual, template<typename> class _UQual>
    struct basic_common_reference
    { };


  template<typename _Tp>
    struct __xref
    { template<typename _Up> using __type = __copy_cv<_Tp, _Up>; };

  template<typename _Tp>
    struct __xref<_Tp&>
    { template<typename _Up> using __type = __copy_cv<_Tp, _Up>&; };

  template<typename _Tp>
    struct __xref<_Tp&&>
    { template<typename _Up> using __type = __copy_cv<_Tp, _Up>&&; };

  template<typename _Tp1, typename _Tp2>
    using __basic_common_ref
      = typename basic_common_reference<remove_cvref_t<_Tp1>,
     remove_cvref_t<_Tp2>,
     __xref<_Tp1>::template __type,
     __xref<_Tp2>::template __type>::type;


  template<typename... _Tp>
    struct common_reference;

  template<typename... _Tp>
    using common_reference_t = typename common_reference<_Tp...>::type;


  template<>
    struct common_reference<>
    { };


  template<typename _Tp0>
    struct common_reference<_Tp0>
    { using type = _Tp0; };


  template<typename _Tp1, typename _Tp2, int _Bullet = 1, typename = void>
    struct __common_reference_impl
    : __common_reference_impl<_Tp1, _Tp2, _Bullet + 1>
    { };


  template<typename _Tp1, typename _Tp2>
    struct common_reference<_Tp1, _Tp2>
    : __common_reference_impl<_Tp1, _Tp2>
    { };


  template<typename _Tp1, typename _Tp2>
    struct __common_reference_impl<_Tp1&, _Tp2&, 1,
       void_t<__common_ref<_Tp1&, _Tp2&>>>
    { using type = __common_ref<_Tp1&, _Tp2&>; };

  template<typename _Tp1, typename _Tp2>
    struct __common_reference_impl<_Tp1&&, _Tp2&&, 1,
       void_t<__common_ref<_Tp1&&, _Tp2&&>>>
    { using type = __common_ref<_Tp1&&, _Tp2&&>; };

  template<typename _Tp1, typename _Tp2>
    struct __common_reference_impl<_Tp1&, _Tp2&&, 1,
       void_t<__common_ref<_Tp1&, _Tp2&&>>>
    { using type = __common_ref<_Tp1&, _Tp2&&>; };

  template<typename _Tp1, typename _Tp2>
    struct __common_reference_impl<_Tp1&&, _Tp2&, 1,
       void_t<__common_ref<_Tp1&&, _Tp2&>>>
    { using type = __common_ref<_Tp1&&, _Tp2&>; };


  template<typename _Tp1, typename _Tp2>
    struct __common_reference_impl<_Tp1, _Tp2, 2,
       void_t<__basic_common_ref<_Tp1, _Tp2>>>
    { using type = __basic_common_ref<_Tp1, _Tp2>; };


  template<typename _Tp1, typename _Tp2>
    struct __common_reference_impl<_Tp1, _Tp2, 3,
       void_t<__cond_res<_Tp1, _Tp2>>>
    { using type = __cond_res<_Tp1, _Tp2>; };


  template<typename _Tp1, typename _Tp2>
    struct __common_reference_impl<_Tp1, _Tp2, 4,
       void_t<common_type_t<_Tp1, _Tp2>>>
    { using type = common_type_t<_Tp1, _Tp2>; };


  template<typename _Tp1, typename _Tp2>
    struct __common_reference_impl<_Tp1, _Tp2, 5, void>
    { };


  template<typename _Tp1, typename _Tp2, typename... _Rest>
    struct common_reference<_Tp1, _Tp2, _Rest...>
    : __common_type_fold<common_reference<_Tp1, _Tp2>,
    __common_type_pack<_Rest...>>
    { };


  template<typename _Tp1, typename _Tp2, typename... _Rest>
    struct __common_type_fold<common_reference<_Tp1, _Tp2>,
         __common_type_pack<_Rest...>,
         void_t<common_reference_t<_Tp1, _Tp2>>>
    : public common_reference<common_reference_t<_Tp1, _Tp2>, _Rest...>
    { };







}
# 61 "/usr/include/c++/14.2.1/bits/stl_pair.h" 2 3
# 1 "/usr/include/c++/14.2.1/bits/move.h" 1 3
# 40 "/usr/include/c++/14.2.1/bits/move.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _Tp>
    inline constexpr _Tp*
    __addressof(_Tp& __r) noexcept
    { return __builtin_addressof(__r); }
# 67 "/usr/include/c++/14.2.1/bits/move.h" 3
  template<typename _Tp>
    [[__nodiscard__]]
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Tp&&>(__t); }







  template<typename _Tp>
    [[__nodiscard__]]
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
    {
      static_assert(!std::is_lvalue_reference<_Tp>::value,
   "std::forward must not be used to convert an rvalue to an lvalue");
      return static_cast<_Tp&&>(__t);
    }
# 124 "/usr/include/c++/14.2.1/bits/move.h" 3
  template<typename _Tp>
    [[__nodiscard__]]
    constexpr typename std::remove_reference<_Tp>::type&&
    move(_Tp&& __t) noexcept
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }


  template<typename _Tp>
    struct __move_if_noexcept_cond
    : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
                    is_copy_constructible<_Tp>>::type { };
# 144 "/usr/include/c++/14.2.1/bits/move.h" 3
  template<typename _Tp>
    [[__nodiscard__]]
    constexpr
    __conditional_t<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>
    move_if_noexcept(_Tp& __x) noexcept
    { return std::move(__x); }
# 160 "/usr/include/c++/14.2.1/bits/move.h" 3
  template<typename _Tp>
    [[__nodiscard__]]
    inline constexpr _Tp*
    addressof(_Tp& __r) noexcept
    { return std::__addressof(__r); }



  template<typename _Tp>
    const _Tp* addressof(const _Tp&&) = delete;


  template <typename _Tp, typename _Up = _Tp>
    constexpr
    inline _Tp
    __exchange(_Tp& __obj, _Up&& __new_val)
    {
      _Tp __old_val = std::move(__obj);
      __obj = std::forward<_Up>(__new_val);
      return __old_val;
    }
# 204 "/usr/include/c++/14.2.1/bits/move.h" 3
  template<typename _Tp>
    constexpr
    inline

    typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>,
         is_move_constructible<_Tp>,
         is_move_assignable<_Tp>>::value>::type



    swap(_Tp& __a, _Tp& __b)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>, is_nothrow_move_assignable<_Tp>>::value)

    {




      _Tp __tmp = std::move(__a);
      __a = std::move(__b);
      __b = std::move(__tmp);
    }




  template<typename _Tp, size_t _Nm>
    constexpr
    inline

    typename enable_if<__is_swappable<_Tp>::value>::type



    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value)
    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }



}
# 62 "/usr/include/c++/14.2.1/bits/stl_pair.h" 2 3
# 1 "/usr/include/c++/14.2.1/bits/utility.h" 1 3
# 36 "/usr/include/c++/14.2.1/bits/utility.h" 3
       
# 37 "/usr/include/c++/14.2.1/bits/utility.h" 3






namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp>
    struct tuple_size;





  template<typename _Tp,
    typename _Up = typename remove_cv<_Tp>::type,
    typename = typename enable_if<is_same<_Tp, _Up>::value>::type,
    size_t = tuple_size<_Tp>::value>
    using __enable_if_has_tuple_size = _Tp;

  template<typename _Tp>
    struct tuple_size<const __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };

  template<typename _Tp>
    struct tuple_size<volatile __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };

  template<typename _Tp>
    struct tuple_size<const volatile __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };


  template<typename _Tp>
    inline constexpr size_t tuple_size_v = tuple_size<_Tp>::value;



  template<size_t __i, typename _Tp>
    struct tuple_element;


  template<size_t __i, typename _Tp>
    using __tuple_element_t = typename tuple_element<__i, _Tp>::type;

  template<size_t __i, typename _Tp>
    struct tuple_element<__i, const _Tp>
    {
      using type = const __tuple_element_t<__i, _Tp>;
    };

  template<size_t __i, typename _Tp>
    struct tuple_element<__i, volatile _Tp>
    {
      using type = volatile __tuple_element_t<__i, _Tp>;
    };

  template<size_t __i, typename _Tp>
    struct tuple_element<__i, const volatile _Tp>
    {
      using type = const volatile __tuple_element_t<__i, _Tp>;
    };





  template<typename _Tp, typename... _Types>
    constexpr size_t
    __find_uniq_type_in_pack()
    {
      constexpr size_t __sz = sizeof...(_Types);
      constexpr bool __found[__sz] = { __is_same(_Tp, _Types) ... };
      size_t __n = __sz;
      for (size_t __i = 0; __i < __sz; ++__i)
 {
   if (__found[__i])
     {
       if (__n < __sz)
  return __sz;
       __n = __i;
     }
 }
      return __n;
    }
# 134 "/usr/include/c++/14.2.1/bits/utility.h" 3
  template<size_t __i, typename _Tp>
    using tuple_element_t = typename tuple_element<__i, _Tp>::type;




  template<size_t... _Indexes> struct _Index_tuple { };


  template<size_t _Num>
    struct _Build_index_tuple
    {
# 154 "/usr/include/c++/14.2.1/bits/utility.h" 3
      using __type = _Index_tuple<__integer_pack(_Num)...>;

    };




  template<typename _Tp, _Tp... _Idx>
    struct integer_sequence
    {

      static_assert(is_integral_v<_Tp>);

      typedef _Tp value_type;
      static constexpr size_t size() noexcept { return sizeof...(_Idx); }
    };


  template<typename _Tp, _Tp _Num>
    using make_integer_sequence



      = integer_sequence<_Tp, __integer_pack(_Num)...>;



  template<size_t... _Idx>
    using index_sequence = integer_sequence<size_t, _Idx...>;


  template<size_t _Num>
    using make_index_sequence = make_integer_sequence<size_t, _Num>;


  template<typename... _Types>
    using index_sequence_for = make_index_sequence<sizeof...(_Types)>;




  struct in_place_t {
    explicit in_place_t() = default;
  };

  inline constexpr in_place_t in_place{};

  template<typename _Tp> struct in_place_type_t
  {
    explicit in_place_type_t() = default;
  };

  template<typename _Tp>
    inline constexpr in_place_type_t<_Tp> in_place_type{};

  template<size_t _Idx> struct in_place_index_t
  {
    explicit in_place_index_t() = default;
  };

  template<size_t _Idx>
    inline constexpr in_place_index_t<_Idx> in_place_index{};

  template<typename>
    inline constexpr bool __is_in_place_type_v = false;

  template<typename _Tp>
    inline constexpr bool __is_in_place_type_v<in_place_type_t<_Tp>> = true;

  template<typename _Tp>
    using __is_in_place_type = bool_constant<__is_in_place_type_v<_Tp>>;

  template<typename>
    inline constexpr bool __is_in_place_index_v = false;

  template<size_t _Nm>
    inline constexpr bool __is_in_place_index_v<in_place_index_t<_Nm>> = true;




  template<size_t _Np, typename... _Types>
    struct _Nth_type
    { using type = __type_pack_element<_Np, _Types...>; };
# 276 "/usr/include/c++/14.2.1/bits/utility.h" 3
  namespace ranges::__detail
  {
    template<typename _Range>
      inline constexpr bool __is_subrange = false;
  }



}
# 63 "/usr/include/c++/14.2.1/bits/stl_pair.h" 2 3


# 1 "/usr/include/c++/14.2.1/compare" 1 3
# 33 "/usr/include/c++/14.2.1/compare" 3
       
# 34 "/usr/include/c++/14.2.1/compare" 3


# 1 "/usr/include/c++/14.2.1/bits/version.h" 1 3
# 47 "/usr/include/c++/14.2.1/bits/version.h" 3
       
# 48 "/usr/include/c++/14.2.1/bits/version.h" 3
# 37 "/usr/include/c++/14.2.1/compare" 2 3



# 1 "/usr/include/c++/14.2.1/concepts" 1 3
# 33 "/usr/include/c++/14.2.1/concepts" 3
       
# 34 "/usr/include/c++/14.2.1/concepts" 3


# 1 "/usr/include/c++/14.2.1/bits/version.h" 1 3
# 47 "/usr/include/c++/14.2.1/bits/version.h" 3
       
# 48 "/usr/include/c++/14.2.1/bits/version.h" 3
# 37 "/usr/include/c++/14.2.1/concepts" 2 3
# 48 "/usr/include/c++/14.2.1/concepts" 3
namespace std __attribute__ ((__visibility__ ("default")))
{




  namespace __detail
  {
    template<typename _Tp, typename _Up>
      concept __same_as = std::is_same_v<_Tp, _Up>;
  }


  template<typename _Tp, typename _Up>
    concept same_as
      = __detail::__same_as<_Tp, _Up> && __detail::__same_as<_Up, _Tp>;

  namespace __detail
  {
    template<typename _Tp, typename _Up>
      concept __different_from
 = !same_as<remove_cvref_t<_Tp>, remove_cvref_t<_Up>>;
  }


  template<typename _Derived, typename _Base>
    concept derived_from = __is_base_of(_Base, _Derived)
      && is_convertible_v<const volatile _Derived*, const volatile _Base*>;


  template<typename _From, typename _To>
    concept convertible_to = is_convertible_v<_From, _To>
      && requires { static_cast<_To>(std::declval<_From>()); };


  template<typename _Tp, typename _Up>
    concept common_reference_with
      = same_as<common_reference_t<_Tp, _Up>, common_reference_t<_Up, _Tp>>
      && convertible_to<_Tp, common_reference_t<_Tp, _Up>>
      && convertible_to<_Up, common_reference_t<_Tp, _Up>>;


  template<typename _Tp, typename _Up>
    concept common_with
      = same_as<common_type_t<_Tp, _Up>, common_type_t<_Up, _Tp>>
      && requires {
 static_cast<common_type_t<_Tp, _Up>>(std::declval<_Tp>());
 static_cast<common_type_t<_Tp, _Up>>(std::declval<_Up>());
      }
      && common_reference_with<add_lvalue_reference_t<const _Tp>,
          add_lvalue_reference_t<const _Up>>
      && common_reference_with<add_lvalue_reference_t<common_type_t<_Tp, _Up>>,
          common_reference_t<
     add_lvalue_reference_t<const _Tp>,
     add_lvalue_reference_t<const _Up>>>;



  template<typename _Tp>
    concept integral = is_integral_v<_Tp>;

  template<typename _Tp>
    concept signed_integral = integral<_Tp> && is_signed_v<_Tp>;

  template<typename _Tp>
    concept unsigned_integral = integral<_Tp> && !signed_integral<_Tp>;

  template<typename _Tp>
    concept floating_point = is_floating_point_v<_Tp>;

  namespace __detail
  {
    template<typename _Tp>
      using __cref = const remove_reference_t<_Tp>&;

    template<typename _Tp>
      concept __class_or_enum
 = is_class_v<_Tp> || is_union_v<_Tp> || is_enum_v<_Tp>;

    template<typename _Tp>
      constexpr bool __destructible_impl = false;
    template<typename _Tp>
      requires requires(_Tp& __t) { { __t.~_Tp() } noexcept; }
      constexpr bool __destructible_impl<_Tp> = true;

    template<typename _Tp>
      constexpr bool __destructible = __destructible_impl<_Tp>;
    template<typename _Tp>
      constexpr bool __destructible<_Tp&> = true;
    template<typename _Tp>
      constexpr bool __destructible<_Tp&&> = true;
    template<typename _Tp, size_t _Nm>
      constexpr bool __destructible<_Tp[_Nm]> = __destructible<_Tp>;

  }


  template<typename _Lhs, typename _Rhs>
    concept assignable_from
      = is_lvalue_reference_v<_Lhs>
      && common_reference_with<__detail::__cref<_Lhs>, __detail::__cref<_Rhs>>
      && requires(_Lhs __lhs, _Rhs&& __rhs) {
 { __lhs = static_cast<_Rhs&&>(__rhs) } -> same_as<_Lhs>;
      };


  template<typename _Tp>
    concept destructible = __detail::__destructible<_Tp>;


  template<typename _Tp, typename... _Args>
    concept constructible_from
      = destructible<_Tp> && is_constructible_v<_Tp, _Args...>;


  template<typename _Tp>
    concept default_initializable = constructible_from<_Tp>
      && requires
      {
 _Tp{};
 (void) ::new _Tp;
      };


  template<typename _Tp>
    concept move_constructible
    = constructible_from<_Tp, _Tp> && convertible_to<_Tp, _Tp>;


  template<typename _Tp>
    concept copy_constructible
      = move_constructible<_Tp>
      && constructible_from<_Tp, _Tp&> && convertible_to<_Tp&, _Tp>
      && constructible_from<_Tp, const _Tp&> && convertible_to<const _Tp&, _Tp>
      && constructible_from<_Tp, const _Tp> && convertible_to<const _Tp, _Tp>;



  namespace ranges
  {

    namespace __swap
    {
      template<typename _Tp> void swap(_Tp&, _Tp&) = delete;

      template<typename _Tp, typename _Up>
 concept __adl_swap
   = (std::__detail::__class_or_enum<remove_reference_t<_Tp>>
     || std::__detail::__class_or_enum<remove_reference_t<_Up>>)
   && requires(_Tp&& __t, _Up&& __u) {
     swap(static_cast<_Tp&&>(__t), static_cast<_Up&&>(__u));
   };

      struct _Swap
      {
      private:
 template<typename _Tp, typename _Up>
   static constexpr bool
   _S_noexcept()
   {
     if constexpr (__adl_swap<_Tp, _Up>)
       return noexcept(swap(std::declval<_Tp>(), std::declval<_Up>()));
     else
       return is_nothrow_move_constructible_v<remove_reference_t<_Tp>>
     && is_nothrow_move_assignable_v<remove_reference_t<_Tp>>;
   }

      public:
 template<typename _Tp, typename _Up>
   requires __adl_swap<_Tp, _Up>
   || (same_as<_Tp, _Up> && is_lvalue_reference_v<_Tp>
       && move_constructible<remove_reference_t<_Tp>>
       && assignable_from<_Tp, remove_reference_t<_Tp>>)
   constexpr void
   operator()(_Tp&& __t, _Up&& __u) const
   noexcept(_S_noexcept<_Tp, _Up>())
   {
     if constexpr (__adl_swap<_Tp, _Up>)
       swap(static_cast<_Tp&&>(__t), static_cast<_Up&&>(__u));
     else
       {
  auto __tmp = static_cast<remove_reference_t<_Tp>&&>(__t);
  __t = static_cast<remove_reference_t<_Tp>&&>(__u);
  __u = static_cast<remove_reference_t<_Tp>&&>(__tmp);
       }
   }

 template<typename _Tp, typename _Up, size_t _Num>
   requires requires(const _Swap& __swap, _Tp& __e1, _Up& __e2) {
     __swap(__e1, __e2);
   }
   constexpr void
   operator()(_Tp (&__e1)[_Num], _Up (&__e2)[_Num]) const
   noexcept(noexcept(std::declval<const _Swap&>()(*__e1, *__e2)))
   {
     for (size_t __n = 0; __n < _Num; ++__n)
       (*this)(__e1[__n], __e2[__n]);
   }
      };
    }


    inline namespace _Cpo {
      inline constexpr __swap::_Swap swap{};
    }
  }

  template<typename _Tp>
    concept swappable
      = requires(_Tp& __a, _Tp& __b) { ranges::swap(__a, __b); };

  template<typename _Tp, typename _Up>
    concept swappable_with = common_reference_with<_Tp, _Up>
      && requires(_Tp&& __t, _Up&& __u) {
 ranges::swap(static_cast<_Tp&&>(__t), static_cast<_Tp&&>(__t));
 ranges::swap(static_cast<_Up&&>(__u), static_cast<_Up&&>(__u));
 ranges::swap(static_cast<_Tp&&>(__t), static_cast<_Up&&>(__u));
 ranges::swap(static_cast<_Up&&>(__u), static_cast<_Tp&&>(__t));
      };



  template<typename _Tp>
    concept movable = is_object_v<_Tp> && move_constructible<_Tp>
      && assignable_from<_Tp&, _Tp> && swappable<_Tp>;

  template<typename _Tp>
    concept copyable = copy_constructible<_Tp> && movable<_Tp>
      && assignable_from<_Tp&, _Tp&> && assignable_from<_Tp&, const _Tp&>
      && assignable_from<_Tp&, const _Tp>;

  template<typename _Tp>
    concept semiregular = copyable<_Tp> && default_initializable<_Tp>;




  namespace __detail
  {
    template<typename _Tp>
      concept __boolean_testable_impl = convertible_to<_Tp, bool>;

    template<typename _Tp>
      concept __boolean_testable
 = __boolean_testable_impl<_Tp>
   && requires(_Tp&& __t)
   { { !static_cast<_Tp&&>(__t) } -> __boolean_testable_impl; };
  }



  namespace __detail
  {
    template<typename _Tp, typename _Up>
      concept __weakly_eq_cmp_with
 = requires(__detail::__cref<_Tp> __t, __detail::__cref<_Up> __u) {
   { __t == __u } -> __boolean_testable;
   { __t != __u } -> __boolean_testable;
   { __u == __t } -> __boolean_testable;
   { __u != __t } -> __boolean_testable;
 };
  }

  template<typename _Tp>
    concept equality_comparable = __detail::__weakly_eq_cmp_with<_Tp, _Tp>;

  template<typename _Tp, typename _Up>
    concept equality_comparable_with
      = equality_comparable<_Tp> && equality_comparable<_Up>
      && common_reference_with<__detail::__cref<_Tp>, __detail::__cref<_Up>>
      && equality_comparable<common_reference_t<__detail::__cref<_Tp>,
      __detail::__cref<_Up>>>
      && __detail::__weakly_eq_cmp_with<_Tp, _Up>;

  namespace __detail
  {
    template<typename _Tp, typename _Up>
      concept __partially_ordered_with
 = requires(const remove_reference_t<_Tp>& __t,
     const remove_reference_t<_Up>& __u) {
   { __t < __u } -> __boolean_testable;
   { __t > __u } -> __boolean_testable;
   { __t <= __u } -> __boolean_testable;
   { __t >= __u } -> __boolean_testable;
   { __u < __t } -> __boolean_testable;
   { __u > __t } -> __boolean_testable;
   { __u <= __t } -> __boolean_testable;
   { __u >= __t } -> __boolean_testable;
 };
  }


  template<typename _Tp>
    concept totally_ordered
      = equality_comparable<_Tp>
      && __detail::__partially_ordered_with<_Tp, _Tp>;

  template<typename _Tp, typename _Up>
    concept totally_ordered_with
      = totally_ordered<_Tp> && totally_ordered<_Up>
      && equality_comparable_with<_Tp, _Up>
      && totally_ordered<common_reference_t<__detail::__cref<_Tp>,
         __detail::__cref<_Up>>>
      && __detail::__partially_ordered_with<_Tp, _Up>;

  template<typename _Tp>
    concept regular = semiregular<_Tp> && equality_comparable<_Tp>;




  template<typename _Fn, typename... _Args>
    concept invocable = is_invocable_v<_Fn, _Args...>;


  template<typename _Fn, typename... _Args>
    concept regular_invocable = invocable<_Fn, _Args...>;


  template<typename _Fn, typename... _Args>
    concept predicate = regular_invocable<_Fn, _Args...>
      && __detail::__boolean_testable<invoke_result_t<_Fn, _Args...>>;


  template<typename _Rel, typename _Tp, typename _Up>
    concept relation
      = predicate<_Rel, _Tp, _Tp> && predicate<_Rel, _Up, _Up>
      && predicate<_Rel, _Tp, _Up> && predicate<_Rel, _Up, _Tp>;


  template<typename _Rel, typename _Tp, typename _Up>
    concept equivalence_relation = relation<_Rel, _Tp, _Up>;


  template<typename _Rel, typename _Tp, typename _Up>
    concept strict_weak_order = relation<_Rel, _Tp, _Up>;


}
# 41 "/usr/include/c++/14.2.1/compare" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  namespace __cmp_cat
  {
    using type = signed char;

    enum class _Ord : type { equivalent = 0, less = -1, greater = 1 };

    enum class _Ncmp : type { _Unordered = 2 };

    struct __unspec
    {
      consteval __unspec(__unspec*) noexcept { }
    };
  }

  class partial_ordering
  {

    __cmp_cat::type _M_value;

    constexpr explicit
    partial_ordering(__cmp_cat::_Ord __v) noexcept
    : _M_value(__cmp_cat::type(__v))
    { }

    constexpr explicit
    partial_ordering(__cmp_cat::_Ncmp __v) noexcept
    : _M_value(__cmp_cat::type(__v))
    { }

    friend class weak_ordering;
    friend class strong_ordering;

  public:

    static const partial_ordering less;
    static const partial_ordering equivalent;
    static const partial_ordering greater;
    static const partial_ordering unordered;


    [[nodiscard]]
    friend constexpr bool
    operator==(partial_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value == 0; }

    [[nodiscard]]
    friend constexpr bool
    operator==(partial_ordering, partial_ordering) noexcept = default;

    [[nodiscard]]
    friend constexpr bool
    operator< (partial_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value == -1; }

    [[nodiscard]]
    friend constexpr bool
    operator> (partial_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value == 1; }

    [[nodiscard]]
    friend constexpr bool
    operator<=(partial_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value <= 0; }

    [[nodiscard]]
    friend constexpr bool
    operator>=(partial_ordering __v, __cmp_cat::__unspec) noexcept
    { return __cmp_cat::type(__v._M_value & 1) == __v._M_value; }

    [[nodiscard]]
    friend constexpr bool
    operator< (__cmp_cat::__unspec, partial_ordering __v) noexcept
    { return __v._M_value == 1; }

    [[nodiscard]]
    friend constexpr bool
    operator> (__cmp_cat::__unspec, partial_ordering __v) noexcept
    { return __v._M_value == -1; }

    [[nodiscard]]
    friend constexpr bool
    operator<=(__cmp_cat::__unspec, partial_ordering __v) noexcept
    { return __cmp_cat::type(__v._M_value & 1) == __v._M_value; }

    [[nodiscard]]
    friend constexpr bool
    operator>=(__cmp_cat::__unspec, partial_ordering __v) noexcept
    { return 0 >= __v._M_value; }

    [[nodiscard]]
    friend constexpr partial_ordering
    operator<=>(partial_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v; }

    [[nodiscard]]
    friend constexpr partial_ordering
    operator<=>(__cmp_cat::__unspec, partial_ordering __v) noexcept
    {
      if (__v._M_value & 1)
 return partial_ordering(__cmp_cat::_Ord(-__v._M_value));
      else
 return __v;
    }
  };


  inline constexpr partial_ordering
  partial_ordering::less(__cmp_cat::_Ord::less);

  inline constexpr partial_ordering
  partial_ordering::equivalent(__cmp_cat::_Ord::equivalent);

  inline constexpr partial_ordering
  partial_ordering::greater(__cmp_cat::_Ord::greater);

  inline constexpr partial_ordering
  partial_ordering::unordered(__cmp_cat::_Ncmp::_Unordered);

  class weak_ordering
  {
    __cmp_cat::type _M_value;

    constexpr explicit
    weak_ordering(__cmp_cat::_Ord __v) noexcept : _M_value(__cmp_cat::type(__v))
    { }

    friend class strong_ordering;

  public:

    static const weak_ordering less;
    static const weak_ordering equivalent;
    static const weak_ordering greater;

    [[nodiscard]]
    constexpr operator partial_ordering() const noexcept
    { return partial_ordering(__cmp_cat::_Ord(_M_value)); }


    [[nodiscard]]
    friend constexpr bool
    operator==(weak_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value == 0; }

    [[nodiscard]]
    friend constexpr bool
    operator==(weak_ordering, weak_ordering) noexcept = default;

    [[nodiscard]]
    friend constexpr bool
    operator< (weak_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value < 0; }

    [[nodiscard]]
    friend constexpr bool
    operator> (weak_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value > 0; }

    [[nodiscard]]
    friend constexpr bool
    operator<=(weak_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value <= 0; }

    [[nodiscard]]
    friend constexpr bool
    operator>=(weak_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value >= 0; }

    [[nodiscard]]
    friend constexpr bool
    operator< (__cmp_cat::__unspec, weak_ordering __v) noexcept
    { return 0 < __v._M_value; }

    [[nodiscard]]
    friend constexpr bool
    operator> (__cmp_cat::__unspec, weak_ordering __v) noexcept
    { return 0 > __v._M_value; }

    [[nodiscard]]
    friend constexpr bool
    operator<=(__cmp_cat::__unspec, weak_ordering __v) noexcept
    { return 0 <= __v._M_value; }

    [[nodiscard]]
    friend constexpr bool
    operator>=(__cmp_cat::__unspec, weak_ordering __v) noexcept
    { return 0 >= __v._M_value; }

    [[nodiscard]]
    friend constexpr weak_ordering
    operator<=>(weak_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v; }

    [[nodiscard]]
    friend constexpr weak_ordering
    operator<=>(__cmp_cat::__unspec, weak_ordering __v) noexcept
    { return weak_ordering(__cmp_cat::_Ord(-__v._M_value)); }
  };


  inline constexpr weak_ordering
  weak_ordering::less(__cmp_cat::_Ord::less);

  inline constexpr weak_ordering
  weak_ordering::equivalent(__cmp_cat::_Ord::equivalent);

  inline constexpr weak_ordering
  weak_ordering::greater(__cmp_cat::_Ord::greater);

  class strong_ordering
  {
    __cmp_cat::type _M_value;

    constexpr explicit
    strong_ordering(__cmp_cat::_Ord __v) noexcept
    : _M_value(__cmp_cat::type(__v))
    { }

  public:

    static const strong_ordering less;
    static const strong_ordering equal;
    static const strong_ordering equivalent;
    static const strong_ordering greater;

    [[nodiscard]]
    constexpr operator partial_ordering() const noexcept
    { return partial_ordering(__cmp_cat::_Ord(_M_value)); }

    [[nodiscard]]
    constexpr operator weak_ordering() const noexcept
    { return weak_ordering(__cmp_cat::_Ord(_M_value)); }


    [[nodiscard]]
    friend constexpr bool
    operator==(strong_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value == 0; }

    [[nodiscard]]
    friend constexpr bool
    operator==(strong_ordering, strong_ordering) noexcept = default;

    [[nodiscard]]
    friend constexpr bool
    operator< (strong_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value < 0; }

    [[nodiscard]]
    friend constexpr bool
    operator> (strong_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value > 0; }

    [[nodiscard]]
    friend constexpr bool
    operator<=(strong_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value <= 0; }

    [[nodiscard]]
    friend constexpr bool
    operator>=(strong_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v._M_value >= 0; }

    [[nodiscard]]
    friend constexpr bool
    operator< (__cmp_cat::__unspec, strong_ordering __v) noexcept
    { return 0 < __v._M_value; }

    [[nodiscard]]
    friend constexpr bool
    operator> (__cmp_cat::__unspec, strong_ordering __v) noexcept
    { return 0 > __v._M_value; }

    [[nodiscard]]
    friend constexpr bool
    operator<=(__cmp_cat::__unspec, strong_ordering __v) noexcept
    { return 0 <= __v._M_value; }

    [[nodiscard]]
    friend constexpr bool
    operator>=(__cmp_cat::__unspec, strong_ordering __v) noexcept
    { return 0 >= __v._M_value; }

    [[nodiscard]]
    friend constexpr strong_ordering
    operator<=>(strong_ordering __v, __cmp_cat::__unspec) noexcept
    { return __v; }

    [[nodiscard]]
    friend constexpr strong_ordering
    operator<=>(__cmp_cat::__unspec, strong_ordering __v) noexcept
    { return strong_ordering(__cmp_cat::_Ord(-__v._M_value)); }
  };


  inline constexpr strong_ordering
  strong_ordering::less(__cmp_cat::_Ord::less);

  inline constexpr strong_ordering
  strong_ordering::equal(__cmp_cat::_Ord::equivalent);

  inline constexpr strong_ordering
  strong_ordering::equivalent(__cmp_cat::_Ord::equivalent);

  inline constexpr strong_ordering
  strong_ordering::greater(__cmp_cat::_Ord::greater);



  [[nodiscard]]
  constexpr bool
  is_eq(partial_ordering __cmp) noexcept
  { return __cmp == 0; }

  [[nodiscard]]
  constexpr bool
  is_neq(partial_ordering __cmp) noexcept
  { return __cmp != 0; }

  [[nodiscard]]
  constexpr bool
  is_lt (partial_ordering __cmp) noexcept
  { return __cmp < 0; }

  [[nodiscard]]
  constexpr bool
  is_lteq(partial_ordering __cmp) noexcept
  { return __cmp <= 0; }

  [[nodiscard]]
  constexpr bool
  is_gt (partial_ordering __cmp) noexcept
  { return __cmp > 0; }

  [[nodiscard]]
  constexpr bool
  is_gteq(partial_ordering __cmp) noexcept
  { return __cmp >= 0; }

  namespace __detail
  {
    template<typename _Tp>
      inline constexpr unsigned __cmp_cat_id = 1;
    template<>
      inline constexpr unsigned __cmp_cat_id<partial_ordering> = 2;
    template<>
      inline constexpr unsigned __cmp_cat_id<weak_ordering> = 4;
    template<>
      inline constexpr unsigned __cmp_cat_id<strong_ordering> = 8;

    template<typename... _Ts>
      constexpr auto __common_cmp_cat()
      {
 constexpr unsigned __cats = (__cmp_cat_id<_Ts> | ...);

 if constexpr (__cats & 1)
   return;


 else if constexpr (bool(__cats & __cmp_cat_id<partial_ordering>))
   return partial_ordering::equivalent;


 else if constexpr (bool(__cats & __cmp_cat_id<weak_ordering>))
   return weak_ordering::equivalent;

 else
   return strong_ordering::equivalent;
      }
  }


  template<typename... _Ts>
    struct common_comparison_category
    {
      using type = decltype(__detail::__common_cmp_cat<_Ts...>());
    };



  template<typename _Tp>
    struct common_comparison_category<_Tp>
    { using type = void; };

  template<>
    struct common_comparison_category<partial_ordering>
    { using type = partial_ordering; };

  template<>
    struct common_comparison_category<weak_ordering>
    { using type = weak_ordering; };

  template<>
    struct common_comparison_category<strong_ordering>
    { using type = strong_ordering; };

  template<>
    struct common_comparison_category<>
    { using type = strong_ordering; };

  template<typename... _Ts>
    using common_comparison_category_t
      = typename common_comparison_category<_Ts...>::type;



  namespace __detail
  {
    template<typename _Tp, typename _Cat>
      concept __compares_as
 = same_as<common_comparison_category_t<_Tp, _Cat>, _Cat>;
  }


  template<typename _Tp, typename _Cat = partial_ordering>
    concept three_way_comparable
      = __detail::__weakly_eq_cmp_with<_Tp, _Tp>
      && __detail::__partially_ordered_with<_Tp, _Tp>
      && requires(const remove_reference_t<_Tp>& __a,
    const remove_reference_t<_Tp>& __b)
      {
 { __a <=> __b } -> __detail::__compares_as<_Cat>;
      };

  template<typename _Tp, typename _Up, typename _Cat = partial_ordering>
    concept three_way_comparable_with
      = three_way_comparable<_Tp, _Cat>
      && three_way_comparable<_Up, _Cat>
      && common_reference_with<const remove_reference_t<_Tp>&,
          const remove_reference_t<_Up>&>
      && three_way_comparable<
   common_reference_t<const remove_reference_t<_Tp>&,
        const remove_reference_t<_Up>&>, _Cat>
      && __detail::__weakly_eq_cmp_with<_Tp, _Up>
      && __detail::__partially_ordered_with<_Tp, _Up>
      && requires(const remove_reference_t<_Tp>& __t,
    const remove_reference_t<_Up>& __u)
      {
 { __t <=> __u } -> __detail::__compares_as<_Cat>;
 { __u <=> __t } -> __detail::__compares_as<_Cat>;
      };

  namespace __detail
  {
    template<typename _Tp, typename _Up>
      using __cmp3way_res_t
 = decltype(std::declval<_Tp>() <=> std::declval<_Up>());






    template<typename _Tp, typename _Up>
      struct __cmp3way_res_impl
      { };

    template<typename _Tp, typename _Up>
      requires requires { typename __cmp3way_res_t<__cref<_Tp>, __cref<_Up>>; }
      struct __cmp3way_res_impl<_Tp, _Up>
      {
 using type = __cmp3way_res_t<__cref<_Tp>, __cref<_Up>>;
      };
  }


  template<typename _Tp, typename _Up = _Tp>
    struct compare_three_way_result
    : __detail::__cmp3way_res_impl<_Tp, _Up>
    { };


  template<typename _Tp, typename _Up = _Tp>
    using compare_three_way_result_t
      = typename __detail::__cmp3way_res_impl<_Tp, _Up>::type;

  namespace __detail
  {




    template<typename _Tp, typename _Up>
      concept __3way_builtin_ptr_cmp
 = requires(_Tp&& __t, _Up&& __u)
   { static_cast<_Tp&&>(__t) <=> static_cast<_Up&&>(__u); }
   && convertible_to<_Tp, const volatile void*>
   && convertible_to<_Up, const volatile void*>
   && ! requires(_Tp&& __t, _Up&& __u)
   { operator<=>(static_cast<_Tp&&>(__t), static_cast<_Up&&>(__u)); }
   && ! requires(_Tp&& __t, _Up&& __u)
   { static_cast<_Tp&&>(__t).operator<=>(static_cast<_Up&&>(__u)); };
  }





  struct compare_three_way
  {
    template<typename _Tp, typename _Up>
      requires three_way_comparable_with<_Tp, _Up>
      constexpr auto
      operator() [[nodiscard]] (_Tp&& __t, _Up&& __u) const
      noexcept(noexcept(std::declval<_Tp>() <=> std::declval<_Up>()))
      {
 if constexpr (__detail::__3way_builtin_ptr_cmp<_Tp, _Up>)
   {
     auto __pt = static_cast<const volatile void*>(__t);
     auto __pu = static_cast<const volatile void*>(__u);
     if (std::__is_constant_evaluated())
       return __pt <=> __pu;
     auto __it = reinterpret_cast<long unsigned int>(__pt);
     auto __iu = reinterpret_cast<long unsigned int>(__pu);
     return __it <=> __iu;
   }
 else
   return static_cast<_Tp&&>(__t) <=> static_cast<_Up&&>(__u);
      }

    using is_transparent = void;
  };



  namespace __compare
  {
    template<floating_point _Tp>
      constexpr weak_ordering
      __fp_weak_ordering(_Tp __e, _Tp __f)
      {


 auto __cat = [](_Tp __fp) -> int {
   const int __sign = __builtin_signbit(__fp) ? -1 : 1;
   if (__builtin_isnormal(__fp))
     return (__fp == 0 ? 1 : 3) * __sign;
   if (__builtin_isnan(__fp))
     return 5 * __sign;
   if (int __inf = __builtin_isinf_sign(__fp))
     return 4 * __inf;
   return 2 * __sign;
 };

 auto __po = __e <=> __f;
 if (is_lt(__po))
   return weak_ordering::less;
 else if (is_gt(__po))
   return weak_ordering::greater;
 else if (__po == partial_ordering::equivalent)
   return weak_ordering::equivalent;
 else
   {

     auto __isnan_sign = [](_Tp __fp) -> int {
       return __builtin_isnan(__fp)
  ? __builtin_signbit(__fp) ? -1 : 1
  : 0;
     };
     auto __ord = __isnan_sign(__e) <=> __isnan_sign(__f);
     if (is_eq(__ord))
       return weak_ordering::equivalent;
     else if (is_lt(__ord))
       return weak_ordering::less;
     else
       return weak_ordering::greater;
   }
      }

    void strong_order() = delete;

    template<typename _Tp, typename _Up>
      concept __adl_strong = requires(_Tp&& __t, _Up&& __u)
 {
   strong_ordering(strong_order(static_cast<_Tp&&>(__t),
           static_cast<_Up&&>(__u)));
 };

    void weak_order() = delete;

    template<typename _Tp, typename _Up>
      concept __adl_weak = requires(_Tp&& __t, _Up&& __u)
 {
   weak_ordering(weak_order(static_cast<_Tp&&>(__t),
       static_cast<_Up&&>(__u)));
 };

    void partial_order() = delete;

    template<typename _Tp, typename _Up>
      concept __adl_partial = requires(_Tp&& __t, _Up&& __u)
 {
   partial_ordering(partial_order(static_cast<_Tp&&>(__t),
      static_cast<_Up&&>(__u)));
 };

    template<typename _Ord, typename _Tp, typename _Up>
      concept __cmp3way = requires(_Tp&& __t, _Up&& __u, compare_three_way __c)
 {
   _Ord(__c(static_cast<_Tp&&>(__t), static_cast<_Up&&>(__u)));
 };

    template<typename _Tp, typename _Up>
      concept __strongly_ordered
 = __adl_strong<_Tp, _Up>
   || floating_point<remove_reference_t<_Tp>>
   || __cmp3way<strong_ordering, _Tp, _Up>;

    template<typename _Tp, typename _Up>
      concept __decayed_same_as = same_as<decay_t<_Tp>, decay_t<_Up>>;

    class _Strong_order
    {
      template<typename _Tp, typename _Up>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (floating_point<decay_t<_Tp>>)
     return true;
   else if constexpr (__adl_strong<_Tp, _Up>)
     return noexcept(strong_ordering(strong_order(std::declval<_Tp>(),
        std::declval<_Up>())));
   else if constexpr (__cmp3way<strong_ordering, _Tp, _Up>)
     return noexcept(compare_three_way()(std::declval<_Tp>(),
      std::declval<_Up>()));
 }

      friend class _Weak_order;
      friend class _Strong_fallback;


      enum class _Fp_fmt
      {
 _Binary16, _Binary32, _Binary64, _Binary128,
 _X86_80bit,
 _M68k_80bit,
 _Dbldbl,
 _Bfloat16,
      };
# 699 "/usr/include/c++/14.2.1/compare" 3
      template<typename _Tp>
 static consteval _Fp_fmt
 _S_fp_fmt() noexcept
 {

   using enum _Fp_fmt;
# 719 "/usr/include/c++/14.2.1/compare" 3
   if constexpr (__is_same(_Tp, long double))
     return (-16381) == -16381 ? _X86_80bit : _M68k_80bit;


   if constexpr (__is_same(_Tp, __float80))
     return _X86_80bit;






   constexpr int __width = sizeof(_Tp) * 8;

   if constexpr (__width == 16)
     return _Binary16;
   else if constexpr (__width == 32)
     return _Binary32;
   else if constexpr (__width == 64)
     return _Binary64;
   else if constexpr (__width == 128)
     return _Binary128;
 }


      using int64_t = long int;
      using int32_t = int;
      using int16_t = short int;
      using uint64_t = long unsigned int;
      using uint16_t = short unsigned int;


      template<typename _Tp>
 struct _Int
 {

   uint64_t _M_lo;
   _Tp _M_hi;





   constexpr explicit
   _Int(_Tp __hi, uint64_t __lo) noexcept : _M_hi(__hi)
   { _M_lo = __lo; }

   constexpr explicit
   _Int(uint64_t __lo) noexcept : _M_hi(0)
   { _M_lo = __lo; }

   constexpr bool operator==(const _Int&) const = default;
# 781 "/usr/include/c++/14.2.1/compare" 3
   constexpr _Int&
   operator^=(const _Int& __rhs) noexcept
   {
     _M_hi ^= __rhs._M_hi;
     _M_lo ^= __rhs._M_lo;
     return *this;
   }

   constexpr strong_ordering
   operator<=>(const _Int& __rhs) const noexcept
   {
     strong_ordering __cmp = _M_hi <=> __rhs._M_hi;
     if (__cmp != strong_ordering::equal)
       return __cmp;
     return _M_lo <=> __rhs._M_lo;
   }
 };

      template<typename _Tp>
 static constexpr _Tp
 _S_compl(_Tp __t) noexcept
 {
   constexpr int __width = sizeof(_Tp) * 8;

   make_unsigned_t<_Tp> __sign = __t >> (__width - 1);


   return __t ^ (__sign >> 1);
 }


      template<typename _Tp>
 static constexpr _Int<_Tp>
 _S_compl(_Int<_Tp> __t) noexcept
 {
   constexpr int __width = sizeof(_Tp) * 8;
   make_unsigned_t<_Tp> __sign = __t._M_hi >> (__width - 1);
   __t._M_hi ^= (__sign >> 1 );
   uint64_t __sign64 = (_Tp)__sign;
   __t._M_lo ^= __sign64;
   return __t;
 }


      template<typename _Tp>
 constexpr static auto
 _S_fp_bits(_Tp __val) noexcept
 {
   if constexpr (sizeof(_Tp) == sizeof(int64_t))
     return __builtin_bit_cast(int64_t, __val);
   else if constexpr (sizeof(_Tp) == sizeof(int32_t))
     return __builtin_bit_cast(int32_t, __val);
   else if constexpr (sizeof(_Tp) == sizeof(int16_t))
     return __builtin_bit_cast(int16_t, __val);
   else
     {

       using enum _Fp_fmt;

       constexpr auto __fmt = _S_fp_fmt<_Tp>();
       if constexpr (__fmt == _X86_80bit || __fmt == _M68k_80bit)
  {
    if constexpr (sizeof(_Tp) == 3 * sizeof(int32_t))
      {
        auto __ival = __builtin_bit_cast(_Int<int32_t>, __val);
        return _Int<int16_t>(__ival._M_hi, __ival._M_lo);
      }
    else
      {
        auto __ival = __builtin_bit_cast(_Int<int64_t>, __val);
        return _Int<int16_t>(__ival._M_hi, __ival._M_lo);
      }
  }
       else if constexpr (sizeof(_Tp) == 2 * sizeof(int64_t))
  {

    return __builtin_bit_cast(__int128, __val);



  }
       else
  static_assert(sizeof(_Tp) == sizeof(int64_t),
         "unsupported floating-point type");
     }
 }

      template<typename _Tp>
 static constexpr strong_ordering
 _S_fp_cmp(_Tp __x, _Tp __y) noexcept
 {
# 885 "/usr/include/c++/14.2.1/compare" 3
   auto __ix = _S_fp_bits(__x);
   auto __iy = _S_fp_bits(__y);

   if (__ix == __iy)
     return strong_ordering::equal;


   using enum _Fp_fmt;

   constexpr auto __fmt = _S_fp_fmt<_Tp>();

   if constexpr (__fmt == _Dbldbl)
     {


       struct _Unpacked { double _M_hi; int64_t _M_lo; };
       auto __x2 = __builtin_bit_cast(_Unpacked, __x);
       auto __y2 = __builtin_bit_cast(_Unpacked, __y);


       auto __cmp = _S_fp_cmp(__x2._M_hi, __y2._M_hi);
       if (__cmp != strong_ordering::equal)
  return __cmp;



       if (__builtin_isnan(__x2._M_hi))
  return strong_ordering::equal;


       if (((__x2._M_lo | __y2._M_lo) & 0x7fffffffffffffffULL) == 0)
  return strong_ordering::equal;


       return _S_compl(__x2._M_lo) <=> _S_compl(__y2._M_lo);
     }
   else
     {
       if constexpr (__fmt == _M68k_80bit)
  {



    constexpr uint16_t __maxexp = 0x7fff;
    if ((__ix._M_hi & __maxexp) == __maxexp)
      __ix._M_lo |= 1ull << 63;
    if ((__iy._M_hi & __maxexp) == __maxexp)
      __iy._M_lo |= 1ull << 63;
  }
       else
  {
# 952 "/usr/include/c++/14.2.1/compare" 3
  }
       return _S_compl(__ix) <=> _S_compl(__iy);
     }
 }

    public:
      template<typename _Tp, __decayed_same_as<_Tp> _Up>
 requires __strongly_ordered<_Tp, _Up>
 constexpr strong_ordering
 operator() [[nodiscard]] (_Tp&& __e, _Up&& __f) const
 noexcept(_S_noexcept<_Tp, _Up>())
 {
   if constexpr (floating_point<decay_t<_Tp>>)
     return _S_fp_cmp(__e, __f);
   else if constexpr (__adl_strong<_Tp, _Up>)
     return strong_ordering(strong_order(static_cast<_Tp&&>(__e),
      static_cast<_Up&&>(__f)));
   else if constexpr (__cmp3way<strong_ordering, _Tp, _Up>)
     return compare_three_way()(static_cast<_Tp&&>(__e),
           static_cast<_Up&&>(__f));
 }
    };

    template<typename _Tp, typename _Up>
      concept __weakly_ordered
 = floating_point<remove_reference_t<_Tp>>
   || __adl_weak<_Tp, _Up>
   || __cmp3way<weak_ordering, _Tp, _Up>
   || __strongly_ordered<_Tp, _Up>;

    class _Weak_order
    {
      template<typename _Tp, typename _Up>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (floating_point<decay_t<_Tp>>)
     return true;
   else if constexpr (__adl_weak<_Tp, _Up>)
     return noexcept(weak_ordering(weak_order(std::declval<_Tp>(),
           std::declval<_Up>())));
   else if constexpr (__cmp3way<weak_ordering, _Tp, _Up>)
     return noexcept(compare_three_way()(std::declval<_Tp>(),
      std::declval<_Up>()));
   else if constexpr (__strongly_ordered<_Tp, _Up>)
     return _Strong_order::_S_noexcept<_Tp, _Up>();
 }

      friend class _Partial_order;
      friend class _Weak_fallback;

    public:
      template<typename _Tp, __decayed_same_as<_Tp> _Up>
 requires __weakly_ordered<_Tp, _Up>
 constexpr weak_ordering
 operator() [[nodiscard]] (_Tp&& __e, _Up&& __f) const
 noexcept(_S_noexcept<_Tp, _Up>())
 {
   if constexpr (floating_point<decay_t<_Tp>>)
     return __compare::__fp_weak_ordering(__e, __f);
   else if constexpr (__adl_weak<_Tp, _Up>)
     return weak_ordering(weak_order(static_cast<_Tp&&>(__e),
         static_cast<_Up&&>(__f)));
   else if constexpr (__cmp3way<weak_ordering, _Tp, _Up>)
     return compare_three_way()(static_cast<_Tp&&>(__e),
           static_cast<_Up&&>(__f));
   else if constexpr (__strongly_ordered<_Tp, _Up>)
     return _Strong_order{}(static_cast<_Tp&&>(__e),
       static_cast<_Up&&>(__f));
 }
    };

    template<typename _Tp, typename _Up>
      concept __partially_ordered
 = __adl_partial<_Tp, _Up>
 || __cmp3way<partial_ordering, _Tp, _Up>
 || __weakly_ordered<_Tp, _Up>;

    class _Partial_order
    {
      template<typename _Tp, typename _Up>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (__adl_partial<_Tp, _Up>)
     return noexcept(partial_ordering(partial_order(std::declval<_Tp>(),
        std::declval<_Up>())));
   else if constexpr (__cmp3way<partial_ordering, _Tp, _Up>)
     return noexcept(compare_three_way()(std::declval<_Tp>(),
      std::declval<_Up>()));
   else if constexpr (__weakly_ordered<_Tp, _Up>)
     return _Weak_order::_S_noexcept<_Tp, _Up>();
 }

      friend class _Partial_fallback;

    public:
      template<typename _Tp, __decayed_same_as<_Tp> _Up>
 requires __partially_ordered<_Tp, _Up>
 constexpr partial_ordering
 operator() [[nodiscard]] (_Tp&& __e, _Up&& __f) const
 noexcept(_S_noexcept<_Tp, _Up>())
 {
   if constexpr (__adl_partial<_Tp, _Up>)
     return partial_ordering(partial_order(static_cast<_Tp&&>(__e),
        static_cast<_Up&&>(__f)));
   else if constexpr (__cmp3way<partial_ordering, _Tp, _Up>)
     return compare_three_way()(static_cast<_Tp&&>(__e),
           static_cast<_Up&&>(__f));
   else if constexpr (__weakly_ordered<_Tp, _Up>)
     return _Weak_order{}(static_cast<_Tp&&>(__e),
     static_cast<_Up&&>(__f));
 }
    };

    template<typename _Tp, typename _Up>
      concept __op_eq_lt = requires(_Tp&& __t, _Up&& __u)
 {
   { static_cast<_Tp&&>(__t) == static_cast<_Up&&>(__u) }
     -> convertible_to<bool>;
   { static_cast<_Tp&&>(__t) < static_cast<_Up&&>(__u) }
     -> convertible_to<bool>;
 };

    class _Strong_fallback
    {
      template<typename _Tp, typename _Up>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (__strongly_ordered<_Tp, _Up>)
     return _Strong_order::_S_noexcept<_Tp, _Up>();
   else
     return noexcept(bool(std::declval<_Tp>() == std::declval<_Up>()))
       && noexcept(bool(std::declval<_Tp>() < std::declval<_Up>()));
 }

    public:
      template<typename _Tp, __decayed_same_as<_Tp> _Up>
 requires __strongly_ordered<_Tp, _Up> || __op_eq_lt<_Tp, _Up>
 constexpr strong_ordering
 operator() [[nodiscard]] (_Tp&& __e, _Up&& __f) const
 noexcept(_S_noexcept<_Tp, _Up>())
 {
   if constexpr (__strongly_ordered<_Tp, _Up>)
     return _Strong_order{}(static_cast<_Tp&&>(__e),
       static_cast<_Up&&>(__f));
   else
     return static_cast<_Tp&&>(__e) == static_cast<_Up&&>(__f)
       ? strong_ordering::equal
       : static_cast<_Tp&&>(__e) < static_cast<_Up&&>(__f)
       ? strong_ordering::less
       : strong_ordering::greater;
 }
    };

    class _Weak_fallback
    {
      template<typename _Tp, typename _Up>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (__weakly_ordered<_Tp, _Up>)
     return _Weak_order::_S_noexcept<_Tp, _Up>();
   else
     return noexcept(bool(std::declval<_Tp>() == std::declval<_Up>()))
       && noexcept(bool(std::declval<_Tp>() < std::declval<_Up>()));
 }

    public:
      template<typename _Tp, __decayed_same_as<_Tp> _Up>
 requires __weakly_ordered<_Tp, _Up> || __op_eq_lt<_Tp, _Up>
 constexpr weak_ordering
 operator() [[nodiscard]] (_Tp&& __e, _Up&& __f) const
 noexcept(_S_noexcept<_Tp, _Up>())
 {
   if constexpr (__weakly_ordered<_Tp, _Up>)
     return _Weak_order{}(static_cast<_Tp&&>(__e),
     static_cast<_Up&&>(__f));
   else
     return static_cast<_Tp&&>(__e) == static_cast<_Up&&>(__f)
       ? weak_ordering::equivalent
       : static_cast<_Tp&&>(__e) < static_cast<_Up&&>(__f)
       ? weak_ordering::less
       : weak_ordering::greater;
 }
    };



    template<typename _Tp, typename _Up>
      concept __op_eq_lt_lt = __op_eq_lt<_Tp, _Up>
 && requires(_Tp&& __t, _Up&& __u)
 {
   { static_cast<_Up&&>(__u) < static_cast<_Tp&&>(__t) }
     -> convertible_to<bool>;
 };

    class _Partial_fallback
    {
      template<typename _Tp, typename _Up>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (__partially_ordered<_Tp, _Up>)
     return _Partial_order::_S_noexcept<_Tp, _Up>();
   else
     return noexcept(bool(std::declval<_Tp>() == std::declval<_Up>()))
       && noexcept(bool(std::declval<_Tp>() < std::declval<_Up>()));
 }

    public:
      template<typename _Tp, __decayed_same_as<_Tp> _Up>
 requires __partially_ordered<_Tp, _Up> || __op_eq_lt_lt<_Tp, _Up>
 constexpr partial_ordering
 operator() [[nodiscard]] (_Tp&& __e, _Up&& __f) const
 noexcept(_S_noexcept<_Tp, _Up>())
 {
   if constexpr (__partially_ordered<_Tp, _Up>)
     return _Partial_order{}(static_cast<_Tp&&>(__e),
        static_cast<_Up&&>(__f));
   else
     return static_cast<_Tp&&>(__e) == static_cast<_Up&&>(__f)
       ? partial_ordering::equivalent
       : static_cast<_Tp&&>(__e) < static_cast<_Up&&>(__f)
       ? partial_ordering::less
       : static_cast<_Up&&>(__f) < static_cast<_Tp&&>(__e)
       ? partial_ordering::greater
       : partial_ordering::unordered;
 }
    };
  }



  inline namespace _Cpo
  {
    inline constexpr __compare::_Strong_order strong_order{};

    inline constexpr __compare::_Weak_order weak_order{};

    inline constexpr __compare::_Partial_order partial_order{};

    inline constexpr __compare::_Strong_fallback
      compare_strong_order_fallback{};

    inline constexpr __compare::_Weak_fallback
      compare_weak_order_fallback{};

    inline constexpr __compare::_Partial_fallback
      compare_partial_order_fallback{};
  }


  namespace __detail
  {

    inline constexpr struct _Synth3way
    {
      template<typename _Tp, typename _Up>
 static constexpr bool
 _S_noexcept(const _Tp* __t = nullptr, const _Up* __u = nullptr)
 {
   if constexpr (three_way_comparable_with<_Tp, _Up>)
     return noexcept(*__t <=> *__u);
   else
     return noexcept(*__t < *__u) && noexcept(*__u < *__t);
 }

      template<typename _Tp, typename _Up>
 [[nodiscard]]
 constexpr auto
 operator()(const _Tp& __t, const _Up& __u) const
 noexcept(_S_noexcept<_Tp, _Up>())
 requires requires
 {
   { __t < __u } -> __boolean_testable;
   { __u < __t } -> __boolean_testable;
 }
 {
   if constexpr (three_way_comparable_with<_Tp, _Up>)
     return __t <=> __u;
   else
     {
       if (__t < __u)
  return weak_ordering::less;
       else if (__u < __t)
  return weak_ordering::greater;
       else
  return weak_ordering::equivalent;
     }
 }
    } __synth3way = {};


    template<typename _Tp, typename _Up = _Tp>
      using __synth3way_t
 = decltype(__detail::__synth3way(std::declval<_Tp&>(),
      std::declval<_Up&>()));
  }


}
# 66 "/usr/include/c++/14.2.1/bits/stl_pair.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{

# 79 "/usr/include/c++/14.2.1/bits/stl_pair.h" 3
  struct piecewise_construct_t { explicit piecewise_construct_t() = default; };


  inline constexpr piecewise_construct_t piecewise_construct =
    piecewise_construct_t();




  template<typename _T1, typename _T2>
    struct pair;

  template<typename...>
    class tuple;





  template<typename _Tp, size_t _Nm>
    struct array;

  template<size_t...>
    struct _Index_tuple;

  template<size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&
    get(pair<_Tp1, _Tp2>& __in) noexcept;

  template<size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&&
    get(pair<_Tp1, _Tp2>&& __in) noexcept;

  template<size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&
    get(const pair<_Tp1, _Tp2>& __in) noexcept;

  template<size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&&
    get(const pair<_Tp1, _Tp2>&& __in) noexcept;

  template<size_t __i, typename... _Elements>
    constexpr __tuple_element_t<__i, tuple<_Elements...>>&
    get(tuple<_Elements...>& __t) noexcept;

  template<size_t __i, typename... _Elements>
    constexpr const __tuple_element_t<__i, tuple<_Elements...>>&
    get(const tuple<_Elements...>& __t) noexcept;

  template<size_t __i, typename... _Elements>
    constexpr __tuple_element_t<__i, tuple<_Elements...>>&&
    get(tuple<_Elements...>&& __t) noexcept;

  template<size_t __i, typename... _Elements>
    constexpr const __tuple_element_t<__i, tuple<_Elements...>>&&
    get(const tuple<_Elements...>&& __t) noexcept;

  template<size_t _Int, typename _Tp, size_t _Nm>
    constexpr _Tp&
    get(array<_Tp, _Nm>&) noexcept;

  template<size_t _Int, typename _Tp, size_t _Nm>
    constexpr _Tp&&
    get(array<_Tp, _Nm>&&) noexcept;

  template<size_t _Int, typename _Tp, size_t _Nm>
    constexpr const _Tp&
    get(const array<_Tp, _Nm>&) noexcept;

  template<size_t _Int, typename _Tp, size_t _Nm>
    constexpr const _Tp&&
    get(const array<_Tp, _Nm>&&) noexcept;
# 260 "/usr/include/c++/14.2.1/bits/stl_pair.h" 3
  template<typename _U1, typename _U2> class __pair_base
  {







  };
# 283 "/usr/include/c++/14.2.1/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    struct pair
    : public __pair_base<_T1, _T2>
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;


      constexpr pair(const pair&) = default;
      constexpr pair(pair&&) = default;

      template<typename... _Args1, typename... _Args2>
 constexpr
 pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);


      constexpr void
      swap(pair& __p)
      noexcept(__and_<__is_nothrow_swappable<_T1>,
        __is_nothrow_swappable<_T2>>::value)
      {
 using std::swap;
 swap(first, __p.first);
 swap(second, __p.second);
      }
# 331 "/usr/include/c++/14.2.1/bits/stl_pair.h" 3
    private:
      template<typename... _Args1, size_t... _Indexes1,
        typename... _Args2, size_t... _Indexes2>
 constexpr
 pair(tuple<_Args1...>&, tuple<_Args2...>&,
      _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);
    public:





      constexpr
      explicit(__not_<__and_<__is_implicitly_default_constructible<_T1>,
        __is_implicitly_default_constructible<_T2>>>())
      pair()
      requires is_default_constructible_v<_T1>
        && is_default_constructible_v<_T2>
      : first(), second()
      { }

    private:


      template<typename _U1, typename _U2>
 static constexpr bool
 _S_constructible()
 {
   if constexpr (is_constructible_v<_T1, _U1>)
     return is_constructible_v<_T2, _U2>;
   return false;
 }

      template<typename _U1, typename _U2>
 static constexpr bool
 _S_nothrow_constructible()
 {
   if constexpr (is_nothrow_constructible_v<_T1, _U1>)
     return is_nothrow_constructible_v<_T2, _U2>;
   return false;
 }

      template<typename _U1, typename _U2>
 static constexpr bool
 _S_convertible()
 {
   if constexpr (is_convertible_v<_U1, _T1>)
     return is_convertible_v<_U2, _T2>;
   return false;
 }


      template<typename _U1, typename _U2>
 static constexpr bool
 _S_dangles()
 {

   if constexpr (__reference_constructs_from_temporary(_T1, _U1&&))
     return true;
   else
     return __reference_constructs_from_temporary(_T2, _U2&&);



 }
# 424 "/usr/include/c++/14.2.1/bits/stl_pair.h" 3
    public:


      constexpr explicit(!_S_convertible<const _T1&, const _T2&>())
      pair(const _T1& __x, const _T2& __y)
      noexcept(_S_nothrow_constructible<const _T1&, const _T2&>())
      requires (_S_constructible<const _T1&, const _T2&>())
      : first(__x), second(__y)
      { }





      template<typename _U1, typename _U2>

 requires (_S_constructible<_U1, _U2>()) && (!_S_dangles<_U1, _U2>())
 constexpr explicit(!_S_convertible<_U1, _U2>())
 pair(_U1&& __x, _U2&& __y)
 noexcept(_S_nothrow_constructible<_U1, _U2>())
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y))
 { }




      template<typename _U1, typename _U2>

 requires (_S_constructible<_U1, _U2>()) && (_S_dangles<_U1, _U2>())
 constexpr explicit(!_S_convertible<_U1, _U2>())
 pair(_U1&&, _U2&&) = delete;


      template<typename _U1, typename _U2>
 requires (_S_constructible<const _U1&, const _U2&>())
   && (!_S_dangles<_U1, _U2>())
 constexpr explicit(!_S_convertible<const _U1&, const _U2&>())
 pair(const pair<_U1, _U2>& __p)
 noexcept(_S_nothrow_constructible<const _U1&, const _U2&>())
 : first(__p.first), second(__p.second)
 { }

      template<typename _U1, typename _U2>
 requires (_S_constructible<const _U1&, const _U2&>())
       && (_S_dangles<const _U1&, const _U2&>())
 constexpr explicit(!_S_convertible<const _U1&, const _U2&>())
 pair(const pair<_U1, _U2>&) = delete;


      template<typename _U1, typename _U2>
 requires (_S_constructible<_U1, _U2>()) && (!_S_dangles<_U1, _U2>())
 constexpr explicit(!_S_convertible<_U1, _U2>())
 pair(pair<_U1, _U2>&& __p)
 noexcept(_S_nothrow_constructible<_U1, _U2>())
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second))
 { }

      template<typename _U1, typename _U2>
 requires (_S_constructible<_U1, _U2>()) && (_S_dangles<_U1, _U2>())
 constexpr explicit(!_S_convertible<_U1, _U2>())
 pair(pair<_U1, _U2>&&) = delete;
# 537 "/usr/include/c++/14.2.1/bits/stl_pair.h" 3
  private:

      template<typename _U1, typename _U2>
 static constexpr bool
 _S_assignable()
 {
   if constexpr (is_assignable_v<_T1&, _U1>)
     return is_assignable_v<_T2&, _U2>;
   return false;
 }

      template<typename _U1, typename _U2>
 static constexpr bool
 _S_const_assignable()
 {
   if constexpr (is_assignable_v<const _T1&, _U1>)
     return is_assignable_v<const _T2&, _U2>;
   return false;
 }

      template<typename _U1, typename _U2>
 static constexpr bool
 _S_nothrow_assignable()
 {
   if constexpr (is_nothrow_assignable_v<_T1&, _U1>)
     return is_nothrow_assignable_v<_T2&, _U2>;
   return false;
 }
# 585 "/usr/include/c++/14.2.1/bits/stl_pair.h" 3
  public:

      pair& operator=(const pair&) = delete;


      constexpr pair&
      operator=(const pair& __p)
      noexcept(_S_nothrow_assignable<const _T1&, const _T2&>())
      requires (_S_assignable<const _T1&, const _T2&>())
      {
 first = __p.first;
 second = __p.second;
 return *this;
      }


      constexpr pair&
      operator=(pair&& __p)
      noexcept(_S_nothrow_assignable<_T1, _T2>())
      requires (_S_assignable<_T1, _T2>())
      {
 first = std::forward<first_type>(__p.first);
 second = std::forward<second_type>(__p.second);
 return *this;
      }


      template<typename _U1, typename _U2>
 constexpr pair&
 operator=(const pair<_U1, _U2>& __p)
 noexcept(_S_nothrow_assignable<const _U1&, const _U2&>())
 requires (_S_assignable<const _U1&, const _U2&>())
 {
   first = __p.first;
   second = __p.second;
   return *this;
 }


      template<typename _U1, typename _U2>
 constexpr pair&
 operator=(pair<_U1, _U2>&& __p)
 noexcept(_S_nothrow_assignable<_U1, _U2>())
 requires (_S_assignable<_U1, _U2>())
 {
   first = std::forward<_U1>(__p.first);
   second = std::forward<_U2>(__p.second);
   return *this;
 }
# 995 "/usr/include/c++/14.2.1/bits/stl_pair.h" 3
    };




  template<typename _T1, typename _T2> pair(_T1, _T2) -> pair<_T1, _T2>;







  template<typename _T1, typename _T2, typename _U1, typename _U2>
    inline constexpr bool
    operator==(const pair<_T1, _T2>& __x, const pair<_U1, _U2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }
# 1020 "/usr/include/c++/14.2.1/bits/stl_pair.h" 3
  template<typename _T1, typename _T2, typename _U1, typename _U2>
    constexpr common_comparison_category_t<__detail::__synth3way_t<_T1, _U1>,
        __detail::__synth3way_t<_T2, _U2>>
    operator<=>(const pair<_T1, _T2>& __x, const pair<_U1, _U2>& __y)
    {
      if (auto __c = __detail::__synth3way(__x.first, __y.first); __c != 0)
 return __c;
      return __detail::__synth3way(__x.second, __y.second);
    }
# 1080 "/usr/include/c++/14.2.1/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    constexpr inline


    typename enable_if<__and_<__is_swappable<_T1>,
                              __is_swappable<_T2>>::value>::type



    swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }
# 1103 "/usr/include/c++/14.2.1/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    typename enable_if<!__and_<__is_swappable<_T1>,
          __is_swappable<_T2>>::value>::type
    swap(pair<_T1, _T2>&, pair<_T1, _T2>&) = delete;
# 1129 "/usr/include/c++/14.2.1/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    constexpr pair<typename __decay_and_strip<_T1>::__type,
                   typename __decay_and_strip<_T2>::__type>
    make_pair(_T1&& __x, _T2&& __y)
    {
      typedef typename __decay_and_strip<_T1>::__type __ds_type1;
      typedef typename __decay_and_strip<_T2>::__type __ds_type2;
      typedef pair<__ds_type1, __ds_type2> __pair_type;
      return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
    }
# 1152 "/usr/include/c++/14.2.1/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    struct __is_tuple_like_impl<pair<_T1, _T2>> : true_type
    { };



  template<class _Tp1, class _Tp2>
    struct tuple_size<pair<_Tp1, _Tp2>>
    : public integral_constant<size_t, 2> { };


  template<class _Tp1, class _Tp2>
    struct tuple_element<0, pair<_Tp1, _Tp2>>
    { typedef _Tp1 type; };


  template<class _Tp1, class _Tp2>
    struct tuple_element<1, pair<_Tp1, _Tp2>>
    { typedef _Tp2 type; };



  template<size_t __i, typename... _Types>
    struct tuple_element<__i, tuple<_Types...>>;


  template<typename _Tp1, typename _Tp2>
    inline constexpr size_t tuple_size_v<pair<_Tp1, _Tp2>> = 2;

  template<typename _Tp1, typename _Tp2>
    inline constexpr size_t tuple_size_v<const pair<_Tp1, _Tp2>> = 2;

  template<typename _Tp>
    inline constexpr bool __is_pair = false;

  template<typename _Tp, typename _Up>
    inline constexpr bool __is_pair<pair<_Tp, _Up>> = true;



  template<size_t _Int>
    struct __pair_get;

  template<>
    struct __pair_get<0>
    {
      template<typename _Tp1, typename _Tp2>
 static constexpr _Tp1&
 __get(pair<_Tp1, _Tp2>& __pair) noexcept
 { return __pair.first; }

      template<typename _Tp1, typename _Tp2>
 static constexpr _Tp1&&
 __move_get(pair<_Tp1, _Tp2>&& __pair) noexcept
 { return std::forward<_Tp1>(__pair.first); }

      template<typename _Tp1, typename _Tp2>
 static constexpr const _Tp1&
 __const_get(const pair<_Tp1, _Tp2>& __pair) noexcept
 { return __pair.first; }

      template<typename _Tp1, typename _Tp2>
 static constexpr const _Tp1&&
 __const_move_get(const pair<_Tp1, _Tp2>&& __pair) noexcept
 { return std::forward<const _Tp1>(__pair.first); }
    };

  template<>
    struct __pair_get<1>
    {
      template<typename _Tp1, typename _Tp2>
 static constexpr _Tp2&
 __get(pair<_Tp1, _Tp2>& __pair) noexcept
 { return __pair.second; }

      template<typename _Tp1, typename _Tp2>
 static constexpr _Tp2&&
 __move_get(pair<_Tp1, _Tp2>&& __pair) noexcept
 { return std::forward<_Tp2>(__pair.second); }

      template<typename _Tp1, typename _Tp2>
 static constexpr const _Tp2&
 __const_get(const pair<_Tp1, _Tp2>& __pair) noexcept
 { return __pair.second; }

      template<typename _Tp1, typename _Tp2>
 static constexpr const _Tp2&&
 __const_move_get(const pair<_Tp1, _Tp2>&& __pair) noexcept
 { return std::forward<const _Tp2>(__pair.second); }
    };






  template<size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&
    get(pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__get(__in); }

  template<size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&&
    get(pair<_Tp1, _Tp2>&& __in) noexcept
    { return __pair_get<_Int>::__move_get(std::move(__in)); }

  template<size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&
    get(const pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__const_get(__in); }

  template<size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&&
    get(const pair<_Tp1, _Tp2>&& __in) noexcept
    { return __pair_get<_Int>::__const_move_get(std::move(__in)); }



  template <typename _Tp, typename _Up>
    constexpr _Tp&
    get(pair<_Tp, _Up>& __p) noexcept
    { return __p.first; }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&
    get(const pair<_Tp, _Up>& __p) noexcept
    { return __p.first; }

  template <typename _Tp, typename _Up>
    constexpr _Tp&&
    get(pair<_Tp, _Up>&& __p) noexcept
    { return std::move(__p.first); }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&&
    get(const pair<_Tp, _Up>&& __p) noexcept
    { return std::move(__p.first); }

  template <typename _Tp, typename _Up>
    constexpr _Tp&
    get(pair<_Up, _Tp>& __p) noexcept
    { return __p.second; }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&
    get(const pair<_Up, _Tp>& __p) noexcept
    { return __p.second; }

  template <typename _Tp, typename _Up>
    constexpr _Tp&&
    get(pair<_Up, _Tp>&& __p) noexcept
    { return std::move(__p.second); }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&&
    get(const pair<_Up, _Tp>&& __p) noexcept
    { return std::move(__p.second); }
# 1332 "/usr/include/c++/14.2.1/bits/stl_pair.h" 3

}
# 65 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/14.2.1/bits/stl_iterator_base_types.h" 1 3
# 62 "/usr/include/c++/14.2.1/bits/stl_iterator_base_types.h" 3
       
# 63 "/usr/include/c++/14.2.1/bits/stl_iterator_base_types.h" 3
# 71 "/usr/include/c++/14.2.1/bits/stl_iterator_base_types.h" 3
# 1 "/usr/include/c++/14.2.1/bits/iterator_concepts.h" 1 3
# 33 "/usr/include/c++/14.2.1/bits/iterator_concepts.h" 3
       
# 34 "/usr/include/c++/14.2.1/bits/iterator_concepts.h" 3



# 1 "/usr/include/c++/14.2.1/bits/ptr_traits.h" 1 3
# 39 "/usr/include/c++/14.2.1/bits/ptr_traits.h" 3
namespace __gnu_debug { struct _Safe_iterator_base; }


namespace std __attribute__ ((__visibility__ ("default")))
{




  class __undefined;



  template<typename _Tp>
    struct __get_first_arg
    { using type = __undefined; };

  template<template<typename, typename...> class _SomeTemplate, typename _Tp,
           typename... _Types>
    struct __get_first_arg<_SomeTemplate<_Tp, _Types...>>
    { using type = _Tp; };



  template<typename _Tp, typename _Up>
    struct __replace_first_arg
    { };

  template<template<typename, typename...> class _SomeTemplate, typename _Up,
           typename _Tp, typename... _Types>
    struct __replace_first_arg<_SomeTemplate<_Tp, _Types...>, _Up>
    { using type = _SomeTemplate<_Up, _Types...>; };


  template<typename _Ptr, typename = void>
    struct __ptr_traits_elem : __get_first_arg<_Ptr>
    { };



  template<typename _Ptr> requires requires { typename _Ptr::element_type; }
    struct __ptr_traits_elem<_Ptr, void>
    { using type = typename _Ptr::element_type; };






  template<typename _Ptr>
    using __ptr_traits_elem_t = typename __ptr_traits_elem<_Ptr>::type;




  template<typename _Ptr, typename _Elt, bool = is_void<_Elt>::value>
    struct __ptr_traits_ptr_to
    {
      using pointer = _Ptr;
      using element_type = _Elt;







      static pointer
      pointer_to(element_type& __r)

      requires requires {
 { pointer::pointer_to(__r) } -> convertible_to<pointer>;
      }

      { return pointer::pointer_to(__r); }
    };


  template<typename _Ptr, typename _Elt>
    struct __ptr_traits_ptr_to<_Ptr, _Elt, true>
    { };


  template<typename _Tp>
    struct __ptr_traits_ptr_to<_Tp*, _Tp, false>
    {
      using pointer = _Tp*;
      using element_type = _Tp;






      static constexpr pointer
      pointer_to(element_type& __r) noexcept
      { return std::addressof(__r); }
    };

  template<typename _Ptr, typename _Elt>
    struct __ptr_traits_impl : __ptr_traits_ptr_to<_Ptr, _Elt>
    {
    private:
      template<typename _Tp>
 using __diff_t = typename _Tp::difference_type;

      template<typename _Tp, typename _Up>
 using __rebind = __type_identity<typename _Tp::template rebind<_Up>>;

    public:

      using pointer = _Ptr;


      using element_type = _Elt;


      using difference_type = __detected_or_t<ptrdiff_t, __diff_t, _Ptr>;


      template<typename _Up>
 using rebind = typename __detected_or_t<__replace_first_arg<_Ptr, _Up>,
      __rebind, _Ptr, _Up>::type;
    };



  template<typename _Ptr>
    struct __ptr_traits_impl<_Ptr, __undefined>
    { };







  template<typename _Ptr>
    struct pointer_traits : __ptr_traits_impl<_Ptr, __ptr_traits_elem_t<_Ptr>>
    { };







  template<typename _Tp>
    struct pointer_traits<_Tp*> : __ptr_traits_ptr_to<_Tp*, _Tp>
    {

      typedef _Tp* pointer;

      typedef _Tp element_type;

      typedef ptrdiff_t difference_type;

      template<typename _Up> using rebind = _Up*;
    };


  template<typename _Ptr, typename _Tp>
    using __ptr_rebind = typename pointer_traits<_Ptr>::template rebind<_Tp>;

  template<typename _Tp>
    constexpr _Tp*
    __to_address(_Tp* __ptr) noexcept
    {
      static_assert(!std::is_function<_Tp>::value, "not a function pointer");
      return __ptr;
    }







  template<typename _Ptr>
    constexpr auto
    __to_address(const _Ptr& __ptr) noexcept
    -> decltype(std::pointer_traits<_Ptr>::to_address(__ptr))
    { return std::pointer_traits<_Ptr>::to_address(__ptr); }

  template<typename _Ptr, typename... _None>
    constexpr auto
    __to_address(const _Ptr& __ptr, _None...) noexcept
    {
      if constexpr (is_base_of_v<__gnu_debug::_Safe_iterator_base, _Ptr>)
 return std::__to_address(__ptr.base().operator->());
      else
 return std::__to_address(__ptr.operator->());
    }







  template<typename _Tp>
    constexpr _Tp*
    to_address(_Tp* __ptr) noexcept
    { return std::__to_address(__ptr); }
# 251 "/usr/include/c++/14.2.1/bits/ptr_traits.h" 3
  template<typename _Ptr>
    constexpr auto
    to_address(const _Ptr& __ptr) noexcept
    { return std::__to_address(__ptr); }



}
# 38 "/usr/include/c++/14.2.1/bits/iterator_concepts.h" 2 3
# 1 "/usr/include/c++/14.2.1/bits/ranges_cmp.h" 1 3
# 37 "/usr/include/c++/14.2.1/bits/ranges_cmp.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  struct __is_transparent;





  struct identity
  {
    template<typename _Tp>
      [[nodiscard]]
      constexpr _Tp&&
      operator()(_Tp&& __t) const noexcept
      { return std::forward<_Tp>(__t); }

    using is_transparent = __is_transparent;
  };


namespace ranges
{
  namespace __detail
  {



    template<typename _Tp, typename _Up>
      concept __less_builtin_ptr_cmp
 = requires (_Tp&& __t, _Up&& __u) { { __t < __u } -> same_as<bool>; }
   && convertible_to<_Tp, const volatile void*>
   && convertible_to<_Up, const volatile void*>
   && (! requires(_Tp&& __t, _Up&& __u)
       { operator<(std::forward<_Tp>(__t), std::forward<_Up>(__u)); }
       && ! requires(_Tp&& __t, _Up&& __u)
       { std::forward<_Tp>(__t).operator<(std::forward<_Up>(__u)); });
  }







  struct equal_to
  {
    template<typename _Tp, typename _Up>
      requires equality_comparable_with<_Tp, _Up>
      constexpr bool
      operator()(_Tp&& __t, _Up&& __u) const
      noexcept(noexcept(std::declval<_Tp>() == std::declval<_Up>()))
      { return std::forward<_Tp>(__t) == std::forward<_Up>(__u); }

    using is_transparent = __is_transparent;
  };


  struct not_equal_to
  {
    template<typename _Tp, typename _Up>
      requires equality_comparable_with<_Tp, _Up>
      constexpr bool
      operator()(_Tp&& __t, _Up&& __u) const
      noexcept(noexcept(std::declval<_Up>() == std::declval<_Tp>()))
      { return !equal_to{}(std::forward<_Tp>(__t), std::forward<_Up>(__u)); }

    using is_transparent = __is_transparent;
  };


  struct less
  {
    template<typename _Tp, typename _Up>
      requires totally_ordered_with<_Tp, _Up>
      constexpr bool
      operator()(_Tp&& __t, _Up&& __u) const
      noexcept(noexcept(std::declval<_Tp>() < std::declval<_Up>()))
      {
 if constexpr (__detail::__less_builtin_ptr_cmp<_Tp, _Up>)
   {
     if (std::__is_constant_evaluated())
       return __t < __u;

     auto __x = reinterpret_cast<long unsigned int>(
       static_cast<const volatile void*>(std::forward<_Tp>(__t)));
     auto __y = reinterpret_cast<long unsigned int>(
       static_cast<const volatile void*>(std::forward<_Up>(__u)));
     return __x < __y;
   }
 else
   return std::forward<_Tp>(__t) < std::forward<_Up>(__u);
      }

    using is_transparent = __is_transparent;
  };


  struct greater
  {
    template<typename _Tp, typename _Up>
      requires totally_ordered_with<_Tp, _Up>
      constexpr bool
      operator()(_Tp&& __t, _Up&& __u) const
      noexcept(noexcept(std::declval<_Up>() < std::declval<_Tp>()))
      { return less{}(std::forward<_Up>(__u), std::forward<_Tp>(__t)); }

    using is_transparent = __is_transparent;
  };


  struct greater_equal
  {
    template<typename _Tp, typename _Up>
      requires totally_ordered_with<_Tp, _Up>
      constexpr bool
      operator()(_Tp&& __t, _Up&& __u) const
      noexcept(noexcept(std::declval<_Tp>() < std::declval<_Up>()))
      { return !less{}(std::forward<_Tp>(__t), std::forward<_Up>(__u)); }

    using is_transparent = __is_transparent;
  };


  struct less_equal
  {
    template<typename _Tp, typename _Up>
      requires totally_ordered_with<_Tp, _Up>
      constexpr bool
      operator()(_Tp&& __t, _Up&& __u) const
      noexcept(noexcept(std::declval<_Up>() < std::declval<_Tp>()))
      { return !less{}(std::forward<_Up>(__u), std::forward<_Tp>(__t)); }

    using is_transparent = __is_transparent;
  };

}


}
# 39 "/usr/include/c++/14.2.1/bits/iterator_concepts.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 58 "/usr/include/c++/14.2.1/bits/iterator_concepts.h" 3
  struct default_sentinel_t { };


  inline constexpr default_sentinel_t default_sentinel{};


  struct input_iterator_tag;
  struct output_iterator_tag;
  struct forward_iterator_tag;
  struct bidirectional_iterator_tag;
  struct random_access_iterator_tag;
  struct contiguous_iterator_tag;

  template<typename _Iterator>
    struct iterator_traits;

  template<typename _Tp> requires is_object_v<_Tp>
    struct iterator_traits<_Tp*>;

  template<typename _Iterator, typename>
    struct __iterator_traits;

  namespace __detail
  {
    template<typename _Tp>
      using __with_ref = _Tp&;

    template<typename _Tp>
      concept __can_reference = requires { typename __with_ref<_Tp>; };

    template<typename _Tp>
      concept __dereferenceable = requires(_Tp& __t)
 {
   { *__t } -> __can_reference;
 };
  }

  template<__detail::__dereferenceable _Tp>
    using iter_reference_t = decltype(*std::declval<_Tp&>());

  namespace ranges
  {

    namespace __imove
    {
      void iter_move() = delete;

      template<typename _Tp>
 concept __adl_imove
   = (std::__detail::__class_or_enum<remove_reference_t<_Tp>>)
   && requires(_Tp&& __t) { iter_move(static_cast<_Tp&&>(__t)); };

      struct _IterMove
      {
      private:
 template<typename _Tp>
   struct __result
   { using type = iter_reference_t<_Tp>; };

 template<typename _Tp>
   requires __adl_imove<_Tp>
   struct __result<_Tp>
   { using type = decltype(iter_move(std::declval<_Tp>())); };

 template<typename _Tp>
   requires (!__adl_imove<_Tp>)
   && is_lvalue_reference_v<iter_reference_t<_Tp>>
   struct __result<_Tp>
   { using type = remove_reference_t<iter_reference_t<_Tp>>&&; };

 template<typename _Tp>
   static constexpr bool
   _S_noexcept()
   {
     if constexpr (__adl_imove<_Tp>)
       return noexcept(iter_move(std::declval<_Tp>()));
     else
       return noexcept(*std::declval<_Tp>());
   }

      public:

 template<std::__detail::__dereferenceable _Tp>
   using __type = typename __result<_Tp>::type;

 template<std::__detail::__dereferenceable _Tp>
   [[nodiscard]]
   constexpr __type<_Tp>
   operator()(_Tp&& __e) const
   noexcept(_S_noexcept<_Tp>())
   {
     if constexpr (__adl_imove<_Tp>)
       return iter_move(static_cast<_Tp&&>(__e));
     else if constexpr (is_lvalue_reference_v<iter_reference_t<_Tp>>)
       return static_cast<__type<_Tp>>(*__e);
     else
       return *__e;
   }
      };
    }


    inline namespace _Cpo {
      inline constexpr __imove::_IterMove iter_move{};
    }
  }

  template<__detail::__dereferenceable _Tp>
    requires __detail::__can_reference<ranges::__imove::_IterMove::__type<_Tp&>>
    using iter_rvalue_reference_t = ranges::__imove::_IterMove::__type<_Tp&>;

  template<typename> struct incrementable_traits { };

  template<typename _Tp> requires is_object_v<_Tp>
    struct incrementable_traits<_Tp*>
    { using difference_type = ptrdiff_t; };

  template<typename _Iter>
    struct incrementable_traits<const _Iter>
    : incrementable_traits<_Iter> { };

  template<typename _Tp> requires requires { typename _Tp::difference_type; }
    struct incrementable_traits<_Tp>
    { using difference_type = typename _Tp::difference_type; };

  template<typename _Tp>
    requires (!requires { typename _Tp::difference_type; }
       && requires(const _Tp& __a, const _Tp& __b)
       { { __a - __b } -> integral; })
    struct incrementable_traits<_Tp>
    {
      using difference_type
 = make_signed_t<decltype(std::declval<_Tp>() - std::declval<_Tp>())>;
    };
# 204 "/usr/include/c++/14.2.1/bits/iterator_concepts.h" 3
  namespace __detail
  {


    template<typename _Iter>
      concept __primary_traits_iter
 = __is_base_of(__iterator_traits<_Iter, void>, iterator_traits<_Iter>);

    template<typename _Iter, typename _Tp>
      struct __iter_traits_impl
      { using type = iterator_traits<_Iter>; };

    template<typename _Iter, typename _Tp>
      requires __primary_traits_iter<_Iter>
      struct __iter_traits_impl<_Iter, _Tp>
      { using type = _Tp; };


    template<typename _Iter, typename _Tp = _Iter>
      using __iter_traits = typename __iter_traits_impl<_Iter, _Tp>::type;

    template<typename _Tp>
      using __iter_diff_t = typename
 __iter_traits<_Tp, incrementable_traits<_Tp>>::difference_type;
  }

  template<typename _Tp>
    using iter_difference_t = __detail::__iter_diff_t<remove_cvref_t<_Tp>>;

  namespace __detail
  {
    template<typename> struct __cond_value_type { };

    template<typename _Tp> requires is_object_v<_Tp>
      struct __cond_value_type<_Tp>
      { using value_type = remove_cv_t<_Tp>; };

    template<typename _Tp>
      concept __has_member_value_type
 = requires { typename _Tp::value_type; };

    template<typename _Tp>
      concept __has_member_element_type
 = requires { typename _Tp::element_type; };

  }

  template<typename> struct indirectly_readable_traits { };

  template<typename _Tp>
    struct indirectly_readable_traits<_Tp*>
    : __detail::__cond_value_type<_Tp>
    { };

  template<typename _Iter> requires is_array_v<_Iter>
    struct indirectly_readable_traits<_Iter>
    { using value_type = remove_cv_t<remove_extent_t<_Iter>>; };

  template<typename _Iter>
    struct indirectly_readable_traits<const _Iter>
    : indirectly_readable_traits<_Iter>
    { };

  template<__detail::__has_member_value_type _Tp>
    struct indirectly_readable_traits<_Tp>
    : __detail::__cond_value_type<typename _Tp::value_type>
    { };

  template<__detail::__has_member_element_type _Tp>
    struct indirectly_readable_traits<_Tp>
    : __detail::__cond_value_type<typename _Tp::element_type>
    { };



  template<__detail::__has_member_value_type _Tp>
    requires __detail::__has_member_element_type<_Tp>
    && same_as<remove_cv_t<typename _Tp::element_type>,
        remove_cv_t<typename _Tp::value_type>>
    struct indirectly_readable_traits<_Tp>
    : __detail::__cond_value_type<typename _Tp::value_type>
    { };



  template<__detail::__has_member_value_type _Tp>
    requires __detail::__has_member_element_type<_Tp>
    struct indirectly_readable_traits<_Tp>
    { };

  namespace __detail
  {
    template<typename _Tp>
      using __iter_value_t = typename
 __iter_traits<_Tp, indirectly_readable_traits<_Tp>>::value_type;
  }

  template<typename _Tp>
    using iter_value_t = __detail::__iter_value_t<remove_cvref_t<_Tp>>;

  namespace __detail
  {


    template<typename _Iter>
      concept __cpp17_iterator = requires(_Iter __it)
 {
   { *__it } -> __can_reference;
   { ++__it } -> same_as<_Iter&>;
   { *__it++ } -> __can_reference;
 } && copyable<_Iter>;

    template<typename _Iter>
      concept __cpp17_input_iterator = __cpp17_iterator<_Iter>
 && equality_comparable<_Iter>
 && requires(_Iter __it)
 {
   typename incrementable_traits<_Iter>::difference_type;
   typename indirectly_readable_traits<_Iter>::value_type;
   typename common_reference_t<iter_reference_t<_Iter>&&,
     typename indirectly_readable_traits<_Iter>::value_type&>;
   typename common_reference_t<decltype(*__it++)&&,
     typename indirectly_readable_traits<_Iter>::value_type&>;
   requires signed_integral<
     typename incrementable_traits<_Iter>::difference_type>;
 };

    template<typename _Iter>
      concept __cpp17_fwd_iterator = __cpp17_input_iterator<_Iter>
 && constructible_from<_Iter>
 && is_lvalue_reference_v<iter_reference_t<_Iter>>
 && same_as<remove_cvref_t<iter_reference_t<_Iter>>,
     typename indirectly_readable_traits<_Iter>::value_type>
 && requires(_Iter __it)
 {
   { __it++ } -> convertible_to<const _Iter&>;
   { *__it++ } -> same_as<iter_reference_t<_Iter>>;
 };

    template<typename _Iter>
      concept __cpp17_bidi_iterator = __cpp17_fwd_iterator<_Iter>
 && requires(_Iter __it)
 {
   { --__it } -> same_as<_Iter&>;
   { __it-- } -> convertible_to<const _Iter&>;
   { *__it-- } -> same_as<iter_reference_t<_Iter>>;
 };

    template<typename _Iter>
      concept __cpp17_randacc_iterator = __cpp17_bidi_iterator<_Iter>
 && totally_ordered<_Iter>
 && requires(_Iter __it,
      typename incrementable_traits<_Iter>::difference_type __n)
 {
   { __it += __n } -> same_as<_Iter&>;
   { __it -= __n } -> same_as<_Iter&>;
   { __it + __n } -> same_as<_Iter>;
   { __n + __it } -> same_as<_Iter>;
   { __it - __n } -> same_as<_Iter>;
   { __it - __it } -> same_as<decltype(__n)>;
   { __it[__n] } -> convertible_to<iter_reference_t<_Iter>>;
 };

    template<typename _Iter>
      concept __iter_with_nested_types = requires {
 typename _Iter::iterator_category;
 typename _Iter::value_type;
 typename _Iter::difference_type;
 typename _Iter::reference;
      };

    template<typename _Iter>
      concept __iter_without_nested_types = !__iter_with_nested_types<_Iter>;

    template<typename _Iter>
      concept __iter_without_category
 = !requires { typename _Iter::iterator_category; };

  }

  template<typename _Iterator>
    requires __detail::__iter_with_nested_types<_Iterator>
    struct __iterator_traits<_Iterator, void>
    {
    private:
      template<typename _Iter>
 struct __ptr
 { using type = void; };

      template<typename _Iter> requires requires { typename _Iter::pointer; }
 struct __ptr<_Iter>
 { using type = typename _Iter::pointer; };

    public:
      using iterator_category = typename _Iterator::iterator_category;
      using value_type = typename _Iterator::value_type;
      using difference_type = typename _Iterator::difference_type;
      using pointer = typename __ptr<_Iterator>::type;
      using reference = typename _Iterator::reference;
    };

  template<typename _Iterator>
    requires __detail::__iter_without_nested_types<_Iterator>
       && __detail::__cpp17_input_iterator<_Iterator>
    struct __iterator_traits<_Iterator, void>
    {
    private:
      template<typename _Iter>
 struct __cat
 { using type = input_iterator_tag; };

      template<typename _Iter>
 requires requires { typename _Iter::iterator_category; }
 struct __cat<_Iter>
 { using type = typename _Iter::iterator_category; };

      template<typename _Iter>
 requires __detail::__iter_without_category<_Iter>
    && __detail::__cpp17_randacc_iterator<_Iter>
 struct __cat<_Iter>
 { using type = random_access_iterator_tag; };

      template<typename _Iter>
 requires __detail::__iter_without_category<_Iter>
    && __detail::__cpp17_bidi_iterator<_Iter>
 struct __cat<_Iter>
 { using type = bidirectional_iterator_tag; };

      template<typename _Iter>
 requires __detail::__iter_without_category<_Iter>
    && __detail::__cpp17_fwd_iterator<_Iter>
 struct __cat<_Iter>
 { using type = forward_iterator_tag; };

      template<typename _Iter>
 struct __ptr
 { using type = void; };

      template<typename _Iter> requires requires { typename _Iter::pointer; }
 struct __ptr<_Iter>
 { using type = typename _Iter::pointer; };

      template<typename _Iter>
 requires (!requires { typename _Iter::pointer; }
     && requires(_Iter& __it) { __it.operator->(); })
 struct __ptr<_Iter>
 { using type = decltype(std::declval<_Iter&>().operator->()); };

      template<typename _Iter>
 struct __ref
 { using type = iter_reference_t<_Iter>; };

      template<typename _Iter> requires requires { typename _Iter::reference; }
 struct __ref<_Iter>
 { using type = typename _Iter::reference; };

    public:
      using iterator_category = typename __cat<_Iterator>::type;
      using value_type
 = typename indirectly_readable_traits<_Iterator>::value_type;
      using difference_type
 = typename incrementable_traits<_Iterator>::difference_type;
      using pointer = typename __ptr<_Iterator>::type;
      using reference = typename __ref<_Iterator>::type;
    };

  template<typename _Iterator>
    requires __detail::__iter_without_nested_types<_Iterator>
       && __detail::__cpp17_iterator<_Iterator>
    struct __iterator_traits<_Iterator, void>
    {
    private:
      template<typename _Iter>
 struct __diff
 { using type = void; };

      template<typename _Iter>
 requires requires
 { typename incrementable_traits<_Iter>::difference_type; }
 struct __diff<_Iter>
 {
   using type = typename incrementable_traits<_Iter>::difference_type;
 };

    public:
      using iterator_category = output_iterator_tag;
      using value_type = void;
      using difference_type = typename __diff<_Iterator>::type;
      using pointer = void;
      using reference = void;
    };

  namespace __detail
  {
    template<typename _Iter>
      struct __iter_concept_impl;


    template<typename _Iter>
      requires requires { typename __iter_traits<_Iter>::iterator_concept; }
      struct __iter_concept_impl<_Iter>
      { using type = typename __iter_traits<_Iter>::iterator_concept; };


    template<typename _Iter>
      requires (!requires { typename __iter_traits<_Iter>::iterator_concept; }
   && requires { typename __iter_traits<_Iter>::iterator_category; })
      struct __iter_concept_impl<_Iter>
      { using type = typename __iter_traits<_Iter>::iterator_category; };


    template<typename _Iter>
      requires (!requires { typename __iter_traits<_Iter>::iterator_concept; }
   && !requires { typename __iter_traits<_Iter>::iterator_category; }
   && __primary_traits_iter<_Iter>)
      struct __iter_concept_impl<_Iter>
      { using type = random_access_iterator_tag; };


    template<typename _Iter>
      struct __iter_concept_impl
      { };


    template<typename _Iter>
      using __iter_concept = typename __iter_concept_impl<_Iter>::type;

  template<typename _In>
    concept __indirectly_readable_impl = requires
      {
 typename iter_value_t<_In>;
 typename iter_reference_t<_In>;
 typename iter_rvalue_reference_t<_In>;
 requires same_as<iter_reference_t<const _In>,
    iter_reference_t<_In>>;
 requires same_as<iter_rvalue_reference_t<const _In>,
    iter_rvalue_reference_t<_In>>;
      }
      && common_reference_with<iter_reference_t<_In>&&, iter_value_t<_In>&>
      && common_reference_with<iter_reference_t<_In>&&,
         iter_rvalue_reference_t<_In>&&>
      && common_reference_with<iter_rvalue_reference_t<_In>&&,
          const iter_value_t<_In>&>;

  }


  template<typename _In>
    concept indirectly_readable
      = __detail::__indirectly_readable_impl<remove_cvref_t<_In>>;

  template<indirectly_readable _Tp>
    using iter_common_reference_t
      = common_reference_t<iter_reference_t<_Tp>, iter_value_t<_Tp>&>;


  template<typename _Out, typename _Tp>
    concept indirectly_writable = requires(_Out&& __o, _Tp&& __t)
      {
 *__o = std::forward<_Tp>(__t);
 *std::forward<_Out>(__o) = std::forward<_Tp>(__t);
 const_cast<const iter_reference_t<_Out>&&>(*__o)
   = std::forward<_Tp>(__t);
 const_cast<const iter_reference_t<_Out>&&>(*std::forward<_Out>(__o))
   = std::forward<_Tp>(__t);
      };

  namespace ranges::__detail
  {
    class __max_diff_type;
    class __max_size_type;

    __extension__
    template<typename _Tp>
      concept __is_signed_int128

 = same_as<_Tp, __int128>;




    __extension__
    template<typename _Tp>
      concept __is_unsigned_int128

 = same_as<_Tp, unsigned __int128>;




    template<typename _Tp>
      concept __cv_bool = same_as<const volatile _Tp, const volatile bool>;

    template<typename _Tp>
      concept __integral_nonbool = integral<_Tp> && !__cv_bool<_Tp>;

    template<typename _Tp>
      concept __is_int128 = __is_signed_int128<_Tp> || __is_unsigned_int128<_Tp>;

    template<typename _Tp>
      concept __is_integer_like = __integral_nonbool<_Tp>
 || __is_int128<_Tp>
 || same_as<_Tp, __max_diff_type> || same_as<_Tp, __max_size_type>;

    template<typename _Tp>
      concept __is_signed_integer_like = signed_integral<_Tp>
 || __is_signed_int128<_Tp>
 || same_as<_Tp, __max_diff_type>;

  }

  namespace __detail { using ranges::__detail::__is_signed_integer_like; }


  template<typename _Iter>
    concept weakly_incrementable = movable<_Iter>
      && requires(_Iter __i)
      {
 typename iter_difference_t<_Iter>;
 requires __detail::__is_signed_integer_like<iter_difference_t<_Iter>>;
 { ++__i } -> same_as<_Iter&>;
 __i++;
      };

  template<typename _Iter>
    concept incrementable = regular<_Iter> && weakly_incrementable<_Iter>
      && requires(_Iter __i) { { __i++ } -> same_as<_Iter>; };

  template<typename _Iter>
    concept input_or_output_iterator
      = requires(_Iter __i) { { *__i } -> __detail::__can_reference; }
 && weakly_incrementable<_Iter>;

  template<typename _Sent, typename _Iter>
    concept sentinel_for = semiregular<_Sent>
      && input_or_output_iterator<_Iter>
      && __detail::__weakly_eq_cmp_with<_Sent, _Iter>;

  template<typename _Sent, typename _Iter>
    inline constexpr bool disable_sized_sentinel_for = false;

  template<typename _Sent, typename _Iter>
    concept sized_sentinel_for = sentinel_for<_Sent, _Iter>
    && !disable_sized_sentinel_for<remove_cv_t<_Sent>, remove_cv_t<_Iter>>
    && requires(const _Iter& __i, const _Sent& __s)
    {
      { __s - __i } -> same_as<iter_difference_t<_Iter>>;
      { __i - __s } -> same_as<iter_difference_t<_Iter>>;
    };

  template<typename _Iter>
    concept input_iterator = input_or_output_iterator<_Iter>
      && indirectly_readable<_Iter>
      && requires { typename __detail::__iter_concept<_Iter>; }
      && derived_from<__detail::__iter_concept<_Iter>, input_iterator_tag>;

  template<typename _Iter, typename _Tp>
    concept output_iterator = input_or_output_iterator<_Iter>
      && indirectly_writable<_Iter, _Tp>
      && requires(_Iter __i, _Tp&& __t) { *__i++ = std::forward<_Tp>(__t); };

  template<typename _Iter>
    concept forward_iterator = input_iterator<_Iter>
      && derived_from<__detail::__iter_concept<_Iter>, forward_iterator_tag>
      && incrementable<_Iter> && sentinel_for<_Iter, _Iter>;

  template<typename _Iter>
    concept bidirectional_iterator = forward_iterator<_Iter>
      && derived_from<__detail::__iter_concept<_Iter>,
        bidirectional_iterator_tag>
      && requires(_Iter __i)
      {
 { --__i } -> same_as<_Iter&>;
 { __i-- } -> same_as<_Iter>;
      };

  template<typename _Iter>
    concept random_access_iterator = bidirectional_iterator<_Iter>
      && derived_from<__detail::__iter_concept<_Iter>,
        random_access_iterator_tag>
      && totally_ordered<_Iter> && sized_sentinel_for<_Iter, _Iter>
      && requires(_Iter __i, const _Iter __j,
    const iter_difference_t<_Iter> __n)
      {
 { __i += __n } -> same_as<_Iter&>;
 { __j + __n } -> same_as<_Iter>;
 { __n + __j } -> same_as<_Iter>;
 { __i -= __n } -> same_as<_Iter&>;
 { __j - __n } -> same_as<_Iter>;
 { __j[__n] } -> same_as<iter_reference_t<_Iter>>;
      };

  template<typename _Iter>
    concept contiguous_iterator = random_access_iterator<_Iter>
      && derived_from<__detail::__iter_concept<_Iter>, contiguous_iterator_tag>
      && is_lvalue_reference_v<iter_reference_t<_Iter>>
      && same_as<iter_value_t<_Iter>, remove_cvref_t<iter_reference_t<_Iter>>>
      && requires(const _Iter& __i)
      {
 { std::to_address(__i) }
   -> same_as<add_pointer_t<iter_reference_t<_Iter>>>;
      };





  template<typename _Fn, typename _Iter>
    concept indirectly_unary_invocable = indirectly_readable<_Iter>
      && copy_constructible<_Fn> && invocable<_Fn&, iter_value_t<_Iter>&>
      && invocable<_Fn&, iter_reference_t<_Iter>>
      && invocable<_Fn&, iter_common_reference_t<_Iter>>
      && common_reference_with<invoke_result_t<_Fn&, iter_value_t<_Iter>&>,
          invoke_result_t<_Fn&, iter_reference_t<_Iter>>>;

  template<typename _Fn, typename _Iter>
    concept indirectly_regular_unary_invocable = indirectly_readable<_Iter>
      && copy_constructible<_Fn>
      && regular_invocable<_Fn&, iter_value_t<_Iter>&>
      && regular_invocable<_Fn&, iter_reference_t<_Iter>>
      && regular_invocable<_Fn&, iter_common_reference_t<_Iter>>
      && common_reference_with<invoke_result_t<_Fn&, iter_value_t<_Iter>&>,
          invoke_result_t<_Fn&, iter_reference_t<_Iter>>>;

  template<typename _Fn, typename _Iter>
    concept indirect_unary_predicate = indirectly_readable<_Iter>
      && copy_constructible<_Fn> && predicate<_Fn&, iter_value_t<_Iter>&>
      && predicate<_Fn&, iter_reference_t<_Iter>>
      && predicate<_Fn&, iter_common_reference_t<_Iter>>;

  template<typename _Fn, typename _I1, typename _I2>
    concept indirect_binary_predicate
      = indirectly_readable<_I1> && indirectly_readable<_I2>
      && copy_constructible<_Fn>
      && predicate<_Fn&, iter_value_t<_I1>&, iter_value_t<_I2>&>
      && predicate<_Fn&, iter_value_t<_I1>&, iter_reference_t<_I2>>
      && predicate<_Fn&, iter_reference_t<_I1>, iter_value_t<_I2>&>
      && predicate<_Fn&, iter_reference_t<_I1>, iter_reference_t<_I2>>
      && predicate<_Fn&, iter_common_reference_t<_I1>,
     iter_common_reference_t<_I2>>;

  template<typename _Fn, typename _I1, typename _I2 = _I1>
    concept indirect_equivalence_relation
      = indirectly_readable<_I1> && indirectly_readable<_I2>
      && copy_constructible<_Fn>
      && equivalence_relation<_Fn&, iter_value_t<_I1>&, iter_value_t<_I2>&>
      && equivalence_relation<_Fn&, iter_value_t<_I1>&, iter_reference_t<_I2>>
      && equivalence_relation<_Fn&, iter_reference_t<_I1>, iter_value_t<_I2>&>
      && equivalence_relation<_Fn&, iter_reference_t<_I1>,
         iter_reference_t<_I2>>
      && equivalence_relation<_Fn&, iter_common_reference_t<_I1>,
         iter_common_reference_t<_I2>>;

  template<typename _Fn, typename _I1, typename _I2 = _I1>
    concept indirect_strict_weak_order
      = indirectly_readable<_I1> && indirectly_readable<_I2>
      && copy_constructible<_Fn>
      && strict_weak_order<_Fn&, iter_value_t<_I1>&, iter_value_t<_I2>&>
      && strict_weak_order<_Fn&, iter_value_t<_I1>&, iter_reference_t<_I2>>
      && strict_weak_order<_Fn&, iter_reference_t<_I1>, iter_value_t<_I2>&>
      && strict_weak_order<_Fn&, iter_reference_t<_I1>, iter_reference_t<_I2>>
      && strict_weak_order<_Fn&, iter_common_reference_t<_I1>,
      iter_common_reference_t<_I2>>;

  template<typename _Fn, typename... _Is>
    requires (indirectly_readable<_Is> && ...)
      && invocable<_Fn, iter_reference_t<_Is>...>
    using indirect_result_t = invoke_result_t<_Fn, iter_reference_t<_Is>...>;

  namespace __detail
  {
    template<typename _Iter, typename _Proj>
      struct __projected
      {
 struct __type
 {
   using value_type = remove_cvref_t<indirect_result_t<_Proj&, _Iter>>;
   indirect_result_t<_Proj&, _Iter> operator*() const;
 };
      };

    template<weakly_incrementable _Iter, typename _Proj>
      struct __projected<_Iter, _Proj>
      {
 struct __type
 {
   using value_type = remove_cvref_t<indirect_result_t<_Proj&, _Iter>>;
   using difference_type = iter_difference_t<_Iter>;
   indirect_result_t<_Proj&, _Iter> operator*() const;
 };
      };
  }


  template<indirectly_readable _Iter,
    indirectly_regular_unary_invocable<_Iter> _Proj>
    using projected = typename __detail::__projected<_Iter, _Proj>::__type;





  template<typename _In, typename _Out>
    concept indirectly_movable = indirectly_readable<_In>
      && indirectly_writable<_Out, iter_rvalue_reference_t<_In>>;

  template<typename _In, typename _Out>
    concept indirectly_movable_storable = indirectly_movable<_In, _Out>
      && indirectly_writable<_Out, iter_value_t<_In>>
      && movable<iter_value_t<_In>>
      && constructible_from<iter_value_t<_In>, iter_rvalue_reference_t<_In>>
      && assignable_from<iter_value_t<_In>&, iter_rvalue_reference_t<_In>>;


  template<typename _In, typename _Out>
    concept indirectly_copyable = indirectly_readable<_In>
      && indirectly_writable<_Out, iter_reference_t<_In>>;

  template<typename _In, typename _Out>
    concept indirectly_copyable_storable = indirectly_copyable<_In, _Out>
      && indirectly_writable<_Out, iter_value_t<_In>&>
      && indirectly_writable<_Out, const iter_value_t<_In>&>
      && indirectly_writable<_Out, iter_value_t<_In>&&>
      && indirectly_writable<_Out, const iter_value_t<_In>&&>
      && copyable<iter_value_t<_In>>
      && constructible_from<iter_value_t<_In>, iter_reference_t<_In>>
      && assignable_from<iter_value_t<_In>&, iter_reference_t<_In>>;

namespace ranges
{

  namespace __iswap
  {
    template<typename _It1, typename _It2>
      void iter_swap(_It1, _It2) = delete;

    template<typename _Tp, typename _Up>
      concept __adl_iswap
 = (std::__detail::__class_or_enum<remove_reference_t<_Tp>>
   || std::__detail::__class_or_enum<remove_reference_t<_Up>>)
 && requires(_Tp&& __t, _Up&& __u) {
   iter_swap(static_cast<_Tp&&>(__t), static_cast<_Up&&>(__u));
 };

    template<typename _Xp, typename _Yp>
      constexpr iter_value_t<_Xp>
      __iter_exchange_move(_Xp&& __x, _Yp&& __y)
      noexcept(noexcept(iter_value_t<_Xp>(iter_move(__x)))
        && noexcept(*__x = iter_move(__y)))
      {
 iter_value_t<_Xp> __old_value(iter_move(__x));
 *__x = iter_move(__y);
 return __old_value;
      }

    struct _IterSwap
    {
    private:
      template<typename _Tp, typename _Up>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (__adl_iswap<_Tp, _Up>)
     return noexcept(iter_swap(std::declval<_Tp>(),
          std::declval<_Up>()));
   else if constexpr (indirectly_readable<_Tp>
       && indirectly_readable<_Up>
       && swappable_with<iter_reference_t<_Tp>, iter_reference_t<_Up>>)
     return noexcept(ranges::swap(*std::declval<_Tp>(),
      *std::declval<_Up>()));
   else
     return noexcept(*std::declval<_Tp>()
  = __iswap::__iter_exchange_move(std::declval<_Up>(),
          std::declval<_Tp>()));
 }

    public:
      template<typename _Tp, typename _Up>
 requires __adl_iswap<_Tp, _Up>
 || (indirectly_readable<remove_reference_t<_Tp>>
     && indirectly_readable<remove_reference_t<_Up>>
     && swappable_with<iter_reference_t<_Tp>, iter_reference_t<_Up>>)
 || (indirectly_movable_storable<_Tp, _Up>
     && indirectly_movable_storable<_Up, _Tp>)
 constexpr void
 operator()(_Tp&& __e1, _Up&& __e2) const
 noexcept(_S_noexcept<_Tp, _Up>())
 {
   if constexpr (__adl_iswap<_Tp, _Up>)
     iter_swap(static_cast<_Tp&&>(__e1), static_cast<_Up&&>(__e2));
   else if constexpr (indirectly_readable<_Tp>
       && indirectly_readable<_Up>
       && swappable_with<iter_reference_t<_Tp>, iter_reference_t<_Up>>)
     ranges::swap(*__e1, *__e2);
   else
     *__e1 = __iswap::__iter_exchange_move(__e2, __e1);
 }
    };
  }


  inline namespace _Cpo {
    inline constexpr __iswap::_IterSwap iter_swap{};
  }

}


  template<typename _I1, typename _I2 = _I1>
    concept indirectly_swappable
      = indirectly_readable<_I1> && indirectly_readable<_I2>
      && requires(const _I1 __i1, const _I2 __i2)
      {
 ranges::iter_swap(__i1, __i1);
 ranges::iter_swap(__i2, __i2);
 ranges::iter_swap(__i1, __i2);
 ranges::iter_swap(__i2, __i1);
      };


  template<typename _I1, typename _I2, typename _Rel, typename _P1 = identity,
    typename _P2 = identity>
    concept indirectly_comparable
      = indirect_binary_predicate<_Rel, projected<_I1, _P1>,
      projected<_I2, _P2>>;


  template<typename _Iter>
    concept permutable = forward_iterator<_Iter>
      && indirectly_movable_storable<_Iter, _Iter>
      && indirectly_swappable<_Iter, _Iter>;


  template<typename _I1, typename _I2, typename _Out,
    typename _Rel = ranges::less, typename _P1 = identity,
    typename _P2 = identity>
    concept mergeable = input_iterator<_I1> && input_iterator<_I2>
      && weakly_incrementable<_Out> && indirectly_copyable<_I1, _Out>
      && indirectly_copyable<_I2, _Out>
      && indirect_strict_weak_order<_Rel, projected<_I1, _P1>,
        projected<_I2, _P2>>;


  template<typename _Iter, typename _Rel = ranges::less,
    typename _Proj = identity>
    concept sortable = permutable<_Iter>
      && indirect_strict_weak_order<_Rel, projected<_Iter, _Proj>>;

  struct unreachable_sentinel_t
  {
    template<weakly_incrementable _It>
      friend constexpr bool
      operator==(unreachable_sentinel_t, const _It&) noexcept
      { return false; }
  };

  inline constexpr unreachable_sentinel_t unreachable_sentinel{};


  namespace ranges::__access
  {
    using std::__detail::__class_or_enum;

    struct _Decay_copy final
    {
      template<typename _Tp>
 constexpr decay_t<_Tp>
 operator()(_Tp&& __t) const
 noexcept(is_nothrow_convertible_v<_Tp, decay_t<_Tp>>)
 { return std::forward<_Tp>(__t); }
    } inline constexpr __decay_copy{};

    template<typename _Tp>
      concept __member_begin = requires(_Tp& __t)
 {
   { __decay_copy(__t.begin()) } -> input_or_output_iterator;
 };


    void begin() = delete;

    template<typename _Tp>
      concept __adl_begin = __class_or_enum<remove_reference_t<_Tp>>
 && requires(_Tp& __t)
 {
   { __decay_copy(begin(__t)) } -> input_or_output_iterator;
 };



    template<typename _Tp>
      requires is_array_v<_Tp> || __member_begin<_Tp&> || __adl_begin<_Tp&>
      auto
      __begin(_Tp& __t)
      {
 if constexpr (is_array_v<_Tp>)
   return __t + 0;
 else if constexpr (__member_begin<_Tp&>)
   return __t.begin();
 else
   return begin(__t);
      }
  }

  namespace __detail
  {

    template<typename _Tp>
      using __range_iter_t
 = decltype(ranges::__access::__begin(std::declval<_Tp&>()));

  }



}
# 72 "/usr/include/c++/14.2.1/bits/stl_iterator_base_types.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{

# 93 "/usr/include/c++/14.2.1/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag { };


  struct output_iterator_tag { };


  struct forward_iterator_tag : public input_iterator_tag { };



  struct bidirectional_iterator_tag : public forward_iterator_tag { };



  struct random_access_iterator_tag : public bidirectional_iterator_tag { };



  struct contiguous_iterator_tag : public random_access_iterator_tag { };
# 125 "/usr/include/c++/14.2.1/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct [[__deprecated__]] iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };
# 149 "/usr/include/c++/14.2.1/bits/stl_iterator_base_types.h" 3
  template<typename _Iterator>
    struct iterator_traits;




  template<typename _Iterator, typename = __void_t<>>
    struct __iterator_traits { };
# 176 "/usr/include/c++/14.2.1/bits/stl_iterator_base_types.h" 3
  template<typename _Iterator>
    struct iterator_traits
    : public __iterator_traits<_Iterator> { };
# 194 "/usr/include/c++/14.2.1/bits/stl_iterator_base_types.h" 3
  template<typename _Tp>

    requires is_object_v<_Tp>

    struct iterator_traits<_Tp*>
    {
      using iterator_concept = contiguous_iterator_tag;
      using iterator_category = random_access_iterator_tag;
      using value_type = remove_cv_t<_Tp>;
      using difference_type = ptrdiff_t;
      using pointer = _Tp*;
      using reference = _Tp&;
    };
# 235 "/usr/include/c++/14.2.1/bits/stl_iterator_base_types.h" 3
  template<typename _Iter>
    __attribute__((__always_inline__))
    inline constexpr
    typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }




  template<typename _Iter>
    using __iter_category_t
      = typename iterator_traits<_Iter>::iterator_category;

  template<typename _InIter>
    using _RequireInputIter =
      __enable_if_t<is_convertible<__iter_category_t<_InIter>,
       input_iterator_tag>::value>;

  template<typename _It,
    typename _Cat = __iter_category_t<_It>>
    struct __is_random_access_iter
      : is_base_of<random_access_iterator_tag, _Cat>
    {
      typedef is_base_of<random_access_iterator_tag, _Cat> _Base;
      enum { __value = _Base::value };
    };








}
# 66 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/14.2.1/bits/stl_iterator_base_funcs.h" 1 3
# 62 "/usr/include/c++/14.2.1/bits/stl_iterator_base_funcs.h" 3
       
# 63 "/usr/include/c++/14.2.1/bits/stl_iterator_base_funcs.h" 3

# 1 "/usr/include/c++/14.2.1/bits/concept_check.h" 1 3
# 33 "/usr/include/c++/14.2.1/bits/concept_check.h" 3
       
# 34 "/usr/include/c++/14.2.1/bits/concept_check.h" 3
# 65 "/usr/include/c++/14.2.1/bits/stl_iterator_base_funcs.h" 2 3
# 1 "/usr/include/c++/14.2.1/debug/assertions.h" 1 3
# 66 "/usr/include/c++/14.2.1/bits/stl_iterator_base_funcs.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{




  template <typename> struct _List_iterator;
  template <typename> struct _List_const_iterator;


  template<typename _InputIterator>
    inline constexpr
    typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {

     

      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    __attribute__((__always_inline__))
    inline constexpr
    typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {

     

      return __last - __first;
    }



  template<typename _Tp>
    ptrdiff_t
    __distance(std::_List_iterator<_Tp>,
        std::_List_iterator<_Tp>,
        input_iterator_tag);

  template<typename _Tp>
    ptrdiff_t
    __distance(std::_List_const_iterator<_Tp>,
        std::_List_const_iterator<_Tp>,
        input_iterator_tag);




  template<typename _OutputIterator>
    void
    __distance(_OutputIterator, _OutputIterator, output_iterator_tag) = delete;
# 144 "/usr/include/c++/14.2.1/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    [[__nodiscard__]] __attribute__((__always_inline__))
    inline constexpr
    typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline constexpr void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {

     
      do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__n >= 0), false)) std::__glibcxx_assert_fail(); } while (false);
      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline constexpr void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {

     

      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline constexpr void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {

     

      if (__builtin_constant_p(__n) && __n == 1)
 ++__i;
      else if (__builtin_constant_p(__n) && __n == -1)
 --__i;
      else
 __i += __n;
    }



  template<typename _OutputIterator, typename _Distance>
    void
    __advance(_OutputIterator&, _Distance, output_iterator_tag) = delete;
# 217 "/usr/include/c++/14.2.1/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    __attribute__((__always_inline__))
    inline constexpr void
    advance(_InputIterator& __i, _Distance __n)
    {

      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }



  template<typename _InputIterator>
    [[__nodiscard__]] [[__gnu__::__always_inline__]]
    inline constexpr _InputIterator
    next(_InputIterator __x, typename
  iterator_traits<_InputIterator>::difference_type __n = 1)
    {

     
      std::advance(__x, __n);
      return __x;
    }

  template<typename _BidirectionalIterator>
    [[__nodiscard__]] [[__gnu__::__always_inline__]]
    inline constexpr _BidirectionalIterator
    prev(_BidirectionalIterator __x, typename
  iterator_traits<_BidirectionalIterator>::difference_type __n = 1)
    {

     

      std::advance(__x, -__n);
      return __x;
    }




}
# 67 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 1 3
# 75 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
# 1 "/usr/include/c++/14.2.1/new" 1 3
# 38 "/usr/include/c++/14.2.1/new" 3
       
# 39 "/usr/include/c++/14.2.1/new" 3


# 1 "/usr/include/c++/14.2.1/bits/exception.h" 1 3
# 34 "/usr/include/c++/14.2.1/bits/exception.h" 3
       
# 35 "/usr/include/c++/14.2.1/bits/exception.h" 3



extern "C++" {

namespace std __attribute__ ((__visibility__ ("default")))
{
# 59 "/usr/include/c++/14.2.1/bits/exception.h" 3
  class exception
  {
  public:
    exception() noexcept { }
    virtual ~exception() noexcept;

    exception(const exception&) = default;
    exception& operator=(const exception&) = default;
    exception(exception&&) = default;
    exception& operator=(exception&&) = default;




    virtual const char*
    what() const noexcept;
  };



}

}
# 42 "/usr/include/c++/14.2.1/new" 2 3




# 1 "/usr/include/c++/14.2.1/bits/version.h" 1 3
# 47 "/usr/include/c++/14.2.1/bits/version.h" 3
       
# 48 "/usr/include/c++/14.2.1/bits/version.h" 3
# 47 "/usr/include/c++/14.2.1/new" 2 3

#pragma GCC visibility push(default)

extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }


    bad_alloc(const bad_alloc&) = default;
    bad_alloc& operator=(const bad_alloc&) = default;




    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };


  class bad_array_new_length : public bad_alloc
  {
  public:
    bad_array_new_length() throw() { }



    virtual ~bad_array_new_length() throw();


    virtual const char* what() const throw();
  };



  enum class align_val_t: size_t {};


  struct nothrow_t
  {

    explicit nothrow_t() = default;

  };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();



  new_handler get_new_handler() noexcept;

}
# 131 "/usr/include/c++/14.2.1/new" 3
[[__nodiscard__]] void* operator new(std::size_t)
  __attribute__((__externally_visible__));
[[__nodiscard__]] void* operator new[](std::size_t)
  __attribute__((__externally_visible__));
void operator delete(void*) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*) noexcept
  __attribute__((__externally_visible__));

void operator delete(void*, std::size_t) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, std::size_t) noexcept
  __attribute__((__externally_visible__));

[[__nodiscard__]] void* operator new(std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
[[__nodiscard__]] void* operator new[](std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
void operator delete(void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));

[[__nodiscard__]] void* operator new(std::size_t, std::align_val_t)
  __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
[[__nodiscard__]] void* operator new(std::size_t, std::align_val_t, const std::nothrow_t&)
  noexcept __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
void operator delete(void*, std::align_val_t)
  noexcept __attribute__((__externally_visible__));
void operator delete(void*, std::align_val_t, const std::nothrow_t&)
  noexcept __attribute__((__externally_visible__));
[[__nodiscard__]] void* operator new[](std::size_t, std::align_val_t)
  __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
[[__nodiscard__]] void* operator new[](std::size_t, std::align_val_t, const std::nothrow_t&)
  noexcept __attribute__((__externally_visible__, __alloc_size__ (1), __malloc__));
void operator delete[](void*, std::align_val_t)
  noexcept __attribute__((__externally_visible__));
void operator delete[](void*, std::align_val_t, const std::nothrow_t&)
  noexcept __attribute__((__externally_visible__));

void operator delete(void*, std::size_t, std::align_val_t)
  noexcept __attribute__((__externally_visible__));
void operator delete[](void*, std::size_t, std::align_val_t)
  noexcept __attribute__((__externally_visible__));




[[__nodiscard__]] inline void* operator new(std::size_t, void* __p) noexcept
{ return __p; }
[[__nodiscard__]] inline void* operator new[](std::size_t, void* __p) noexcept
{ return __p; }


inline void operator delete (void*, void*) noexcept { }
inline void operator delete[](void*, void*) noexcept { }

}


namespace std
{


  template<typename _Tp>
    [[nodiscard]] constexpr _Tp*
    launder(_Tp* __p) noexcept
    { return __builtin_launder(__p); }




  template<typename _Ret, typename... _Args , bool _NE>
    void launder(_Ret (*)(_Args...) noexcept (_NE)) = delete;
  template<typename _Ret, typename... _Args , bool _NE>
    void launder(_Ret (*)(_Args......) noexcept (_NE)) = delete;

  void launder(void*) = delete;
  void launder(const void*) = delete;
  void launder(volatile void*) = delete;
  void launder(const volatile void*) = delete;



  inline constexpr size_t hardware_destructive_interference_size = 64;
  inline constexpr size_t hardware_constructive_interference_size = 64;

}




namespace std
{


  struct destroying_delete_t
  {
    explicit destroying_delete_t() = default;
  };

  inline constexpr destroying_delete_t destroying_delete{};
}


#pragma GCC visibility pop
# 76 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 2 3


# 1 "/usr/include/c++/14.2.1/bits/stl_construct.h" 1 3
# 73 "/usr/include/c++/14.2.1/bits/stl_construct.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template <typename _Tp>
    constexpr inline void
    destroy_at(_Tp* __location)
    {
      if constexpr (202002L > 201703L && is_array_v<_Tp>)
 {
   for (auto& __x : *__location)
     std::destroy_at(std::__addressof(__x));
 }
      else
 __location->~_Tp();
    }


  template<typename _Tp, typename... _Args>
    constexpr auto
    construct_at(_Tp* __location, _Args&&... __args)
    noexcept(noexcept(::new((void*)0) _Tp(std::declval<_Args>()...)))
    -> decltype(::new((void*)0) _Tp(std::declval<_Args>()...))
    { return ::new((void*)__location) _Tp(std::forward<_Args>(__args)...); }
# 106 "/usr/include/c++/14.2.1/bits/stl_construct.h" 3
  template<typename _Tp, typename... _Args>
    constexpr
    inline void
    _Construct(_Tp* __p, _Args&&... __args)
    {

      if (std::__is_constant_evaluated())
 {

   std::construct_at(__p, std::forward<_Args>(__args)...);
   return;
 }

      ::new((void*)__p) _Tp(std::forward<_Args>(__args)...);
    }
# 132 "/usr/include/c++/14.2.1/bits/stl_construct.h" 3
  template<typename _T1>
    inline void
    _Construct_novalue(_T1* __p)
    { ::new((void*)__p) _T1; }

  template<typename _ForwardIterator>
    constexpr void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last);




  template<typename _Tp>
    constexpr inline void
    _Destroy(_Tp* __pointer)
    {

      std::destroy_at(__pointer);



    }

  template<bool>
    struct _Destroy_aux
    {
      template<typename _ForwardIterator>
 static constexpr void
 __destroy(_ForwardIterator __first, _ForwardIterator __last)
 {
   for (; __first != __last; ++__first)
     std::_Destroy(std::__addressof(*__first));
 }
    };

  template<>
    struct _Destroy_aux<true>
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator, _ForwardIterator) { }
    };






  template<typename _ForwardIterator>
    constexpr inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;


      static_assert(is_destructible<_Value_type>::value,
      "value type is destructible");


      if (std::__is_constant_evaluated())
 return std::_Destroy_aux<false>::__destroy(__first, __last);

      std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
 __destroy(__first, __last);
    }

  template<bool>
    struct _Destroy_n_aux
    {
      template<typename _ForwardIterator, typename _Size>
 static constexpr _ForwardIterator
 __destroy_n(_ForwardIterator __first, _Size __count)
 {
   for (; __count > 0; (void)++__first, --__count)
     std::_Destroy(std::__addressof(*__first));
   return __first;
 }
    };

  template<>
    struct _Destroy_n_aux<true>
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __destroy_n(_ForwardIterator __first, _Size __count)
 {
   std::advance(__first, __count);
   return __first;
 }
    };






  template<typename _ForwardIterator, typename _Size>
    constexpr inline _ForwardIterator
    _Destroy_n(_ForwardIterator __first, _Size __count)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;


      static_assert(is_destructible<_Value_type>::value,
      "value type is destructible");


      if (std::__is_constant_evaluated())
 return std::_Destroy_n_aux<false>::__destroy_n(__first, __count);

      return std::_Destroy_n_aux<__has_trivial_destructor(_Value_type)>::
 __destroy_n(__first, __count);
    }


  template <typename _ForwardIterator>
    constexpr inline void
    destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      std::_Destroy(__first, __last);
    }

  template <typename _ForwardIterator, typename _Size>
    constexpr inline _ForwardIterator
    destroy_n(_ForwardIterator __first, _Size __count)
    {
      return std::_Destroy_n(__first, __count);
    }



}
# 79 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 2 3






namespace std __attribute__ ((__visibility__ ("default")))
{








  namespace __detail
  {


    template<typename _Cat, typename _Limit, typename _Otherwise = _Cat>
      using __clamp_iter_cat
 = __conditional_t<derived_from<_Cat, _Limit>, _Limit, _Otherwise>;
  }



#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
# 128 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
      template<typename _Iter>
 friend class reverse_iterator;




      template<typename _Iter>
 static constexpr bool __convertible = !is_same_v<_Iter, _Iterator>
     && convertible_to<const _Iter&, _Iterator>;


    protected:
      _Iterator current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::pointer pointer;




      using iterator_concept
 = __conditional_t<random_access_iterator<_Iterator>,
     random_access_iterator_tag,
     bidirectional_iterator_tag>;
      using iterator_category
 = __detail::__clamp_iter_cat<typename __traits_type::iterator_category,
         random_access_iterator_tag>;
      using value_type = iter_value_t<_Iterator>;
      using difference_type = iter_difference_t<_Iterator>;
      using reference = iter_reference_t<_Iterator>;
# 178 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
      constexpr
      reverse_iterator()
      noexcept(noexcept(_Iterator()))
      : current()
      { }




      explicit constexpr
      reverse_iterator(iterator_type __x)
      noexcept(noexcept(_Iterator(__x)))
      : current(__x)
      { }




      constexpr
      reverse_iterator(const reverse_iterator& __x)
      noexcept(noexcept(_Iterator(__x.current)))
      : current(__x.current)
      { }


      reverse_iterator& operator=(const reverse_iterator&) = default;






      template<typename _Iter>

 requires __convertible<_Iter>

 constexpr
        reverse_iterator(const reverse_iterator<_Iter>& __x)
 noexcept(noexcept(_Iterator(__x.current)))
 : current(__x.current)
 { }


      template<typename _Iter>

 requires __convertible<_Iter>
   && assignable_from<_Iterator&, const _Iter&>

 constexpr
 reverse_iterator&
 operator=(const reverse_iterator<_Iter>& __x)
 noexcept(noexcept(current = __x.current))
 {
   current = __x.current;
   return *this;
 }





      [[__nodiscard__]]
      constexpr iterator_type
      base() const
      noexcept(noexcept(_Iterator(current)))
      { return current; }
# 255 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
      [[__nodiscard__]]
      constexpr reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }






      [[__nodiscard__]]
      constexpr pointer
      operator->() const

      requires is_pointer_v<_Iterator>
 || requires(const _Iterator __i) { __i.operator->(); }

      {


 _Iterator __tmp = current;
 --__tmp;
 return _S_to_pointer(__tmp);
      }






      constexpr reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      constexpr reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      constexpr reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      constexpr reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      [[__nodiscard__]]
      constexpr reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }







      constexpr reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      [[__nodiscard__]]
      constexpr reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }







      constexpr reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      [[__nodiscard__]]
      constexpr reference
      operator[](difference_type __n) const
      { return *(*this + __n); }


      [[nodiscard]]
      friend constexpr iter_rvalue_reference_t<_Iterator>
      iter_move(const reverse_iterator& __i)
      noexcept(is_nothrow_copy_constructible_v<_Iterator>
        && noexcept(ranges::iter_move(--std::declval<_Iterator&>())))
      {
 auto __tmp = __i.base();
 return ranges::iter_move(--__tmp);
      }

      template<indirectly_swappable<_Iterator> _Iter2>
 friend constexpr void
 iter_swap(const reverse_iterator& __x,
    const reverse_iterator<_Iter2>& __y)
 noexcept(is_nothrow_copy_constructible_v<_Iterator>
   && is_nothrow_copy_constructible_v<_Iter2>
   && noexcept(ranges::iter_swap(--std::declval<_Iterator&>(),
            --std::declval<_Iter2&>())))
 {
   auto __xtmp = __x.base();
   auto __ytmp = __y.base();
   ranges::iter_swap(--__xtmp, --__ytmp);
 }


    private:
      template<typename _Tp>
 static constexpr _Tp*
 _S_to_pointer(_Tp* __p)
        { return __p; }

      template<typename _Tp>
 static constexpr pointer
 _S_to_pointer(_Tp __t)
        { return __t.operator->(); }
    };
# 524 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR>
    [[nodiscard]]
    constexpr bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    requires requires { { __x.base() == __y.base() } -> convertible_to<bool>; }
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    [[nodiscard]]
    constexpr bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    requires requires { { __x.base() != __y.base() } -> convertible_to<bool>; }
    { return __x.base() != __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    [[nodiscard]]
    constexpr bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    requires requires { { __x.base() > __y.base() } -> convertible_to<bool>; }
    { return __x.base() > __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    [[nodiscard]]
    constexpr bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    requires requires { { __x.base() < __y.base() } -> convertible_to<bool>; }
    { return __x.base() < __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    [[nodiscard]]
    constexpr bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    requires requires { { __x.base() >= __y.base() } -> convertible_to<bool>; }
    { return __x.base() >= __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    [[nodiscard]]
    constexpr bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    requires requires { { __x.base() <= __y.base() } -> convertible_to<bool>; }
    { return __x.base() <= __y.base(); }

  template<typename _IteratorL,
    three_way_comparable_with<_IteratorL> _IteratorR>
    [[nodiscard]]
    constexpr compare_three_way_result_t<_IteratorL, _IteratorR>
    operator<=>(const reverse_iterator<_IteratorL>& __x,
  const reverse_iterator<_IteratorR>& __y)
    { return __y.base() <=> __x.base(); }




  template<typename _Iterator>
    [[nodiscard]]
    constexpr bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    requires requires { { __x.base() == __y.base() } -> convertible_to<bool>; }
    { return __x.base() == __y.base(); }

  template<three_way_comparable _Iterator>
    [[nodiscard]]
    constexpr compare_three_way_result_t<_Iterator, _Iterator>
    operator<=>(const reverse_iterator<_Iterator>& __x,
  const reverse_iterator<_Iterator>& __y)
    { return __y.base() <=> __x.base(); }
# 615 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr auto
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    -> decltype(__y.base() - __x.base())
    { return __y.base() - __x.base(); }


  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }



  template<typename _Iterator>
    inline constexpr reverse_iterator<_Iterator>
    __make_reverse_iterator(_Iterator __i)
    { return reverse_iterator<_Iterator>(__i); }





  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr reverse_iterator<_Iterator>
    make_reverse_iterator(_Iterator __i)
    { return reverse_iterator<_Iterator>(__i); }


  template<typename _Iterator1, typename _Iterator2>
    requires (!sized_sentinel_for<_Iterator1, _Iterator2>)
    inline constexpr bool
    disable_sized_sentinel_for<reverse_iterator<_Iterator1>,
          reverse_iterator<_Iterator2>> = true;



  template<typename _Iterator>
    constexpr
    auto
    __niter_base(reverse_iterator<_Iterator> __it)
    -> decltype(__make_reverse_iterator(__niter_base(__it.base())))
    { return __make_reverse_iterator(__niter_base(__it.base())); }

  template<typename _Iterator>
    struct __is_move_iterator<reverse_iterator<_Iterator> >
      : __is_move_iterator<_Iterator>
    { };

  template<typename _Iterator>
    constexpr
    auto
    __miter_base(reverse_iterator<_Iterator> __it)
    -> decltype(__make_reverse_iterator(__miter_base(__it.base())))
    { return __make_reverse_iterator(__miter_base(__it.base())); }
# 688 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;

      using difference_type = ptrdiff_t;



      explicit constexpr
      back_insert_iterator(_Container& __x)
      : container(std::__addressof(__x)) { }
# 726 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
      constexpr
      back_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_back(__value);
 return *this;
      }

      constexpr
      back_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_back(std::move(__value));
 return *this;
      }



      [[__nodiscard__]] constexpr
      back_insert_iterator&
      operator*()
      { return *this; }


      constexpr
      back_insert_iterator&
      operator++()
      { return *this; }


      constexpr
      back_insert_iterator
      operator++(int)
      { return *this; }
    };
# 773 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
  template<typename _Container>
    [[__nodiscard__]] constexpr
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
# 789 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;

      using difference_type = ptrdiff_t;



      explicit constexpr
      front_insert_iterator(_Container& __x)
      : container(std::__addressof(__x)) { }
# 827 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
      constexpr
      front_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_front(__value);
 return *this;
      }

      constexpr
      front_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_front(std::move(__value));
 return *this;
      }



      [[__nodiscard__]] constexpr
      front_insert_iterator&
      operator*()
      { return *this; }


      constexpr
      front_insert_iterator&
      operator++()
      { return *this; }


      constexpr
      front_insert_iterator
      operator++(int)
      { return *this; }
    };
# 874 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
  template<typename _Container>
    [[__nodiscard__]] constexpr
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
# 894 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {

      using _Iter = std::__detail::__range_iter_t<_Container>;



    protected:
      _Container* container;
      _Iter iter;

    public:

      typedef _Container container_type;


      using difference_type = ptrdiff_t;






      constexpr
      insert_iterator(_Container& __x, _Iter __i)
      : container(std::__addressof(__x)), iter(__i) {}
# 955 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
      constexpr
      insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }

      constexpr
      insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 iter = container->insert(iter, std::move(__value));
 ++iter;
 return *this;
      }



      [[__nodiscard__]] constexpr
      insert_iterator&
      operator*()
      { return *this; }


      constexpr
      insert_iterator&
      operator++()
      { return *this; }


      constexpr
      insert_iterator&
      operator++(int)
      { return *this; }
    };

#pragma GCC diagnostic pop
# 1008 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
  template<typename _Container>
    [[nodiscard]]
    constexpr insert_iterator<_Container>
    inserter(_Container& __x, std::__detail::__range_iter_t<_Container> __i)
    { return insert_iterator<_Container>(__x, __i); }
# 1023 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3

}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 1037 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

      typedef std::iterator_traits<_Iterator> __traits_type;


      template<typename _Iter>
 using __convertible_from
   = std::__enable_if_t<std::is_convertible<_Iter, _Iterator>::value>;


    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::reference reference;
      typedef typename __traits_type::pointer pointer;


      using iterator_concept = std::__detail::__iter_concept<_Iterator>;


      constexpr __normal_iterator() noexcept
      : _M_current(_Iterator()) { }

      explicit constexpr
      __normal_iterator(const _Iterator& __i) noexcept
      : _M_current(__i) { }



      template<typename _Iter, typename = __convertible_from<_Iter>>
 constexpr
 __normal_iterator(const __normal_iterator<_Iter, _Container>& __i)
 noexcept
# 1085 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
        : _M_current(__i.base()) { }


      constexpr
      reference
      operator*() const noexcept
      { return *_M_current; }

      constexpr
      pointer
      operator->() const noexcept
      { return _M_current; }

      constexpr
      __normal_iterator&
      operator++() noexcept
      {
 ++_M_current;
 return *this;
      }

      constexpr
      __normal_iterator
      operator++(int) noexcept
      { return __normal_iterator(_M_current++); }


      constexpr
      __normal_iterator&
      operator--() noexcept
      {
 --_M_current;
 return *this;
      }

      constexpr
      __normal_iterator
      operator--(int) noexcept
      { return __normal_iterator(_M_current--); }


      constexpr
      reference
      operator[](difference_type __n) const noexcept
      { return _M_current[__n]; }

      constexpr
      __normal_iterator&
      operator+=(difference_type __n) noexcept
      { _M_current += __n; return *this; }

      constexpr
      __normal_iterator
      operator+(difference_type __n) const noexcept
      { return __normal_iterator(_M_current + __n); }

      constexpr
      __normal_iterator&
      operator-=(difference_type __n) noexcept
      { _M_current -= __n; return *this; }

      constexpr
      __normal_iterator
      operator-(difference_type __n) const noexcept
      { return __normal_iterator(_M_current - __n); }

      constexpr
      const _Iterator&
      base() const noexcept
      { return _M_current; }
    };
# 1166 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    [[nodiscard]]
    constexpr bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept(noexcept(__lhs.base() == __rhs.base()))
    requires requires {
      { __lhs.base() == __rhs.base() } -> std::convertible_to<bool>;
    }
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    [[nodiscard]]
    constexpr std::__detail::__synth3way_t<_IteratorR, _IteratorL>
    operator<=>(const __normal_iterator<_IteratorL, _Container>& __lhs,
  const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept(noexcept(std::__detail::__synth3way(__lhs.base(), __rhs.base())))
    { return std::__detail::__synth3way(__lhs.base(), __rhs.base()); }

  template<typename _Iterator, typename _Container>
    [[nodiscard]]
    constexpr bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept(noexcept(__lhs.base() == __rhs.base()))
    requires requires {
      { __lhs.base() == __rhs.base() } -> std::convertible_to<bool>;
    }
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
    [[nodiscard]]
    constexpr std::__detail::__synth3way_t<_Iterator>
    operator<=>(const __normal_iterator<_Iterator, _Container>& __lhs,
  const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept(noexcept(std::__detail::__synth3way(__lhs.base(), __rhs.base())))
    { return std::__detail::__synth3way(__lhs.base(), __rhs.base()); }
# 1307 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>


    [[__nodiscard__]] constexpr
    inline auto
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs) noexcept
    -> decltype(__lhs.base() - __rhs.base())





    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    [[__nodiscard__]] constexpr
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    [[__nodiscard__]] constexpr
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    noexcept
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }


}

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Iterator, typename _Container>
    constexpr
    _Iterator
    __niter_base(__gnu_cxx::__normal_iterator<_Iterator, _Container> __it)
    noexcept(std::is_nothrow_copy_constructible<_Iterator>::value)
    { return __it.base(); }
# 1371 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
  template<semiregular _Sent>
    class move_sentinel
    {
    public:
      constexpr
      move_sentinel()
      noexcept(is_nothrow_default_constructible_v<_Sent>)
      : _M_last() { }

      constexpr explicit
      move_sentinel(_Sent __s)
      noexcept(is_nothrow_move_constructible_v<_Sent>)
      : _M_last(std::move(__s)) { }

      template<typename _S2> requires convertible_to<const _S2&, _Sent>
 constexpr
 move_sentinel(const move_sentinel<_S2>& __s)
 noexcept(is_nothrow_constructible_v<_Sent, const _S2&>)
 : _M_last(__s.base())
 { }

      template<typename _S2> requires assignable_from<_Sent&, const _S2&>
 constexpr move_sentinel&
 operator=(const move_sentinel<_S2>& __s)
 noexcept(is_nothrow_assignable_v<_Sent, const _S2&>)
 {
   _M_last = __s.base();
   return *this;
 }

      [[nodiscard]]
      constexpr _Sent
      base() const
      noexcept(is_nothrow_copy_constructible_v<_Sent>)
      { return _M_last; }

    private:
      _Sent _M_last;
    };


  namespace __detail
  {

    template<typename _Iterator>
      struct __move_iter_cat
      { };

    template<typename _Iterator>
      requires requires { typename __iter_category_t<_Iterator>; }
      struct __move_iter_cat<_Iterator>
      {
 using iterator_category
   = __clamp_iter_cat<__iter_category_t<_Iterator>,
        random_access_iterator_tag>;
      };

  }
# 1439 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class move_iterator

      : public __detail::__move_iter_cat<_Iterator>

    {
      _Iterator _M_current;

      using __traits_type = iterator_traits<_Iterator>;




      template<typename _Iter2>
 friend class move_iterator;




      template<typename _Iter2>
 static constexpr bool __convertible = !is_same_v<_Iter2, _Iterator>
     && convertible_to<const _Iter2&, _Iterator>;



      static auto
      _S_iter_concept()
      {
 if constexpr (random_access_iterator<_Iterator>)
   return random_access_iterator_tag{};
 else if constexpr (bidirectional_iterator<_Iterator>)
   return bidirectional_iterator_tag{};
 else if constexpr (forward_iterator<_Iterator>)
   return forward_iterator_tag{};
 else
   return input_iterator_tag{};
      }


    public:
      using iterator_type = _Iterator;


      using iterator_concept = decltype(_S_iter_concept());


      using value_type = iter_value_t<_Iterator>;
      using difference_type = iter_difference_t<_Iterator>;
      using pointer = _Iterator;
      using reference = iter_rvalue_reference_t<_Iterator>;
# 1503 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
      constexpr
      move_iterator()
      : _M_current() { }

      explicit constexpr
      move_iterator(iterator_type __i)
      : _M_current(std::move(__i)) { }

      template<typename _Iter>

 requires __convertible<_Iter>

 constexpr
 move_iterator(const move_iterator<_Iter>& __i)
 : _M_current(__i._M_current) { }

      template<typename _Iter>

 requires __convertible<_Iter>
   && assignable_from<_Iterator&, const _Iter&>

 constexpr
 move_iterator& operator=(const move_iterator<_Iter>& __i)
 {
   _M_current = __i._M_current;
   return *this;
 }







      [[nodiscard]]
      constexpr const iterator_type&
      base() const & noexcept
      { return _M_current; }

      [[nodiscard]]
      constexpr iterator_type
      base() &&
      { return std::move(_M_current); }


      [[__nodiscard__]]
      constexpr reference
      operator*() const

      { return ranges::iter_move(_M_current); }




      [[__nodiscard__]]
      constexpr pointer
      operator->() const
      { return _M_current; }

      constexpr move_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      constexpr move_iterator
      operator++(int)
      {
 move_iterator __tmp = *this;
 ++_M_current;
 return __tmp;
      }


      constexpr void
      operator++(int) requires (!forward_iterator<_Iterator>)
      { ++_M_current; }


      constexpr move_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      constexpr move_iterator
      operator--(int)
      {
 move_iterator __tmp = *this;
 --_M_current;
 return __tmp;
      }

      [[__nodiscard__]]
      constexpr move_iterator
      operator+(difference_type __n) const
      { return move_iterator(_M_current + __n); }

      constexpr move_iterator&
      operator+=(difference_type __n)
      {
 _M_current += __n;
 return *this;
      }

      [[__nodiscard__]]
      constexpr move_iterator
      operator-(difference_type __n) const
      { return move_iterator(_M_current - __n); }

      constexpr move_iterator&
      operator-=(difference_type __n)
      {
 _M_current -= __n;
 return *this;
      }

      [[__nodiscard__]]
      constexpr reference
      operator[](difference_type __n) const

      { return ranges::iter_move(_M_current + __n); }





      template<sentinel_for<_Iterator> _Sent>
 [[nodiscard]]
 friend constexpr bool
 operator==(const move_iterator& __x, const move_sentinel<_Sent>& __y)
 { return __x.base() == __y.base(); }

      template<sized_sentinel_for<_Iterator> _Sent>
 [[nodiscard]]
 friend constexpr iter_difference_t<_Iterator>
 operator-(const move_sentinel<_Sent>& __x, const move_iterator& __y)
 { return __x.base() - __y.base(); }

      template<sized_sentinel_for<_Iterator> _Sent>
 [[nodiscard]]
 friend constexpr iter_difference_t<_Iterator>
 operator-(const move_iterator& __x, const move_sentinel<_Sent>& __y)
 { return __x.base() - __y.base(); }

      [[nodiscard]]
      friend constexpr iter_rvalue_reference_t<_Iterator>
      iter_move(const move_iterator& __i)
      noexcept(noexcept(ranges::iter_move(__i._M_current)))
      { return ranges::iter_move(__i._M_current); }

      template<indirectly_swappable<_Iterator> _Iter2>
 friend constexpr void
 iter_swap(const move_iterator& __x, const move_iterator<_Iter2>& __y)
 noexcept(noexcept(ranges::iter_swap(__x._M_current, __y._M_current)))
 { return ranges::iter_swap(__x._M_current, __y._M_current); }

    };

  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr bool
    operator==(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)

    requires requires { { __x.base() == __y.base() } -> convertible_to<bool>; }

    { return __x.base() == __y.base(); }


  template<typename _IteratorL,
    three_way_comparable_with<_IteratorL> _IteratorR>
    [[__nodiscard__]]
    constexpr compare_three_way_result_t<_IteratorL, _IteratorR>
    operator<=>(const move_iterator<_IteratorL>& __x,
  const move_iterator<_IteratorR>& __y)
    { return __x.base() <=> __y.base(); }
# 1691 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr bool
    operator<(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)

    requires requires { { __x.base() < __y.base() } -> convertible_to<bool>; }

    { return __x.base() < __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr bool
    operator<=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)

    requires requires { { __y.base() < __x.base() } -> convertible_to<bool>; }

    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr bool
    operator>(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)

    requires requires { { __y.base() < __x.base() } -> convertible_to<bool>; }

    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr bool
    operator>=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)

    requires requires { { __x.base() < __y.base() } -> convertible_to<bool>; }

    { return !(__x < __y); }




  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr bool
    operator==(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }


  template<three_way_comparable _Iterator>
    [[__nodiscard__]]
    constexpr compare_three_way_result_t<_Iterator>
    operator<=>(const move_iterator<_Iterator>& __x,
  const move_iterator<_Iterator>& __y)
    { return __x.base() <=> __y.base(); }
# 1786 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR>
    [[__nodiscard__]]
    inline constexpr auto
    operator-(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    -> decltype(__x.base() - __y.base())
    { return __x.base() - __y.base(); }

  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr move_iterator<_Iterator>
    operator+(typename move_iterator<_Iterator>::difference_type __n,
       const move_iterator<_Iterator>& __x)
    { return __x + __n; }

  template<typename _Iterator>
    [[__nodiscard__]]
    inline constexpr move_iterator<_Iterator>
    make_move_iterator(_Iterator __i)
    { return move_iterator<_Iterator>(std::move(__i)); }

  template<typename _Iterator, typename _ReturnType
    = __conditional_t<__move_if_noexcept_cond
      <typename iterator_traits<_Iterator>::value_type>::value,
  _Iterator, move_iterator<_Iterator>>>
    inline constexpr _ReturnType
    __make_move_if_noexcept_iterator(_Iterator __i)
    { return _ReturnType(__i); }



  template<typename _Tp, typename _ReturnType
    = __conditional_t<__move_if_noexcept_cond<_Tp>::value,
        const _Tp*, move_iterator<_Tp*>>>
    inline constexpr _ReturnType
    __make_move_if_noexcept_iterator(_Tp* __i)
    { return _ReturnType(__i); }




  template<typename _Iterator1, typename _Iterator2>
    requires (!sized_sentinel_for<_Iterator1, _Iterator2>)
    inline constexpr bool
    disable_sized_sentinel_for<move_iterator<_Iterator1>,
          move_iterator<_Iterator2>> = true;



  namespace __detail
  {
    template<typename _It>
      concept __common_iter_has_arrow = indirectly_readable<const _It>
 && (requires(const _It& __it) { __it.operator->(); }
     || is_reference_v<iter_reference_t<_It>>
     || constructible_from<iter_value_t<_It>, iter_reference_t<_It>>);

    template<typename _It>
      concept __common_iter_use_postfix_proxy
 = (!requires (_It& __i) { { *__i++ } -> __can_reference; })
   && constructible_from<iter_value_t<_It>, iter_reference_t<_It>>
   && move_constructible<iter_value_t<_It>>;
  }


  template<input_or_output_iterator _It, sentinel_for<_It> _Sent>
    requires (!same_as<_It, _Sent>) && copyable<_It>
  class common_iterator
  {
    template<typename _Tp, typename _Up>
      static constexpr bool
      _S_noexcept1()
      {
 if constexpr (is_trivially_default_constructible_v<_Tp>)
   return is_nothrow_assignable_v<_Tp&, _Up>;
 else
   return is_nothrow_constructible_v<_Tp, _Up>;
      }

    template<typename _It2, typename _Sent2>
      static constexpr bool
      _S_noexcept()
      { return _S_noexcept1<_It, _It2>() && _S_noexcept1<_Sent, _Sent2>(); }

    class __arrow_proxy
    {
      iter_value_t<_It> _M_keep;

      constexpr
      __arrow_proxy(iter_reference_t<_It>&& __x)
      : _M_keep(std::move(__x)) { }

      friend class common_iterator;

    public:
      constexpr const iter_value_t<_It>*
      operator->() const noexcept
      { return std::__addressof(_M_keep); }
    };

    class __postfix_proxy
    {
      iter_value_t<_It> _M_keep;

      constexpr
      __postfix_proxy(iter_reference_t<_It>&& __x)
      : _M_keep(std::forward<iter_reference_t<_It>>(__x)) { }

      friend class common_iterator;

    public:
      constexpr const iter_value_t<_It>&
      operator*() const noexcept
      { return _M_keep; }
    };

  public:
    constexpr
    common_iterator()
    noexcept(is_nothrow_default_constructible_v<_It>)
    requires default_initializable<_It>
    : _M_it(), _M_index(0)
    { }

    constexpr
    common_iterator(_It __i)
    noexcept(is_nothrow_move_constructible_v<_It>)
    : _M_it(std::move(__i)), _M_index(0)
    { }

    constexpr
    common_iterator(_Sent __s)
    noexcept(is_nothrow_move_constructible_v<_Sent>)
    : _M_sent(std::move(__s)), _M_index(1)
    { }

    template<typename _It2, typename _Sent2>
      requires convertible_to<const _It2&, _It>
 && convertible_to<const _Sent2&, _Sent>
      constexpr
      common_iterator(const common_iterator<_It2, _Sent2>& __x)
      noexcept(_S_noexcept<const _It2&, const _Sent2&>())
      : _M_valueless(), _M_index(__x._M_index)
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__x._M_has_value()), false)) std::__glibcxx_assert_fail(); } while (false);
 if (_M_index == 0)
   {
     if constexpr (is_trivially_default_constructible_v<_It>)
       _M_it = std::move(__x._M_it);
     else
       std::construct_at(std::__addressof(_M_it), __x._M_it);
   }
 else if (_M_index == 1)
   {
     if constexpr (is_trivially_default_constructible_v<_Sent>)
       _M_sent = std::move(__x._M_sent);
     else
       std::construct_at(std::__addressof(_M_sent), __x._M_sent);
   }
      }

    common_iterator(const common_iterator&) = default;

    constexpr
    common_iterator(const common_iterator& __x)
    noexcept(_S_noexcept<const _It&, const _Sent&>())
    requires (!is_trivially_copyable_v<_It> || !is_trivially_copyable_v<_Sent>)
    : _M_valueless(), _M_index(__x._M_index)
    {
      if (_M_index == 0)
 {
   if constexpr (is_trivially_default_constructible_v<_It>)
     _M_it = __x._M_it;
   else
     std::construct_at(std::__addressof(_M_it), __x._M_it);
 }
      else if (_M_index == 1)
 {
   if constexpr (is_trivially_default_constructible_v<_Sent>)
     _M_sent = __x._M_sent;
   else
     std::construct_at(std::__addressof(_M_sent), __x._M_sent);
 }
    }

    common_iterator(common_iterator&&) = default;

    constexpr
    common_iterator(common_iterator&& __x)
    noexcept(_S_noexcept<_It, _Sent>())
    requires (!is_trivially_copyable_v<_It> || !is_trivially_copyable_v<_Sent>)
    : _M_valueless(), _M_index(__x._M_index)
    {
      if (_M_index == 0)
 {
   if constexpr (is_trivially_default_constructible_v<_It>)
     _M_it = std::move(__x._M_it);
   else
     std::construct_at(std::__addressof(_M_it), std::move(__x._M_it));
 }
      else if (_M_index == 1)
 {
   if constexpr (is_trivially_default_constructible_v<_Sent>)
     _M_sent = std::move(__x._M_sent);
   else
     std::construct_at(std::__addressof(_M_sent),
         std::move(__x._M_sent));
 }
    }

    constexpr common_iterator&
    operator=(const common_iterator&) = default;

    constexpr common_iterator&
    operator=(const common_iterator& __x)
    noexcept(is_nothrow_copy_assignable_v<_It>
      && is_nothrow_copy_assignable_v<_Sent>
      && is_nothrow_copy_constructible_v<_It>
      && is_nothrow_copy_constructible_v<_Sent>)
    requires (!is_trivially_copy_assignable_v<_It>
  || !is_trivially_copy_assignable_v<_Sent>)
    {
      _M_assign(__x);
      return *this;
    }

    constexpr common_iterator&
    operator=(common_iterator&&) = default;

    constexpr common_iterator&
    operator=(common_iterator&& __x)
    noexcept(is_nothrow_move_assignable_v<_It>
      && is_nothrow_move_assignable_v<_Sent>
      && is_nothrow_move_constructible_v<_It>
      && is_nothrow_move_constructible_v<_Sent>)
    requires (!is_trivially_move_assignable_v<_It>
  || !is_trivially_move_assignable_v<_Sent>)
    {
      _M_assign(std::move(__x));
      return *this;
    }

    template<typename _It2, typename _Sent2>
      requires convertible_to<const _It2&, _It>
 && convertible_to<const _Sent2&, _Sent>
 && assignable_from<_It&, const _It2&>
 && assignable_from<_Sent&, const _Sent2&>
      constexpr common_iterator&
      operator=(const common_iterator<_It2, _Sent2>& __x)
      noexcept(is_nothrow_constructible_v<_It, const _It2&>
        && is_nothrow_constructible_v<_Sent, const _Sent2&>
        && is_nothrow_assignable_v<_It&, const _It2&>
        && is_nothrow_assignable_v<_Sent&, const _Sent2&>)
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__x._M_has_value()), false)) std::__glibcxx_assert_fail(); } while (false);
 _M_assign(__x);
 return *this;
      }


    ~common_iterator() = default;

    constexpr
    ~common_iterator()
      requires (!is_trivially_destructible_v<_It>
    || !is_trivially_destructible_v<_Sent>)




    {
      if (_M_index == 0)
 _M_it.~_It();
      else if (_M_index == 1)
 _M_sent.~_Sent();
    }

    [[nodiscard]]
    constexpr decltype(auto)
    operator*()
    {
      do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(_M_index == 0), false)) std::__glibcxx_assert_fail(); } while (false);
      return *_M_it;
    }

    [[nodiscard]]
    constexpr decltype(auto)
    operator*() const requires __detail::__dereferenceable<const _It>
    {
      do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(_M_index == 0), false)) std::__glibcxx_assert_fail(); } while (false);
      return *_M_it;
    }

    [[nodiscard]]
    constexpr auto
    operator->() const requires __detail::__common_iter_has_arrow<_It>
    {
      do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(_M_index == 0), false)) std::__glibcxx_assert_fail(); } while (false);
      if constexpr (is_pointer_v<_It> || requires { _M_it.operator->(); })
 return _M_it;
      else if constexpr (is_reference_v<iter_reference_t<_It>>)
 {
   auto&& __tmp = *_M_it;
   return std::__addressof(__tmp);
 }
      else
 return __arrow_proxy{*_M_it};
    }

    constexpr common_iterator&
    operator++()
    {
      do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(_M_index == 0), false)) std::__glibcxx_assert_fail(); } while (false);
      ++_M_it;
      return *this;
    }

    constexpr decltype(auto)
    operator++(int)
    {
      do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(_M_index == 0), false)) std::__glibcxx_assert_fail(); } while (false);
      if constexpr (forward_iterator<_It>)
 {
   common_iterator __tmp = *this;
   ++*this;
   return __tmp;
 }
      else if constexpr (!__detail::__common_iter_use_postfix_proxy<_It>)
 return _M_it++;
      else
 {
   __postfix_proxy __p(**this);
   ++*this;
   return __p;
 }
    }

    template<typename _It2, sentinel_for<_It> _Sent2>
      requires sentinel_for<_Sent, _It2>
      friend constexpr bool
      operator== [[nodiscard]] (const common_iterator& __x,
    const common_iterator<_It2, _Sent2>& __y)
      {
 switch(__x._M_index << 2 | __y._M_index)
   {
   case 0b0000:
   case 0b0101:
     return true;
   case 0b0001:
     return __x._M_it == __y._M_sent;
   case 0b0100:
     return __x._M_sent == __y._M_it;
   default:
     do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__x._M_has_value()), false)) std::__glibcxx_assert_fail(); } while (false);
     do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__y._M_has_value()), false)) std::__glibcxx_assert_fail(); } while (false);
     __builtin_unreachable();
   }
      }

    template<typename _It2, sentinel_for<_It> _Sent2>
      requires sentinel_for<_Sent, _It2> && equality_comparable_with<_It, _It2>
      friend constexpr bool
      operator== [[nodiscard]] (const common_iterator& __x,
    const common_iterator<_It2, _Sent2>& __y)
      {
 switch(__x._M_index << 2 | __y._M_index)
   {
   case 0b0101:
     return true;
   case 0b0000:
     return __x._M_it == __y._M_it;
   case 0b0001:
     return __x._M_it == __y._M_sent;
   case 0b0100:
     return __x._M_sent == __y._M_it;
   default:
     do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__x._M_has_value()), false)) std::__glibcxx_assert_fail(); } while (false);
     do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__y._M_has_value()), false)) std::__glibcxx_assert_fail(); } while (false);
     __builtin_unreachable();
   }
      }

    template<sized_sentinel_for<_It> _It2, sized_sentinel_for<_It> _Sent2>
      requires sized_sentinel_for<_Sent, _It2>
      friend constexpr iter_difference_t<_It2>
      operator- [[nodiscard]] (const common_iterator& __x,
          const common_iterator<_It2, _Sent2>& __y)
      {
 switch(__x._M_index << 2 | __y._M_index)
   {
   case 0b0101:
     return 0;
   case 0b0000:
     return __x._M_it - __y._M_it;
   case 0b0001:
     return __x._M_it - __y._M_sent;
   case 0b0100:
     return __x._M_sent - __y._M_it;
   default:
     do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__x._M_has_value()), false)) std::__glibcxx_assert_fail(); } while (false);
     do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__y._M_has_value()), false)) std::__glibcxx_assert_fail(); } while (false);
     __builtin_unreachable();
   }
      }

    [[nodiscard]]
    friend constexpr iter_rvalue_reference_t<_It>
    iter_move(const common_iterator& __i)
    noexcept(noexcept(ranges::iter_move(std::declval<const _It&>())))
    requires input_iterator<_It>
    {
      do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__i._M_index == 0), false)) std::__glibcxx_assert_fail(); } while (false);
      return ranges::iter_move(__i._M_it);
    }

    template<indirectly_swappable<_It> _It2, typename _Sent2>
      friend constexpr void
      iter_swap(const common_iterator& __x,
  const common_iterator<_It2, _Sent2>& __y)
      noexcept(noexcept(ranges::iter_swap(std::declval<const _It&>(),
       std::declval<const _It2&>())))
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__x._M_index == 0), false)) std::__glibcxx_assert_fail(); } while (false);
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__y._M_index == 0), false)) std::__glibcxx_assert_fail(); } while (false);
 return ranges::iter_swap(__x._M_it, __y._M_it);
      }

  private:
    template<input_or_output_iterator _It2, sentinel_for<_It2> _Sent2>
      requires (!same_as<_It2, _Sent2>) && copyable<_It2>
      friend class common_iterator;

    constexpr bool
    _M_has_value() const noexcept { return _M_index != _S_valueless; }

    template<typename _CIt>
      constexpr void
      _M_assign(_CIt&& __x)
      {
 if (_M_index == __x._M_index)
   {
     if (_M_index == 0)
       _M_it = std::forward<_CIt>(__x)._M_it;
     else if (_M_index == 1)
       _M_sent = std::forward<_CIt>(__x)._M_sent;
   }
 else
   {
     if (_M_index == 0)
       _M_it.~_It();
     else if (_M_index == 1)
       _M_sent.~_Sent();
     _M_index = _S_valueless;

     if (__x._M_index == 0)
       std::construct_at(std::__addressof(_M_it),
    std::forward<_CIt>(__x)._M_it);
     else if (__x._M_index == 1)
       std::construct_at(std::__addressof(_M_sent),
    std::forward<_CIt>(__x)._M_sent);
     _M_index = __x._M_index;
   }
      }

    union
    {
      _It _M_it;
      _Sent _M_sent;
      unsigned char _M_valueless;
    };
    unsigned char _M_index;

    static constexpr unsigned char _S_valueless{2};
  };

  template<typename _It, typename _Sent>
    struct incrementable_traits<common_iterator<_It, _Sent>>
    {
      using difference_type = iter_difference_t<_It>;
    };

  template<input_iterator _It, typename _Sent>
    struct iterator_traits<common_iterator<_It, _Sent>>
    {
    private:
      template<typename _Iter>
 struct __ptr
 {
   using type = void;
 };

      template<typename _Iter>
 requires __detail::__common_iter_has_arrow<_Iter>
 struct __ptr<_Iter>
 {
   using _CIter = common_iterator<_Iter, _Sent>;
   using type = decltype(std::declval<const _CIter&>().operator->());
 };

      static auto
      _S_iter_cat()
      {
 if constexpr (requires { requires derived_from<__iter_category_t<_It>,
             forward_iterator_tag>; })
   return forward_iterator_tag{};
 else
   return input_iterator_tag{};
      }

    public:
      using iterator_concept = __conditional_t<forward_iterator<_It>,
            forward_iterator_tag,
            input_iterator_tag>;
      using iterator_category = decltype(_S_iter_cat());
      using value_type = iter_value_t<_It>;
      using difference_type = iter_difference_t<_It>;
      using pointer = typename __ptr<_It>::type;
      using reference = iter_reference_t<_It>;
    };



  namespace __detail
  {
    template<typename _It>
      struct __counted_iter_value_type
      { };

    template<indirectly_readable _It>
      struct __counted_iter_value_type<_It>
      { using value_type = iter_value_t<_It>; };

    template<typename _It>
      struct __counted_iter_concept
      { };

    template<typename _It>
      requires requires { typename _It::iterator_concept; }
      struct __counted_iter_concept<_It>
      { using iterator_concept = typename _It::iterator_concept; };

    template<typename _It>
      struct __counted_iter_cat
      { };

    template<typename _It>
      requires requires { typename _It::iterator_category; }
      struct __counted_iter_cat<_It>
      { using iterator_category = typename _It::iterator_category; };
  }


  template<input_or_output_iterator _It>
    class counted_iterator
      : public __detail::__counted_iter_value_type<_It>,
 public __detail::__counted_iter_concept<_It>,
 public __detail::__counted_iter_cat<_It>
    {
    public:
      using iterator_type = _It;

      using difference_type = iter_difference_t<_It>;



      constexpr counted_iterator() requires default_initializable<_It> = default;

      constexpr
      counted_iterator(_It __i, iter_difference_t<_It> __n)
      : _M_current(std::move(__i)), _M_length(__n)
      { do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__n >= 0), false)) std::__glibcxx_assert_fail(); } while (false); }

      template<typename _It2>
 requires convertible_to<const _It2&, _It>
 constexpr
 counted_iterator(const counted_iterator<_It2>& __x)
 : _M_current(__x._M_current), _M_length(__x._M_length)
 { }

      template<typename _It2>
 requires assignable_from<_It&, const _It2&>
 constexpr counted_iterator&
 operator=(const counted_iterator<_It2>& __x)
 {
   _M_current = __x._M_current;
   _M_length = __x._M_length;
   return *this;
 }

      [[nodiscard]]
      constexpr const _It&
      base() const & noexcept
      { return _M_current; }

      [[nodiscard]]
      constexpr _It
      base() &&
      noexcept(is_nothrow_move_constructible_v<_It>)
      { return std::move(_M_current); }

      [[nodiscard]]
      constexpr iter_difference_t<_It>
      count() const noexcept { return _M_length; }

      [[nodiscard]]
      constexpr decltype(auto)
      operator*()
      noexcept(noexcept(*_M_current))
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(_M_length > 0), false)) std::__glibcxx_assert_fail(); } while (false);
 return *_M_current;
      }

      [[nodiscard]]
      constexpr decltype(auto)
      operator*() const
      noexcept(noexcept(*_M_current))
      requires __detail::__dereferenceable<const _It>
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(_M_length > 0), false)) std::__glibcxx_assert_fail(); } while (false);
 return *_M_current;
      }

      [[nodiscard]]
      constexpr auto
      operator->() const noexcept
      requires contiguous_iterator<_It>
      { return std::to_address(_M_current); }

      constexpr counted_iterator&
      operator++()
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(_M_length > 0), false)) std::__glibcxx_assert_fail(); } while (false);
 ++_M_current;
 --_M_length;
 return *this;
      }

      constexpr decltype(auto)
      operator++(int)
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(_M_length > 0), false)) std::__glibcxx_assert_fail(); } while (false);
 --_M_length;
 try
   {
     return _M_current++;
   } catch(...) {
     ++_M_length;
     throw;
   }
      }

      constexpr counted_iterator
      operator++(int) requires forward_iterator<_It>
      {
 auto __tmp = *this;
 ++*this;
 return __tmp;
      }

      constexpr counted_iterator&
      operator--() requires bidirectional_iterator<_It>
      {
 --_M_current;
 ++_M_length;
 return *this;
      }

      constexpr counted_iterator
      operator--(int) requires bidirectional_iterator<_It>
      {
 auto __tmp = *this;
 --*this;
 return __tmp;
      }

      [[nodiscard]]
      constexpr counted_iterator
      operator+(iter_difference_t<_It> __n) const
 requires random_access_iterator<_It>
      { return counted_iterator(_M_current + __n, _M_length - __n); }

      [[nodiscard]]
      friend constexpr counted_iterator
      operator+(iter_difference_t<_It> __n, const counted_iterator& __x)
      requires random_access_iterator<_It>
      { return __x + __n; }

      constexpr counted_iterator&
      operator+=(iter_difference_t<_It> __n)
      requires random_access_iterator<_It>
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__n <= _M_length), false)) std::__glibcxx_assert_fail(); } while (false);
 _M_current += __n;
 _M_length -= __n;
 return *this;
      }

      [[nodiscard]]
      constexpr counted_iterator
      operator-(iter_difference_t<_It> __n) const
      requires random_access_iterator<_It>
      { return counted_iterator(_M_current - __n, _M_length + __n); }

      template<common_with<_It> _It2>
 [[nodiscard]]
 friend constexpr iter_difference_t<_It2>
 operator-(const counted_iterator& __x,
    const counted_iterator<_It2>& __y)
 { return __y._M_length - __x._M_length; }

      [[nodiscard]]
      friend constexpr iter_difference_t<_It>
      operator-(const counted_iterator& __x, default_sentinel_t)
      { return -__x._M_length; }

      [[nodiscard]]
      friend constexpr iter_difference_t<_It>
      operator-(default_sentinel_t, const counted_iterator& __y)
      { return __y._M_length; }

      constexpr counted_iterator&
      operator-=(iter_difference_t<_It> __n)
      requires random_access_iterator<_It>
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(-__n <= _M_length), false)) std::__glibcxx_assert_fail(); } while (false);
 _M_current -= __n;
 _M_length += __n;
 return *this;
      }

      [[nodiscard]]
      constexpr decltype(auto)
      operator[](iter_difference_t<_It> __n) const
      noexcept(noexcept(_M_current[__n]))
      requires random_access_iterator<_It>
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__n < _M_length), false)) std::__glibcxx_assert_fail(); } while (false);
 return _M_current[__n];
      }

      template<common_with<_It> _It2>
 [[nodiscard]]
 friend constexpr bool
 operator==(const counted_iterator& __x,
     const counted_iterator<_It2>& __y)
 { return __x._M_length == __y._M_length; }

      [[nodiscard]]
      friend constexpr bool
      operator==(const counted_iterator& __x, default_sentinel_t)
      { return __x._M_length == 0; }

      template<common_with<_It> _It2>
 [[nodiscard]]
 friend constexpr strong_ordering
 operator<=>(const counted_iterator& __x,
      const counted_iterator<_It2>& __y)
 { return __y._M_length <=> __x._M_length; }

      [[nodiscard]]
      friend constexpr iter_rvalue_reference_t<_It>
      iter_move(const counted_iterator& __i)
      noexcept(noexcept(ranges::iter_move(__i._M_current)))
      requires input_iterator<_It>
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__i._M_length > 0), false)) std::__glibcxx_assert_fail(); } while (false);
 return ranges::iter_move(__i._M_current);
      }

      template<indirectly_swappable<_It> _It2>
 friend constexpr void
 iter_swap(const counted_iterator& __x,
    const counted_iterator<_It2>& __y)
 noexcept(noexcept(ranges::iter_swap(__x._M_current, __y._M_current)))
 {
   do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__x._M_length > 0 && __y._M_length > 0), false)) std::__glibcxx_assert_fail(); } while (false);
   ranges::iter_swap(__x._M_current, __y._M_current);
 }

    private:
      template<input_or_output_iterator _It2> friend class counted_iterator;

      _It _M_current = _It();
      iter_difference_t<_It> _M_length = 0;
    };

  template<input_iterator _It>
    requires same_as<__detail::__iter_traits<_It>, iterator_traits<_It>>
    struct iterator_traits<counted_iterator<_It>> : iterator_traits<_It>
    {
      using pointer = __conditional_t<contiguous_iterator<_It>,
          add_pointer_t<iter_reference_t<_It>>,
          void>;
    };
# 2960 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
  template<typename _Iterator>
    constexpr
    auto
    __niter_base(move_iterator<_Iterator> __it)
    -> decltype(make_move_iterator(__niter_base(__it.base())))
    { return make_move_iterator(__niter_base(__it.base())); }

  template<typename _Iterator>
    struct __is_move_iterator<move_iterator<_Iterator> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<typename _Iterator>
    constexpr
    auto
    __miter_base(move_iterator<_Iterator> __it)
    -> decltype(__miter_base(__it.base()))
    { return __miter_base(__it.base()); }
# 2992 "/usr/include/c++/14.2.1/bits/stl_iterator.h" 3
  template<typename _InputIterator>
    using __iter_key_t = remove_const_t<



      typename iterator_traits<_InputIterator>::value_type::first_type>;


  template<typename _InputIterator>
    using __iter_val_t



      = typename iterator_traits<_InputIterator>::value_type::second_type;


  template<typename _T1, typename _T2>
    struct pair;

  template<typename _InputIterator>
    using __iter_to_alloc_t
      = pair<const __iter_key_t<_InputIterator>, __iter_val_t<_InputIterator>>;



}
# 68 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 2 3

# 1 "/usr/include/c++/14.2.1/debug/debug.h" 1 3
# 48 "/usr/include/c++/14.2.1/debug/debug.h" 3
namespace std
{
  namespace __debug { }
}




namespace __gnu_debug
{
  using namespace std::__debug;

  template<typename _Ite, typename _Seq, typename _Cat>
    struct _Safe_iterator;
}
# 70 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 2 3

# 1 "/usr/include/c++/14.2.1/bits/predefined_ops.h" 1 3
# 35 "/usr/include/c++/14.2.1/bits/predefined_ops.h" 3
namespace __gnu_cxx
{
namespace __ops
{
  struct _Iter_less_iter
  {
    template<typename _Iterator1, typename _Iterator2>
      constexpr
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 < *__it2; }
  };

  constexpr
  inline _Iter_less_iter
  __iter_less_iter()
  { return _Iter_less_iter(); }

  struct _Iter_less_val
  {

    constexpr _Iter_less_val() = default;




    constexpr
    explicit
    _Iter_less_val(_Iter_less_iter) { }

    template<typename _Iterator, typename _Value>
      constexpr
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it < __val; }
  };

  constexpr
  inline _Iter_less_val
  __iter_less_val()
  { return _Iter_less_val(); }

  constexpr
  inline _Iter_less_val
  __iter_comp_val(_Iter_less_iter)
  { return _Iter_less_val(); }

  struct _Val_less_iter
  {

    constexpr _Val_less_iter() = default;




    constexpr
    explicit
    _Val_less_iter(_Iter_less_iter) { }

    template<typename _Value, typename _Iterator>
      constexpr
      bool
      operator()(_Value& __val, _Iterator __it) const
      { return __val < *__it; }
  };

  constexpr
  inline _Val_less_iter
  __val_less_iter()
  { return _Val_less_iter(); }

  constexpr
  inline _Val_less_iter
  __val_comp_iter(_Iter_less_iter)
  { return _Val_less_iter(); }

  struct _Iter_equal_to_iter
  {
    template<typename _Iterator1, typename _Iterator2>
      constexpr
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 == *__it2; }
  };

  constexpr
  inline _Iter_equal_to_iter
  __iter_equal_to_iter()
  { return _Iter_equal_to_iter(); }

  struct _Iter_equal_to_val
  {
    template<typename _Iterator, typename _Value>
      constexpr
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it == __val; }
  };

  constexpr
  inline _Iter_equal_to_val
  __iter_equal_to_val()
  { return _Iter_equal_to_val(); }

  constexpr
  inline _Iter_equal_to_val
  __iter_comp_val(_Iter_equal_to_iter)
  { return _Iter_equal_to_val(); }

  template<typename _Compare>
    struct _Iter_comp_iter
    {
      _Compare _M_comp;

      explicit constexpr
      _Iter_comp_iter(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

      template<typename _Iterator1, typename _Iterator2>
        constexpr
        bool
        operator()(_Iterator1 __it1, _Iterator2 __it2)
        { return bool(_M_comp(*__it1, *__it2)); }
    };

  template<typename _Compare>
    constexpr
    inline _Iter_comp_iter<_Compare>
    __iter_comp_iter(_Compare __comp)
    { return _Iter_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    struct _Iter_comp_val
    {
      _Compare _M_comp;

      constexpr
      explicit
      _Iter_comp_val(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

      constexpr
      explicit
      _Iter_comp_val(const _Iter_comp_iter<_Compare>& __comp)
 : _M_comp(__comp._M_comp)
      { }


      constexpr
      explicit
      _Iter_comp_val(_Iter_comp_iter<_Compare>&& __comp)
 : _M_comp(std::move(__comp._M_comp))
      { }


      template<typename _Iterator, typename _Value>
 constexpr
 bool
 operator()(_Iterator __it, _Value& __val)
 { return bool(_M_comp(*__it, __val)); }
    };

  template<typename _Compare>
    constexpr
    inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Compare __comp)
    { return _Iter_comp_val<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    constexpr
    inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Iter_comp_iter<_Compare> __comp)
    { return _Iter_comp_val<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    struct _Val_comp_iter
    {
      _Compare _M_comp;

      constexpr
      explicit
      _Val_comp_iter(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

      constexpr
      explicit
      _Val_comp_iter(const _Iter_comp_iter<_Compare>& __comp)
 : _M_comp(__comp._M_comp)
      { }


      constexpr
      explicit
      _Val_comp_iter(_Iter_comp_iter<_Compare>&& __comp)
 : _M_comp(std::move(__comp._M_comp))
      { }


      template<typename _Value, typename _Iterator>
 constexpr
 bool
 operator()(_Value& __val, _Iterator __it)
 { return bool(_M_comp(__val, *__it)); }
    };

  template<typename _Compare>
    constexpr
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Compare __comp)
    { return _Val_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    constexpr
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Iter_comp_iter<_Compare> __comp)
    { return _Val_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Value>
    struct _Iter_equals_val
    {
      _Value& _M_value;

      constexpr
      explicit
      _Iter_equals_val(_Value& __value)
 : _M_value(__value)
      { }

      template<typename _Iterator>
 constexpr
 bool
 operator()(_Iterator __it)
 { return *__it == _M_value; }
    };

  template<typename _Value>
    constexpr
    inline _Iter_equals_val<_Value>
    __iter_equals_val(_Value& __val)
    { return _Iter_equals_val<_Value>(__val); }

  template<typename _Iterator1>
    struct _Iter_equals_iter
    {
      _Iterator1 _M_it1;

      constexpr
      explicit
      _Iter_equals_iter(_Iterator1 __it1)
 : _M_it1(__it1)
      { }

      template<typename _Iterator2>
 constexpr
 bool
 operator()(_Iterator2 __it2)
 { return *__it2 == *_M_it1; }
    };

  template<typename _Iterator>
    constexpr
    inline _Iter_equals_iter<_Iterator>
    __iter_comp_iter(_Iter_equal_to_iter, _Iterator __it)
    { return _Iter_equals_iter<_Iterator>(__it); }

  template<typename _Predicate>
    struct _Iter_pred
    {
      _Predicate _M_pred;

      constexpr
      explicit
      _Iter_pred(_Predicate __pred)
 : _M_pred(std::move(__pred))
      { }

      template<typename _Iterator>
 constexpr
 bool
 operator()(_Iterator __it)
 { return bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
    constexpr
    inline _Iter_pred<_Predicate>
    __pred_iter(_Predicate __pred)
    { return _Iter_pred<_Predicate>(std::move(__pred)); }

  template<typename _Compare, typename _Value>
    struct _Iter_comp_to_val
    {
      _Compare _M_comp;
      _Value& _M_value;

      constexpr
      _Iter_comp_to_val(_Compare __comp, _Value& __value)
 : _M_comp(std::move(__comp)), _M_value(__value)
      { }

      template<typename _Iterator>
 constexpr
 bool
 operator()(_Iterator __it)
 { return bool(_M_comp(*__it, _M_value)); }
    };

  template<typename _Compare, typename _Value>
    _Iter_comp_to_val<_Compare, _Value>
    constexpr
    __iter_comp_val(_Compare __comp, _Value &__val)
    {
      return _Iter_comp_to_val<_Compare, _Value>(std::move(__comp), __val);
    }

  template<typename _Compare, typename _Iterator1>
    struct _Iter_comp_to_iter
    {
      _Compare _M_comp;
      _Iterator1 _M_it1;

      constexpr
      _Iter_comp_to_iter(_Compare __comp, _Iterator1 __it1)
 : _M_comp(std::move(__comp)), _M_it1(__it1)
      { }

      template<typename _Iterator2>
 constexpr
 bool
 operator()(_Iterator2 __it2)
 { return bool(_M_comp(*__it2, *_M_it1)); }
    };

  template<typename _Compare, typename _Iterator>
    constexpr
    inline _Iter_comp_to_iter<_Compare, _Iterator>
    __iter_comp_iter(_Iter_comp_iter<_Compare> __comp, _Iterator __it)
    {
      return _Iter_comp_to_iter<_Compare, _Iterator>(
   std::move(__comp._M_comp), __it);
    }

  template<typename _Predicate>
    struct _Iter_negate
    {
      _Predicate _M_pred;

      constexpr
      explicit
      _Iter_negate(_Predicate __pred)
 : _M_pred(std::move(__pred))
      { }

      template<typename _Iterator>
 constexpr
 bool
 operator()(_Iterator __it)
 { return !bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
    constexpr
    inline _Iter_negate<_Predicate>
    __negate(_Iter_pred<_Predicate> __pred)
    { return _Iter_negate<_Predicate>(std::move(__pred._M_pred)); }

}
}
# 72 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 2 3




# 1 "/usr/include/c++/14.2.1/bit" 1 3
# 32 "/usr/include/c++/14.2.1/bit" 3
       
# 33 "/usr/include/c++/14.2.1/bit" 3
# 61 "/usr/include/c++/14.2.1/bit" 3
# 1 "/usr/include/c++/14.2.1/bits/version.h" 1 3
# 47 "/usr/include/c++/14.2.1/bits/version.h" 3
       
# 48 "/usr/include/c++/14.2.1/bits/version.h" 3
# 62 "/usr/include/c++/14.2.1/bit" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 85 "/usr/include/c++/14.2.1/bit" 3
  template<typename _To, typename _From>
    [[nodiscard]]
    constexpr _To
    bit_cast(const _From& __from) noexcept

    requires (sizeof(_To) == sizeof(_From))
      && is_trivially_copyable_v<_To> && is_trivially_copyable_v<_From>

    {
      return __builtin_bit_cast(_To, __from);
    }
# 155 "/usr/include/c++/14.2.1/bit" 3
  template<typename _Tp>
    constexpr _Tp
    __rotl(_Tp __x, int __s) noexcept
    {
      constexpr auto _Nd = __gnu_cxx::__int_traits<_Tp>::__digits;
      if constexpr ((_Nd & (_Nd - 1)) == 0)
 {


   constexpr unsigned __uNd = _Nd;
   const unsigned __r = __s;
   return (__x << (__r % __uNd)) | (__x >> ((-__r) % __uNd));
 }
      const int __r = __s % _Nd;
      if (__r == 0)
 return __x;
      else if (__r > 0)
 return (__x << __r) | (__x >> ((_Nd - __r) % _Nd));
      else
 return (__x >> -__r) | (__x << ((_Nd + __r) % _Nd));
    }

  template<typename _Tp>
    constexpr _Tp
    __rotr(_Tp __x, int __s) noexcept
    {
      constexpr auto _Nd = __gnu_cxx::__int_traits<_Tp>::__digits;
      if constexpr ((_Nd & (_Nd - 1)) == 0)
 {


   constexpr unsigned __uNd = _Nd;
   const unsigned __r = __s;
   return (__x >> (__r % __uNd)) | (__x << ((-__r) % __uNd));
 }
      const int __r = __s % _Nd;
      if (__r == 0)
 return __x;
      else if (__r > 0)
 return (__x >> __r) | (__x << ((_Nd - __r) % _Nd));
      else
 return (__x << -__r) | (__x >> ((_Nd + __r) % _Nd));
    }

  template<typename _Tp>
    constexpr int
    __countl_zero(_Tp __x) noexcept
    {
      using __gnu_cxx::__int_traits;
      constexpr auto _Nd = __int_traits<_Tp>::__digits;

      if (__x == 0)
        return _Nd;

      constexpr auto _Nd_ull = __int_traits<unsigned long long>::__digits;
      constexpr auto _Nd_ul = __int_traits<unsigned long>::__digits;
      constexpr auto _Nd_u = __int_traits<unsigned>::__digits;

      if constexpr (_Nd <= _Nd_u)
 {
   constexpr int __diff = _Nd_u - _Nd;
   return __builtin_clz(__x) - __diff;
 }
      else if constexpr (_Nd <= _Nd_ul)
 {
   constexpr int __diff = _Nd_ul - _Nd;
   return __builtin_clzl(__x) - __diff;
 }
      else if constexpr (_Nd <= _Nd_ull)
 {
   constexpr int __diff = _Nd_ull - _Nd;
   return __builtin_clzll(__x) - __diff;
 }
      else
 {
   static_assert(_Nd <= (2 * _Nd_ull),
   "Maximum supported integer size is 128-bit");

   unsigned long long __high = __x >> _Nd_ull;
   if (__high != 0)
     {
       constexpr int __diff = (2 * _Nd_ull) - _Nd;
       return __builtin_clzll(__high) - __diff;
     }
   constexpr auto __max_ull = __int_traits<unsigned long long>::__max;
   unsigned long long __low = __x & __max_ull;
   return (_Nd - _Nd_ull) + __builtin_clzll(__low);
 }
    }

  template<typename _Tp>
    constexpr int
    __countl_one(_Tp __x) noexcept
    {
      return std::__countl_zero<_Tp>((_Tp)~__x);
    }

  template<typename _Tp>
    constexpr int
    __countr_zero(_Tp __x) noexcept
    {
      using __gnu_cxx::__int_traits;
      constexpr auto _Nd = __int_traits<_Tp>::__digits;

      if (__x == 0)
        return _Nd;

      constexpr auto _Nd_ull = __int_traits<unsigned long long>::__digits;
      constexpr auto _Nd_ul = __int_traits<unsigned long>::__digits;
      constexpr auto _Nd_u = __int_traits<unsigned>::__digits;

      if constexpr (_Nd <= _Nd_u)
 return __builtin_ctz(__x);
      else if constexpr (_Nd <= _Nd_ul)
 return __builtin_ctzl(__x);
      else if constexpr (_Nd <= _Nd_ull)
 return __builtin_ctzll(__x);
      else
 {
   static_assert(_Nd <= (2 * _Nd_ull),
   "Maximum supported integer size is 128-bit");

   constexpr auto __max_ull = __int_traits<unsigned long long>::__max;
   unsigned long long __low = __x & __max_ull;
   if (__low != 0)
     return __builtin_ctzll(__low);
   unsigned long long __high = __x >> _Nd_ull;
   return __builtin_ctzll(__high) + _Nd_ull;
 }
    }

  template<typename _Tp>
    constexpr int
    __countr_one(_Tp __x) noexcept
    {
      return std::__countr_zero((_Tp)~__x);
    }

  template<typename _Tp>
    constexpr int
    __popcount(_Tp __x) noexcept
    {
      using __gnu_cxx::__int_traits;
      constexpr auto _Nd = __int_traits<_Tp>::__digits;

      constexpr auto _Nd_ull = __int_traits<unsigned long long>::__digits;
      constexpr auto _Nd_ul = __int_traits<unsigned long>::__digits;
      constexpr auto _Nd_u = __int_traits<unsigned>::__digits;

      if constexpr (_Nd <= _Nd_u)
 return __builtin_popcount(__x);
      else if constexpr (_Nd <= _Nd_ul)
 return __builtin_popcountl(__x);
      else if constexpr (_Nd <= _Nd_ull)
 return __builtin_popcountll(__x);
      else
 {
   static_assert(_Nd <= (2 * _Nd_ull),
   "Maximum supported integer size is 128-bit");

   constexpr auto __max_ull = __int_traits<unsigned long long>::__max;
   unsigned long long __low = __x & __max_ull;
   unsigned long long __high = __x >> _Nd_ull;
   return __builtin_popcountll(__low) + __builtin_popcountll(__high);
 }
    }

  template<typename _Tp>
    constexpr bool
    __has_single_bit(_Tp __x) noexcept
    { return std::__popcount(__x) == 1; }

  template<typename _Tp>
    constexpr _Tp
    __bit_ceil(_Tp __x) noexcept
    {
      using __gnu_cxx::__int_traits;
      constexpr auto _Nd = __int_traits<_Tp>::__digits;
      if (__x == 0 || __x == 1)
        return 1;
      auto __shift_exponent = _Nd - std::__countl_zero((_Tp)(__x - 1u));




      if (!std::__is_constant_evaluated())
 {
   do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__shift_exponent != __int_traits<_Tp>::__digits), false)) std::__glibcxx_assert_fail(); } while (false);
 }

      using __promoted_type = decltype(__x << 1);
      if constexpr (!is_same<__promoted_type, _Tp>::value)
 {





   const int __extra_exp = sizeof(__promoted_type) / sizeof(_Tp) / 2;
   __shift_exponent |= (__shift_exponent & _Nd) << __extra_exp;
 }
      return (_Tp)1u << __shift_exponent;
    }

  template<typename _Tp>
    constexpr _Tp
    __bit_floor(_Tp __x) noexcept
    {
      constexpr auto _Nd = __gnu_cxx::__int_traits<_Tp>::__digits;
      if (__x == 0)
        return 0;
      return (_Tp)1u << (_Nd - std::__countl_zero((_Tp)(__x >> 1)));
    }

  template<typename _Tp>
    constexpr int
    __bit_width(_Tp __x) noexcept
    {
      constexpr auto _Nd = __gnu_cxx::__int_traits<_Tp>::__digits;
      return _Nd - std::__countl_zero(__x);
    }






  template<typename _Tp>
    concept __unsigned_integer = __is_unsigned_integer<_Tp>::value;





  template<__unsigned_integer _Tp>
    [[nodiscard]] constexpr _Tp
    rotl(_Tp __x, int __s) noexcept
    { return std::__rotl(__x, __s); }


  template<__unsigned_integer _Tp>
    [[nodiscard]] constexpr _Tp
    rotr(_Tp __x, int __s) noexcept
    { return std::__rotr(__x, __s); }




  template<__unsigned_integer _Tp>
    constexpr int
    countl_zero(_Tp __x) noexcept
    { return std::__countl_zero(__x); }


  template<__unsigned_integer _Tp>
    constexpr int
    countl_one(_Tp __x) noexcept
    { return std::__countl_one(__x); }


  template<__unsigned_integer _Tp>
    constexpr int
    countr_zero(_Tp __x) noexcept
    { return std::__countr_zero(__x); }


  template<__unsigned_integer _Tp>
    constexpr int
    countr_one(_Tp __x) noexcept
    { return std::__countr_one(__x); }


  template<__unsigned_integer _Tp>
    constexpr int
    popcount(_Tp __x) noexcept
    { return std::__popcount(__x); }






  template<__unsigned_integer _Tp>
    constexpr bool
    has_single_bit(_Tp __x) noexcept
    { return std::__has_single_bit(__x); }


  template<__unsigned_integer _Tp>
    constexpr _Tp
    bit_ceil(_Tp __x) noexcept
    { return std::__bit_ceil(__x); }


  template<__unsigned_integer _Tp>
    constexpr _Tp
    bit_floor(_Tp __x) noexcept
    { return std::__bit_floor(__x); }




  template<__unsigned_integer _Tp>
    constexpr int
    bit_width(_Tp __x) noexcept
    { return std::__bit_width(__x); }
# 472 "/usr/include/c++/14.2.1/bit" 3
  enum class endian
  {
    little = 1234,
    big = 4321,
    native = 1234
  };





}
# 77 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{






  template<typename _Tp, typename _Up>
    constexpr
    inline int
    __memcmp(const _Tp* __first1, const _Up* __first2, size_t __num)
    {

      static_assert(sizeof(_Tp) == sizeof(_Up), "can be compared with memcmp");


      if (std::is_constant_evaluated())
 {
   for(; __num > 0; ++__first1, ++__first2, --__num)
     if (*__first1 != *__first2)
       return *__first1 < *__first2 ? -1 : 1;
   return 0;
 }
      else

 return __builtin_memcmp(__first1, __first2, sizeof(_Tp) * __num);
    }
# 152 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    constexpr
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {

     

     
# 185 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
      swap(*__a, *__b);

    }
# 201 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    constexpr
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {

     

     

      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
# 230 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _Tp>
    [[__nodiscard__]] constexpr
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {

     

      if (__b < __a)
 return __b;
      return __a;
    }
# 254 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _Tp>
    [[__nodiscard__]] constexpr
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {

     

      if (__a < __b)
 return __b;
      return __a;
    }
# 278 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    [[__nodiscard__]] constexpr
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
# 300 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    [[__nodiscard__]] constexpr
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }



  template<typename _Iterator>
    constexpr
    inline _Iterator
    __niter_base(_Iterator __it)
    noexcept(std::is_nothrow_copy_constructible<_Iterator>::value)
    { return __it; }
# 332 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _Ite, typename _Seq>
    constexpr
    decltype(std::__niter_base(std::declval<_Ite>()))
    __niter_base(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq,
   std::random_access_iterator_tag>&)
    noexcept(std::is_nothrow_copy_constructible<_Ite>::value);





  template<typename _From, typename _To>
    constexpr
    inline _From
    __niter_wrap(_From __from, _To __res)
    { return __from + (std::__niter_base(__res) - std::__niter_base(__from)); }


  template<typename _Iterator>
    constexpr
    inline _Iterator
    __niter_wrap(const _Iterator&, _Iterator __res)
    { return __res; }







  template<bool _IsMove, bool _IsSimple, typename _Category>
    struct __copy_move
    {
      template<typename _II, typename _OI>
 constexpr
 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   for (; __first != __last; ++__result, (void)++__first)
     *__result = *__first;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move<true, false, _Category>
    {
      template<typename _II, typename _OI>
 constexpr
 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   for (; __first != __last; ++__result, (void)++__first)
     *__result = std::move(*__first);
   return __result;
 }
    };


  template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
 constexpr
 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }

      template<typename _Tp, typename _Up>
 static void
 __assign_one(_Tp* __to, _Up* __from)
 { *__to = *__from; }
    };


  template<>
    struct __copy_move<true, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
 constexpr
 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = std::move(*__first);
       ++__first;
       ++__result;
     }
   return __result;
 }

      template<typename _Tp, typename _Up>
 static void
 __assign_one(_Tp* __to, _Up* __from)
 { *__to = std::move(*__from); }
    };


  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp, typename _Up>
 constexpr
 static _Up*
 __copy_m(_Tp* __first, _Tp* __last, _Up* __result)
 {
   const ptrdiff_t _Num = __last - __first;
   if (__builtin_expect(_Num > 1, true))
     __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
   else if (_Num == 1)
     std::__copy_move<_IsMove, false, random_access_iterator_tag>::
       __assign_one(__result, __first);
   return __result + _Num;
 }
    };



  template<typename _Tp, typename _Ref, typename _Ptr>
    struct _Deque_iterator;

  struct _Bit_iterator;






  template<typename _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(_CharT*, _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(const _CharT*, const _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
     istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<
      __is_char<_CharT>::__value,
      std::_Deque_iterator<_CharT, _CharT&, _CharT*> >::__type
    __copy_move_a2(
 istreambuf_iterator<_CharT, char_traits<_CharT> >,
 istreambuf_iterator<_CharT, char_traits<_CharT> >,
 std::_Deque_iterator<_CharT, _CharT&, _CharT*>);


  template<bool _IsMove, typename _II, typename _OI>
    constexpr
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::iterator_category _Category;

      if (std::is_constant_evaluated())
 return std::__copy_move<_IsMove, false, _Category>::
   __copy_m(__first, __last, __result);

      return std::__copy_move<_IsMove, __memcpyable<_OI, _II>::__value,
         _Category>::__copy_m(__first, __last, __result);
    }

  template<bool _IsMove,
    typename _Tp, typename _Ref, typename _Ptr, typename _OI>
    _OI
    __copy_move_a1(std::_Deque_iterator<_Tp, _Ref, _Ptr>,
     std::_Deque_iterator<_Tp, _Ref, _Ptr>,
     _OI);

  template<bool _IsMove,
    typename _ITp, typename _IRef, typename _IPtr, typename _OTp>
    std::_Deque_iterator<_OTp, _OTp&, _OTp*>
    __copy_move_a1(std::_Deque_iterator<_ITp, _IRef, _IPtr>,
     std::_Deque_iterator<_ITp, _IRef, _IPtr>,
     std::_Deque_iterator<_OTp, _OTp&, _OTp*>);

  template<bool _IsMove, typename _II, typename _Tp>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value,
      std::_Deque_iterator<_Tp, _Tp&, _Tp*> >::__type
    __copy_move_a1(_II, _II, std::_Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<bool _IsMove, typename _II, typename _OI>
    constexpr
    inline _OI
    __copy_move_a1(_II __first, _II __last, _OI __result)
    { return std::__copy_move_a2<_IsMove>(__first, __last, __result); }

  template<bool _IsMove, typename _II, typename _OI>
    constexpr
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
    {
      return std::__niter_wrap(__result,
  std::__copy_move_a1<_IsMove>(std::__niter_base(__first),
          std::__niter_base(__last),
          std::__niter_base(__result)));
    }

  template<bool _IsMove,
    typename _Ite, typename _Seq, typename _Cat, typename _OI>
    constexpr
    _OI
    __copy_move_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
    const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
    _OI);

  template<bool _IsMove,
    typename _II, typename _Ite, typename _Seq, typename _Cat>
    constexpr
    __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>
    __copy_move_a(_II, _II,
    const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&);

  template<bool _IsMove,
    typename _IIte, typename _ISeq, typename _ICat,
    typename _OIte, typename _OSeq, typename _OCat>
    constexpr
    ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>
    __copy_move_a(const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
    const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
    const ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>&);

  template<typename _InputIterator, typename _Size, typename _OutputIterator>
    constexpr
    _OutputIterator
    __copy_n_a(_InputIterator __first, _Size __n, _OutputIterator __result,
        bool)
    {
      if (__n > 0)
 {
   while (true)
     {
       *__result = *__first;
       ++__result;
       if (--__n > 0)
  ++__first;
       else
  break;
     }
 }
      return __result;
    }


  template<typename _CharT, typename _Size>
    typename __gnu_cxx::__enable_if<
      __is_char<_CharT>::__value, _CharT*>::__type
    __copy_n_a(istreambuf_iterator<_CharT, char_traits<_CharT> >,
        _Size, _CharT*, bool);

  template<typename _CharT, typename _Size>
    typename __gnu_cxx::__enable_if<
      __is_char<_CharT>::__value,
      std::_Deque_iterator<_CharT, _CharT&, _CharT*> >::__type
    __copy_n_a(istreambuf_iterator<_CharT, char_traits<_CharT> >, _Size,
        std::_Deque_iterator<_CharT, _CharT&, _CharT*>,
        bool);
# 639 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    constexpr
    inline _OI
    copy(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return std::__copy_move_a<__is_move_iterator<_II>::__value>
      (std::__miter_base(__first), std::__miter_base(__last), __result);
    }
# 672 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    constexpr
    inline _OI
    move(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return std::__copy_move_a<true>(std::__miter_base(__first),
          std::__miter_base(__last), __result);
    }






  template<bool _IsMove, bool _IsSimple, typename _Category>
    struct __copy_move_backward
    {
      template<typename _BI1, typename _BI2>
 constexpr
 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move_backward<true, false, _Category>
    {
      template<typename _BI1, typename _BI2>
 constexpr
 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   while (__first != __last)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
 constexpr
 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   typename iterator_traits<_BI1>::difference_type
     __n = __last - __first;
   for (; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<true, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
 constexpr
 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   typename iterator_traits<_BI1>::difference_type
     __n = __last - __first;
   for (; __n > 0; --__n)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp, typename _Up>
 constexpr
 static _Up*
 __copy_move_b(_Tp* __first, _Tp* __last, _Up* __result)
 {
   const ptrdiff_t _Num = __last - __first;
   if (__builtin_expect(_Num > 1, true))
     __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   else if (_Num == 1)
     std::__copy_move<_IsMove, false, random_access_iterator_tag>::
       __assign_one(__result - 1, __first);
   return __result - _Num;
 }
    };

  template<bool _IsMove, typename _BI1, typename _BI2>
    constexpr
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::iterator_category _Category;

      if (std::is_constant_evaluated())
 return std::__copy_move_backward<_IsMove, false, _Category>::
   __copy_move_b(__first, __last, __result);

      return std::__copy_move_backward<_IsMove,
           __memcpyable<_BI2, _BI1>::__value,
           _Category>::__copy_move_b(__first,
         __last,
         __result);
    }

  template<bool _IsMove, typename _BI1, typename _BI2>
    constexpr
    inline _BI2
    __copy_move_backward_a1(_BI1 __first, _BI1 __last, _BI2 __result)
    { return std::__copy_move_backward_a2<_IsMove>(__first, __last, __result); }

  template<bool _IsMove,
    typename _Tp, typename _Ref, typename _Ptr, typename _OI>
    _OI
    __copy_move_backward_a1(std::_Deque_iterator<_Tp, _Ref, _Ptr>,
       std::_Deque_iterator<_Tp, _Ref, _Ptr>,
       _OI);

  template<bool _IsMove,
    typename _ITp, typename _IRef, typename _IPtr, typename _OTp>
    std::_Deque_iterator<_OTp, _OTp&, _OTp*>
    __copy_move_backward_a1(
   std::_Deque_iterator<_ITp, _IRef, _IPtr>,
   std::_Deque_iterator<_ITp, _IRef, _IPtr>,
   std::_Deque_iterator<_OTp, _OTp&, _OTp*>);

  template<bool _IsMove, typename _II, typename _Tp>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value,
      std::_Deque_iterator<_Tp, _Tp&, _Tp*> >::__type
    __copy_move_backward_a1(_II, _II,
       std::_Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<bool _IsMove, typename _II, typename _OI>
    constexpr
    inline _OI
    __copy_move_backward_a(_II __first, _II __last, _OI __result)
    {
      return std::__niter_wrap(__result,
  std::__copy_move_backward_a1<_IsMove>
    (std::__niter_base(__first), std::__niter_base(__last),
     std::__niter_base(__result)));
    }

  template<bool _IsMove,
    typename _Ite, typename _Seq, typename _Cat, typename _OI>
    constexpr
    _OI
    __copy_move_backward_a(
  const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
  const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
  _OI);

  template<bool _IsMove,
    typename _II, typename _Ite, typename _Seq, typename _Cat>
    constexpr
    __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>
    __copy_move_backward_a(_II, _II,
  const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&);

  template<bool _IsMove,
    typename _IIte, typename _ISeq, typename _ICat,
    typename _OIte, typename _OSeq, typename _OCat>
    constexpr
    ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>
    __copy_move_backward_a(
  const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
  const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
  const ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>&);
# 875 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    constexpr
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     

      ;

      return std::__copy_move_backward_a<__is_move_iterator<_BI1>::__value>
      (std::__miter_base(__first), std::__miter_base(__last), __result);
    }
# 910 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    constexpr
    inline _BI2
    move_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     

      ;

      return std::__copy_move_backward_a<true>(std::__miter_base(__first),
            std::__miter_base(__last),
            __result);
    }






  template<typename _ForwardIterator, typename _Tp>
    constexpr
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
    __fill_a1(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      for (; __first != __last; ++__first)
 *__first = __value;
    }

  template<typename _ForwardIterator, typename _Tp>
    constexpr
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a1(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
 *__first = __tmp;
    }


  template<typename _Tp>
    constexpr
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a1(_Tp* __first, _Tp* __last, const _Tp& __c)
    {
      const _Tp __tmp = __c;

      if (std::is_constant_evaluated())
 {
   for (; __first != __last; ++__first)
     *__first = __tmp;
   return;
 }

      if (const size_t __len = __last - __first)
 __builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);
    }

  template<typename _Ite, typename _Cont, typename _Tp>
    constexpr
    inline void
    __fill_a1(::__gnu_cxx::__normal_iterator<_Ite, _Cont> __first,
       ::__gnu_cxx::__normal_iterator<_Ite, _Cont> __last,
       const _Tp& __value)
    { std::__fill_a1(__first.base(), __last.base(), __value); }

  template<typename _Tp, typename _VTp>
    void
    __fill_a1(const std::_Deque_iterator<_Tp, _Tp&, _Tp*>&,
       const std::_Deque_iterator<_Tp, _Tp&, _Tp*>&,
       const _VTp&);

  constexpr
  void
  __fill_a1(std::_Bit_iterator, std::_Bit_iterator,
     const bool&);

  template<typename _FIte, typename _Tp>
    constexpr
    inline void
    __fill_a(_FIte __first, _FIte __last, const _Tp& __value)
    { std::__fill_a1(__first, __last, __value); }

  template<typename _Ite, typename _Seq, typename _Cat, typename _Tp>
    constexpr
    void
    __fill_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
      const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
      const _Tp&);
# 1019 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    constexpr
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {

     

      ;

      std::__fill_a(__first, __last, __value);
    }


  inline constexpr int
  __size_to_integer(int __n) { return __n; }
  inline constexpr unsigned
  __size_to_integer(unsigned __n) { return __n; }
  inline constexpr long
  __size_to_integer(long __n) { return __n; }
  inline constexpr unsigned long
  __size_to_integer(unsigned long __n) { return __n; }
  inline constexpr long long
  __size_to_integer(long long __n) { return __n; }
  inline constexpr unsigned long long
  __size_to_integer(unsigned long long __n) { return __n; }


  __extension__ inline constexpr __int128
  __size_to_integer(__int128 __n) { return __n; }
  __extension__ inline constexpr unsigned __int128
  __size_to_integer(unsigned __int128 __n) { return __n; }
# 1071 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  inline constexpr long long
  __size_to_integer(float __n) { return (long long)__n; }
  inline constexpr long long
  __size_to_integer(double __n) { return (long long)__n; }
  inline constexpr long long
  __size_to_integer(long double __n) { return (long long)__n; }

  __extension__ inline constexpr long long
  __size_to_integer(__float128 __n) { return (long long)__n; }


  template<typename _OutputIterator, typename _Size, typename _Tp>
    constexpr
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a1(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      for (; __n > 0; --__n, (void) ++__first)
 *__first = __value;
      return __first;
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    constexpr
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a1(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __n > 0; --__n, (void) ++__first)
 *__first = __tmp;
      return __first;
    }

  template<typename _Ite, typename _Seq, typename _Cat, typename _Size,
    typename _Tp>
    constexpr
    ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>
    __fill_n_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>& __first,
        _Size __n, const _Tp& __value,
        std::input_iterator_tag);

  template<typename _OutputIterator, typename _Size, typename _Tp>
    constexpr
    inline _OutputIterator
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
        std::output_iterator_tag)
    {

      static_assert(is_integral<_Size>{}, "fill_n must pass integral size");

      return __fill_n_a1(__first, __n, __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    constexpr
    inline _OutputIterator
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
        std::input_iterator_tag)
    {

      static_assert(is_integral<_Size>{}, "fill_n must pass integral size");

      return __fill_n_a1(__first, __n, __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    constexpr
    inline _OutputIterator
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
        std::random_access_iterator_tag)
    {

      static_assert(is_integral<_Size>{}, "fill_n must pass integral size");

      if (__n <= 0)
 return __first;

      ;

      std::__fill_a(__first, __first + __n, __value);
      return __first + __n;
    }
# 1172 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _OI, typename _Size, typename _Tp>
    constexpr
    inline _OI
    fill_n(_OI __first, _Size __n, const _Tp& __value)
    {

     

      return std::__fill_n_a(__first, std::__size_to_integer(__n), __value,
          std::__iterator_category(__first));
    }

  template<bool _BoolType>
    struct __equal
    {
      template<typename _II1, typename _II2>
 constexpr
 static bool
 equal(_II1 __first1, _II1 __last1, _II2 __first2)
 {
   for (; __first1 != __last1; ++__first1, (void) ++__first2)
     if (!(*__first1 == *__first2))
       return false;
   return true;
 }
    };

  template<>
    struct __equal<true>
    {
      template<typename _Tp>
 constexpr
 static bool
 equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
 {
   if (const size_t __len = (__last1 - __first1))
     return !std::__memcmp(__first1, __first2, __len);
   return true;
 }
    };

  template<typename _Tp, typename _Ref, typename _Ptr, typename _II>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value, bool>::__type
    __equal_aux1(std::_Deque_iterator<_Tp, _Ref, _Ptr>,
   std::_Deque_iterator<_Tp, _Ref, _Ptr>,
   _II);

  template<typename _Tp1, typename _Ref1, typename _Ptr1,
    typename _Tp2, typename _Ref2, typename _Ptr2>
    bool
    __equal_aux1(std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
   std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
   std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);

  template<typename _II, typename _Tp, typename _Ref, typename _Ptr>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value, bool>::__type
    __equal_aux1(_II, _II,
  std::_Deque_iterator<_Tp, _Ref, _Ptr>);

  template<typename _II1, typename _II2>
    constexpr
    inline bool
    __equal_aux1(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      const bool __simple = ((__is_integer<_ValueType1>::__value
         || __is_pointer<_ValueType1>::__value)
        && __memcmpable<_II1, _II2>::__value);
      return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }

  template<typename _II1, typename _II2>
    constexpr
    inline bool
    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      return std::__equal_aux1(std::__niter_base(__first1),
          std::__niter_base(__last1),
          std::__niter_base(__first2));
    }

  template<typename _II1, typename _Seq1, typename _Cat1, typename _II2>
    constexpr
    bool
    __equal_aux(const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
  _II2);

  template<typename _II1, typename _II2, typename _Seq2, typename _Cat2>
    constexpr
    bool
    __equal_aux(_II1, _II1,
  const ::__gnu_debug::_Safe_iterator<_II2, _Seq2, _Cat2>&);

  template<typename _II1, typename _Seq1, typename _Cat1,
    typename _II2, typename _Seq2, typename _Cat2>
    constexpr
    bool
    __equal_aux(const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_II2, _Seq2, _Cat2>&);

  template<typename, typename>
    struct __lc_rai
    {
      template<typename _II1, typename _II2>
 constexpr
 static _II1
 __newlast1(_II1, _II1 __last1, _II2, _II2)
 { return __last1; }

      template<typename _II>
 constexpr
 static bool
 __cnd2(_II __first, _II __last)
 { return __first != __last; }
    };

  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
      template<typename _RAI1, typename _RAI2>
 constexpr
 static _RAI1
 __newlast1(_RAI1 __first1, _RAI1 __last1,
     _RAI2 __first2, _RAI2 __last2)
 {
   const typename iterator_traits<_RAI1>::difference_type
     __diff1 = __last1 - __first1;
   const typename iterator_traits<_RAI2>::difference_type
     __diff2 = __last2 - __first2;
   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
 }

      template<typename _RAI>
 static constexpr bool
 __cnd2(_RAI, _RAI)
 { return true; }
    };

  template<typename _II1, typename _II2, typename _Compare>
    constexpr
    bool
    __lexicographical_compare_impl(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2,
       _Compare __comp)
    {
      typedef typename iterator_traits<_II1>::iterator_category _Category1;
      typedef typename iterator_traits<_II2>::iterator_category _Category2;
      typedef std::__lc_rai<_Category1, _Category2> __rai_type;

      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
    ++__first1, (void)++__first2)
 {
   if (__comp(__first1, __first2))
     return true;
   if (__comp(__first2, __first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }

  template<bool _BoolType>
    struct __lexicographical_compare
    {
      template<typename _II1, typename _II2>
 constexpr
 static bool
 __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
 {
   using __gnu_cxx::__ops::__iter_less_iter;
   return std::__lexicographical_compare_impl(__first1, __last1,
           __first2, __last2,
           __iter_less_iter());
 }

      template<typename _II1, typename _II2>
 constexpr
 static int
 __3way(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
 {
   while (__first1 != __last1)
     {
       if (__first2 == __last2)
  return +1;
       if (*__first1 < *__first2)
  return -1;
       if (*__first2 < *__first1)
  return +1;
       ++__first1;
       ++__first2;
     }
   return int(__first2 == __last2) - 1;
 }
    };

  template<>
    struct __lexicographical_compare<true>
    {
      template<typename _Tp, typename _Up>
 constexpr
 static bool
 __lc(const _Tp* __first1, const _Tp* __last1,
      const _Up* __first2, const _Up* __last2)
 { return __3way(__first1, __last1, __first2, __last2) < 0; }

      template<typename _Tp, typename _Up>
 constexpr
 static ptrdiff_t
 __3way(const _Tp* __first1, const _Tp* __last1,
        const _Up* __first2, const _Up* __last2)
 {
   const size_t __len1 = __last1 - __first1;
   const size_t __len2 = __last2 - __first2;
   if (const size_t __len = std::min(__len1, __len2))
     if (int __result = std::__memcmp(__first1, __first2, __len))
       return __result;
   return ptrdiff_t(__len1 - __len2);
 }
    };

  template<typename _II1, typename _II2>
    constexpr
    inline bool
    __lexicographical_compare_aux1(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple =
 (__is_memcmp_ordered_with<_ValueType1, _ValueType2>::__value
  && __is_pointer<_II1>::__value
  && __is_pointer<_II2>::__value




  && !is_volatile_v<remove_reference_t<iter_reference_t<_II1>>>
  && !is_volatile_v<remove_reference_t<iter_reference_t<_II2>>>

  );

      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
           __first2, __last2);
    }

  template<typename _Tp1, typename _Ref1, typename _Ptr1,
    typename _Tp2>
    bool
    __lexicographical_compare_aux1(
 std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
 std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
 _Tp2*, _Tp2*);

  template<typename _Tp1,
    typename _Tp2, typename _Ref2, typename _Ptr2>
    bool
    __lexicographical_compare_aux1(_Tp1*, _Tp1*,
 std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>,
 std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);

  template<typename _Tp1, typename _Ref1, typename _Ptr1,
    typename _Tp2, typename _Ref2, typename _Ptr2>
    bool
    __lexicographical_compare_aux1(
 std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
 std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
 std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>,
 std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);

  template<typename _II1, typename _II2>
    constexpr
    inline bool
    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
      _II2 __first2, _II2 __last2)
    {
      return std::__lexicographical_compare_aux1(std::__niter_base(__first1),
       std::__niter_base(__last1),
       std::__niter_base(__first2),
       std::__niter_base(__last2));
    }

  template<typename _Iter1, typename _Seq1, typename _Cat1,
    typename _II2>
    constexpr
    bool
    __lexicographical_compare_aux(
  const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1>&,
  _II2, _II2);

  template<typename _II1,
    typename _Iter2, typename _Seq2, typename _Cat2>
    constexpr
    bool
    __lexicographical_compare_aux(
  _II1, _II1,
  const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2>&,
  const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2>&);

  template<typename _Iter1, typename _Seq1, typename _Cat1,
    typename _Iter2, typename _Seq2, typename _Cat2>
    constexpr
    bool
    __lexicographical_compare_aux(
  const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_Iter1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2>&,
  const ::__gnu_debug::_Safe_iterator<_Iter2, _Seq2, _Cat2>&);

  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    constexpr
    _ForwardIterator
    __lower_bound(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 1524 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    [[__nodiscard__]] constexpr
    inline _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {

     
     

      ;

      return std::__lower_bound(__first, __last, __val,
    __gnu_cxx::__ops::__iter_less_val());
    }



  template<typename _Tp>
    inline constexpr _Tp
    __lg(_Tp __n)
    {

      return std::__bit_width(make_unsigned_t<_Tp>(__n)) - 1;
# 1557 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
    }


# 1573 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    [[__nodiscard__]] constexpr
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {

     
     
     


      ;

      return std::__equal_aux(__first1, __last1, __first2);
    }
# 1604 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    [[__nodiscard__]] constexpr
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return true;
    }



  template<typename _II1, typename _II2>
    constexpr
    inline bool
    __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
    {
      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if (_RAIters())
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
   return std::equal(__first1, __last1, __first2);
 }

      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!(*__first1 == *__first2))
   return false;
      return __first1 == __last1 && __first2 == __last2;
    }


  template<typename _II1, typename _II2, typename _BinaryPredicate>
    constexpr
    inline bool
    __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2,
      _BinaryPredicate __binary_pred)
    {
      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if (_RAIters())
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
   return std::equal(__first1, __last1, __first2,
           __binary_pred);
 }

      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return __first1 == __last1 && __first2 == __last2;
    }
# 1691 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    [[__nodiscard__]] constexpr
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
    {

     
     
     


      ;
      ;

      return std::__equal4(__first1, __last1, __first2, __last2);
    }
# 1724 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    [[__nodiscard__]] constexpr
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _IIter2 __last2, _BinaryPredicate __binary_pred)
    {

     
     
      ;
      ;

      return std::__equal4(__first1, __last1, __first2, __last2,
          __binary_pred);
    }
# 1756 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    [[__nodiscard__]] constexpr
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {





     
     
     
     
      ;
      ;

      return std::__lexicographical_compare_aux(__first1, __last1,
      __first2, __last2);
    }
# 1791 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2, typename _Compare>
    [[__nodiscard__]] constexpr
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2, _Compare __comp)
    {

     
     
      ;
      ;

      return std::__lexicographical_compare_impl
 (__first1, __last1, __first2, __last2,
  __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }





  template<typename _Iter1, typename _Iter2>
    concept __memcmp_ordered_with
      = (__is_memcmp_ordered_with<iter_value_t<_Iter1>,
      iter_value_t<_Iter2>>::__value)
   && contiguous_iterator<_Iter1> && contiguous_iterator<_Iter2>;



  template<typename _Tp>
    constexpr auto
    __min_cmp(_Tp __x, _Tp __y)
    {
      struct _Res {
 _Tp _M_min;
 decltype(__x <=> __y) _M_cmp;
      };
      auto __c = __x <=> __y;
      if (__c > 0)
 return _Res{__y, __c};
      return _Res{__x, __c};
    }
# 1845 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _InputIter1, typename _InputIter2, typename _Comp>
    [[nodiscard]] constexpr auto
    lexicographical_compare_three_way(_InputIter1 __first1,
          _InputIter1 __last1,
          _InputIter2 __first2,
          _InputIter2 __last2,
          _Comp __comp)
    -> decltype(__comp(*__first1, *__first2))
    {

     
     
      ;
      ;

      using _Cat = decltype(__comp(*__first1, *__first2));
      static_assert(same_as<common_comparison_category_t<_Cat>, _Cat>);

      if (!std::__is_constant_evaluated())
 if constexpr (same_as<_Comp, __detail::_Synth3way>
        || same_as<_Comp, compare_three_way>)
   if constexpr (__memcmp_ordered_with<_InputIter1, _InputIter2>)
     {
       const auto [__len, __lencmp] = std::
  __min_cmp(__last1 - __first1, __last2 - __first2);
       if (__len)
  {
    const auto __blen = __len * sizeof(*__first1);
    const auto __c
      = __builtin_memcmp(&*__first1, &*__first2, __blen) <=> 0;
    if (__c != 0)
      return __c;
  }
       return __lencmp;
     }

      while (__first1 != __last1)
 {
   if (__first2 == __last2)
     return strong_ordering::greater;
   if (auto __cmp = __comp(*__first1, *__first2); __cmp != 0)
     return __cmp;
   ++__first1;
   ++__first2;
 }
      return (__first2 == __last2) <=> true;
    }

  template<typename _InputIter1, typename _InputIter2>
    constexpr auto
    lexicographical_compare_three_way(_InputIter1 __first1,
          _InputIter1 __last1,
          _InputIter2 __first2,
          _InputIter2 __last2)
    {
      return std::
 lexicographical_compare_three_way(__first1, __last1, __first2, __last2,
       compare_three_way{});
    }


  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    constexpr
    pair<_InputIterator1, _InputIterator2>
    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {
      while (__first1 != __last1 && __binary_pred(__first1, __first2))
 {
   ++__first1;
   ++__first2;
 }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1934 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    [[__nodiscard__]] constexpr
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {

     
     
     


      ;

      return std::__mismatch(__first1, __last1, __first2,
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 1968 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    [[__nodiscard__]] constexpr
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      return std::__mismatch(__first1, __last1, __first2,
 __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }


  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    constexpr
    pair<_InputIterator1, _InputIterator2>
    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _BinaryPredicate __binary_pred)
    {
      while (__first1 != __last1 && __first2 != __last2
      && __binary_pred(__first1, __first2))
 {
   ++__first1;
   ++__first2;
 }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 2016 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    [[__nodiscard__]] constexpr
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {

     
     
     


      ;
      ;

      return std::__mismatch(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 2052 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    [[__nodiscard__]] constexpr
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _BinaryPredicate __binary_pred)
    {

     
     
      ;
      ;

      return std::__mismatch(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }





  template<typename _InputIterator, typename _Predicate>
    constexpr
    inline _InputIterator
    __find_if(_InputIterator __first, _InputIterator __last,
       _Predicate __pred, input_iterator_tag)
    {
      while (__first != __last && !__pred(__first))
 ++__first;
      return __first;
    }


  template<typename _RandomAccessIterator, typename _Predicate>
    constexpr
    _RandomAccessIterator
    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Predicate __pred, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for (; __trip_count > 0; --__trip_count)
 {
   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (__pred(__first))
     return __first;
   ++__first;

 case 2:
   if (__pred(__first))
     return __first;
   ++__first;

 case 1:
   if (__pred(__first))
     return __first;
   ++__first;

 case 0:
 default:
   return __last;
 }
    }

  template<typename _Iterator, typename _Predicate>
    constexpr
    inline _Iterator
    __find_if(_Iterator __first, _Iterator __last, _Predicate __pred)
    {
      return __find_if(__first, __last, __pred,
         std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Predicate>
    constexpr
    typename iterator_traits<_InputIterator>::difference_type
    __count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for (; __first != __last; ++__first)
 if (__pred(__first))
   ++__n;
      return __n;
    }

  template<typename _ForwardIterator, typename _Predicate>
    constexpr
    _ForwardIterator
    __remove_if(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred)
    {
      __first = std::__find_if(__first, __last, __pred);
      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      ++__first;
      for (; __first != __last; ++__first)
 if (!__pred(__first))
   {
     *__result = std::move(*__first);
     ++__result;
   }
      return __result;
    }

  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    constexpr
    _ForwardIterator1
    __search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __predicate)
    {

      if (__first1 == __last1 || __first2 == __last2)
 return __first1;


      _ForwardIterator2 __p1(__first2);
      if (++__p1 == __last2)
 return std::__find_if(__first1, __last1,
  __gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));


      _ForwardIterator1 __current = __first1;

      for (;;)
 {
   __first1 =
     std::__find_if(__first1, __last1,
  __gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));

   if (__first1 == __last1)
     return __last1;

   _ForwardIterator2 __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;

   while (__predicate(__current, __p))
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }


  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    constexpr
    bool
    __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _BinaryPredicate __pred)
    {


      for (; __first1 != __last1; ++__first1, (void)++__first2)
 if (!__pred(__first1, __first2))
   break;

      if (__first1 == __last1)
 return true;



      _ForwardIterator2 __last2 = __first2;
      std::advance(__last2, std::distance(__first1, __last1));
      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
 {
   if (__scan != std::__find_if(__first1, __scan,
     __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
     continue;

   auto __matches
     = std::__count_if(__first2, __last2,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
   if (0 == __matches ||
       std::__count_if(__scan, __last1,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))
       != __matches)
     return false;
 }
      return true;
    }
# 2276 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    constexpr
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2)
    {

     
     
     


      ;

      return std::__is_permutation(__first1, __last1, __first2,
       __gnu_cxx::__ops::__iter_equal_to_iter());
    }



# 2318 "/usr/include/c++/14.2.1/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    constexpr
    inline _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2,
    _BinaryPredicate __predicate)
    {

     
     
     


      ;
      ;

      return std::__search(__first1, __last1, __first2, __last2,
      __gnu_cxx::__ops::__iter_comp_iter(__predicate));
    }



}
# 44 "/usr/include/c++/14.2.1/bits/specfun.h" 2 3
# 1 "/usr/include/c++/14.2.1/limits" 1 3
# 40 "/usr/include/c++/14.2.1/limits" 3
       
# 41 "/usr/include/c++/14.2.1/limits" 3
# 158 "/usr/include/c++/14.2.1/limits" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };







  enum float_denorm_style
  {

    denorm_indeterminate = -1,

    denorm_absent = 0,

    denorm_present = 1
  };
# 202 "/usr/include/c++/14.2.1/limits" 3
  struct __numeric_limits_base
  {


    static constexpr bool is_specialized = false;




    static constexpr int digits = 0;


    static constexpr int digits10 = 0;




    static constexpr int max_digits10 = 0;



    static constexpr bool is_signed = false;


    static constexpr bool is_integer = false;




    static constexpr bool is_exact = false;



    static constexpr int radix = 0;



    static constexpr int min_exponent = 0;



    static constexpr int min_exponent10 = 0;




    static constexpr int max_exponent = 0;



    static constexpr int max_exponent10 = 0;


    static constexpr bool has_infinity = false;



    static constexpr bool has_quiet_NaN = false;



    static constexpr bool has_signaling_NaN = false;


    static constexpr float_denorm_style has_denorm = denorm_absent;



    static constexpr bool has_denorm_loss = false;



    static constexpr bool is_iec559 = false;




    static constexpr bool is_bounded = false;
# 288 "/usr/include/c++/14.2.1/limits" 3
    static constexpr bool is_modulo = false;


    static constexpr bool traps = false;


    static constexpr bool tinyness_before = false;




    static constexpr float_round_style round_style =
          round_toward_zero;
  };
# 311 "/usr/include/c++/14.2.1/limits" 3
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {


      static constexpr _Tp
      min() noexcept { return _Tp(); }


      static constexpr _Tp
      max() noexcept { return _Tp(); }




      static constexpr _Tp
      lowest() noexcept { return _Tp(); }




      static constexpr _Tp
      epsilon() noexcept { return _Tp(); }


      static constexpr _Tp
      round_error() noexcept { return _Tp(); }


      static constexpr _Tp
      infinity() noexcept { return _Tp(); }



      static constexpr _Tp
      quiet_NaN() noexcept { return _Tp(); }



      static constexpr _Tp
      signaling_NaN() noexcept { return _Tp(); }




      static constexpr _Tp
      denorm_min() noexcept { return _Tp(); }
    };




  template<typename _Tp>
    struct numeric_limits<const _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<volatile _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<const volatile _Tp>
    : public numeric_limits<_Tp> { };
# 383 "/usr/include/c++/14.2.1/limits" 3
  template<>
    struct numeric_limits<bool>
    {
      static constexpr bool is_specialized = true;

      static constexpr bool
      min() noexcept { return false; }

      static constexpr bool
      max() noexcept { return true; }


      static constexpr bool
      lowest() noexcept { return min(); }

      static constexpr int digits = 1;
      static constexpr int digits10 = 0;

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr bool
      epsilon() noexcept { return false; }

      static constexpr bool
      round_error() noexcept { return false; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr bool
      infinity() noexcept { return false; }

      static constexpr bool
      quiet_NaN() noexcept { return false; }

      static constexpr bool
      signaling_NaN() noexcept { return false; }

      static constexpr bool
      denorm_min() noexcept { return false; }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;




      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<char>
    {
      static constexpr bool is_specialized = true;

      static constexpr char
      min() noexcept { return (((char)(-1) < 0) ? -(((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0) - 1 : (char)0); }

      static constexpr char
      max() noexcept { return (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0); }


      static constexpr char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((char)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char
      epsilon() noexcept { return 0; }

      static constexpr char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr
      char infinity() noexcept { return char(); }

      static constexpr char
      quiet_NaN() noexcept { return char(); }

      static constexpr char
      signaling_NaN() noexcept { return char(); }

      static constexpr char
      denorm_min() noexcept { return static_cast<char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<signed char>
    {
      static constexpr bool is_specialized = true;

      static constexpr signed char
      min() noexcept { return -0x7f - 1; }

      static constexpr signed char
      max() noexcept { return 0x7f; }


      static constexpr signed char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr signed char
      epsilon() noexcept { return 0; }

      static constexpr signed char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr signed char
      infinity() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      quiet_NaN() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      signaling_NaN() noexcept
      { return static_cast<signed char>(0); }

      static constexpr signed char
      denorm_min() noexcept
      { return static_cast<signed char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned char>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned char
      min() noexcept { return 0; }

      static constexpr unsigned char
      max() noexcept { return 0x7f * 2U + 1; }


      static constexpr unsigned char
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned char
      epsilon() noexcept { return 0; }

      static constexpr unsigned char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned char
      infinity() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      quiet_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      signaling_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      denorm_min() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<wchar_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr wchar_t
      min() noexcept { return (((wchar_t)(-1) < 0) ? -(((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0) - 1 : (wchar_t)0); }

      static constexpr wchar_t
      max() noexcept { return (((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0); }


      static constexpr wchar_t
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((wchar_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr wchar_t
      epsilon() noexcept { return 0; }

      static constexpr wchar_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr wchar_t
      infinity() noexcept { return wchar_t(); }

      static constexpr wchar_t
      quiet_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      signaling_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      denorm_min() noexcept { return wchar_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };



  template<>
    struct numeric_limits<char8_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char8_t
      min() noexcept { return (((char8_t)(-1) < 0) ? -(((char8_t)(-1) < 0) ? (((((char8_t)1 << ((sizeof(char8_t) * 8 - ((char8_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char8_t)0) - 1 : (char8_t)0); }

      static constexpr char8_t
      max() noexcept { return (((char8_t)(-1) < 0) ? (((((char8_t)1 << ((sizeof(char8_t) * 8 - ((char8_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char8_t)0); }

      static constexpr char8_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char8_t) * 8 - ((char8_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char8_t) * 8 - ((char8_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char8_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char8_t
      epsilon() noexcept { return 0; }

      static constexpr char8_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
 = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char8_t
      infinity() noexcept { return char8_t(); }

      static constexpr char8_t
      quiet_NaN() noexcept { return char8_t(); }

      static constexpr char8_t
      signaling_NaN() noexcept { return char8_t(); }

      static constexpr char8_t
      denorm_min() noexcept { return char8_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
 = round_toward_zero;
    };




  template<>
    struct numeric_limits<char16_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char16_t
      min() noexcept { return (((char16_t)(-1) < 0) ? -(((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0) - 1 : (char16_t)0); }

      static constexpr char16_t
      max() noexcept { return (((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0); }

      static constexpr char16_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char16_t) * 8 - ((char16_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char16_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char16_t
      epsilon() noexcept { return 0; }

      static constexpr char16_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char16_t
      infinity() noexcept { return char16_t(); }

      static constexpr char16_t
      quiet_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      signaling_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      denorm_min() noexcept { return char16_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<char32_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char32_t
      min() noexcept { return (((char32_t)(-1) < 0) ? -(((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0) - 1 : (char32_t)0); }

      static constexpr char32_t
      max() noexcept { return (((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0); }

      static constexpr char32_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char32_t) * 8 - ((char32_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char32_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char32_t
      epsilon() noexcept { return 0; }

      static constexpr char32_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char32_t
      infinity() noexcept { return char32_t(); }

      static constexpr char32_t
      quiet_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      signaling_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      denorm_min() noexcept { return char32_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };



  template<>
    struct numeric_limits<short>
    {
      static constexpr bool is_specialized = true;

      static constexpr short
      min() noexcept { return -0x7fff - 1; }

      static constexpr short
      max() noexcept { return 0x7fff; }


      static constexpr short
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static constexpr int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr short
      epsilon() noexcept { return 0; }

      static constexpr short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr short
      infinity() noexcept { return short(); }

      static constexpr short
      quiet_NaN() noexcept { return short(); }

      static constexpr short
      signaling_NaN() noexcept { return short(); }

      static constexpr short
      denorm_min() noexcept { return short(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned short>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned short
      min() noexcept { return 0; }

      static constexpr unsigned short
      max() noexcept { return 0x7fff * 2U + 1; }


      static constexpr unsigned short
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned short
      epsilon() noexcept { return 0; }

      static constexpr unsigned short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned short
      infinity() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      quiet_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      signaling_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      denorm_min() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<int>
    {
      static constexpr bool is_specialized = true;

      static constexpr int
      min() noexcept { return -0x7fffffff - 1; }

      static constexpr int
      max() noexcept { return 0x7fffffff; }


      static constexpr int
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static constexpr int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr int
      epsilon() noexcept { return 0; }

      static constexpr int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr int
      infinity() noexcept { return static_cast<int>(0); }

      static constexpr int
      quiet_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      signaling_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      denorm_min() noexcept { return static_cast<int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned int>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned int
      min() noexcept { return 0; }

      static constexpr unsigned int
      max() noexcept { return 0x7fffffff * 2U + 1; }


      static constexpr unsigned int
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned int
      epsilon() noexcept { return 0; }

      static constexpr unsigned int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned int
      infinity() noexcept { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      quiet_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      signaling_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      denorm_min() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long
      min() noexcept { return -0x7fffffffffffffffL - 1; }

      static constexpr long
      max() noexcept { return 0x7fffffffffffffffL; }


      static constexpr long
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static constexpr int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long
      epsilon() noexcept { return 0; }

      static constexpr long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long
      infinity() noexcept { return static_cast<long>(0); }

      static constexpr long
      quiet_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      signaling_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      denorm_min() noexcept { return static_cast<long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long
      min() noexcept { return 0; }

      static constexpr unsigned long
      max() noexcept { return 0x7fffffffffffffffL * 2UL + 1; }


      static constexpr unsigned long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long
      infinity() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      quiet_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      signaling_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      denorm_min() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long long
      min() noexcept { return -0x7fffffffffffffffLL - 1; }

      static constexpr long long
      max() noexcept { return 0x7fffffffffffffffLL; }


      static constexpr long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long long
      epsilon() noexcept { return 0; }

      static constexpr long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long long
      infinity() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      quiet_NaN() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      signaling_NaN() noexcept
      { return static_cast<long long>(0); }

      static constexpr long long
      denorm_min() noexcept { return static_cast<long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long long
      min() noexcept { return 0; }

      static constexpr unsigned long long
      max() noexcept { return 0x7fffffffffffffffLL * 2ULL + 1; }


      static constexpr unsigned long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long long
      infinity() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      quiet_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      signaling_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      denorm_min() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };
# 1637 "/usr/include/c++/14.2.1/limits" 3
  __extension__ template<> struct numeric_limits<__int128> { static constexpr bool is_specialized = true; static constexpr __int128 min() noexcept { return (((__int128)(-1) < 0) ? -(((__int128)(-1) < 0) ? (((((__int128)1 << ((128 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(__int128)0) - 1 : (__int128)0); } static constexpr __int128 max() noexcept { return (((__int128)(-1) < 0) ? (((((__int128)1 << ((128 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(__int128)0); } static constexpr int digits = 128 - 1; static constexpr int digits10 = (128 - 1) * 643L / 2136; static constexpr bool is_signed = true; static constexpr bool is_integer = true; static constexpr bool is_exact = true; static constexpr int radix = 2; static constexpr __int128 epsilon() noexcept { return 0; } static constexpr __int128 round_error() noexcept { return 0; } static constexpr __int128 lowest() noexcept { return min(); } static constexpr int max_digits10 = 0; static constexpr int min_exponent = 0; static constexpr int min_exponent10 = 0; static constexpr int max_exponent = 0; static constexpr int max_exponent10 = 0; static constexpr bool has_infinity = false; static constexpr bool has_quiet_NaN = false; static constexpr bool has_signaling_NaN = false; static constexpr float_denorm_style has_denorm = denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr __int128 infinity() noexcept { return static_cast<__int128>(0); } static constexpr __int128 quiet_NaN() noexcept { return static_cast<__int128>(0); } static constexpr __int128 signaling_NaN() noexcept { return static_cast<__int128>(0); } static constexpr __int128 denorm_min() noexcept { return static_cast<__int128>(0); } static constexpr bool is_iec559 = false; static constexpr bool is_bounded = true; static constexpr bool is_modulo = false; static constexpr bool traps = true; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_toward_zero; }; __extension__ template<> struct numeric_limits<unsigned __int128> { static constexpr bool is_specialized = true; static constexpr unsigned __int128 min() noexcept { return 0; } static constexpr unsigned __int128 max() noexcept { return (((unsigned __int128)(-1) < 0) ? (((((unsigned __int128)1 << ((128 - ((unsigned __int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(unsigned __int128)0); } static constexpr unsigned __int128 lowest() noexcept { return min(); } static constexpr int max_digits10 = 0; static constexpr int digits = 128; static constexpr int digits10 = 128 * 643L / 2136; static constexpr bool is_signed = false; static constexpr bool is_integer = true; static constexpr bool is_exact = true; static constexpr int radix = 2; static constexpr unsigned __int128 epsilon() noexcept { return 0; } static constexpr unsigned __int128 round_error() noexcept { return 0; } static constexpr int min_exponent = 0; static constexpr int min_exponent10 = 0; static constexpr int max_exponent = 0; static constexpr int max_exponent10 = 0; static constexpr bool has_infinity = false; static constexpr bool has_quiet_NaN = false; static constexpr bool has_signaling_NaN = false; static constexpr float_denorm_style has_denorm = denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr unsigned __int128 infinity() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 quiet_NaN() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 signaling_NaN() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 denorm_min() noexcept { return static_cast<unsigned __int128>(0); } static constexpr bool is_iec559 = false; static constexpr bool is_bounded = true; static constexpr bool is_modulo = true; static constexpr bool traps = true; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_toward_zero; };
# 1669 "/usr/include/c++/14.2.1/limits" 3
  template<>
    struct numeric_limits<float>
    {
      static constexpr bool is_specialized = true;

      static constexpr float
      min() noexcept { return 1.17549435082228750796873653722224568e-38F; }

      static constexpr float
      max() noexcept { return 3.40282346638528859811704183484516925e+38F; }


      static constexpr float
      lowest() noexcept { return -3.40282346638528859811704183484516925e+38F; }


      static constexpr int digits = 24;
      static constexpr int digits10 = 6;

      static constexpr int max_digits10
  = (2 + (24) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr float
      epsilon() noexcept { return 1.19209289550781250000000000000000000e-7F; }

      static constexpr float
      round_error() noexcept { return 0.5F; }

      static constexpr int min_exponent = (-125);
      static constexpr int min_exponent10 = (-37);
      static constexpr int max_exponent = 128;
      static constexpr int max_exponent10 = 38;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
       = false;

      static constexpr float
      infinity() noexcept { return __builtin_huge_valf(); }

      static constexpr float
      quiet_NaN() noexcept { return __builtin_nanf(""); }

      static constexpr float
      signaling_NaN() noexcept { return __builtin_nansf(""); }

      static constexpr float
      denorm_min() noexcept { return 1.40129846432481707092372958328991613e-45F; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<double>
    {
      static constexpr bool is_specialized = true;

      static constexpr double
      min() noexcept { return double(2.22507385850720138309023271733240406e-308L); }

      static constexpr double
      max() noexcept { return double(1.79769313486231570814527423731704357e+308L); }


      static constexpr double
      lowest() noexcept { return -double(1.79769313486231570814527423731704357e+308L); }


      static constexpr int digits = 53;
      static constexpr int digits10 = 15;

      static constexpr int max_digits10
  = (2 + (53) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr double
      epsilon() noexcept { return double(2.22044604925031308084726333618164062e-16L); }

      static constexpr double
      round_error() noexcept { return 0.5; }

      static constexpr int min_exponent = (-1021);
      static constexpr int min_exponent10 = (-307);
      static constexpr int max_exponent = 1024;
      static constexpr int max_exponent10 = 308;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
        = false;

      static constexpr double
      infinity() noexcept { return __builtin_huge_val(); }

      static constexpr double
      quiet_NaN() noexcept { return __builtin_nan(""); }

      static constexpr double
      signaling_NaN() noexcept { return __builtin_nans(""); }

      static constexpr double
      denorm_min() noexcept { return double(4.94065645841246544176568792868221372e-324L); }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<long double>
    {
      static constexpr bool is_specialized = true;

      static constexpr long double
      min() noexcept { return 3.36210314311209350626267781732175260e-4932L; }

      static constexpr long double
      max() noexcept { return 1.18973149535723176502126385303097021e+4932L; }


      static constexpr long double
      lowest() noexcept { return -1.18973149535723176502126385303097021e+4932L; }


      static constexpr int digits = 64;
      static constexpr int digits10 = 18;

      static constexpr int max_digits10
  = (2 + (64) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr long double
      epsilon() noexcept { return 1.08420217248550443400745280086994171e-19L; }

      static constexpr long double
      round_error() noexcept { return 0.5L; }

      static constexpr int min_exponent = (-16381);
      static constexpr int min_exponent10 = (-4931);
      static constexpr int max_exponent = 16384;
      static constexpr int max_exponent10 = 4932;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
 = false;

      static constexpr long double
      infinity() noexcept { return __builtin_huge_vall(); }

      static constexpr long double
      quiet_NaN() noexcept { return __builtin_nanl(""); }

      static constexpr long double
      signaling_NaN() noexcept { return __builtin_nansl(""); }

      static constexpr long double
      denorm_min() noexcept { return 3.64519953188247460252840593361941982e-4951L; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before =
      false;
      static constexpr float_round_style round_style =
            round_to_nearest;
    };
# 1989 "/usr/include/c++/14.2.1/limits" 3
__extension__ template<> struct numeric_limits<_Float32> { static constexpr bool is_specialized = true; static constexpr _Float32 min() noexcept { return 1.17549435082228750796873653722224568e-38F32; } static constexpr _Float32 max() noexcept { return 3.40282346638528859811704183484516925e+38F32; } static constexpr _Float32 lowest() noexcept { return -3.40282346638528859811704183484516925e+38F32; } static constexpr int digits = 24; static constexpr int digits10 = 6; static constexpr int max_digits10 = (2 + (24) * 643L / 2136); static constexpr bool is_signed = true; static constexpr bool is_integer = false; static constexpr bool is_exact = false; static constexpr int radix = 2; static constexpr _Float32 epsilon() noexcept { return 1.19209289550781250000000000000000000e-7F32; } static constexpr _Float32 round_error() noexcept { return 0.5F32; } static constexpr int min_exponent = (-125); static constexpr int min_exponent10 = (-37); static constexpr int max_exponent = 128; static constexpr int max_exponent10 = 38; static constexpr bool has_infinity = 1; static constexpr bool has_quiet_NaN = 1; static constexpr bool has_signaling_NaN = has_quiet_NaN; static constexpr float_denorm_style has_denorm = bool(1) ? denorm_present : denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr _Float32 infinity() noexcept { return __builtin_huge_valf32(); } static constexpr _Float32 quiet_NaN() noexcept { return __builtin_nanf32(""); } static constexpr _Float32 signaling_NaN() noexcept { return __builtin_nansf32(""); } static constexpr _Float32 denorm_min() noexcept { return 1.40129846432481707092372958328991613e-45F32; } static constexpr bool is_iec559 = has_infinity && has_quiet_NaN && has_denorm == denorm_present; static constexpr bool is_bounded = true; static constexpr bool is_modulo = false; static constexpr bool traps = false; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_to_nearest; };


__extension__ template<> struct numeric_limits<_Float64> { static constexpr bool is_specialized = true; static constexpr _Float64 min() noexcept { return 2.22507385850720138309023271733240406e-308F64; } static constexpr _Float64 max() noexcept { return 1.79769313486231570814527423731704357e+308F64; } static constexpr _Float64 lowest() noexcept { return -1.79769313486231570814527423731704357e+308F64; } static constexpr int digits = 53; static constexpr int digits10 = 15; static constexpr int max_digits10 = (2 + (53) * 643L / 2136); static constexpr bool is_signed = true; static constexpr bool is_integer = false; static constexpr bool is_exact = false; static constexpr int radix = 2; static constexpr _Float64 epsilon() noexcept { return 2.22044604925031308084726333618164062e-16F64; } static constexpr _Float64 round_error() noexcept { return 0.5F64; } static constexpr int min_exponent = (-1021); static constexpr int min_exponent10 = (-307); static constexpr int max_exponent = 1024; static constexpr int max_exponent10 = 308; static constexpr bool has_infinity = 1; static constexpr bool has_quiet_NaN = 1; static constexpr bool has_signaling_NaN = has_quiet_NaN; static constexpr float_denorm_style has_denorm = bool(1) ? denorm_present : denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr _Float64 infinity() noexcept { return __builtin_huge_valf64(); } static constexpr _Float64 quiet_NaN() noexcept { return __builtin_nanf64(""); } static constexpr _Float64 signaling_NaN() noexcept { return __builtin_nansf64(""); } static constexpr _Float64 denorm_min() noexcept { return 4.94065645841246544176568792868221372e-324F64; } static constexpr bool is_iec559 = has_infinity && has_quiet_NaN && has_denorm == denorm_present; static constexpr bool is_bounded = true; static constexpr bool is_modulo = false; static constexpr bool traps = false; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_to_nearest; };


__extension__ template<> struct numeric_limits<_Float128> { static constexpr bool is_specialized = true; static constexpr _Float128 min() noexcept { return 3.36210314311209350626267781732175260e-4932F128; } static constexpr _Float128 max() noexcept { return 1.18973149535723176508575932662800702e+4932F128; } static constexpr _Float128 lowest() noexcept { return -1.18973149535723176508575932662800702e+4932F128; } static constexpr int digits = 113; static constexpr int digits10 = 33; static constexpr int max_digits10 = (2 + (113) * 643L / 2136); static constexpr bool is_signed = true; static constexpr bool is_integer = false; static constexpr bool is_exact = false; static constexpr int radix = 2; static constexpr _Float128 epsilon() noexcept { return 1.92592994438723585305597794258492732e-34F128; } static constexpr _Float128 round_error() noexcept { return 0.5F128; } static constexpr int min_exponent = (-16381); static constexpr int min_exponent10 = (-4931); static constexpr int max_exponent = 16384; static constexpr int max_exponent10 = 4932; static constexpr bool has_infinity = 1; static constexpr bool has_quiet_NaN = 1; static constexpr bool has_signaling_NaN = has_quiet_NaN; static constexpr float_denorm_style has_denorm = bool(1) ? denorm_present : denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr _Float128 infinity() noexcept { return __builtin_huge_valf128(); } static constexpr _Float128 quiet_NaN() noexcept { return __builtin_nanf128(""); } static constexpr _Float128 signaling_NaN() noexcept { return __builtin_nansf128(""); } static constexpr _Float128 denorm_min() noexcept { return 6.47517511943802511092443895822764655e-4966F128; } static constexpr bool is_iec559 = has_infinity && has_quiet_NaN && has_denorm == denorm_present; static constexpr bool is_bounded = true; static constexpr bool is_modulo = false; static constexpr bool traps = false; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_to_nearest; };
# 2087 "/usr/include/c++/14.2.1/limits" 3
  __extension__
  template<>
    struct numeric_limits<__float128>
    {
      static constexpr bool is_specialized = true;

      static constexpr __float128
      min() noexcept
      {




 return __extension__ 0x1.0p-16382Q;

      }

      static constexpr __float128
      max() noexcept
      {







 return __extension__ 0x1.ffffffffffffffffffffffffffffp+16383Q;

      }

      static constexpr __float128
      lowest() noexcept
      { return -max(); }

      static constexpr int digits = 113;
      static constexpr int digits10 = 33;

      static constexpr int max_digits10 = 35;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr __float128
      epsilon() noexcept
      { return double(1.9259299443872359e-34); }

      static constexpr __float128
      round_error() noexcept { return 0.5; }

      static constexpr int min_exponent = -16381;
      static constexpr int min_exponent10 = -4931;
      static constexpr int max_exponent = 16384;
      static constexpr int max_exponent10 = 4932;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;


      static constexpr bool has_signaling_NaN = true;



      static constexpr float_denorm_style has_denorm
 = denorm_present;
      static constexpr bool has_denorm_loss = false;

      static constexpr __float128
      infinity() noexcept
      { return __builtin_huge_val(); }

      static constexpr __float128
      quiet_NaN() noexcept
      { return __builtin_nan(""); }

      static constexpr __float128
      signaling_NaN() noexcept
      {

 return __builtin_nansq("");





      }

      static constexpr __float128
      denorm_min() noexcept
      {




 return __extension__ 0x1.0p-16494Q;

      }

      static constexpr bool is_iec559 = has_signaling_NaN;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
 = round_to_nearest;
# 2218 "/usr/include/c++/14.2.1/limits" 3
    };




}
# 45 "/usr/include/c++/14.2.1/bits/specfun.h" 2 3


# 1 "/usr/include/c++/14.2.1/tr1/gamma.tcc" 1 3
# 49 "/usr/include/c++/14.2.1/tr1/gamma.tcc" 3
# 1 "/usr/include/c++/14.2.1/tr1/special_function_util.h" 1 3
# 39 "/usr/include/c++/14.2.1/tr1/special_function_util.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 50 "/usr/include/c++/14.2.1/tr1/special_function_util.h" 3
  namespace __detail
  {



    template<typename _Tp>
    struct __floating_point_constant
    {
      static const _Tp __value;
    };



    template<typename _Tp>
      struct __numeric_constants
      {

        static _Tp __pi() throw()
        { return static_cast<_Tp>(3.1415926535897932384626433832795029L); }

        static _Tp __pi_2() throw()
        { return static_cast<_Tp>(1.5707963267948966192313216916397514L); }

        static _Tp __pi_3() throw()
        { return static_cast<_Tp>(1.0471975511965977461542144610931676L); }

        static _Tp __pi_4() throw()
        { return static_cast<_Tp>(0.7853981633974483096156608458198757L); }

        static _Tp __1_pi() throw()
        { return static_cast<_Tp>(0.3183098861837906715377675267450287L); }

        static _Tp __2_sqrtpi() throw()
        { return static_cast<_Tp>(1.1283791670955125738961589031215452L); }

        static _Tp __sqrt2() throw()
        { return static_cast<_Tp>(1.4142135623730950488016887242096981L); }

        static _Tp __sqrt3() throw()
        { return static_cast<_Tp>(1.7320508075688772935274463415058723L); }

        static _Tp __sqrtpio2() throw()
        { return static_cast<_Tp>(1.2533141373155002512078826424055226L); }

        static _Tp __sqrt1_2() throw()
        { return static_cast<_Tp>(0.7071067811865475244008443621048490L); }

        static _Tp __lnpi() throw()
        { return static_cast<_Tp>(1.1447298858494001741434273513530587L); }

        static _Tp __gamma_e() throw()
        { return static_cast<_Tp>(0.5772156649015328606065120900824024L); }

        static _Tp __euler() throw()
        { return static_cast<_Tp>(2.7182818284590452353602874713526625L); }
      };
# 114 "/usr/include/c++/14.2.1/tr1/special_function_util.h" 3
    template<typename _Tp>
    inline bool __isnan(_Tp __x)
    { return std::isnan(__x); }
# 133 "/usr/include/c++/14.2.1/tr1/special_function_util.h" 3
  }





}
# 50 "/usr/include/c++/14.2.1/tr1/gamma.tcc" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 65 "/usr/include/c++/14.2.1/tr1/gamma.tcc" 3
  namespace __detail
  {
# 76 "/usr/include/c++/14.2.1/tr1/gamma.tcc" 3
    template <typename _Tp>
    _Tp
    __bernoulli_series(unsigned int __n)
    {

      static const _Tp __num[28] = {
        _Tp(1UL), -_Tp(1UL) / _Tp(2UL),
        _Tp(1UL) / _Tp(6UL), _Tp(0UL),
        -_Tp(1UL) / _Tp(30UL), _Tp(0UL),
        _Tp(1UL) / _Tp(42UL), _Tp(0UL),
        -_Tp(1UL) / _Tp(30UL), _Tp(0UL),
        _Tp(5UL) / _Tp(66UL), _Tp(0UL),
        -_Tp(691UL) / _Tp(2730UL), _Tp(0UL),
        _Tp(7UL) / _Tp(6UL), _Tp(0UL),
        -_Tp(3617UL) / _Tp(510UL), _Tp(0UL),
        _Tp(43867UL) / _Tp(798UL), _Tp(0UL),
        -_Tp(174611) / _Tp(330UL), _Tp(0UL),
        _Tp(854513UL) / _Tp(138UL), _Tp(0UL),
        -_Tp(236364091UL) / _Tp(2730UL), _Tp(0UL),
        _Tp(8553103UL) / _Tp(6UL), _Tp(0UL)
      };

      if (__n == 0)
        return _Tp(1);

      if (__n == 1)
        return -_Tp(1) / _Tp(2);


      if (__n % 2 == 1)
        return _Tp(0);


      if (__n < 28)
        return __num[__n];


      _Tp __fact = _Tp(1);
      if ((__n / 2) % 2 == 0)
        __fact *= _Tp(-1);
      for (unsigned int __k = 1; __k <= __n; ++__k)
        __fact *= __k / (_Tp(2) * __numeric_constants<_Tp>::__pi());
      __fact *= _Tp(2);

      _Tp __sum = _Tp(0);
      for (unsigned int __i = 1; __i < 1000; ++__i)
        {
          _Tp __term = std::pow(_Tp(__i), -_Tp(__n));
          if (__term < std::numeric_limits<_Tp>::epsilon())
            break;
          __sum += __term;
        }

      return __fact * __sum;
    }
# 139 "/usr/include/c++/14.2.1/tr1/gamma.tcc" 3
    template<typename _Tp>
    inline _Tp
    __bernoulli(int __n)
    { return __bernoulli_series<_Tp>(__n); }
# 153 "/usr/include/c++/14.2.1/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __log_gamma_bernoulli(_Tp __x)
    {
      _Tp __lg = (__x - _Tp(0.5L)) * std::log(__x) - __x
               + _Tp(0.5L) * std::log(_Tp(2)
               * __numeric_constants<_Tp>::__pi());

      const _Tp __xx = __x * __x;
      _Tp __help = _Tp(1) / __x;
      for ( unsigned int __i = 1; __i < 20; ++__i )
        {
          const _Tp __2i = _Tp(2 * __i);
          __help /= __2i * (__2i - _Tp(1)) * __xx;
          __lg += __bernoulli<_Tp>(2 * __i) * __help;
        }

      return __lg;
    }
# 181 "/usr/include/c++/14.2.1/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __log_gamma_lanczos(_Tp __x)
    {
      const _Tp __xm1 = __x - _Tp(1);

      static const _Tp __lanczos_cheb_7[9] = {
       _Tp( 0.99999999999980993227684700473478L),
       _Tp( 676.520368121885098567009190444019L),
       _Tp(-1259.13921672240287047156078755283L),
       _Tp( 771.3234287776530788486528258894L),
       _Tp(-176.61502916214059906584551354L),
       _Tp( 12.507343278686904814458936853L),
       _Tp(-0.13857109526572011689554707L),
       _Tp( 9.984369578019570859563e-6L),
       _Tp( 1.50563273514931155834e-7L)
      };

      static const _Tp __LOGROOT2PI
          = _Tp(0.9189385332046727417803297364056176L);

      _Tp __sum = __lanczos_cheb_7[0];
      for(unsigned int __k = 1; __k < 9; ++__k)
        __sum += __lanczos_cheb_7[__k] / (__xm1 + __k);

      const _Tp __term1 = (__xm1 + _Tp(0.5L))
                        * std::log((__xm1 + _Tp(7.5L))
                       / __numeric_constants<_Tp>::__euler());
      const _Tp __term2 = __LOGROOT2PI + std::log(__sum);
      const _Tp __result = __term1 + (__term2 - _Tp(7));

      return __result;
    }
# 225 "/usr/include/c++/14.2.1/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __log_gamma(_Tp __x)
    {
      if (__x > _Tp(0.5L))
        return __log_gamma_lanczos(__x);
      else
        {
          const _Tp __sin_fact
                 = std::abs(std::sin(__numeric_constants<_Tp>::__pi() * __x));
          if (__sin_fact == _Tp(0))
            std::__throw_domain_error(("Argument is nonpositive integer " "in __log_gamma")
                                                           );
          return __numeric_constants<_Tp>::__lnpi()
                     - std::log(__sin_fact)
                     - __log_gamma_lanczos(_Tp(1) - __x);
        }
    }
# 252 "/usr/include/c++/14.2.1/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __log_gamma_sign(_Tp __x)
    {
      if (__x > _Tp(0))
        return _Tp(1);
      else
        {
          const _Tp __sin_fact
                  = std::sin(__numeric_constants<_Tp>::__pi() * __x);
          if (__sin_fact > _Tp(0))
            return (1);
          else if (__sin_fact < _Tp(0))
            return -_Tp(1);
          else
            return _Tp(0);
        }
    }
# 283 "/usr/include/c++/14.2.1/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __log_bincoef(unsigned int __n, unsigned int __k)
    {

      static const _Tp __max_bincoeff
                      = std::numeric_limits<_Tp>::max_exponent10
                      * std::log(_Tp(10)) - _Tp(1);

      _Tp __coeff = ::std::lgamma(_Tp(1 + __n))
                  - ::std::lgamma(_Tp(1 + __k))
                  - ::std::lgamma(_Tp(1 + __n - __k));





    }
# 314 "/usr/include/c++/14.2.1/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __bincoef(unsigned int __n, unsigned int __k)
    {

      static const _Tp __max_bincoeff
                      = std::numeric_limits<_Tp>::max_exponent10
                      * std::log(_Tp(10)) - _Tp(1);

      const _Tp __log_coeff = __log_bincoef<_Tp>(__n, __k);
      if (__log_coeff > __max_bincoeff)
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        return std::exp(__log_coeff);
    }
# 337 "/usr/include/c++/14.2.1/tr1/gamma.tcc" 3
    template<typename _Tp>
    inline _Tp
    __gamma(_Tp __x)
    { return std::exp(__log_gamma(__x)); }
# 356 "/usr/include/c++/14.2.1/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __psi_series(_Tp __x)
    {
      _Tp __sum = -__numeric_constants<_Tp>::__gamma_e() - _Tp(1) / __x;
      const unsigned int __max_iter = 100000;
      for (unsigned int __k = 1; __k < __max_iter; ++__k)
        {
          const _Tp __term = __x / (__k * (__k + __x));
          __sum += __term;
          if (std::abs(__term / __sum) < std::numeric_limits<_Tp>::epsilon())
            break;
        }
      return __sum;
    }
# 386 "/usr/include/c++/14.2.1/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __psi_asymp(_Tp __x)
    {
      _Tp __sum = std::log(__x) - _Tp(0.5L) / __x;
      const _Tp __xx = __x * __x;
      _Tp __xp = __xx;
      const unsigned int __max_iter = 100;
      for (unsigned int __k = 1; __k < __max_iter; ++__k)
        {
          const _Tp __term = __bernoulli<_Tp>(2 * __k) / (2 * __k * __xp);
          __sum -= __term;
          if (std::abs(__term / __sum) < std::numeric_limits<_Tp>::epsilon())
            break;
          __xp *= __xx;
        }
      return __sum;
    }
# 417 "/usr/include/c++/14.2.1/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __psi(_Tp __x)
    {
      const int __n = static_cast<int>(__x + 0.5L);
      const _Tp __eps = _Tp(4) * std::numeric_limits<_Tp>::epsilon();
      if (__n <= 0 && std::abs(__x - _Tp(__n)) < __eps)
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x < _Tp(0))
        {
          const _Tp __pi = __numeric_constants<_Tp>::__pi();
          return __psi(_Tp(1) - __x)
               - __pi * std::cos(__pi * __x) / std::sin(__pi * __x);
        }
      else if (__x > _Tp(100))
        return __psi_asymp(__x);
      else
        return __psi_series(__x);
    }
# 446 "/usr/include/c++/14.2.1/tr1/gamma.tcc" 3
    template<typename _Tp>
    _Tp
    __psi(unsigned int __n, _Tp __x)
    {
      if (__x <= _Tp(0))
        std::__throw_domain_error(("Argument out of range " "in __psi")
                                                 );
      else if (__n == 0)
        return __psi(__x);
      else
        {
          const _Tp __hzeta = __hurwitz_zeta(_Tp(__n + 1), __x);

          const _Tp __ln_nfact = ::std::lgamma(_Tp(__n + 1));



          _Tp __result = std::exp(__ln_nfact) * __hzeta;
          if (__n % 2 == 1)
            __result = -__result;
          return __result;
        }
    }
  }






}
# 48 "/usr/include/c++/14.2.1/bits/specfun.h" 2 3
# 1 "/usr/include/c++/14.2.1/tr1/bessel_function.tcc" 1 3
# 55 "/usr/include/c++/14.2.1/tr1/bessel_function.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 71 "/usr/include/c++/14.2.1/tr1/bessel_function.tcc" 3
  namespace __detail
  {
# 98 "/usr/include/c++/14.2.1/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    void
    __gamma_temme(_Tp __mu,
                  _Tp & __gam1, _Tp & __gam2, _Tp & __gampl, _Tp & __gammi)
    {

      __gampl = _Tp(1) / ::std::tgamma(_Tp(1) + __mu);
      __gammi = _Tp(1) / ::std::tgamma(_Tp(1) - __mu);





      if (std::abs(__mu) < std::numeric_limits<_Tp>::epsilon())
        __gam1 = -_Tp(__numeric_constants<_Tp>::__gamma_e());
      else
        __gam1 = (__gammi - __gampl) / (_Tp(2) * __mu);

      __gam2 = (__gammi + __gampl) / (_Tp(2));

      return;
    }
# 136 "/usr/include/c++/14.2.1/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    void
    __bessel_jn(_Tp __nu, _Tp __x,
                _Tp & __Jnu, _Tp & __Nnu, _Tp & __Jpnu, _Tp & __Npnu)
    {
      if (__x == _Tp(0))
        {
          if (__nu == _Tp(0))
            {
              __Jnu = _Tp(1);
              __Jpnu = _Tp(0);
            }
          else if (__nu == _Tp(1))
            {
              __Jnu = _Tp(0);
              __Jpnu = _Tp(0.5L);
            }
          else
            {
              __Jnu = _Tp(0);
              __Jpnu = _Tp(0);
            }
          __Nnu = -std::numeric_limits<_Tp>::infinity();
          __Npnu = std::numeric_limits<_Tp>::infinity();
          return;
        }

      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();




      const _Tp __fp_min = std::sqrt(std::numeric_limits<_Tp>::min());
      const int __max_iter = 15000;
      const _Tp __x_min = _Tp(2);

      const int __nl = (__x < __x_min
                    ? static_cast<int>(__nu + _Tp(0.5L))
                    : std::max(0, static_cast<int>(__nu - __x + _Tp(1.5L))));

      const _Tp __mu = __nu - __nl;
      const _Tp __mu2 = __mu * __mu;
      const _Tp __xi = _Tp(1) / __x;
      const _Tp __xi2 = _Tp(2) * __xi;
      _Tp __w = __xi2 / __numeric_constants<_Tp>::__pi();
      int __isign = 1;
      _Tp __h = __nu * __xi;
      if (__h < __fp_min)
        __h = __fp_min;
      _Tp __b = __xi2 * __nu;
      _Tp __d = _Tp(0);
      _Tp __c = __h;
      int __i;
      for (__i = 1; __i <= __max_iter; ++__i)
        {
          __b += __xi2;
          __d = __b - __d;
          if (std::abs(__d) < __fp_min)
            __d = __fp_min;
          __c = __b - _Tp(1) / __c;
          if (std::abs(__c) < __fp_min)
            __c = __fp_min;
          __d = _Tp(1) / __d;
          const _Tp __del = __c * __d;
          __h *= __del;
          if (__d < _Tp(0))
            __isign = -__isign;
          if (std::abs(__del - _Tp(1)) < __eps)
            break;
        }
      if (__i > __max_iter)
        std::__throw_runtime_error(("Argument x too large in __bessel_jn; " "try asymptotic expansion.")
                                                                   );
      _Tp __Jnul = __isign * __fp_min;
      _Tp __Jpnul = __h * __Jnul;
      _Tp __Jnul1 = __Jnul;
      _Tp __Jpnu1 = __Jpnul;
      _Tp __fact = __nu * __xi;
      for ( int __l = __nl; __l >= 1; --__l )
        {
          const _Tp __Jnutemp = __fact * __Jnul + __Jpnul;
          __fact -= __xi;
          __Jpnul = __fact * __Jnutemp - __Jnul;
          __Jnul = __Jnutemp;
        }
      if (__Jnul == _Tp(0))
        __Jnul = __eps;
      _Tp __f= __Jpnul / __Jnul;
      _Tp __Nmu, __Nnu1, __Npmu, __Jmu;
      if (__x < __x_min)
        {
          const _Tp __x2 = __x / _Tp(2);
          const _Tp __pimu = __numeric_constants<_Tp>::__pi() * __mu;
          _Tp __fact = (std::abs(__pimu) < __eps
                      ? _Tp(1) : __pimu / std::sin(__pimu));
          _Tp __d = -std::log(__x2);
          _Tp __e = __mu * __d;
          _Tp __fact2 = (std::abs(__e) < __eps
                       ? _Tp(1) : std::sinh(__e) / __e);
          _Tp __gam1, __gam2, __gampl, __gammi;
          __gamma_temme(__mu, __gam1, __gam2, __gampl, __gammi);
          _Tp __ff = (_Tp(2) / __numeric_constants<_Tp>::__pi())
                   * __fact * (__gam1 * std::cosh(__e) + __gam2 * __fact2 * __d);
          __e = std::exp(__e);
          _Tp __p = __e / (__numeric_constants<_Tp>::__pi() * __gampl);
          _Tp __q = _Tp(1) / (__e * __numeric_constants<_Tp>::__pi() * __gammi);
          const _Tp __pimu2 = __pimu / _Tp(2);
          _Tp __fact3 = (std::abs(__pimu2) < __eps
                       ? _Tp(1) : std::sin(__pimu2) / __pimu2 );
          _Tp __r = __numeric_constants<_Tp>::__pi() * __pimu2 * __fact3 * __fact3;
          _Tp __c = _Tp(1);
          __d = -__x2 * __x2;
          _Tp __sum = __ff + __r * __q;
          _Tp __sum1 = __p;
          for (__i = 1; __i <= __max_iter; ++__i)
            {
              __ff = (__i * __ff + __p + __q) / (__i * __i - __mu2);
              __c *= __d / _Tp(__i);
              __p /= _Tp(__i) - __mu;
              __q /= _Tp(__i) + __mu;
              const _Tp __del = __c * (__ff + __r * __q);
              __sum += __del;
              const _Tp __del1 = __c * __p - __i * __del;
              __sum1 += __del1;
              if ( std::abs(__del) < __eps * (_Tp(1) + std::abs(__sum)) )
                break;
            }
          if ( __i > __max_iter )
            std::__throw_runtime_error(("Bessel y series failed to converge " "in __bessel_jn.")
                                                             );
          __Nmu = -__sum;
          __Nnu1 = -__sum1 * __xi2;
          __Npmu = __mu * __xi * __Nmu - __Nnu1;
          __Jmu = __w / (__Npmu - __f * __Nmu);
        }
      else
        {
          _Tp __a = _Tp(0.25L) - __mu2;
          _Tp __q = _Tp(1);
          _Tp __p = -__xi / _Tp(2);
          _Tp __br = _Tp(2) * __x;
          _Tp __bi = _Tp(2);
          _Tp __fact = __a * __xi / (__p * __p + __q * __q);
          _Tp __cr = __br + __q * __fact;
          _Tp __ci = __bi + __p * __fact;
          _Tp __den = __br * __br + __bi * __bi;
          _Tp __dr = __br / __den;
          _Tp __di = -__bi / __den;
          _Tp __dlr = __cr * __dr - __ci * __di;
          _Tp __dli = __cr * __di + __ci * __dr;
          _Tp __temp = __p * __dlr - __q * __dli;
          __q = __p * __dli + __q * __dlr;
          __p = __temp;
          int __i;
          for (__i = 2; __i <= __max_iter; ++__i)
            {
              __a += _Tp(2 * (__i - 1));
              __bi += _Tp(2);
              __dr = __a * __dr + __br;
              __di = __a * __di + __bi;
              if (std::abs(__dr) + std::abs(__di) < __fp_min)
                __dr = __fp_min;
              __fact = __a / (__cr * __cr + __ci * __ci);
              __cr = __br + __cr * __fact;
              __ci = __bi - __ci * __fact;
              if (std::abs(__cr) + std::abs(__ci) < __fp_min)
                __cr = __fp_min;
              __den = __dr * __dr + __di * __di;
              __dr /= __den;
              __di /= -__den;
              __dlr = __cr * __dr - __ci * __di;
              __dli = __cr * __di + __ci * __dr;
              __temp = __p * __dlr - __q * __dli;
              __q = __p * __dli + __q * __dlr;
              __p = __temp;
              if (std::abs(__dlr - _Tp(1)) + std::abs(__dli) < __eps)
                break;
          }
          if (__i > __max_iter)
            std::__throw_runtime_error(("Lentz's method failed " "in __bessel_jn.")
                                                             );
          const _Tp __gam = (__p - __f) / __q;
          __Jmu = std::sqrt(__w / ((__p - __f) * __gam + __q));

          __Jmu = ::std::copysign(__Jmu, __Jnul);




          __Nmu = __gam * __Jmu;
          __Npmu = (__p + __q / __gam) * __Nmu;
          __Nnu1 = __mu * __xi * __Nmu - __Npmu;
      }
      __fact = __Jmu / __Jnul;
      __Jnu = __fact * __Jnul1;
      __Jpnu = __fact * __Jpnu1;
      for (__i = 1; __i <= __nl; ++__i)
        {
          const _Tp __Nnutemp = (__mu + __i) * __xi2 * __Nnu1 - __Nmu;
          __Nmu = __Nnu1;
          __Nnu1 = __Nnutemp;
        }
      __Nnu = __Nmu;
      __Npnu = __nu * __xi * __Nmu - __Nnu1;

      return;
    }
# 361 "/usr/include/c++/14.2.1/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    void
    __cyl_bessel_jn_asymp(_Tp __nu, _Tp __x, _Tp & __Jnu, _Tp & __Nnu)
    {
      const _Tp __mu = _Tp(4) * __nu * __nu;
      const _Tp __8x = _Tp(8) * __x;

      _Tp __P = _Tp(0);
      _Tp __Q = _Tp(0);

      _Tp __k = _Tp(0);
      _Tp __term = _Tp(1);

      int __epsP = 0;
      int __epsQ = 0;

      _Tp __eps = std::numeric_limits<_Tp>::epsilon();

      do
        {
          __term *= (__k == 0
                     ? _Tp(1)
                     : -(__mu - (2 * __k - 1) * (2 * __k - 1)) / (__k * __8x));

          __epsP = std::abs(__term) < __eps * std::abs(__P);
          __P += __term;

          __k++;

          __term *= (__mu - (2 * __k - 1) * (2 * __k - 1)) / (__k * __8x);
          __epsQ = std::abs(__term) < __eps * std::abs(__Q);
          __Q += __term;

          if (__epsP && __epsQ && __k > (__nu / 2.))
            break;

          __k++;
        }
      while (__k < 1000);

      const _Tp __chi = __x - (__nu + _Tp(0.5L))
                             * __numeric_constants<_Tp>::__pi_2();

      const _Tp __c = std::cos(__chi);
      const _Tp __s = std::sin(__chi);

      const _Tp __coef = std::sqrt(_Tp(2)
                             / (__numeric_constants<_Tp>::__pi() * __x));

      __Jnu = __coef * (__c * __P - __s * __Q);
      __Nnu = __coef * (__s * __P + __c * __Q);

      return;
    }
# 444 "/usr/include/c++/14.2.1/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    _Tp
    __cyl_bessel_ij_series(_Tp __nu, _Tp __x, _Tp __sgn,
                           unsigned int __max_iter)
    {
      if (__x == _Tp(0))
 return __nu == _Tp(0) ? _Tp(1) : _Tp(0);

      const _Tp __x2 = __x / _Tp(2);
      _Tp __fact = __nu * std::log(__x2);

      __fact -= ::std::lgamma(__nu + _Tp(1));



      __fact = std::exp(__fact);
      const _Tp __xx4 = __sgn * __x2 * __x2;
      _Tp __Jn = _Tp(1);
      _Tp __term = _Tp(1);

      for (unsigned int __i = 1; __i < __max_iter; ++__i)
        {
          __term *= __xx4 / (_Tp(__i) * (__nu + _Tp(__i)));
          __Jn += __term;
          if (std::abs(__term / __Jn) < std::numeric_limits<_Tp>::epsilon())
            break;
        }

      return __fact * __Jn;
    }
# 490 "/usr/include/c++/14.2.1/tr1/bessel_function.tcc" 3
    template<typename _Tp>
    _Tp
    __cyl_bessel_j(_Tp __nu, _Tp __x)
    {
      if (__nu < _Tp(0) || __x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __cyl_bessel_j.")
                                                           );
      else if (__isnan(__nu) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x * __x < _Tp(10) * (__nu + _Tp(1)))
        return __cyl_bessel_ij_series(__nu, __x, -_Tp(1), 200);
      else if (__x > _Tp(1000))
        {
          _Tp __J_nu, __N_nu;
          __cyl_bessel_jn_asymp(__nu, __x, __J_nu, __N_nu);
          return __J_nu;
        }
      else
        {
          _Tp __J_nu, __N_nu, __Jp_nu, __Np_nu;
          __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);
          return __J_nu;
        }
    }
# 532 "/usr/include/c++/14.2.1/tr1/bessel_function.tcc" 3
    template<typename _Tp>
    _Tp
    __cyl_neumann_n(_Tp __nu, _Tp __x)
    {
      if (__nu < _Tp(0) || __x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __cyl_neumann_n.")
                                                            );
      else if (__isnan(__nu) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x > _Tp(1000))
        {
          _Tp __J_nu, __N_nu;
          __cyl_bessel_jn_asymp(__nu, __x, __J_nu, __N_nu);
          return __N_nu;
        }
      else
        {
          _Tp __J_nu, __N_nu, __Jp_nu, __Np_nu;
          __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);
          return __N_nu;
        }
    }
# 569 "/usr/include/c++/14.2.1/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    void
    __sph_bessel_jn(unsigned int __n, _Tp __x,
                    _Tp & __j_n, _Tp & __n_n, _Tp & __jp_n, _Tp & __np_n)
    {
      const _Tp __nu = _Tp(__n) + _Tp(0.5L);

      _Tp __J_nu, __N_nu, __Jp_nu, __Np_nu;
      __bessel_jn(__nu, __x, __J_nu, __N_nu, __Jp_nu, __Np_nu);

      const _Tp __factor = __numeric_constants<_Tp>::__sqrtpio2()
                         / std::sqrt(__x);

      __j_n = __factor * __J_nu;
      __n_n = __factor * __N_nu;
      __jp_n = __factor * __Jp_nu - __j_n / (_Tp(2) * __x);
      __np_n = __factor * __Np_nu - __n_n / (_Tp(2) * __x);

      return;
    }
# 604 "/usr/include/c++/14.2.1/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    _Tp
    __sph_bessel(unsigned int __n, _Tp __x)
    {
      if (__x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __sph_bessel.")
                                                         );
      else if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x == _Tp(0))
        {
          if (__n == 0)
            return _Tp(1);
          else
            return _Tp(0);
        }
      else
        {
          _Tp __j_n, __n_n, __jp_n, __np_n;
          __sph_bessel_jn(__n, __x, __j_n, __n_n, __jp_n, __np_n);
          return __j_n;
        }
    }
# 642 "/usr/include/c++/14.2.1/tr1/bessel_function.tcc" 3
    template <typename _Tp>
    _Tp
    __sph_neumann(unsigned int __n, _Tp __x)
    {
      if (__x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __sph_neumann.")
                                                          );
      else if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x == _Tp(0))
        return -std::numeric_limits<_Tp>::infinity();
      else
        {
          _Tp __j_n, __n_n, __jp_n, __np_n;
          __sph_bessel_jn(__n, __x, __j_n, __n_n, __jp_n, __np_n);
          return __n_n;
        }
    }
  }






}
# 49 "/usr/include/c++/14.2.1/bits/specfun.h" 2 3
# 1 "/usr/include/c++/14.2.1/tr1/beta_function.tcc" 1 3
# 49 "/usr/include/c++/14.2.1/tr1/beta_function.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 65 "/usr/include/c++/14.2.1/tr1/beta_function.tcc" 3
  namespace __detail
  {
# 79 "/usr/include/c++/14.2.1/tr1/beta_function.tcc" 3
    template<typename _Tp>
    _Tp
    __beta_gamma(_Tp __x, _Tp __y)
    {

      _Tp __bet;

      if (__x > __y)
        {
          __bet = ::std::tgamma(__x)
                / ::std::tgamma(__x + __y);
          __bet *= ::std::tgamma(__y);
        }
      else
        {
          __bet = ::std::tgamma(__y)
                / ::std::tgamma(__x + __y);
          __bet *= ::std::tgamma(__x);
        }
# 111 "/usr/include/c++/14.2.1/tr1/beta_function.tcc" 3
      return __bet;
    }
# 127 "/usr/include/c++/14.2.1/tr1/beta_function.tcc" 3
    template<typename _Tp>
    _Tp
    __beta_lgamma(_Tp __x, _Tp __y)
    {

      _Tp __bet = ::std::lgamma(__x)
                + ::std::lgamma(__y)
                - ::std::lgamma(__x + __y);





      __bet = std::exp(__bet);
      return __bet;
    }
# 158 "/usr/include/c++/14.2.1/tr1/beta_function.tcc" 3
    template<typename _Tp>
    _Tp
    __beta_product(_Tp __x, _Tp __y)
    {

      _Tp __bet = (__x + __y) / (__x * __y);

      unsigned int __max_iter = 1000000;
      for (unsigned int __k = 1; __k < __max_iter; ++__k)
        {
          _Tp __term = (_Tp(1) + (__x + __y) / __k)
                     / ((_Tp(1) + __x / __k) * (_Tp(1) + __y / __k));
          __bet *= __term;
        }

      return __bet;
    }
# 189 "/usr/include/c++/14.2.1/tr1/beta_function.tcc" 3
    template<typename _Tp>
    inline _Tp
    __beta(_Tp __x, _Tp __y)
    {
      if (__isnan(__x) || __isnan(__y))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        return __beta_lgamma(__x, __y);
    }
  }






}
# 50 "/usr/include/c++/14.2.1/bits/specfun.h" 2 3
# 1 "/usr/include/c++/14.2.1/tr1/ell_integral.tcc" 1 3
# 45 "/usr/include/c++/14.2.1/tr1/ell_integral.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 59 "/usr/include/c++/14.2.1/tr1/ell_integral.tcc" 3
  namespace __detail
  {
# 76 "/usr/include/c++/14.2.1/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_rf(_Tp __x, _Tp __y, _Tp __z)
    {
      const _Tp __min = std::numeric_limits<_Tp>::min();
      const _Tp __lolim = _Tp(5) * __min;

      if (__x < _Tp(0) || __y < _Tp(0) || __z < _Tp(0))
        std::__throw_domain_error(("Argument less than zero " "in __ellint_rf.")
                                                        );
      else if (__x + __y < __lolim || __x + __z < __lolim
            || __y + __z < __lolim)
        std::__throw_domain_error(("Argument too small in __ellint_rf"));
      else
        {
          const _Tp __c0 = _Tp(1) / _Tp(4);
          const _Tp __c1 = _Tp(1) / _Tp(24);
          const _Tp __c2 = _Tp(1) / _Tp(10);
          const _Tp __c3 = _Tp(3) / _Tp(44);
          const _Tp __c4 = _Tp(1) / _Tp(14);

          _Tp __xn = __x;
          _Tp __yn = __y;
          _Tp __zn = __z;

          const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
          const _Tp __errtol = std::pow(__eps, _Tp(1) / _Tp(6));
          _Tp __mu;
          _Tp __xndev, __yndev, __zndev;

          const unsigned int __max_iter = 100;
          for (unsigned int __iter = 0; __iter < __max_iter; ++__iter)
            {
              __mu = (__xn + __yn + __zn) / _Tp(3);
              __xndev = 2 - (__mu + __xn) / __mu;
              __yndev = 2 - (__mu + __yn) / __mu;
              __zndev = 2 - (__mu + __zn) / __mu;
              _Tp __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
              __epsilon = std::max(__epsilon, std::abs(__zndev));
              if (__epsilon < __errtol)
                break;
              const _Tp __xnroot = std::sqrt(__xn);
              const _Tp __ynroot = std::sqrt(__yn);
              const _Tp __znroot = std::sqrt(__zn);
              const _Tp __lambda = __xnroot * (__ynroot + __znroot)
                                 + __ynroot * __znroot;
              __xn = __c0 * (__xn + __lambda);
              __yn = __c0 * (__yn + __lambda);
              __zn = __c0 * (__zn + __lambda);
            }

          const _Tp __e2 = __xndev * __yndev - __zndev * __zndev;
          const _Tp __e3 = __xndev * __yndev * __zndev;
          const _Tp __s = _Tp(1) + (__c1 * __e2 - __c2 - __c3 * __e3) * __e2
                   + __c4 * __e3;

          return __s / std::sqrt(__mu);
        }
    }
# 153 "/usr/include/c++/14.2.1/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __comp_ellint_1_series(_Tp __k)
    {

      const _Tp __kk = __k * __k;

      _Tp __term = __kk / _Tp(4);
      _Tp __sum = _Tp(1) + __term;

      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 2; __i < __max_iter; ++__i)
        {
          __term *= (2 * __i - 1) * __kk / (2 * __i);
          if (__term < std::numeric_limits<_Tp>::epsilon())
            break;
          __sum += __term;
        }

      return __numeric_constants<_Tp>::__pi_2() * __sum;
    }
# 191 "/usr/include/c++/14.2.1/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __comp_ellint_1(_Tp __k)
    {

      if (__isnan(__k))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (std::abs(__k) >= _Tp(1))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        return __ellint_rf(_Tp(0), _Tp(1) - __k * __k, _Tp(1));
    }
# 219 "/usr/include/c++/14.2.1/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_1(_Tp __k, _Tp __phi)
    {

      if (__isnan(__k) || __isnan(__phi))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (std::abs(__k) > _Tp(1))
        std::__throw_domain_error(("Bad argument in __ellint_1."));
      else
        {

          const int __n = std::floor(__phi / __numeric_constants<_Tp>::__pi()
                                   + _Tp(0.5L));
          const _Tp __phi_red = __phi
                              - __n * __numeric_constants<_Tp>::__pi();

          const _Tp __s = std::sin(__phi_red);
          const _Tp __c = std::cos(__phi_red);

          const _Tp __F = __s
                        * __ellint_rf(__c * __c,
                                _Tp(1) - __k * __k * __s * __s, _Tp(1));

          if (__n == 0)
            return __F;
          else
            return __F + _Tp(2) * __n * __comp_ellint_1(__k);
        }
    }
# 266 "/usr/include/c++/14.2.1/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __comp_ellint_2_series(_Tp __k)
    {

      const _Tp __kk = __k * __k;

      _Tp __term = __kk;
      _Tp __sum = __term;

      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 2; __i < __max_iter; ++__i)
        {
          const _Tp __i2m = 2 * __i - 1;
          const _Tp __i2 = 2 * __i;
          __term *= __i2m * __i2m * __kk / (__i2 * __i2);
          if (__term < std::numeric_limits<_Tp>::epsilon())
            break;
          __sum += __term / __i2m;
        }

      return __numeric_constants<_Tp>::__pi_2() * (_Tp(1) - __sum);
    }
# 314 "/usr/include/c++/14.2.1/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_rd(_Tp __x, _Tp __y, _Tp __z)
    {
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __errtol = std::pow(__eps / _Tp(8), _Tp(1) / _Tp(6));
      const _Tp __max = std::numeric_limits<_Tp>::max();
      const _Tp __lolim = _Tp(2) / std::pow(__max, _Tp(2) / _Tp(3));

      if (__x < _Tp(0) || __y < _Tp(0))
        std::__throw_domain_error(("Argument less than zero " "in __ellint_rd.")
                                                        );
      else if (__x + __y < __lolim || __z < __lolim)
        std::__throw_domain_error(("Argument too small " "in __ellint_rd.")
                                                        );
      else
        {
          const _Tp __c0 = _Tp(1) / _Tp(4);
          const _Tp __c1 = _Tp(3) / _Tp(14);
          const _Tp __c2 = _Tp(1) / _Tp(6);
          const _Tp __c3 = _Tp(9) / _Tp(22);
          const _Tp __c4 = _Tp(3) / _Tp(26);

          _Tp __xn = __x;
          _Tp __yn = __y;
          _Tp __zn = __z;
          _Tp __sigma = _Tp(0);
          _Tp __power4 = _Tp(1);

          _Tp __mu;
          _Tp __xndev, __yndev, __zndev;

          const unsigned int __max_iter = 100;
          for (unsigned int __iter = 0; __iter < __max_iter; ++__iter)
            {
              __mu = (__xn + __yn + _Tp(3) * __zn) / _Tp(5);
              __xndev = (__mu - __xn) / __mu;
              __yndev = (__mu - __yn) / __mu;
              __zndev = (__mu - __zn) / __mu;
              _Tp __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
              __epsilon = std::max(__epsilon, std::abs(__zndev));
              if (__epsilon < __errtol)
                break;
              _Tp __xnroot = std::sqrt(__xn);
              _Tp __ynroot = std::sqrt(__yn);
              _Tp __znroot = std::sqrt(__zn);
              _Tp __lambda = __xnroot * (__ynroot + __znroot)
                           + __ynroot * __znroot;
              __sigma += __power4 / (__znroot * (__zn + __lambda));
              __power4 *= __c0;
              __xn = __c0 * (__xn + __lambda);
              __yn = __c0 * (__yn + __lambda);
              __zn = __c0 * (__zn + __lambda);
            }

          _Tp __ea = __xndev * __yndev;
          _Tp __eb = __zndev * __zndev;
          _Tp __ec = __ea - __eb;
          _Tp __ed = __ea - _Tp(6) * __eb;
          _Tp __ef = __ed + __ec + __ec;
          _Tp __s1 = __ed * (-__c1 + __c3 * __ed
                                   / _Tp(3) - _Tp(3) * __c4 * __zndev * __ef
                                   / _Tp(2));
          _Tp __s2 = __zndev
                   * (__c2 * __ef
                    + __zndev * (-__c3 * __ec - __zndev * __c4 - __ea));

          return _Tp(3) * __sigma + __power4 * (_Tp(1) + __s1 + __s2)
                                        / (__mu * std::sqrt(__mu));
        }
    }
# 399 "/usr/include/c++/14.2.1/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __comp_ellint_2(_Tp __k)
    {

      if (__isnan(__k))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (std::abs(__k) == 1)
        return _Tp(1);
      else if (std::abs(__k) > _Tp(1))
        std::__throw_domain_error(("Bad argument in __comp_ellint_2."));
      else
        {
          const _Tp __kk = __k * __k;

          return __ellint_rf(_Tp(0), _Tp(1) - __kk, _Tp(1))
               - __kk * __ellint_rd(_Tp(0), _Tp(1) - __kk, _Tp(1)) / _Tp(3);
        }
    }
# 433 "/usr/include/c++/14.2.1/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_2(_Tp __k, _Tp __phi)
    {

      if (__isnan(__k) || __isnan(__phi))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (std::abs(__k) > _Tp(1))
        std::__throw_domain_error(("Bad argument in __ellint_2."));
      else
        {

          const int __n = std::floor(__phi / __numeric_constants<_Tp>::__pi()
                                   + _Tp(0.5L));
          const _Tp __phi_red = __phi
                              - __n * __numeric_constants<_Tp>::__pi();

          const _Tp __kk = __k * __k;
          const _Tp __s = std::sin(__phi_red);
          const _Tp __ss = __s * __s;
          const _Tp __sss = __ss * __s;
          const _Tp __c = std::cos(__phi_red);
          const _Tp __cc = __c * __c;

          const _Tp __E = __s
                        * __ellint_rf(__cc, _Tp(1) - __kk * __ss, _Tp(1))
                        - __kk * __sss
                        * __ellint_rd(__cc, _Tp(1) - __kk * __ss, _Tp(1))
                        / _Tp(3);

          if (__n == 0)
            return __E;
          else
            return __E + _Tp(2) * __n * __comp_ellint_2(__k);
        }
    }
# 492 "/usr/include/c++/14.2.1/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_rc(_Tp __x, _Tp __y)
    {
      const _Tp __min = std::numeric_limits<_Tp>::min();
      const _Tp __lolim = _Tp(5) * __min;

      if (__x < _Tp(0) || __y < _Tp(0) || __x + __y < __lolim)
        std::__throw_domain_error(("Argument less than zero " "in __ellint_rc.")
                                                        );
      else
        {
          const _Tp __c0 = _Tp(1) / _Tp(4);
          const _Tp __c1 = _Tp(1) / _Tp(7);
          const _Tp __c2 = _Tp(9) / _Tp(22);
          const _Tp __c3 = _Tp(3) / _Tp(10);
          const _Tp __c4 = _Tp(3) / _Tp(8);

          _Tp __xn = __x;
          _Tp __yn = __y;

          const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
          const _Tp __errtol = std::pow(__eps / _Tp(30), _Tp(1) / _Tp(6));
          _Tp __mu;
          _Tp __sn;

          const unsigned int __max_iter = 100;
          for (unsigned int __iter = 0; __iter < __max_iter; ++__iter)
            {
              __mu = (__xn + _Tp(2) * __yn) / _Tp(3);
              __sn = (__yn + __mu) / __mu - _Tp(2);
              if (std::abs(__sn) < __errtol)
                break;
              const _Tp __lambda = _Tp(2) * std::sqrt(__xn) * std::sqrt(__yn)
                             + __yn;
              __xn = __c0 * (__xn + __lambda);
              __yn = __c0 * (__yn + __lambda);
            }

          _Tp __s = __sn * __sn
                  * (__c3 + __sn*(__c1 + __sn * (__c4 + __sn * __c2)));

          return (_Tp(1) + __s) / std::sqrt(__mu);
        }
    }
# 561 "/usr/include/c++/14.2.1/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_rj(_Tp __x, _Tp __y, _Tp __z, _Tp __p)
    {
      const _Tp __min = std::numeric_limits<_Tp>::min();
      const _Tp __lolim = std::pow(_Tp(5) * __min, _Tp(1)/_Tp(3));

      if (__x < _Tp(0) || __y < _Tp(0) || __z < _Tp(0))
        std::__throw_domain_error(("Argument less than zero " "in __ellint_rj.")
                                                        );
      else if (__x + __y < __lolim || __x + __z < __lolim
            || __y + __z < __lolim || __p < __lolim)
        std::__throw_domain_error(("Argument too small " "in __ellint_rj")
                                                       );
      else
        {
          const _Tp __c0 = _Tp(1) / _Tp(4);
          const _Tp __c1 = _Tp(3) / _Tp(14);
          const _Tp __c2 = _Tp(1) / _Tp(3);
          const _Tp __c3 = _Tp(3) / _Tp(22);
          const _Tp __c4 = _Tp(3) / _Tp(26);

          _Tp __xn = __x;
          _Tp __yn = __y;
          _Tp __zn = __z;
          _Tp __pn = __p;
          _Tp __sigma = _Tp(0);
          _Tp __power4 = _Tp(1);

          const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
          const _Tp __errtol = std::pow(__eps / _Tp(8), _Tp(1) / _Tp(6));

          _Tp __mu;
          _Tp __xndev, __yndev, __zndev, __pndev;

          const unsigned int __max_iter = 100;
          for (unsigned int __iter = 0; __iter < __max_iter; ++__iter)
            {
              __mu = (__xn + __yn + __zn + _Tp(2) * __pn) / _Tp(5);
              __xndev = (__mu - __xn) / __mu;
              __yndev = (__mu - __yn) / __mu;
              __zndev = (__mu - __zn) / __mu;
              __pndev = (__mu - __pn) / __mu;
              _Tp __epsilon = std::max(std::abs(__xndev), std::abs(__yndev));
              __epsilon = std::max(__epsilon, std::abs(__zndev));
              __epsilon = std::max(__epsilon, std::abs(__pndev));
              if (__epsilon < __errtol)
                break;
              const _Tp __xnroot = std::sqrt(__xn);
              const _Tp __ynroot = std::sqrt(__yn);
              const _Tp __znroot = std::sqrt(__zn);
              const _Tp __lambda = __xnroot * (__ynroot + __znroot)
                                 + __ynroot * __znroot;
              const _Tp __alpha1 = __pn * (__xnroot + __ynroot + __znroot)
                                + __xnroot * __ynroot * __znroot;
              const _Tp __alpha2 = __alpha1 * __alpha1;
              const _Tp __beta = __pn * (__pn + __lambda)
                                      * (__pn + __lambda);
              __sigma += __power4 * __ellint_rc(__alpha2, __beta);
              __power4 *= __c0;
              __xn = __c0 * (__xn + __lambda);
              __yn = __c0 * (__yn + __lambda);
              __zn = __c0 * (__zn + __lambda);
              __pn = __c0 * (__pn + __lambda);
            }

          _Tp __ea = __xndev * (__yndev + __zndev) + __yndev * __zndev;
          _Tp __eb = __xndev * __yndev * __zndev;
          _Tp __ec = __pndev * __pndev;
          _Tp __e2 = __ea - _Tp(3) * __ec;
          _Tp __e3 = __eb + _Tp(2) * __pndev * (__ea - __ec);
          _Tp __s1 = _Tp(1) + __e2 * (-__c1 + _Tp(3) * __c3 * __e2 / _Tp(4)
                            - _Tp(3) * __c4 * __e3 / _Tp(2));
          _Tp __s2 = __eb * (__c2 / _Tp(2)
                   + __pndev * (-__c3 - __c3 + __pndev * __c4));
          _Tp __s3 = __pndev * __ea * (__c2 - __pndev * __c3)
                   - __c2 * __pndev * __ec;

          return _Tp(3) * __sigma + __power4 * (__s1 + __s2 + __s3)
                                             / (__mu * std::sqrt(__mu));
        }
    }
# 661 "/usr/include/c++/14.2.1/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __comp_ellint_3(_Tp __k, _Tp __nu)
    {

      if (__isnan(__k) || __isnan(__nu))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__nu == _Tp(1))
        return std::numeric_limits<_Tp>::infinity();
      else if (std::abs(__k) > _Tp(1))
        std::__throw_domain_error(("Bad argument in __comp_ellint_3."));
      else
        {
          const _Tp __kk = __k * __k;

          return __ellint_rf(_Tp(0), _Tp(1) - __kk, _Tp(1))
               + __nu
               * __ellint_rj(_Tp(0), _Tp(1) - __kk, _Tp(1), _Tp(1) - __nu)
               / _Tp(3);
        }
    }
# 701 "/usr/include/c++/14.2.1/tr1/ell_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __ellint_3(_Tp __k, _Tp __nu, _Tp __phi)
    {

      if (__isnan(__k) || __isnan(__nu) || __isnan(__phi))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (std::abs(__k) > _Tp(1))
        std::__throw_domain_error(("Bad argument in __ellint_3."));
      else
        {

          const int __n = std::floor(__phi / __numeric_constants<_Tp>::__pi()
                                   + _Tp(0.5L));
          const _Tp __phi_red = __phi
                              - __n * __numeric_constants<_Tp>::__pi();

          const _Tp __kk = __k * __k;
          const _Tp __s = std::sin(__phi_red);
          const _Tp __ss = __s * __s;
          const _Tp __sss = __ss * __s;
          const _Tp __c = std::cos(__phi_red);
          const _Tp __cc = __c * __c;

          const _Tp __Pi = __s
                         * __ellint_rf(__cc, _Tp(1) - __kk * __ss, _Tp(1))
                         + __nu * __sss
                         * __ellint_rj(__cc, _Tp(1) - __kk * __ss, _Tp(1),
                                       _Tp(1) - __nu * __ss) / _Tp(3);

          if (__n == 0)
            return __Pi;
          else
            return __Pi + _Tp(2) * __n * __comp_ellint_3(__k, __nu);
        }
    }
  }





}
# 51 "/usr/include/c++/14.2.1/bits/specfun.h" 2 3
# 1 "/usr/include/c++/14.2.1/tr1/exp_integral.tcc" 1 3
# 50 "/usr/include/c++/14.2.1/tr1/exp_integral.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 64 "/usr/include/c++/14.2.1/tr1/exp_integral.tcc" 3
  namespace __detail
  {
    template<typename _Tp> _Tp __expint_E1(_Tp);
# 81 "/usr/include/c++/14.2.1/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_E1_series(_Tp __x)
    {
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      _Tp __term = _Tp(1);
      _Tp __esum = _Tp(0);
      _Tp __osum = _Tp(0);
      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 1; __i < __max_iter; ++__i)
        {
          __term *= - __x / __i;
          if (std::abs(__term) < __eps)
            break;
          if (__term >= _Tp(0))
            __esum += __term / __i;
          else
            __osum += __term / __i;
        }

      return - __esum - __osum
             - __numeric_constants<_Tp>::__gamma_e() - std::log(__x);
    }
# 118 "/usr/include/c++/14.2.1/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_E1_asymp(_Tp __x)
    {
      _Tp __term = _Tp(1);
      _Tp __esum = _Tp(1);
      _Tp __osum = _Tp(0);
      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 1; __i < __max_iter; ++__i)
        {
          _Tp __prev = __term;
          __term *= - __i / __x;
          if (std::abs(__term) > std::abs(__prev))
            break;
          if (__term >= _Tp(0))
            __esum += __term;
          else
            __osum += __term;
        }

      return std::exp(- __x) * (__esum + __osum) / __x;
    }
# 155 "/usr/include/c++/14.2.1/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_En_series(unsigned int __n, _Tp __x)
    {
      const unsigned int __max_iter = 1000;
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const int __nm1 = __n - 1;
      _Tp __ans = (__nm1 != 0
                ? _Tp(1) / __nm1 : -std::log(__x)
                                   - __numeric_constants<_Tp>::__gamma_e());
      _Tp __fact = _Tp(1);
      for (int __i = 1; __i <= __max_iter; ++__i)
        {
          __fact *= -__x / _Tp(__i);
          _Tp __del;
          if ( __i != __nm1 )
            __del = -__fact / _Tp(__i - __nm1);
          else
            {
              _Tp __psi = -__numeric_constants<_Tp>::gamma_e();
              for (int __ii = 1; __ii <= __nm1; ++__ii)
                __psi += _Tp(1) / _Tp(__ii);
              __del = __fact * (__psi - std::log(__x));
            }
          __ans += __del;
          if (std::abs(__del) < __eps * std::abs(__ans))
            return __ans;
        }
      std::__throw_runtime_error(("Series summation failed " "in __expint_En_series.")
                                                              );
    }
# 201 "/usr/include/c++/14.2.1/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_En_cont_frac(unsigned int __n, _Tp __x)
    {
      const unsigned int __max_iter = 1000;
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __fp_min = std::numeric_limits<_Tp>::min();
      const int __nm1 = __n - 1;
      _Tp __b = __x + _Tp(__n);
      _Tp __c = _Tp(1) / __fp_min;
      _Tp __d = _Tp(1) / __b;
      _Tp __h = __d;
      for ( unsigned int __i = 1; __i <= __max_iter; ++__i )
        {
          _Tp __a = -_Tp(__i * (__nm1 + __i));
          __b += _Tp(2);
          __d = _Tp(1) / (__a * __d + __b);
          __c = __b + __a / __c;
          const _Tp __del = __c * __d;
          __h *= __del;
          if (std::abs(__del - _Tp(1)) < __eps)
            {
              const _Tp __ans = __h * std::exp(-__x);
              return __ans;
            }
        }
      std::__throw_runtime_error(("Continued fraction failed " "in __expint_En_cont_frac.")
                                                                 );
    }
# 246 "/usr/include/c++/14.2.1/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_En_recursion(unsigned int __n, _Tp __x)
    {
      _Tp __En;
      _Tp __E1 = __expint_E1(__x);
      if (__x < _Tp(__n))
        {

          __En = __E1;
          for (unsigned int __j = 2; __j < __n; ++__j)
            __En = (std::exp(-__x) - __x * __En) / _Tp(__j - 1);
        }
      else
        {

          __En = _Tp(1);
          const int __N = __n + 20;
          _Tp __save = _Tp(0);
          for (int __j = __N; __j > 0; --__j)
            {
              __En = (std::exp(-__x) - __j * __En) / __x;
              if (__j == __n)
                __save = __En;
            }
            _Tp __norm = __En / __E1;
            __En /= __norm;
        }

      return __En;
    }
# 290 "/usr/include/c++/14.2.1/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_Ei_series(_Tp __x)
    {
      _Tp __term = _Tp(1);
      _Tp __sum = _Tp(0);
      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 1; __i < __max_iter; ++__i)
        {
          __term *= __x / __i;
          __sum += __term / __i;
          if (__term < std::numeric_limits<_Tp>::epsilon() * __sum)
            break;
        }

      return __numeric_constants<_Tp>::__gamma_e() + __sum + std::log(__x);
    }
# 321 "/usr/include/c++/14.2.1/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_Ei_asymp(_Tp __x)
    {
      _Tp __term = _Tp(1);
      _Tp __sum = _Tp(1);
      const unsigned int __max_iter = 1000;
      for (unsigned int __i = 1; __i < __max_iter; ++__i)
        {
          _Tp __prev = __term;
          __term *= __i / __x;
          if (__term < std::numeric_limits<_Tp>::epsilon())
            break;
          if (__term >= __prev)
            break;
          __sum += __term;
        }

      return std::exp(__x) * __sum / __x;
    }
# 354 "/usr/include/c++/14.2.1/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_Ei(_Tp __x)
    {
      if (__x < _Tp(0))
        return -__expint_E1(-__x);
      else if (__x < -std::log(std::numeric_limits<_Tp>::epsilon()))
        return __expint_Ei_series(__x);
      else
        return __expint_Ei_asymp(__x);
    }
# 378 "/usr/include/c++/14.2.1/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_E1(_Tp __x)
    {
      if (__x < _Tp(0))
        return -__expint_Ei(-__x);
      else if (__x < _Tp(1))
        return __expint_E1_series(__x);
      else if (__x < _Tp(100))
        return __expint_En_cont_frac(1, __x);
      else
        return __expint_E1_asymp(__x);
    }
# 408 "/usr/include/c++/14.2.1/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_asymp(unsigned int __n, _Tp __x)
    {
      _Tp __term = _Tp(1);
      _Tp __sum = _Tp(1);
      for (unsigned int __i = 1; __i <= __n; ++__i)
        {
          _Tp __prev = __term;
          __term *= -(__n - __i + 1) / __x;
          if (std::abs(__term) > std::abs(__prev))
            break;
          __sum += __term;
        }

      return std::exp(-__x) * __sum / __x;
    }
# 442 "/usr/include/c++/14.2.1/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint_large_n(unsigned int __n, _Tp __x)
    {
      const _Tp __xpn = __x + __n;
      const _Tp __xpn2 = __xpn * __xpn;
      _Tp __term = _Tp(1);
      _Tp __sum = _Tp(1);
      for (unsigned int __i = 1; __i <= __n; ++__i)
        {
          _Tp __prev = __term;
          __term *= (__n - 2 * (__i - 1) * __x) / __xpn2;
          if (std::abs(__term) < std::numeric_limits<_Tp>::epsilon())
            break;
          __sum += __term;
        }

      return std::exp(-__x) * __sum / __xpn;
    }
# 476 "/usr/include/c++/14.2.1/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    _Tp
    __expint(unsigned int __n, _Tp __x)
    {

      if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__n <= 1 && __x == _Tp(0))
        return std::numeric_limits<_Tp>::infinity();
      else
        {
          _Tp __E0 = std::exp(__x) / __x;
          if (__n == 0)
            return __E0;

          _Tp __E1 = __expint_E1(__x);
          if (__n == 1)
            return __E1;

          if (__x == _Tp(0))
            return _Tp(1) / static_cast<_Tp>(__n - 1);

          _Tp __En = __expint_En_recursion(__n, __x);

          return __En;
        }
    }
# 516 "/usr/include/c++/14.2.1/tr1/exp_integral.tcc" 3
    template<typename _Tp>
    inline _Tp
    __expint(_Tp __x)
    {
      if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        return __expint_Ei(__x);
    }
  }





}
# 52 "/usr/include/c++/14.2.1/bits/specfun.h" 2 3
# 1 "/usr/include/c++/14.2.1/tr1/hypergeometric.tcc" 1 3
# 44 "/usr/include/c++/14.2.1/tr1/hypergeometric.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 60 "/usr/include/c++/14.2.1/tr1/hypergeometric.tcc" 3
  namespace __detail
  {
# 83 "/usr/include/c++/14.2.1/tr1/hypergeometric.tcc" 3
    template<typename _Tp>
    _Tp
    __conf_hyperg_series(_Tp __a, _Tp __c, _Tp __x)
    {
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();

      _Tp __term = _Tp(1);
      _Tp __Fac = _Tp(1);
      const unsigned int __max_iter = 100000;
      unsigned int __i;
      for (__i = 0; __i < __max_iter; ++__i)
        {
          __term *= (__a + _Tp(__i)) * __x
                  / ((__c + _Tp(__i)) * _Tp(1 + __i));
          if (std::abs(__term) < __eps)
            {
              break;
            }
          __Fac += __term;
        }
      if (__i == __max_iter)
        std::__throw_runtime_error(("Series failed to converge " "in __conf_hyperg_series.")
                                                                  );

      return __Fac;
    }
# 120 "/usr/include/c++/14.2.1/tr1/hypergeometric.tcc" 3
    template<typename _Tp>
    _Tp
    __conf_hyperg_luke(_Tp __a, _Tp __c, _Tp __xin)
    {
      const _Tp __big = std::pow(std::numeric_limits<_Tp>::max(), _Tp(0.16L));
      const int __nmax = 20000;
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __x = -__xin;
      const _Tp __x3 = __x * __x * __x;
      const _Tp __t0 = __a / __c;
      const _Tp __t1 = (__a + _Tp(1)) / (_Tp(2) * __c);
      const _Tp __t2 = (__a + _Tp(2)) / (_Tp(2) * (__c + _Tp(1)));
      _Tp __F = _Tp(1);
      _Tp __prec;

      _Tp __Bnm3 = _Tp(1);
      _Tp __Bnm2 = _Tp(1) + __t1 * __x;
      _Tp __Bnm1 = _Tp(1) + __t2 * __x * (_Tp(1) + __t1 / _Tp(3) * __x);

      _Tp __Anm3 = _Tp(1);
      _Tp __Anm2 = __Bnm2 - __t0 * __x;
      _Tp __Anm1 = __Bnm1 - __t0 * (_Tp(1) + __t2 * __x) * __x
                 + __t0 * __t1 * (__c / (__c + _Tp(1))) * __x * __x;

      int __n = 3;
      while(1)
        {
          _Tp __npam1 = _Tp(__n - 1) + __a;
          _Tp __npcm1 = _Tp(__n - 1) + __c;
          _Tp __npam2 = _Tp(__n - 2) + __a;
          _Tp __npcm2 = _Tp(__n - 2) + __c;
          _Tp __tnm1 = _Tp(2 * __n - 1);
          _Tp __tnm3 = _Tp(2 * __n - 3);
          _Tp __tnm5 = _Tp(2 * __n - 5);
          _Tp __F1 = (_Tp(__n - 2) - __a) / (_Tp(2) * __tnm3 * __npcm1);
          _Tp __F2 = (_Tp(__n) + __a) * __npam1
                   / (_Tp(4) * __tnm1 * __tnm3 * __npcm2 * __npcm1);
          _Tp __F3 = -__npam2 * __npam1 * (_Tp(__n - 2) - __a)
                   / (_Tp(8) * __tnm3 * __tnm3 * __tnm5
                   * (_Tp(__n - 3) + __c) * __npcm2 * __npcm1);
          _Tp __E = -__npam1 * (_Tp(__n - 1) - __c)
                   / (_Tp(2) * __tnm3 * __npcm2 * __npcm1);

          _Tp __An = (_Tp(1) + __F1 * __x) * __Anm1
                   + (__E + __F2 * __x) * __x * __Anm2 + __F3 * __x3 * __Anm3;
          _Tp __Bn = (_Tp(1) + __F1 * __x) * __Bnm1
                   + (__E + __F2 * __x) * __x * __Bnm2 + __F3 * __x3 * __Bnm3;
          _Tp __r = __An / __Bn;

          __prec = std::abs((__F - __r) / __F);
          __F = __r;

          if (__prec < __eps || __n > __nmax)
            break;

          if (std::abs(__An) > __big || std::abs(__Bn) > __big)
            {
              __An /= __big;
              __Bn /= __big;
              __Anm1 /= __big;
              __Bnm1 /= __big;
              __Anm2 /= __big;
              __Bnm2 /= __big;
              __Anm3 /= __big;
              __Bnm3 /= __big;
            }
          else if (std::abs(__An) < _Tp(1) / __big
                || std::abs(__Bn) < _Tp(1) / __big)
            {
              __An *= __big;
              __Bn *= __big;
              __Anm1 *= __big;
              __Bnm1 *= __big;
              __Anm2 *= __big;
              __Bnm2 *= __big;
              __Anm3 *= __big;
              __Bnm3 *= __big;
            }

          ++__n;
          __Bnm3 = __Bnm2;
          __Bnm2 = __Bnm1;
          __Bnm1 = __Bn;
          __Anm3 = __Anm2;
          __Anm2 = __Anm1;
          __Anm1 = __An;
        }

      if (__n >= __nmax)
        std::__throw_runtime_error(("Iteration failed to converge " "in __conf_hyperg_luke.")
                                                                );

      return __F;
    }
# 227 "/usr/include/c++/14.2.1/tr1/hypergeometric.tcc" 3
    template<typename _Tp>
    _Tp
    __conf_hyperg(_Tp __a, _Tp __c, _Tp __x)
    {

      const _Tp __c_nint = ::std::nearbyint(__c);



      if (__isnan(__a) || __isnan(__c) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__c_nint == __c && __c_nint <= 0)
        return std::numeric_limits<_Tp>::infinity();
      else if (__a == _Tp(0))
        return _Tp(1);
      else if (__c == __a)
        return std::exp(__x);
      else if (__x < _Tp(0))
        return __conf_hyperg_luke(__a, __c, __x);
      else
        return __conf_hyperg_series(__a, __c, __x);
    }
# 271 "/usr/include/c++/14.2.1/tr1/hypergeometric.tcc" 3
    template<typename _Tp>
    _Tp
    __hyperg_series(_Tp __a, _Tp __b, _Tp __c, _Tp __x)
    {
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();

      _Tp __term = _Tp(1);
      _Tp __Fabc = _Tp(1);
      const unsigned int __max_iter = 100000;
      unsigned int __i;
      for (__i = 0; __i < __max_iter; ++__i)
        {
          __term *= (__a + _Tp(__i)) * (__b + _Tp(__i)) * __x
                  / ((__c + _Tp(__i)) * _Tp(1 + __i));
          if (std::abs(__term) < __eps)
            {
              break;
            }
          __Fabc += __term;
        }
      if (__i == __max_iter)
        std::__throw_runtime_error(("Series failed to converge " "in __hyperg_series.")
                                                             );

      return __Fabc;
    }







    template<typename _Tp>
    _Tp
    __hyperg_luke(_Tp __a, _Tp __b, _Tp __c, _Tp __xin)
    {
      const _Tp __big = std::pow(std::numeric_limits<_Tp>::max(), _Tp(0.16L));
      const int __nmax = 20000;
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __x = -__xin;
      const _Tp __x3 = __x * __x * __x;
      const _Tp __t0 = __a * __b / __c;
      const _Tp __t1 = (__a + _Tp(1)) * (__b + _Tp(1)) / (_Tp(2) * __c);
      const _Tp __t2 = (__a + _Tp(2)) * (__b + _Tp(2))
                     / (_Tp(2) * (__c + _Tp(1)));

      _Tp __F = _Tp(1);

      _Tp __Bnm3 = _Tp(1);
      _Tp __Bnm2 = _Tp(1) + __t1 * __x;
      _Tp __Bnm1 = _Tp(1) + __t2 * __x * (_Tp(1) + __t1 / _Tp(3) * __x);

      _Tp __Anm3 = _Tp(1);
      _Tp __Anm2 = __Bnm2 - __t0 * __x;
      _Tp __Anm1 = __Bnm1 - __t0 * (_Tp(1) + __t2 * __x) * __x
                 + __t0 * __t1 * (__c / (__c + _Tp(1))) * __x * __x;

      int __n = 3;
      while (1)
        {
          const _Tp __npam1 = _Tp(__n - 1) + __a;
          const _Tp __npbm1 = _Tp(__n - 1) + __b;
          const _Tp __npcm1 = _Tp(__n - 1) + __c;
          const _Tp __npam2 = _Tp(__n - 2) + __a;
          const _Tp __npbm2 = _Tp(__n - 2) + __b;
          const _Tp __npcm2 = _Tp(__n - 2) + __c;
          const _Tp __tnm1 = _Tp(2 * __n - 1);
          const _Tp __tnm3 = _Tp(2 * __n - 3);
          const _Tp __tnm5 = _Tp(2 * __n - 5);
          const _Tp __n2 = __n * __n;
          const _Tp __F1 = (_Tp(3) * __n2 + (__a + __b - _Tp(6)) * __n
                         + _Tp(2) - __a * __b - _Tp(2) * (__a + __b))
                         / (_Tp(2) * __tnm3 * __npcm1);
          const _Tp __F2 = -(_Tp(3) * __n2 - (__a + __b + _Tp(6)) * __n
                         + _Tp(2) - __a * __b) * __npam1 * __npbm1
                         / (_Tp(4) * __tnm1 * __tnm3 * __npcm2 * __npcm1);
          const _Tp __F3 = (__npam2 * __npam1 * __npbm2 * __npbm1
                         * (_Tp(__n - 2) - __a) * (_Tp(__n - 2) - __b))
                         / (_Tp(8) * __tnm3 * __tnm3 * __tnm5
                         * (_Tp(__n - 3) + __c) * __npcm2 * __npcm1);
          const _Tp __E = -__npam1 * __npbm1 * (_Tp(__n - 1) - __c)
                         / (_Tp(2) * __tnm3 * __npcm2 * __npcm1);

          _Tp __An = (_Tp(1) + __F1 * __x) * __Anm1
                   + (__E + __F2 * __x) * __x * __Anm2 + __F3 * __x3 * __Anm3;
          _Tp __Bn = (_Tp(1) + __F1 * __x) * __Bnm1
                   + (__E + __F2 * __x) * __x * __Bnm2 + __F3 * __x3 * __Bnm3;
          const _Tp __r = __An / __Bn;

          const _Tp __prec = std::abs((__F - __r) / __F);
          __F = __r;

          if (__prec < __eps || __n > __nmax)
            break;

          if (std::abs(__An) > __big || std::abs(__Bn) > __big)
            {
              __An /= __big;
              __Bn /= __big;
              __Anm1 /= __big;
              __Bnm1 /= __big;
              __Anm2 /= __big;
              __Bnm2 /= __big;
              __Anm3 /= __big;
              __Bnm3 /= __big;
            }
          else if (std::abs(__An) < _Tp(1) / __big
                || std::abs(__Bn) < _Tp(1) / __big)
            {
              __An *= __big;
              __Bn *= __big;
              __Anm1 *= __big;
              __Bnm1 *= __big;
              __Anm2 *= __big;
              __Bnm2 *= __big;
              __Anm3 *= __big;
              __Bnm3 *= __big;
            }

          ++__n;
          __Bnm3 = __Bnm2;
          __Bnm2 = __Bnm1;
          __Bnm1 = __Bn;
          __Anm3 = __Anm2;
          __Anm2 = __Anm1;
          __Anm1 = __An;
        }

      if (__n >= __nmax)
        std::__throw_runtime_error(("Iteration failed to converge " "in __hyperg_luke.")
                                                           );

      return __F;
    }
# 438 "/usr/include/c++/14.2.1/tr1/hypergeometric.tcc" 3
    template<typename _Tp>
    _Tp
    __hyperg_reflect(_Tp __a, _Tp __b, _Tp __c, _Tp __x)
    {
      const _Tp __d = __c - __a - __b;
      const int __intd = std::floor(__d + _Tp(0.5L));
      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __toler = _Tp(1000) * __eps;
      const _Tp __log_max = std::log(std::numeric_limits<_Tp>::max());
      const bool __d_integer = (std::abs(__d - __intd) < __toler);

      if (__d_integer)
        {
          const _Tp __ln_omx = std::log(_Tp(1) - __x);
          const _Tp __ad = std::abs(__d);
          _Tp __F1, __F2;

          _Tp __d1, __d2;
          if (__d >= _Tp(0))
            {
              __d1 = __d;
              __d2 = _Tp(0);
            }
          else
            {
              __d1 = _Tp(0);
              __d2 = __d;
            }

          const _Tp __lng_c = __log_gamma(__c);


          if (__ad < __eps)
            {

              __F1 = _Tp(0);
            }
          else
            {

              bool __ok_d1 = true;
              _Tp __lng_ad, __lng_ad1, __lng_bd1;
              try
                {
                  __lng_ad = __log_gamma(__ad);
                  __lng_ad1 = __log_gamma(__a + __d1);
                  __lng_bd1 = __log_gamma(__b + __d1);
                }
              catch(...)
                {
                  __ok_d1 = false;
                }

              if (__ok_d1)
                {



                  _Tp __sum1 = _Tp(1);
                  _Tp __term = _Tp(1);
                  _Tp __ln_pre1 = __lng_ad + __lng_c + __d2 * __ln_omx
                                - __lng_ad1 - __lng_bd1;



                  for (int __i = 1; __i < __ad; ++__i)
                    {
                      const int __j = __i - 1;
                      __term *= (__a + __d2 + __j) * (__b + __d2 + __j)
                              / (_Tp(1) + __d2 + __j) / __i * (_Tp(1) - __x);
                      __sum1 += __term;
                    }

                  if (__ln_pre1 > __log_max)
                    std::__throw_runtime_error(("Overflow of gamma functions" " in __hyperg_luke.")
                                                                        );
                  else
                    __F1 = std::exp(__ln_pre1) * __sum1;
                }
              else
                {


                  __F1 = _Tp(0);
                }
            }


          bool __ok_d2 = true;
          _Tp __lng_ad2, __lng_bd2;
          try
            {
              __lng_ad2 = __log_gamma(__a + __d2);
              __lng_bd2 = __log_gamma(__b + __d2);
            }
          catch(...)
            {
              __ok_d2 = false;
            }

          if (__ok_d2)
            {


              const int __maxiter = 2000;
              const _Tp __psi_1 = -__numeric_constants<_Tp>::__gamma_e();
              const _Tp __psi_1pd = __psi(_Tp(1) + __ad);
              const _Tp __psi_apd1 = __psi(__a + __d1);
              const _Tp __psi_bpd1 = __psi(__b + __d1);

              _Tp __psi_term = __psi_1 + __psi_1pd - __psi_apd1
                             - __psi_bpd1 - __ln_omx;
              _Tp __fact = _Tp(1);
              _Tp __sum2 = __psi_term;
              _Tp __ln_pre2 = __lng_c + __d1 * __ln_omx
                            - __lng_ad2 - __lng_bd2;


              int __j;
              for (__j = 1; __j < __maxiter; ++__j)
                {


                  const _Tp __term1 = _Tp(1) / _Tp(__j)
                                    + _Tp(1) / (__ad + __j);
                  const _Tp __term2 = _Tp(1) / (__a + __d1 + _Tp(__j - 1))
                                    + _Tp(1) / (__b + __d1 + _Tp(__j - 1));
                  __psi_term += __term1 - __term2;
                  __fact *= (__a + __d1 + _Tp(__j - 1))
                          * (__b + __d1 + _Tp(__j - 1))
                          / ((__ad + __j) * __j) * (_Tp(1) - __x);
                  const _Tp __delta = __fact * __psi_term;
                  __sum2 += __delta;
                  if (std::abs(__delta) < __eps * std::abs(__sum2))
                    break;
                }
              if (__j == __maxiter)
                std::__throw_runtime_error(("Sum F2 failed to converge " "in __hyperg_reflect")
                                                                     );

              if (__sum2 == _Tp(0))
                __F2 = _Tp(0);
              else
                __F2 = std::exp(__ln_pre2) * __sum2;
            }
          else
            {


              __F2 = _Tp(0);
            }

          const _Tp __sgn_2 = (__intd % 2 == 1 ? -_Tp(1) : _Tp(1));
          const _Tp __F = __F1 + __sgn_2 * __F2;

          return __F;
        }
      else
        {




          bool __ok1 = true;
          _Tp __sgn_g1ca = _Tp(0), __ln_g1ca = _Tp(0);
          _Tp __sgn_g1cb = _Tp(0), __ln_g1cb = _Tp(0);
          try
            {
              __sgn_g1ca = __log_gamma_sign(__c - __a);
              __ln_g1ca = __log_gamma(__c - __a);
              __sgn_g1cb = __log_gamma_sign(__c - __b);
              __ln_g1cb = __log_gamma(__c - __b);
            }
          catch(...)
            {
              __ok1 = false;
            }

          bool __ok2 = true;
          _Tp __sgn_g2a = _Tp(0), __ln_g2a = _Tp(0);
          _Tp __sgn_g2b = _Tp(0), __ln_g2b = _Tp(0);
          try
            {
              __sgn_g2a = __log_gamma_sign(__a);
              __ln_g2a = __log_gamma(__a);
              __sgn_g2b = __log_gamma_sign(__b);
              __ln_g2b = __log_gamma(__b);
            }
          catch(...)
            {
              __ok2 = false;
            }

          const _Tp __sgn_gc = __log_gamma_sign(__c);
          const _Tp __ln_gc = __log_gamma(__c);
          const _Tp __sgn_gd = __log_gamma_sign(__d);
          const _Tp __ln_gd = __log_gamma(__d);
          const _Tp __sgn_gmd = __log_gamma_sign(-__d);
          const _Tp __ln_gmd = __log_gamma(-__d);

          const _Tp __sgn1 = __sgn_gc * __sgn_gd * __sgn_g1ca * __sgn_g1cb;
          const _Tp __sgn2 = __sgn_gc * __sgn_gmd * __sgn_g2a * __sgn_g2b;

          _Tp __pre1, __pre2;
          if (__ok1 && __ok2)
            {
              _Tp __ln_pre1 = __ln_gc + __ln_gd - __ln_g1ca - __ln_g1cb;
              _Tp __ln_pre2 = __ln_gc + __ln_gmd - __ln_g2a - __ln_g2b
                            + __d * std::log(_Tp(1) - __x);
              if (__ln_pre1 < __log_max && __ln_pre2 < __log_max)
                {
                  __pre1 = std::exp(__ln_pre1);
                  __pre2 = std::exp(__ln_pre2);
                  __pre1 *= __sgn1;
                  __pre2 *= __sgn2;
                }
              else
                {
                  std::__throw_runtime_error(("Overflow of gamma functions " "in __hyperg_reflect")
                                                                       );
                }
            }
          else if (__ok1 && !__ok2)
            {
              _Tp __ln_pre1 = __ln_gc + __ln_gd - __ln_g1ca - __ln_g1cb;
              if (__ln_pre1 < __log_max)
                {
                  __pre1 = std::exp(__ln_pre1);
                  __pre1 *= __sgn1;
                  __pre2 = _Tp(0);
                }
              else
                {
                  std::__throw_runtime_error(("Overflow of gamma functions " "in __hyperg_reflect")
                                                                       );
                }
            }
          else if (!__ok1 && __ok2)
            {
              _Tp __ln_pre2 = __ln_gc + __ln_gmd - __ln_g2a - __ln_g2b
                            + __d * std::log(_Tp(1) - __x);
              if (__ln_pre2 < __log_max)
                {
                  __pre1 = _Tp(0);
                  __pre2 = std::exp(__ln_pre2);
                  __pre2 *= __sgn2;
                }
              else
                {
                  std::__throw_runtime_error(("Overflow of gamma functions " "in __hyperg_reflect")
                                                                       );
                }
            }
          else
            {
              __pre1 = _Tp(0);
              __pre2 = _Tp(0);
              std::__throw_runtime_error(("Underflow of gamma functions " "in __hyperg_reflect")
                                                                   );
            }

          const _Tp __F1 = __hyperg_series(__a, __b, _Tp(1) - __d,
                                           _Tp(1) - __x);
          const _Tp __F2 = __hyperg_series(__c - __a, __c - __b, _Tp(1) + __d,
                                           _Tp(1) - __x);

          const _Tp __F = __pre1 * __F1 + __pre2 * __F2;

          return __F;
        }
    }
# 728 "/usr/include/c++/14.2.1/tr1/hypergeometric.tcc" 3
    template<typename _Tp>
    _Tp
    __hyperg(_Tp __a, _Tp __b, _Tp __c, _Tp __x)
    {

      const _Tp __a_nint = ::std::nearbyint(__a);
      const _Tp __b_nint = ::std::nearbyint(__b);
      const _Tp __c_nint = ::std::nearbyint(__c);





      const _Tp __toler = _Tp(1000) * std::numeric_limits<_Tp>::epsilon();
      if (std::abs(__x) >= _Tp(1))
        std::__throw_domain_error(("Argument outside unit circle " "in __hyperg.")
                                                     );
      else if (__isnan(__a) || __isnan(__b)
            || __isnan(__c) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__c_nint == __c && __c_nint <= _Tp(0))
        return std::numeric_limits<_Tp>::infinity();
      else if (std::abs(__c - __b) < __toler || std::abs(__c - __a) < __toler)
        return std::pow(_Tp(1) - __x, __c - __a - __b);
      else if (__a >= _Tp(0) && __b >= _Tp(0) && __c >= _Tp(0)
            && __x >= _Tp(0) && __x < _Tp(0.995L))
        return __hyperg_series(__a, __b, __c, __x);
      else if (std::abs(__a) < _Tp(10) && std::abs(__b) < _Tp(10))
        {


          if (__a < _Tp(0) && std::abs(__a - __a_nint) < __toler)
            return __hyperg_series(__a_nint, __b, __c, __x);
          else if (__b < _Tp(0) && std::abs(__b - __b_nint) < __toler)
            return __hyperg_series(__a, __b_nint, __c, __x);
          else if (__x < -_Tp(0.25L))
            return __hyperg_luke(__a, __b, __c, __x);
          else if (__x < _Tp(0.5L))
            return __hyperg_series(__a, __b, __c, __x);
          else
            if (std::abs(__c) > _Tp(10))
              return __hyperg_series(__a, __b, __c, __x);
            else
              return __hyperg_reflect(__a, __b, __c, __x);
        }
      else
        return __hyperg_luke(__a, __b, __c, __x);
    }
  }






}
# 53 "/usr/include/c++/14.2.1/bits/specfun.h" 2 3
# 1 "/usr/include/c++/14.2.1/tr1/legendre_function.tcc" 1 3
# 49 "/usr/include/c++/14.2.1/tr1/legendre_function.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 65 "/usr/include/c++/14.2.1/tr1/legendre_function.tcc" 3
  namespace __detail
  {
# 80 "/usr/include/c++/14.2.1/tr1/legendre_function.tcc" 3
    template<typename _Tp>
    _Tp
    __poly_legendre_p(unsigned int __l, _Tp __x)
    {

      if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x == +_Tp(1))
        return +_Tp(1);
      else if (__x == -_Tp(1))
        return (__l % 2 == 1 ? -_Tp(1) : +_Tp(1));
      else
        {
          _Tp __p_lm2 = _Tp(1);
          if (__l == 0)
            return __p_lm2;

          _Tp __p_lm1 = __x;
          if (__l == 1)
            return __p_lm1;

          _Tp __p_l = 0;
          for (unsigned int __ll = 2; __ll <= __l; ++__ll)
            {


              __p_l = _Tp(2) * __x * __p_lm1 - __p_lm2
                    - (__x * __p_lm1 - __p_lm2) / _Tp(__ll);
              __p_lm2 = __p_lm1;
              __p_lm1 = __p_l;
            }

          return __p_l;
        }
    }
# 136 "/usr/include/c++/14.2.1/tr1/legendre_function.tcc" 3
    template<typename _Tp>
    _Tp
    __assoc_legendre_p(unsigned int __l, unsigned int __m, _Tp __x,
         _Tp __phase = _Tp(+1))
    {

      if (__m > __l)
        return _Tp(0);
      else if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__m == 0)
        return __poly_legendre_p(__l, __x);
      else
        {
          _Tp __p_mm = _Tp(1);
          if (__m > 0)
            {


              _Tp __root = std::sqrt(_Tp(1) - __x) * std::sqrt(_Tp(1) + __x);
              _Tp __fact = _Tp(1);
              for (unsigned int __i = 1; __i <= __m; ++__i)
                {
                  __p_mm *= __phase * __fact * __root;
                  __fact += _Tp(2);
                }
            }
          if (__l == __m)
            return __p_mm;

          _Tp __p_mp1m = _Tp(2 * __m + 1) * __x * __p_mm;
          if (__l == __m + 1)
            return __p_mp1m;

          _Tp __p_lm2m = __p_mm;
          _Tp __P_lm1m = __p_mp1m;
          _Tp __p_lm = _Tp(0);
          for (unsigned int __j = __m + 2; __j <= __l; ++__j)
            {
              __p_lm = (_Tp(2 * __j - 1) * __x * __P_lm1m
                      - _Tp(__j + __m - 1) * __p_lm2m) / _Tp(__j - __m);
              __p_lm2m = __P_lm1m;
              __P_lm1m = __p_lm;
            }

          return __p_lm;
        }
    }
# 214 "/usr/include/c++/14.2.1/tr1/legendre_function.tcc" 3
    template <typename _Tp>
    _Tp
    __sph_legendre(unsigned int __l, unsigned int __m, _Tp __theta)
    {
      if (__isnan(__theta))
        return std::numeric_limits<_Tp>::quiet_NaN();

      const _Tp __x = std::cos(__theta);

      if (__m > __l)
        return _Tp(0);
      else if (__m == 0)
        {
          _Tp __P = __poly_legendre_p(__l, __x);
          _Tp __fact = std::sqrt(_Tp(2 * __l + 1)
                     / (_Tp(4) * __numeric_constants<_Tp>::__pi()));
          __P *= __fact;
          return __P;
        }
      else if (__x == _Tp(1) || __x == -_Tp(1))
        {

          return _Tp(0);
        }
      else
        {





          const _Tp __sgn = ( __m % 2 == 1 ? -_Tp(1) : _Tp(1));
          const _Tp __y_mp1m_factor = __x * std::sqrt(_Tp(2 * __m + 3));

          const _Tp __lncirc = ::std::log1p(-__x * __x);





          const _Tp __lnpoch = ::std::lgamma(_Tp(__m + _Tp(0.5L)))
                             - ::std::lgamma(_Tp(__m));




          const _Tp __lnpre_val =
                    -_Tp(0.25L) * __numeric_constants<_Tp>::__lnpi()
                    + _Tp(0.5L) * (__lnpoch + __m * __lncirc);
          const _Tp __sr = std::sqrt((_Tp(2) + _Tp(1) / __m)
                         / (_Tp(4) * __numeric_constants<_Tp>::__pi()));
          _Tp __y_mm = __sgn * __sr * std::exp(__lnpre_val);
          _Tp __y_mp1m = __y_mp1m_factor * __y_mm;

          if (__l == __m)
            return __y_mm;
          else if (__l == __m + 1)
            return __y_mp1m;
          else
            {
              _Tp __y_lm = _Tp(0);


              for (unsigned int __ll = __m + 2; __ll <= __l; ++__ll)
                {
                  const _Tp __rat1 = _Tp(__ll - __m) / _Tp(__ll + __m);
                  const _Tp __rat2 = _Tp(__ll - __m - 1) / _Tp(__ll + __m - 1);
                  const _Tp __fact1 = std::sqrt(__rat1 * _Tp(2 * __ll + 1)
                                                       * _Tp(2 * __ll - 1));
                  const _Tp __fact2 = std::sqrt(__rat1 * __rat2 * _Tp(2 * __ll + 1)
                                                                / _Tp(2 * __ll - 3));
                  __y_lm = (__x * __y_mp1m * __fact1
                         - (__ll + __m - 1) * __y_mm * __fact2) / _Tp(__ll - __m);
                  __y_mm = __y_mp1m;
                  __y_mp1m = __y_lm;
                }

              return __y_lm;
            }
        }
    }
  }






}
# 54 "/usr/include/c++/14.2.1/bits/specfun.h" 2 3
# 1 "/usr/include/c++/14.2.1/tr1/modified_bessel_func.tcc" 1 3
# 51 "/usr/include/c++/14.2.1/tr1/modified_bessel_func.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 65 "/usr/include/c++/14.2.1/tr1/modified_bessel_func.tcc" 3
  namespace __detail
  {
# 83 "/usr/include/c++/14.2.1/tr1/modified_bessel_func.tcc" 3
    template <typename _Tp>
    void
    __bessel_ik(_Tp __nu, _Tp __x,
                _Tp & __Inu, _Tp & __Knu, _Tp & __Ipnu, _Tp & __Kpnu)
    {
      if (__x == _Tp(0))
        {
          if (__nu == _Tp(0))
            {
              __Inu = _Tp(1);
              __Ipnu = _Tp(0);
            }
          else if (__nu == _Tp(1))
            {
              __Inu = _Tp(0);
              __Ipnu = _Tp(0.5L);
            }
          else
            {
              __Inu = _Tp(0);
              __Ipnu = _Tp(0);
            }
          __Knu = std::numeric_limits<_Tp>::infinity();
          __Kpnu = -std::numeric_limits<_Tp>::infinity();
          return;
        }

      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
      const _Tp __fp_min = _Tp(10) * std::numeric_limits<_Tp>::epsilon();
      const int __max_iter = 15000;
      const _Tp __x_min = _Tp(2);

      const int __nl = static_cast<int>(__nu + _Tp(0.5L));

      const _Tp __mu = __nu - __nl;
      const _Tp __mu2 = __mu * __mu;
      const _Tp __xi = _Tp(1) / __x;
      const _Tp __xi2 = _Tp(2) * __xi;
      _Tp __h = __nu * __xi;
      if ( __h < __fp_min )
        __h = __fp_min;
      _Tp __b = __xi2 * __nu;
      _Tp __d = _Tp(0);
      _Tp __c = __h;
      int __i;
      for ( __i = 1; __i <= __max_iter; ++__i )
        {
          __b += __xi2;
          __d = _Tp(1) / (__b + __d);
          __c = __b + _Tp(1) / __c;
          const _Tp __del = __c * __d;
          __h *= __del;
          if (std::abs(__del - _Tp(1)) < __eps)
            break;
        }
      if (__i > __max_iter)
        std::__throw_runtime_error(("Argument x too large " "in __bessel_ik; " "try asymptotic expansion.")

                                                                   );
      _Tp __Inul = __fp_min;
      _Tp __Ipnul = __h * __Inul;
      _Tp __Inul1 = __Inul;
      _Tp __Ipnu1 = __Ipnul;
      _Tp __fact = __nu * __xi;
      for (int __l = __nl; __l >= 1; --__l)
        {
          const _Tp __Inutemp = __fact * __Inul + __Ipnul;
          __fact -= __xi;
          __Ipnul = __fact * __Inutemp + __Inul;
          __Inul = __Inutemp;
        }
      _Tp __f = __Ipnul / __Inul;
      _Tp __Kmu, __Knu1;
      if (__x < __x_min)
        {
          const _Tp __x2 = __x / _Tp(2);
          const _Tp __pimu = __numeric_constants<_Tp>::__pi() * __mu;
          const _Tp __fact = (std::abs(__pimu) < __eps
                            ? _Tp(1) : __pimu / std::sin(__pimu));
          _Tp __d = -std::log(__x2);
          _Tp __e = __mu * __d;
          const _Tp __fact2 = (std::abs(__e) < __eps
                            ? _Tp(1) : std::sinh(__e) / __e);
          _Tp __gam1, __gam2, __gampl, __gammi;
          __gamma_temme(__mu, __gam1, __gam2, __gampl, __gammi);
          _Tp __ff = __fact
                   * (__gam1 * std::cosh(__e) + __gam2 * __fact2 * __d);
          _Tp __sum = __ff;
          __e = std::exp(__e);
          _Tp __p = __e / (_Tp(2) * __gampl);
          _Tp __q = _Tp(1) / (_Tp(2) * __e * __gammi);
          _Tp __c = _Tp(1);
          __d = __x2 * __x2;
          _Tp __sum1 = __p;
          int __i;
          for (__i = 1; __i <= __max_iter; ++__i)
            {
              __ff = (__i * __ff + __p + __q) / (__i * __i - __mu2);
              __c *= __d / __i;
              __p /= __i - __mu;
              __q /= __i + __mu;
              const _Tp __del = __c * __ff;
              __sum += __del;
              const _Tp __del1 = __c * (__p - __i * __ff);
              __sum1 += __del1;
              if (std::abs(__del) < __eps * std::abs(__sum))
                break;
            }
          if (__i > __max_iter)
            std::__throw_runtime_error(("Bessel k series failed to converge " "in __bessel_ik.")
                                                             );
          __Kmu = __sum;
          __Knu1 = __sum1 * __xi2;
        }
      else
        {
          _Tp __b = _Tp(2) * (_Tp(1) + __x);
          _Tp __d = _Tp(1) / __b;
          _Tp __delh = __d;
          _Tp __h = __delh;
          _Tp __q1 = _Tp(0);
          _Tp __q2 = _Tp(1);
          _Tp __a1 = _Tp(0.25L) - __mu2;
          _Tp __q = __c = __a1;
          _Tp __a = -__a1;
          _Tp __s = _Tp(1) + __q * __delh;
          int __i;
          for (__i = 2; __i <= __max_iter; ++__i)
            {
              __a -= 2 * (__i - 1);
              __c = -__a * __c / __i;
              const _Tp __qnew = (__q1 - __b * __q2) / __a;
              __q1 = __q2;
              __q2 = __qnew;
              __q += __c * __qnew;
              __b += _Tp(2);
              __d = _Tp(1) / (__b + __a * __d);
              __delh = (__b * __d - _Tp(1)) * __delh;
              __h += __delh;
              const _Tp __dels = __q * __delh;
              __s += __dels;
              if ( std::abs(__dels / __s) < __eps )
                break;
            }
          if (__i > __max_iter)
            std::__throw_runtime_error(("Steed's method failed " "in __bessel_ik.")
                                                             );
          __h = __a1 * __h;
          __Kmu = std::sqrt(__numeric_constants<_Tp>::__pi() / (_Tp(2) * __x))
                * std::exp(-__x) / __s;
          __Knu1 = __Kmu * (__mu + __x + _Tp(0.5L) - __h) * __xi;
        }

      _Tp __Kpmu = __mu * __xi * __Kmu - __Knu1;
      _Tp __Inumu = __xi / (__f * __Kmu - __Kpmu);
      __Inu = __Inumu * __Inul1 / __Inul;
      __Ipnu = __Inumu * __Ipnu1 / __Inul;
      for ( __i = 1; __i <= __nl; ++__i )
        {
          const _Tp __Knutemp = (__mu + __i) * __xi2 * __Knu1 + __Kmu;
          __Kmu = __Knu1;
          __Knu1 = __Knutemp;
        }
      __Knu = __Kmu;
      __Kpnu = __nu * __xi * __Kmu - __Knu1;

      return;
    }
# 267 "/usr/include/c++/14.2.1/tr1/modified_bessel_func.tcc" 3
    template<typename _Tp>
    _Tp
    __cyl_bessel_i(_Tp __nu, _Tp __x)
    {
      if (__nu < _Tp(0) || __x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __cyl_bessel_i.")
                                                           );
      else if (__isnan(__nu) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__x * __x < _Tp(10) * (__nu + _Tp(1)))
        return __cyl_bessel_ij_series(__nu, __x, +_Tp(1), 200);
      else
        {
          _Tp __I_nu, __K_nu, __Ip_nu, __Kp_nu;
          __bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
          return __I_nu;
        }
    }
# 303 "/usr/include/c++/14.2.1/tr1/modified_bessel_func.tcc" 3
    template<typename _Tp>
    _Tp
    __cyl_bessel_k(_Tp __nu, _Tp __x)
    {
      if (__nu < _Tp(0) || __x < _Tp(0))
        std::__throw_domain_error(("Bad argument " "in __cyl_bessel_k.")
                                                           );
      else if (__isnan(__nu) || __isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        {
          _Tp __I_nu, __K_nu, __Ip_nu, __Kp_nu;
          __bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
          return __K_nu;
        }
    }
# 337 "/usr/include/c++/14.2.1/tr1/modified_bessel_func.tcc" 3
    template <typename _Tp>
    void
    __sph_bessel_ik(unsigned int __n, _Tp __x,
                    _Tp & __i_n, _Tp & __k_n, _Tp & __ip_n, _Tp & __kp_n)
    {
      const _Tp __nu = _Tp(__n) + _Tp(0.5L);

      _Tp __I_nu, __Ip_nu, __K_nu, __Kp_nu;
      __bessel_ik(__nu, __x, __I_nu, __K_nu, __Ip_nu, __Kp_nu);

      const _Tp __factor = __numeric_constants<_Tp>::__sqrtpio2()
                         / std::sqrt(__x);

      __i_n = __factor * __I_nu;
      __k_n = __factor * __K_nu;
      __ip_n = __factor * __Ip_nu - __i_n / (_Tp(2) * __x);
      __kp_n = __factor * __Kp_nu - __k_n / (_Tp(2) * __x);

      return;
    }
# 373 "/usr/include/c++/14.2.1/tr1/modified_bessel_func.tcc" 3
    template <typename _Tp>
    void
    __airy(_Tp __x, _Tp & __Ai, _Tp & __Bi, _Tp & __Aip, _Tp & __Bip)
    {
      const _Tp __absx = std::abs(__x);
      const _Tp __rootx = std::sqrt(__absx);
      const _Tp __z = _Tp(2) * __absx * __rootx / _Tp(3);
      const _Tp _S_inf = std::numeric_limits<_Tp>::infinity();

      if (__isnan(__x))
        __Bip = __Aip = __Bi = __Ai = std::numeric_limits<_Tp>::quiet_NaN();
      else if (__z == _S_inf)
        {
   __Aip = __Ai = _Tp(0);
   __Bip = __Bi = _S_inf;
 }
      else if (__z == -_S_inf)
 __Bip = __Aip = __Bi = __Ai = _Tp(0);
      else if (__x > _Tp(0))
        {
          _Tp __I_nu, __Ip_nu, __K_nu, __Kp_nu;

          __bessel_ik(_Tp(1) / _Tp(3), __z, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
          __Ai = __rootx * __K_nu
               / (__numeric_constants<_Tp>::__sqrt3()
                * __numeric_constants<_Tp>::__pi());
          __Bi = __rootx * (__K_nu / __numeric_constants<_Tp>::__pi()
                 + _Tp(2) * __I_nu / __numeric_constants<_Tp>::__sqrt3());

          __bessel_ik(_Tp(2) / _Tp(3), __z, __I_nu, __K_nu, __Ip_nu, __Kp_nu);
          __Aip = -__x * __K_nu
                / (__numeric_constants<_Tp>::__sqrt3()
                 * __numeric_constants<_Tp>::__pi());
          __Bip = __x * (__K_nu / __numeric_constants<_Tp>::__pi()
                      + _Tp(2) * __I_nu
                      / __numeric_constants<_Tp>::__sqrt3());
        }
      else if (__x < _Tp(0))
        {
          _Tp __J_nu, __Jp_nu, __N_nu, __Np_nu;

          __bessel_jn(_Tp(1) / _Tp(3), __z, __J_nu, __N_nu, __Jp_nu, __Np_nu);
          __Ai = __rootx * (__J_nu
                    - __N_nu / __numeric_constants<_Tp>::__sqrt3()) / _Tp(2);
          __Bi = -__rootx * (__N_nu
                    + __J_nu / __numeric_constants<_Tp>::__sqrt3()) / _Tp(2);

          __bessel_jn(_Tp(2) / _Tp(3), __z, __J_nu, __N_nu, __Jp_nu, __Np_nu);
          __Aip = __absx * (__N_nu / __numeric_constants<_Tp>::__sqrt3()
                          + __J_nu) / _Tp(2);
          __Bip = __absx * (__J_nu / __numeric_constants<_Tp>::__sqrt3()
                          - __N_nu) / _Tp(2);
        }
      else
        {



          __Ai = _Tp(0.35502805388781723926L);
          __Bi = __Ai * __numeric_constants<_Tp>::__sqrt3();




          __Aip = -_Tp(0.25881940379280679840L);
          __Bip = -__Aip * __numeric_constants<_Tp>::__sqrt3();
        }

      return;
    }
  }





}
# 55 "/usr/include/c++/14.2.1/bits/specfun.h" 2 3
# 1 "/usr/include/c++/14.2.1/tr1/poly_hermite.tcc" 1 3
# 42 "/usr/include/c++/14.2.1/tr1/poly_hermite.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 56 "/usr/include/c++/14.2.1/tr1/poly_hermite.tcc" 3
  namespace __detail
  {
# 72 "/usr/include/c++/14.2.1/tr1/poly_hermite.tcc" 3
    template<typename _Tp>
    _Tp
    __poly_hermite_recursion(unsigned int __n, _Tp __x)
    {

      _Tp __H_0 = 1;
      if (__n == 0)
        return __H_0;


      _Tp __H_1 = 2 * __x;
      if (__n == 1)
        return __H_1;


      _Tp __H_n, __H_nm1, __H_nm2;
      unsigned int __i;
      for (__H_nm2 = __H_0, __H_nm1 = __H_1, __i = 2; __i <= __n; ++__i)
        {
          __H_n = 2 * (__x * __H_nm1 - (__i - 1) * __H_nm2);
          __H_nm2 = __H_nm1;
          __H_nm1 = __H_n;
        }

      return __H_n;
    }
# 114 "/usr/include/c++/14.2.1/tr1/poly_hermite.tcc" 3
    template<typename _Tp>
    inline _Tp
    __poly_hermite(unsigned int __n, _Tp __x)
    {
      if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else
        return __poly_hermite_recursion(__n, __x);
    }
  }





}
# 56 "/usr/include/c++/14.2.1/bits/specfun.h" 2 3
# 1 "/usr/include/c++/14.2.1/tr1/poly_laguerre.tcc" 1 3
# 44 "/usr/include/c++/14.2.1/tr1/poly_laguerre.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 60 "/usr/include/c++/14.2.1/tr1/poly_laguerre.tcc" 3
  namespace __detail
  {
# 75 "/usr/include/c++/14.2.1/tr1/poly_laguerre.tcc" 3
    template<typename _Tpa, typename _Tp>
    _Tp
    __poly_laguerre_large_n(unsigned __n, _Tpa __alpha1, _Tp __x)
    {
      const _Tp __a = -_Tp(__n);
      const _Tp __b = _Tp(__alpha1) + _Tp(1);
      const _Tp __eta = _Tp(2) * __b - _Tp(4) * __a;
      const _Tp __cos2th = __x / __eta;
      const _Tp __sin2th = _Tp(1) - __cos2th;
      const _Tp __th = std::acos(std::sqrt(__cos2th));
      const _Tp __pre_h = __numeric_constants<_Tp>::__pi_2()
                        * __numeric_constants<_Tp>::__pi_2()
                        * __eta * __eta * __cos2th * __sin2th;


      const _Tp __lg_b = ::std::lgamma(_Tp(__n) + __b);
      const _Tp __lnfact = ::std::lgamma(_Tp(__n + 1));





      _Tp __pre_term1 = _Tp(0.5L) * (_Tp(1) - __b)
                      * std::log(_Tp(0.25L) * __x * __eta);
      _Tp __pre_term2 = _Tp(0.25L) * std::log(__pre_h);
      _Tp __lnpre = __lg_b - __lnfact + _Tp(0.5L) * __x
                      + __pre_term1 - __pre_term2;
      _Tp __ser_term1 = std::sin(__a * __numeric_constants<_Tp>::__pi());
      _Tp __ser_term2 = std::sin(_Tp(0.25L) * __eta
                              * (_Tp(2) * __th
                               - std::sin(_Tp(2) * __th))
                               + __numeric_constants<_Tp>::__pi_4());
      _Tp __ser = __ser_term1 + __ser_term2;

      return std::exp(__lnpre) * __ser;
    }
# 129 "/usr/include/c++/14.2.1/tr1/poly_laguerre.tcc" 3
    template<typename _Tpa, typename _Tp>
    _Tp
    __poly_laguerre_hyperg(unsigned int __n, _Tpa __alpha1, _Tp __x)
    {
      const _Tp __b = _Tp(__alpha1) + _Tp(1);
      const _Tp __mx = -__x;
      const _Tp __tc_sgn = (__x < _Tp(0) ? _Tp(1)
                         : ((__n % 2 == 1) ? -_Tp(1) : _Tp(1)));

      _Tp __tc = _Tp(1);
      const _Tp __ax = std::abs(__x);
      for (unsigned int __k = 1; __k <= __n; ++__k)
        __tc *= (__ax / __k);

      _Tp __term = __tc * __tc_sgn;
      _Tp __sum = __term;
      for (int __k = int(__n) - 1; __k >= 0; --__k)
        {
          __term *= ((__b + _Tp(__k)) / _Tp(int(__n) - __k))
                  * _Tp(__k + 1) / __mx;
          __sum += __term;
        }

      return __sum;
    }
# 185 "/usr/include/c++/14.2.1/tr1/poly_laguerre.tcc" 3
    template<typename _Tpa, typename _Tp>
    _Tp
    __poly_laguerre_recursion(unsigned int __n, _Tpa __alpha1, _Tp __x)
    {

      _Tp __l_0 = _Tp(1);
      if (__n == 0)
        return __l_0;


      _Tp __l_1 = -__x + _Tp(1) + _Tp(__alpha1);
      if (__n == 1)
        return __l_1;


      _Tp __l_n2 = __l_0;
      _Tp __l_n1 = __l_1;
      _Tp __l_n = _Tp(0);
      for (unsigned int __nn = 2; __nn <= __n; ++__nn)
        {
            __l_n = (_Tp(2 * __nn - 1) + _Tp(__alpha1) - __x)
                  * __l_n1 / _Tp(__nn)
                  - (_Tp(__nn - 1) + _Tp(__alpha1)) * __l_n2 / _Tp(__nn);
            __l_n2 = __l_n1;
            __l_n1 = __l_n;
        }

      return __l_n;
    }
# 244 "/usr/include/c++/14.2.1/tr1/poly_laguerre.tcc" 3
    template<typename _Tpa, typename _Tp>
    _Tp
    __poly_laguerre(unsigned int __n, _Tpa __alpha1, _Tp __x)
    {
      if (__x < _Tp(0))
        std::__throw_domain_error(("Negative argument " "in __poly_laguerre.")
                                                            );

      else if (__isnan(__x))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__n == 0)
        return _Tp(1);
      else if (__n == 1)
        return _Tp(1) + _Tp(__alpha1) - __x;
      else if (__x == _Tp(0))
        {
          _Tp __prod = _Tp(__alpha1) + _Tp(1);
          for (unsigned int __k = 2; __k <= __n; ++__k)
            __prod *= (_Tp(__alpha1) + _Tp(__k)) / _Tp(__k);
          return __prod;
        }
      else if (__n > 10000000 && _Tp(__alpha1) > -_Tp(1)
            && __x < _Tp(2) * (_Tp(__alpha1) + _Tp(1)) + _Tp(4 * __n))
        return __poly_laguerre_large_n(__n, __alpha1, __x);
      else if (_Tp(__alpha1) >= _Tp(0)
           || (__x > _Tp(0) && _Tp(__alpha1) < -_Tp(__n + 1)))
        return __poly_laguerre_recursion(__n, __alpha1, __x);
      else
        return __poly_laguerre_hyperg(__n, __alpha1, __x);
    }
# 296 "/usr/include/c++/14.2.1/tr1/poly_laguerre.tcc" 3
    template<typename _Tp>
    inline _Tp
    __assoc_laguerre(unsigned int __n, unsigned int __m, _Tp __x)
    { return __poly_laguerre<unsigned int, _Tp>(__n, __m, __x); }
# 316 "/usr/include/c++/14.2.1/tr1/poly_laguerre.tcc" 3
    template<typename _Tp>
    inline _Tp
    __laguerre(unsigned int __n, _Tp __x)
    { return __poly_laguerre<unsigned int, _Tp>(__n, 0, __x); }
  }






}
# 57 "/usr/include/c++/14.2.1/bits/specfun.h" 2 3
# 1 "/usr/include/c++/14.2.1/tr1/riemann_zeta.tcc" 1 3
# 47 "/usr/include/c++/14.2.1/tr1/riemann_zeta.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 63 "/usr/include/c++/14.2.1/tr1/riemann_zeta.tcc" 3
  namespace __detail
  {
# 78 "/usr/include/c++/14.2.1/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    _Tp
    __riemann_zeta_sum(_Tp __s)
    {

      if (__s < _Tp(1))
        std::__throw_domain_error(("Bad argument in zeta sum."));

      const unsigned int max_iter = 10000;
      _Tp __zeta = _Tp(0);
      for (unsigned int __k = 1; __k < max_iter; ++__k)
        {
          _Tp __term = std::pow(static_cast<_Tp>(__k), -__s);
          if (__term < std::numeric_limits<_Tp>::epsilon())
            {
              break;
            }
          __zeta += __term;
        }

      return __zeta;
    }
# 115 "/usr/include/c++/14.2.1/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    _Tp
    __riemann_zeta_alt(_Tp __s)
    {
      _Tp __sgn = _Tp(1);
      _Tp __zeta = _Tp(0);
      for (unsigned int __i = 1; __i < 10000000; ++__i)
        {
          _Tp __term = __sgn / std::pow(__i, __s);
          if (std::abs(__term) < std::numeric_limits<_Tp>::epsilon())
            break;
          __zeta += __term;
          __sgn *= _Tp(-1);
        }
      __zeta /= _Tp(1) - std::pow(_Tp(2), _Tp(1) - __s);

      return __zeta;
    }
# 157 "/usr/include/c++/14.2.1/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    _Tp
    __riemann_zeta_glob(_Tp __s)
    {
      _Tp __zeta = _Tp(0);

      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();

      const _Tp __max_bincoeff = std::numeric_limits<_Tp>::max_exponent10
                               * std::log(_Tp(10)) - _Tp(1);



      if (__s < _Tp(0))
        {

          if (::std::fmod(__s,_Tp(2)) == _Tp(0))
            return _Tp(0);
          else

            {
              _Tp __zeta = __riemann_zeta_glob(_Tp(1) - __s);
              __zeta *= std::pow(_Tp(2)
                     * __numeric_constants<_Tp>::__pi(), __s)
                     * std::sin(__numeric_constants<_Tp>::__pi_2() * __s)

                     * std::exp(::std::lgamma(_Tp(1) - __s))



                     / __numeric_constants<_Tp>::__pi();
              return __zeta;
            }
        }

      _Tp __num = _Tp(0.5L);
      const unsigned int __maxit = 10000;
      for (unsigned int __i = 0; __i < __maxit; ++__i)
        {
          bool __punt = false;
          _Tp __sgn = _Tp(1);
          _Tp __term = _Tp(0);
          for (unsigned int __j = 0; __j <= __i; ++__j)
            {

              _Tp __bincoeff = ::std::lgamma(_Tp(1 + __i))
                              - ::std::lgamma(_Tp(1 + __j))
                              - ::std::lgamma(_Tp(1 + __i - __j));





              if (__bincoeff > __max_bincoeff)
                {

                  __punt = true;
                  break;
                }
              __bincoeff = std::exp(__bincoeff);
              __term += __sgn * __bincoeff * std::pow(_Tp(1 + __j), -__s);
              __sgn *= _Tp(-1);
            }
          if (__punt)
            break;
          __term *= __num;
          __zeta += __term;
          if (std::abs(__term/__zeta) < __eps)
            break;
          __num *= _Tp(0.5L);
        }

      __zeta /= _Tp(1) - std::pow(_Tp(2), _Tp(1) - __s);

      return __zeta;
    }
# 252 "/usr/include/c++/14.2.1/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    _Tp
    __riemann_zeta_product(_Tp __s)
    {
      static const _Tp __prime[] = {
        _Tp(2), _Tp(3), _Tp(5), _Tp(7), _Tp(11), _Tp(13), _Tp(17), _Tp(19),
        _Tp(23), _Tp(29), _Tp(31), _Tp(37), _Tp(41), _Tp(43), _Tp(47),
        _Tp(53), _Tp(59), _Tp(61), _Tp(67), _Tp(71), _Tp(73), _Tp(79),
        _Tp(83), _Tp(89), _Tp(97), _Tp(101), _Tp(103), _Tp(107), _Tp(109)
      };
      static const unsigned int __num_primes = sizeof(__prime) / sizeof(_Tp);

      _Tp __zeta = _Tp(1);
      for (unsigned int __i = 0; __i < __num_primes; ++__i)
        {
          const _Tp __fact = _Tp(1) - std::pow(__prime[__i], -__s);
          __zeta *= __fact;
          if (_Tp(1) - __fact < std::numeric_limits<_Tp>::epsilon())
            break;
        }

      __zeta = _Tp(1) / __zeta;

      return __zeta;
    }
# 293 "/usr/include/c++/14.2.1/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    _Tp
    __riemann_zeta(_Tp __s)
    {
      if (__isnan(__s))
        return std::numeric_limits<_Tp>::quiet_NaN();
      else if (__s == _Tp(1))
        return std::numeric_limits<_Tp>::infinity();
      else if (__s < -_Tp(19))
        {
          _Tp __zeta = __riemann_zeta_product(_Tp(1) - __s);
          __zeta *= std::pow(_Tp(2) * __numeric_constants<_Tp>::__pi(), __s)
                 * std::sin(__numeric_constants<_Tp>::__pi_2() * __s)

                 * std::exp(::std::lgamma(_Tp(1) - __s))



                 / __numeric_constants<_Tp>::__pi();
          return __zeta;
        }
      else if (__s < _Tp(20))
        {

          bool __glob = true;
          if (__glob)
            return __riemann_zeta_glob(__s);
          else
            {
              if (__s > _Tp(1))
                return __riemann_zeta_sum(__s);
              else
                {
                  _Tp __zeta = std::pow(_Tp(2)
                                * __numeric_constants<_Tp>::__pi(), __s)
                         * std::sin(__numeric_constants<_Tp>::__pi_2() * __s)

                             * ::std::tgamma(_Tp(1) - __s)



                             * __riemann_zeta_sum(_Tp(1) - __s);
                  return __zeta;
                }
            }
        }
      else
        return __riemann_zeta_product(__s);
    }
# 365 "/usr/include/c++/14.2.1/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    _Tp
    __hurwitz_zeta_glob(_Tp __a, _Tp __s)
    {
      _Tp __zeta = _Tp(0);

      const _Tp __eps = std::numeric_limits<_Tp>::epsilon();

      const _Tp __max_bincoeff = std::numeric_limits<_Tp>::max_exponent10
                               * std::log(_Tp(10)) - _Tp(1);

      const unsigned int __maxit = 10000;
      for (unsigned int __i = 0; __i < __maxit; ++__i)
        {
          bool __punt = false;
          _Tp __sgn = _Tp(1);
          _Tp __term = _Tp(0);
          for (unsigned int __j = 0; __j <= __i; ++__j)
            {

              _Tp __bincoeff = ::std::lgamma(_Tp(1 + __i))
                              - ::std::lgamma(_Tp(1 + __j))
                              - ::std::lgamma(_Tp(1 + __i - __j));





              if (__bincoeff > __max_bincoeff)
                {

                  __punt = true;
                  break;
                }
              __bincoeff = std::exp(__bincoeff);
              __term += __sgn * __bincoeff * std::pow(_Tp(__a + __j), -__s);
              __sgn *= _Tp(-1);
            }
          if (__punt)
            break;
          __term /= _Tp(__i + 1);
          if (std::abs(__term / __zeta) < __eps)
            break;
          __zeta += __term;
        }

      __zeta /= __s - _Tp(1);

      return __zeta;
    }
# 430 "/usr/include/c++/14.2.1/tr1/riemann_zeta.tcc" 3
    template<typename _Tp>
    inline _Tp
    __hurwitz_zeta(_Tp __a, _Tp __s)
    { return __hurwitz_zeta_glob(__a, __s); }
  }






}
# 58 "/usr/include/c++/14.2.1/bits/specfun.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 203 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline float
  assoc_laguerref(unsigned int __n, unsigned int __m, float __x)
  { return __detail::__assoc_laguerre<float>(__n, __m, __x); }







  inline long double
  assoc_laguerrel(unsigned int __n, unsigned int __m, long double __x)
  { return __detail::__assoc_laguerre<long double>(__n, __m, __x); }
# 248 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    assoc_laguerre(unsigned int __n, unsigned int __m, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__assoc_laguerre<__type>(__n, __m, __x);
    }
# 264 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline float
  assoc_legendref(unsigned int __l, unsigned int __m, float __x)
  { return __detail::__assoc_legendre_p<float>(__l, __m, __x); }






  inline long double
  assoc_legendrel(unsigned int __l, unsigned int __m, long double __x)
  { return __detail::__assoc_legendre_p<long double>(__l, __m, __x); }
# 294 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    assoc_legendre(unsigned int __l, unsigned int __m, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__assoc_legendre_p<__type>(__l, __m, __x);
    }
# 309 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline float
  betaf(float __a, float __b)
  { return __detail::__beta<float>(__a, __b); }







  inline long double
  betal(long double __a, long double __b)
  { return __detail::__beta<long double>(__a, __b); }
# 339 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  template<typename _Tpa, typename _Tpb>
    inline typename __gnu_cxx::__promote_2<_Tpa, _Tpb>::__type
    beta(_Tpa __a, _Tpb __b)
    {
      typedef typename __gnu_cxx::__promote_2<_Tpa, _Tpb>::__type __type;
      return __detail::__beta<__type>(__a, __b);
    }
# 355 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline float
  comp_ellint_1f(float __k)
  { return __detail::__comp_ellint_1<float>(__k); }







  inline long double
  comp_ellint_1l(long double __k)
  { return __detail::__comp_ellint_1<long double>(__k); }
# 387 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    comp_ellint_1(_Tp __k)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__comp_ellint_1<__type>(__k);
    }
# 403 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline float
  comp_ellint_2f(float __k)
  { return __detail::__comp_ellint_2<float>(__k); }







  inline long double
  comp_ellint_2l(long double __k)
  { return __detail::__comp_ellint_2<long double>(__k); }
# 434 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    comp_ellint_2(_Tp __k)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__comp_ellint_2<__type>(__k);
    }
# 450 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline float
  comp_ellint_3f(float __k, float __nu)
  { return __detail::__comp_ellint_3<float>(__k, __nu); }







  inline long double
  comp_ellint_3l(long double __k, long double __nu)
  { return __detail::__comp_ellint_3<long double>(__k, __nu); }
# 485 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  template<typename _Tp, typename _Tpn>
    inline typename __gnu_cxx::__promote_2<_Tp, _Tpn>::__type
    comp_ellint_3(_Tp __k, _Tpn __nu)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Tpn>::__type __type;
      return __detail::__comp_ellint_3<__type>(__k, __nu);
    }
# 501 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline float
  cyl_bessel_if(float __nu, float __x)
  { return __detail::__cyl_bessel_i<float>(__nu, __x); }







  inline long double
  cyl_bessel_il(long double __nu, long double __x)
  { return __detail::__cyl_bessel_i<long double>(__nu, __x); }
# 531 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  template<typename _Tpnu, typename _Tp>
    inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type
    cyl_bessel_i(_Tpnu __nu, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
      return __detail::__cyl_bessel_i<__type>(__nu, __x);
    }
# 547 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline float
  cyl_bessel_jf(float __nu, float __x)
  { return __detail::__cyl_bessel_j<float>(__nu, __x); }







  inline long double
  cyl_bessel_jl(long double __nu, long double __x)
  { return __detail::__cyl_bessel_j<long double>(__nu, __x); }
# 577 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  template<typename _Tpnu, typename _Tp>
    inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type
    cyl_bessel_j(_Tpnu __nu, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
      return __detail::__cyl_bessel_j<__type>(__nu, __x);
    }
# 593 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline float
  cyl_bessel_kf(float __nu, float __x)
  { return __detail::__cyl_bessel_k<float>(__nu, __x); }







  inline long double
  cyl_bessel_kl(long double __nu, long double __x)
  { return __detail::__cyl_bessel_k<long double>(__nu, __x); }
# 629 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  template<typename _Tpnu, typename _Tp>
    inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type
    cyl_bessel_k(_Tpnu __nu, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
      return __detail::__cyl_bessel_k<__type>(__nu, __x);
    }
# 645 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline float
  cyl_neumannf(float __nu, float __x)
  { return __detail::__cyl_neumann_n<float>(__nu, __x); }







  inline long double
  cyl_neumannl(long double __nu, long double __x)
  { return __detail::__cyl_neumann_n<long double>(__nu, __x); }
# 677 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  template<typename _Tpnu, typename _Tp>
    inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type
    cyl_neumann(_Tpnu __nu, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
      return __detail::__cyl_neumann_n<__type>(__nu, __x);
    }
# 693 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline float
  ellint_1f(float __k, float __phi)
  { return __detail::__ellint_1<float>(__k, __phi); }







  inline long double
  ellint_1l(long double __k, long double __phi)
  { return __detail::__ellint_1<long double>(__k, __phi); }
# 725 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  template<typename _Tp, typename _Tpp>
    inline typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type
    ellint_1(_Tp __k, _Tpp __phi)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type __type;
      return __detail::__ellint_1<__type>(__k, __phi);
    }
# 741 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline float
  ellint_2f(float __k, float __phi)
  { return __detail::__ellint_2<float>(__k, __phi); }







  inline long double
  ellint_2l(long double __k, long double __phi)
  { return __detail::__ellint_2<long double>(__k, __phi); }
# 773 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  template<typename _Tp, typename _Tpp>
    inline typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type
    ellint_2(_Tp __k, _Tpp __phi)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type __type;
      return __detail::__ellint_2<__type>(__k, __phi);
    }
# 789 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline float
  ellint_3f(float __k, float __nu, float __phi)
  { return __detail::__ellint_3<float>(__k, __nu, __phi); }







  inline long double
  ellint_3l(long double __k, long double __nu, long double __phi)
  { return __detail::__ellint_3<long double>(__k, __nu, __phi); }
# 826 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  template<typename _Tp, typename _Tpn, typename _Tpp>
    inline typename __gnu_cxx::__promote_3<_Tp, _Tpn, _Tpp>::__type
    ellint_3(_Tp __k, _Tpn __nu, _Tpp __phi)
    {
      typedef typename __gnu_cxx::__promote_3<_Tp, _Tpn, _Tpp>::__type __type;
      return __detail::__ellint_3<__type>(__k, __nu, __phi);
    }
# 841 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline float
  expintf(float __x)
  { return __detail::__expint<float>(__x); }







  inline long double
  expintl(long double __x)
  { return __detail::__expint<long double>(__x); }
# 866 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    expint(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__expint<__type>(__x);
    }
# 882 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline float
  hermitef(unsigned int __n, float __x)
  { return __detail::__poly_hermite<float>(__n, __x); }







  inline long double
  hermitel(unsigned int __n, long double __x)
  { return __detail::__poly_hermite<long double>(__n, __x); }
# 914 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    hermite(unsigned int __n, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__poly_hermite<__type>(__n, __x);
    }
# 930 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline float
  laguerref(unsigned int __n, float __x)
  { return __detail::__laguerre<float>(__n, __x); }







  inline long double
  laguerrel(unsigned int __n, long double __x)
  { return __detail::__laguerre<long double>(__n, __x); }
# 958 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    laguerre(unsigned int __n, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__laguerre<__type>(__n, __x);
    }
# 974 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline float
  legendref(unsigned int __l, float __x)
  { return __detail::__poly_legendre_p<float>(__l, __x); }







  inline long double
  legendrel(unsigned int __l, long double __x)
  { return __detail::__poly_legendre_p<long double>(__l, __x); }
# 1003 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    legendre(unsigned int __l, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__poly_legendre_p<__type>(__l, __x);
    }
# 1019 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline float
  riemann_zetaf(float __s)
  { return __detail::__riemann_zeta<float>(__s); }







  inline long double
  riemann_zetal(long double __s)
  { return __detail::__riemann_zeta<long double>(__s); }
# 1054 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    riemann_zeta(_Tp __s)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__riemann_zeta<__type>(__s);
    }
# 1070 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline float
  sph_besself(unsigned int __n, float __x)
  { return __detail::__sph_bessel<float>(__n, __x); }







  inline long double
  sph_bessell(unsigned int __n, long double __x)
  { return __detail::__sph_bessel<long double>(__n, __x); }
# 1098 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    sph_bessel(unsigned int __n, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__sph_bessel<__type>(__n, __x);
    }
# 1114 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline float
  sph_legendref(unsigned int __l, unsigned int __m, float __theta)
  { return __detail::__sph_legendre<float>(__l, __m, __theta); }
# 1125 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline long double
  sph_legendrel(unsigned int __l, unsigned int __m, long double __theta)
  { return __detail::__sph_legendre<long double>(__l, __m, __theta); }
# 1145 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    sph_legendre(unsigned int __l, unsigned int __m, _Tp __theta)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__sph_legendre<__type>(__l, __m, __theta);
    }
# 1161 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline float
  sph_neumannf(unsigned int __n, float __x)
  { return __detail::__sph_neumann<float>(__n, __x); }







  inline long double
  sph_neumannl(unsigned int __n, long double __x)
  { return __detail::__sph_neumann<long double>(__n, __x); }
# 1189 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    sph_neumann(unsigned int __n, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__sph_neumann<__type>(__n, __x);
    }




}


namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 1216 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline float
  airy_aif(float __x)
  {
    float __Ai, __Bi, __Aip, __Bip;
    std::__detail::__airy<float>(__x, __Ai, __Bi, __Aip, __Bip);
    return __Ai;
  }




  inline long double
  airy_ail(long double __x)
  {
    long double __Ai, __Bi, __Aip, __Bip;
    std::__detail::__airy<long double>(__x, __Ai, __Bi, __Aip, __Bip);
    return __Ai;
  }




  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    airy_ai(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      __type __Ai, __Bi, __Aip, __Bip;
      std::__detail::__airy<__type>(__x, __Ai, __Bi, __Aip, __Bip);
      return __Ai;
    }




  inline float
  airy_bif(float __x)
  {
    float __Ai, __Bi, __Aip, __Bip;
    std::__detail::__airy<float>(__x, __Ai, __Bi, __Aip, __Bip);
    return __Bi;
  }




  inline long double
  airy_bil(long double __x)
  {
    long double __Ai, __Bi, __Aip, __Bip;
    std::__detail::__airy<long double>(__x, __Ai, __Bi, __Aip, __Bip);
    return __Bi;
  }




  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    airy_bi(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      __type __Ai, __Bi, __Aip, __Bip;
      std::__detail::__airy<__type>(__x, __Ai, __Bi, __Aip, __Bip);
      return __Bi;
    }
# 1292 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline float
  conf_hypergf(float __a, float __c, float __x)
  { return std::__detail::__conf_hyperg<float>(__a, __c, __x); }
# 1303 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline long double
  conf_hypergl(long double __a, long double __c, long double __x)
  { return std::__detail::__conf_hyperg<long double>(__a, __c, __x); }
# 1323 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  template<typename _Tpa, typename _Tpc, typename _Tp>
    inline typename __gnu_cxx::__promote_3<_Tpa, _Tpc, _Tp>::__type
    conf_hyperg(_Tpa __a, _Tpc __c, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_3<_Tpa, _Tpc, _Tp>::__type __type;
      return std::__detail::__conf_hyperg<__type>(__a, __c, __x);
    }
# 1340 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline float
  hypergf(float __a, float __b, float __c, float __x)
  { return std::__detail::__hyperg<float>(__a, __b, __c, __x); }
# 1351 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  inline long double
  hypergl(long double __a, long double __b, long double __c, long double __x)
  { return std::__detail::__hyperg<long double>(__a, __b, __c, __x); }
# 1372 "/usr/include/c++/14.2.1/bits/specfun.h" 3
  template<typename _Tpa, typename _Tpb, typename _Tpc, typename _Tp>
    inline typename __gnu_cxx::__promote_4<_Tpa, _Tpb, _Tpc, _Tp>::__type
    hyperg(_Tpa __a, _Tpb __b, _Tpc __c, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_4<_Tpa, _Tpb, _Tpc, _Tp>
  ::__type __type;
      return std::__detail::__hyperg<__type>(__a, __b, __c, __x);
    }



}
# 3899 "/usr/include/c++/14.2.1/cmath" 2 3


}
# 2 "/usr/include/glm/detail/_fixes.hpp" 2 3 4
# 105 "/usr/include/glm/glm.hpp" 2 3 4

# 1 "/usr/include/glm/detail/setup.hpp" 1 3 4


# 1 "/usr/include/c++/14.2.1/cassert" 1 3 4
# 41 "/usr/include/c++/14.2.1/cassert" 3 4
       
# 42 "/usr/include/c++/14.2.1/cassert" 3


# 1 "/usr/include/assert.h" 1 3 4
# 64 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     noexcept (true) __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     noexcept (true) __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     noexcept (true) __attribute__ ((__noreturn__));


}
# 45 "/usr/include/c++/14.2.1/cassert" 2 3
# 4 "/usr/include/glm/detail/setup.hpp" 2 3 4
# 43 "/usr/include/glm/detail/setup.hpp" 3 4
# 1 "/usr/include/glm/simd/platform.h" 1 3 4
       
# 44 "/usr/include/glm/detail/setup.hpp" 2 3 4
# 632 "/usr/include/glm/detail/setup.hpp" 3 4
namespace glm
{
 using std::size_t;



  typedef int length_t;

}







 namespace glm
 {
  template<typename T, std::size_t N>
  constexpr std::size_t countof(T const (&)[N])
  {
   return N;
  }
 }
# 670 "/usr/include/glm/detail/setup.hpp" 3 4
namespace glm{
namespace detail
{
 template<typename T>
 struct is_int
 {
  enum test {value = 0};
 };

 template<>
 struct is_int<unsigned int>
 {
  enum test {value = ~0};
 };

 template<>
 struct is_int<signed int>
 {
  enum test {value = ~0};
 };
}

 typedef unsigned int uint;
}
# 702 "/usr/include/glm/detail/setup.hpp" 3 4
namespace glm{
namespace detail
{

  typedef std::uint64_t uint64;
  typedef std::int64_t int64;
# 726 "/usr/include/glm/detail/setup.hpp" 3 4
}
}







namespace glm{
namespace detail
{
 using std::make_unsigned;
}
}
# 107 "/usr/include/glm/glm.hpp" 2 3 4

       

# 1 "/usr/include/c++/14.2.1/cmath" 1 3 4
# 39 "/usr/include/c++/14.2.1/cmath" 3 4
       
# 40 "/usr/include/c++/14.2.1/cmath" 3
# 111 "/usr/include/glm/glm.hpp" 2 3 4
# 1 "/usr/include/c++/14.2.1/climits" 1 3 4
# 39 "/usr/include/c++/14.2.1/climits" 3 4
       
# 40 "/usr/include/c++/14.2.1/climits" 3


# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/limits.h" 1 3 4
# 34 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/limits.h" 3 4
# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/syslimits.h" 1 3 4






# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/limits.h" 1 3 4
# 210 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 26 "/usr/include/limits.h" 3 4
# 1 "/usr/include/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/limits.h" 2 3 4
# 195 "/usr/include/limits.h" 3 4
# 1 "/usr/include/bits/posix1_lim.h" 1 3 4
# 27 "/usr/include/bits/posix1_lim.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 28 "/usr/include/bits/posix1_lim.h" 2 3 4
# 161 "/usr/include/bits/posix1_lim.h" 3 4
# 1 "/usr/include/bits/local_lim.h" 1 3 4
# 38 "/usr/include/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 39 "/usr/include/bits/local_lim.h" 2 3 4
# 81 "/usr/include/bits/local_lim.h" 3 4
# 1 "/usr/include/bits/pthread_stack_min-dynamic.h" 1 3 4
# 23 "/usr/include/bits/pthread_stack_min-dynamic.h" 3 4
extern "C" {
extern long int __sysconf (int __name) noexcept (true);
}
# 82 "/usr/include/bits/local_lim.h" 2 3 4
# 162 "/usr/include/bits/posix1_lim.h" 2 3 4
# 196 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/bits/posix2_lim.h" 1 3 4
# 200 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/bits/xopen_lim.h" 1 3 4
# 64 "/usr/include/bits/xopen_lim.h" 3 4
# 1 "/usr/include/bits/uio_lim.h" 1 3 4
# 65 "/usr/include/bits/xopen_lim.h" 2 3 4
# 204 "/usr/include/limits.h" 2 3 4
# 211 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/limits.h" 2 3 4
# 8 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/syslimits.h" 2 3 4
# 35 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/limits.h" 2 3 4
# 43 "/usr/include/c++/14.2.1/climits" 2 3
# 112 "/usr/include/glm/glm.hpp" 2 3 4
# 1 "/usr/include/c++/14.2.1/cfloat" 1 3 4
# 39 "/usr/include/c++/14.2.1/cfloat" 3 4
       
# 40 "/usr/include/c++/14.2.1/cfloat" 3


# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/float.h" 1 3 4
# 43 "/usr/include/c++/14.2.1/cfloat" 2 3
# 113 "/usr/include/glm/glm.hpp" 2 3 4

# 1 "/usr/include/c++/14.2.1/cassert" 1 3 4
# 41 "/usr/include/c++/14.2.1/cassert" 3 4
       
# 42 "/usr/include/c++/14.2.1/cassert" 3


# 1 "/usr/include/assert.h" 1 3 4
# 64 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     noexcept (true) __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     noexcept (true) __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     noexcept (true) __attribute__ ((__noreturn__));


}
# 45 "/usr/include/c++/14.2.1/cassert" 2 3
# 115 "/usr/include/glm/glm.hpp" 2 3 4
# 1 "/usr/include/glm/fwd.hpp" 1 3 4
       

# 1 "/usr/include/glm/detail/qualifier.hpp" 1 3 4
       

# 1 "/usr/include/glm/detail/setup.hpp" 1 3 4
# 4 "/usr/include/glm/detail/qualifier.hpp" 2 3 4

namespace glm
{

 enum qualifier
 {
  packed_highp,
  packed_mediump,
  packed_lowp,
# 21 "/usr/include/glm/detail/qualifier.hpp" 3 4
  highp = packed_highp,
  mediump = packed_mediump,
  lowp = packed_lowp,
  packed = packed_highp,




   defaultp = highp

 };

 typedef qualifier precision;

 template<length_t L, typename T, qualifier Q = defaultp> struct vec;
 template<length_t C, length_t R, typename T, qualifier Q = defaultp> struct mat;
 template<typename T, qualifier Q = defaultp> struct qua;


  template <typename T, qualifier Q = defaultp> using tvec1 = vec<1, T, Q>;
  template <typename T, qualifier Q = defaultp> using tvec2 = vec<2, T, Q>;
  template <typename T, qualifier Q = defaultp> using tvec3 = vec<3, T, Q>;
  template <typename T, qualifier Q = defaultp> using tvec4 = vec<4, T, Q>;
  template <typename T, qualifier Q = defaultp> using tmat2x2 = mat<2, 2, T, Q>;
  template <typename T, qualifier Q = defaultp> using tmat2x3 = mat<2, 3, T, Q>;
  template <typename T, qualifier Q = defaultp> using tmat2x4 = mat<2, 4, T, Q>;
  template <typename T, qualifier Q = defaultp> using tmat3x2 = mat<3, 2, T, Q>;
  template <typename T, qualifier Q = defaultp> using tmat3x3 = mat<3, 3, T, Q>;
  template <typename T, qualifier Q = defaultp> using tmat3x4 = mat<3, 4, T, Q>;
  template <typename T, qualifier Q = defaultp> using tmat4x2 = mat<4, 2, T, Q>;
  template <typename T, qualifier Q = defaultp> using tmat4x3 = mat<4, 3, T, Q>;
  template <typename T, qualifier Q = defaultp> using tmat4x4 = mat<4, 4, T, Q>;
  template <typename T, qualifier Q = defaultp> using tquat = qua<T, Q>;


namespace detail
{
 template<glm::qualifier P>
 struct is_aligned
 {
  static const bool value = false;
 };
# 84 "/usr/include/glm/detail/qualifier.hpp" 3 4
 template<length_t L, typename T, bool is_aligned>
 struct storage
 {
  typedef struct type {
   T data[L];
  } type;
 };


  template<length_t L, typename T>
  struct storage<L, T, true>
  {
   typedef struct alignas(L * sizeof(T)) type {
    T data[L];
   } type;
  };

  template<typename T>
  struct storage<3, T, true>
  {
   typedef struct alignas(4 * sizeof(T)) type {
    T data[4];
   } type;
  };
# 189 "/usr/include/glm/detail/qualifier.hpp" 3 4
 enum genTypeEnum
 {
  GENTYPE_VEC,
  GENTYPE_MAT,
  GENTYPE_QUAT
 };

 template <typename genType>
 struct genTypeTrait
 {};

 template <length_t C, length_t R, typename T>
 struct genTypeTrait<mat<C, R, T> >
 {
  static const genTypeEnum GENTYPE = GENTYPE_MAT;
 };

 template<typename genType, genTypeEnum type>
 struct init_gentype
 {
 };

 template<typename genType>
 struct init_gentype<genType, GENTYPE_QUAT>
 {
  inline constexpr static genType identity()
  {
   return genType(1, 0, 0, 0);
  }
 };

 template<typename genType>
 struct init_gentype<genType, GENTYPE_MAT>
 {
  inline constexpr static genType identity()
  {
   return genType(1);
  }
 };
}
}
# 4 "/usr/include/glm/fwd.hpp" 2 3 4

namespace glm
{

 typedef std::int8_t int8;
 typedef std::int16_t int16;
 typedef std::int32_t int32;
 typedef std::int64_t int64;

 typedef std::uint8_t uint8;
 typedef std::uint16_t uint16;
 typedef std::uint32_t uint32;
 typedef std::uint64_t uint64;
# 31 "/usr/include/glm/fwd.hpp" 3 4
 typedef int8 lowp_i8;
 typedef int8 mediump_i8;
 typedef int8 highp_i8;
 typedef int8 i8;

 typedef int8 lowp_int8;
 typedef int8 mediump_int8;
 typedef int8 highp_int8;

 typedef int8 lowp_int8_t;
 typedef int8 mediump_int8_t;
 typedef int8 highp_int8_t;
 typedef int8 int8_t;

 typedef int16 lowp_i16;
 typedef int16 mediump_i16;
 typedef int16 highp_i16;
 typedef int16 i16;

 typedef int16 lowp_int16;
 typedef int16 mediump_int16;
 typedef int16 highp_int16;

 typedef int16 lowp_int16_t;
 typedef int16 mediump_int16_t;
 typedef int16 highp_int16_t;
 typedef int16 int16_t;

 typedef int32 lowp_i32;
 typedef int32 mediump_i32;
 typedef int32 highp_i32;
 typedef int32 i32;

 typedef int32 lowp_int32;
 typedef int32 mediump_int32;
 typedef int32 highp_int32;

 typedef int32 lowp_int32_t;
 typedef int32 mediump_int32_t;
 typedef int32 highp_int32_t;
 typedef int32 int32_t;

 typedef int64 lowp_i64;
 typedef int64 mediump_i64;
 typedef int64 highp_i64;
 typedef int64 i64;

 typedef int64 lowp_int64;
 typedef int64 mediump_int64;
 typedef int64 highp_int64;

 typedef int64 lowp_int64_t;
 typedef int64 mediump_int64_t;
 typedef int64 highp_int64_t;
 typedef int64 int64_t;



 typedef unsigned int uint;

 typedef uint8 lowp_u8;
 typedef uint8 mediump_u8;
 typedef uint8 highp_u8;
 typedef uint8 u8;

 typedef uint8 lowp_uint8;
 typedef uint8 mediump_uint8;
 typedef uint8 highp_uint8;

 typedef uint8 lowp_uint8_t;
 typedef uint8 mediump_uint8_t;
 typedef uint8 highp_uint8_t;
 typedef uint8 uint8_t;

 typedef uint16 lowp_u16;
 typedef uint16 mediump_u16;
 typedef uint16 highp_u16;
 typedef uint16 u16;

 typedef uint16 lowp_uint16;
 typedef uint16 mediump_uint16;
 typedef uint16 highp_uint16;

 typedef uint16 lowp_uint16_t;
 typedef uint16 mediump_uint16_t;
 typedef uint16 highp_uint16_t;
 typedef uint16 uint16_t;

 typedef uint32 lowp_u32;
 typedef uint32 mediump_u32;
 typedef uint32 highp_u32;
 typedef uint32 u32;

 typedef uint32 lowp_uint32;
 typedef uint32 mediump_uint32;
 typedef uint32 highp_uint32;

 typedef uint32 lowp_uint32_t;
 typedef uint32 mediump_uint32_t;
 typedef uint32 highp_uint32_t;
 typedef uint32 uint32_t;

 typedef uint64 lowp_u64;
 typedef uint64 mediump_u64;
 typedef uint64 highp_u64;
 typedef uint64 u64;

 typedef uint64 lowp_uint64;
 typedef uint64 mediump_uint64;
 typedef uint64 highp_uint64;

 typedef uint64 lowp_uint64_t;
 typedef uint64 mediump_uint64_t;
 typedef uint64 highp_uint64_t;
 typedef uint64 uint64_t;



 typedef float lowp_f32;
 typedef float mediump_f32;
 typedef float highp_f32;
 typedef float f32;

 typedef float lowp_float32;
 typedef float mediump_float32;
 typedef float highp_float32;
 typedef float float32;

 typedef float lowp_float32_t;
 typedef float mediump_float32_t;
 typedef float highp_float32_t;
 typedef float float32_t;


 typedef double lowp_f64;
 typedef double mediump_f64;
 typedef double highp_f64;
 typedef double f64;

 typedef double lowp_float64;
 typedef double mediump_float64;
 typedef double highp_float64;
 typedef double float64;

 typedef double lowp_float64_t;
 typedef double mediump_float64_t;
 typedef double highp_float64_t;
 typedef double float64_t;



 typedef vec<1, bool, lowp> lowp_bvec1;
 typedef vec<2, bool, lowp> lowp_bvec2;
 typedef vec<3, bool, lowp> lowp_bvec3;
 typedef vec<4, bool, lowp> lowp_bvec4;

 typedef vec<1, bool, mediump> mediump_bvec1;
 typedef vec<2, bool, mediump> mediump_bvec2;
 typedef vec<3, bool, mediump> mediump_bvec3;
 typedef vec<4, bool, mediump> mediump_bvec4;

 typedef vec<1, bool, highp> highp_bvec1;
 typedef vec<2, bool, highp> highp_bvec2;
 typedef vec<3, bool, highp> highp_bvec3;
 typedef vec<4, bool, highp> highp_bvec4;

 typedef vec<1, bool, defaultp> bvec1;
 typedef vec<2, bool, defaultp> bvec2;
 typedef vec<3, bool, defaultp> bvec3;
 typedef vec<4, bool, defaultp> bvec4;



 typedef vec<1, int, lowp> lowp_ivec1;
 typedef vec<2, int, lowp> lowp_ivec2;
 typedef vec<3, int, lowp> lowp_ivec3;
 typedef vec<4, int, lowp> lowp_ivec4;

 typedef vec<1, int, mediump> mediump_ivec1;
 typedef vec<2, int, mediump> mediump_ivec2;
 typedef vec<3, int, mediump> mediump_ivec3;
 typedef vec<4, int, mediump> mediump_ivec4;

 typedef vec<1, int, highp> highp_ivec1;
 typedef vec<2, int, highp> highp_ivec2;
 typedef vec<3, int, highp> highp_ivec3;
 typedef vec<4, int, highp> highp_ivec4;

 typedef vec<1, int, defaultp> ivec1;
 typedef vec<2, int, defaultp> ivec2;
 typedef vec<3, int, defaultp> ivec3;
 typedef vec<4, int, defaultp> ivec4;

 typedef vec<1, i8, lowp> lowp_i8vec1;
 typedef vec<2, i8, lowp> lowp_i8vec2;
 typedef vec<3, i8, lowp> lowp_i8vec3;
 typedef vec<4, i8, lowp> lowp_i8vec4;

 typedef vec<1, i8, mediump> mediump_i8vec1;
 typedef vec<2, i8, mediump> mediump_i8vec2;
 typedef vec<3, i8, mediump> mediump_i8vec3;
 typedef vec<4, i8, mediump> mediump_i8vec4;

 typedef vec<1, i8, highp> highp_i8vec1;
 typedef vec<2, i8, highp> highp_i8vec2;
 typedef vec<3, i8, highp> highp_i8vec3;
 typedef vec<4, i8, highp> highp_i8vec4;

 typedef vec<1, i8, defaultp> i8vec1;
 typedef vec<2, i8, defaultp> i8vec2;
 typedef vec<3, i8, defaultp> i8vec3;
 typedef vec<4, i8, defaultp> i8vec4;

 typedef vec<1, i16, lowp> lowp_i16vec1;
 typedef vec<2, i16, lowp> lowp_i16vec2;
 typedef vec<3, i16, lowp> lowp_i16vec3;
 typedef vec<4, i16, lowp> lowp_i16vec4;

 typedef vec<1, i16, mediump> mediump_i16vec1;
 typedef vec<2, i16, mediump> mediump_i16vec2;
 typedef vec<3, i16, mediump> mediump_i16vec3;
 typedef vec<4, i16, mediump> mediump_i16vec4;

 typedef vec<1, i16, highp> highp_i16vec1;
 typedef vec<2, i16, highp> highp_i16vec2;
 typedef vec<3, i16, highp> highp_i16vec3;
 typedef vec<4, i16, highp> highp_i16vec4;

 typedef vec<1, i16, defaultp> i16vec1;
 typedef vec<2, i16, defaultp> i16vec2;
 typedef vec<3, i16, defaultp> i16vec3;
 typedef vec<4, i16, defaultp> i16vec4;

 typedef vec<1, i32, lowp> lowp_i32vec1;
 typedef vec<2, i32, lowp> lowp_i32vec2;
 typedef vec<3, i32, lowp> lowp_i32vec3;
 typedef vec<4, i32, lowp> lowp_i32vec4;

 typedef vec<1, i32, mediump> mediump_i32vec1;
 typedef vec<2, i32, mediump> mediump_i32vec2;
 typedef vec<3, i32, mediump> mediump_i32vec3;
 typedef vec<4, i32, mediump> mediump_i32vec4;

 typedef vec<1, i32, highp> highp_i32vec1;
 typedef vec<2, i32, highp> highp_i32vec2;
 typedef vec<3, i32, highp> highp_i32vec3;
 typedef vec<4, i32, highp> highp_i32vec4;

 typedef vec<1, i32, defaultp> i32vec1;
 typedef vec<2, i32, defaultp> i32vec2;
 typedef vec<3, i32, defaultp> i32vec3;
 typedef vec<4, i32, defaultp> i32vec4;

 typedef vec<1, i64, lowp> lowp_i64vec1;
 typedef vec<2, i64, lowp> lowp_i64vec2;
 typedef vec<3, i64, lowp> lowp_i64vec3;
 typedef vec<4, i64, lowp> lowp_i64vec4;

 typedef vec<1, i64, mediump> mediump_i64vec1;
 typedef vec<2, i64, mediump> mediump_i64vec2;
 typedef vec<3, i64, mediump> mediump_i64vec3;
 typedef vec<4, i64, mediump> mediump_i64vec4;

 typedef vec<1, i64, highp> highp_i64vec1;
 typedef vec<2, i64, highp> highp_i64vec2;
 typedef vec<3, i64, highp> highp_i64vec3;
 typedef vec<4, i64, highp> highp_i64vec4;

 typedef vec<1, i64, defaultp> i64vec1;
 typedef vec<2, i64, defaultp> i64vec2;
 typedef vec<3, i64, defaultp> i64vec3;
 typedef vec<4, i64, defaultp> i64vec4;



 typedef vec<1, uint, lowp> lowp_uvec1;
 typedef vec<2, uint, lowp> lowp_uvec2;
 typedef vec<3, uint, lowp> lowp_uvec3;
 typedef vec<4, uint, lowp> lowp_uvec4;

 typedef vec<1, uint, mediump> mediump_uvec1;
 typedef vec<2, uint, mediump> mediump_uvec2;
 typedef vec<3, uint, mediump> mediump_uvec3;
 typedef vec<4, uint, mediump> mediump_uvec4;

 typedef vec<1, uint, highp> highp_uvec1;
 typedef vec<2, uint, highp> highp_uvec2;
 typedef vec<3, uint, highp> highp_uvec3;
 typedef vec<4, uint, highp> highp_uvec4;

 typedef vec<1, uint, defaultp> uvec1;
 typedef vec<2, uint, defaultp> uvec2;
 typedef vec<3, uint, defaultp> uvec3;
 typedef vec<4, uint, defaultp> uvec4;

 typedef vec<1, u8, lowp> lowp_u8vec1;
 typedef vec<2, u8, lowp> lowp_u8vec2;
 typedef vec<3, u8, lowp> lowp_u8vec3;
 typedef vec<4, u8, lowp> lowp_u8vec4;

 typedef vec<1, u8, mediump> mediump_u8vec1;
 typedef vec<2, u8, mediump> mediump_u8vec2;
 typedef vec<3, u8, mediump> mediump_u8vec3;
 typedef vec<4, u8, mediump> mediump_u8vec4;

 typedef vec<1, u8, highp> highp_u8vec1;
 typedef vec<2, u8, highp> highp_u8vec2;
 typedef vec<3, u8, highp> highp_u8vec3;
 typedef vec<4, u8, highp> highp_u8vec4;

 typedef vec<1, u8, defaultp> u8vec1;
 typedef vec<2, u8, defaultp> u8vec2;
 typedef vec<3, u8, defaultp> u8vec3;
 typedef vec<4, u8, defaultp> u8vec4;

 typedef vec<1, u16, lowp> lowp_u16vec1;
 typedef vec<2, u16, lowp> lowp_u16vec2;
 typedef vec<3, u16, lowp> lowp_u16vec3;
 typedef vec<4, u16, lowp> lowp_u16vec4;

 typedef vec<1, u16, mediump> mediump_u16vec1;
 typedef vec<2, u16, mediump> mediump_u16vec2;
 typedef vec<3, u16, mediump> mediump_u16vec3;
 typedef vec<4, u16, mediump> mediump_u16vec4;

 typedef vec<1, u16, highp> highp_u16vec1;
 typedef vec<2, u16, highp> highp_u16vec2;
 typedef vec<3, u16, highp> highp_u16vec3;
 typedef vec<4, u16, highp> highp_u16vec4;

 typedef vec<1, u16, defaultp> u16vec1;
 typedef vec<2, u16, defaultp> u16vec2;
 typedef vec<3, u16, defaultp> u16vec3;
 typedef vec<4, u16, defaultp> u16vec4;

 typedef vec<1, u32, lowp> lowp_u32vec1;
 typedef vec<2, u32, lowp> lowp_u32vec2;
 typedef vec<3, u32, lowp> lowp_u32vec3;
 typedef vec<4, u32, lowp> lowp_u32vec4;

 typedef vec<1, u32, mediump> mediump_u32vec1;
 typedef vec<2, u32, mediump> mediump_u32vec2;
 typedef vec<3, u32, mediump> mediump_u32vec3;
 typedef vec<4, u32, mediump> mediump_u32vec4;

 typedef vec<1, u32, highp> highp_u32vec1;
 typedef vec<2, u32, highp> highp_u32vec2;
 typedef vec<3, u32, highp> highp_u32vec3;
 typedef vec<4, u32, highp> highp_u32vec4;

 typedef vec<1, u32, defaultp> u32vec1;
 typedef vec<2, u32, defaultp> u32vec2;
 typedef vec<3, u32, defaultp> u32vec3;
 typedef vec<4, u32, defaultp> u32vec4;

 typedef vec<1, u64, lowp> lowp_u64vec1;
 typedef vec<2, u64, lowp> lowp_u64vec2;
 typedef vec<3, u64, lowp> lowp_u64vec3;
 typedef vec<4, u64, lowp> lowp_u64vec4;

 typedef vec<1, u64, mediump> mediump_u64vec1;
 typedef vec<2, u64, mediump> mediump_u64vec2;
 typedef vec<3, u64, mediump> mediump_u64vec3;
 typedef vec<4, u64, mediump> mediump_u64vec4;

 typedef vec<1, u64, highp> highp_u64vec1;
 typedef vec<2, u64, highp> highp_u64vec2;
 typedef vec<3, u64, highp> highp_u64vec3;
 typedef vec<4, u64, highp> highp_u64vec4;

 typedef vec<1, u64, defaultp> u64vec1;
 typedef vec<2, u64, defaultp> u64vec2;
 typedef vec<3, u64, defaultp> u64vec3;
 typedef vec<4, u64, defaultp> u64vec4;



 typedef vec<1, float, lowp> lowp_vec1;
 typedef vec<2, float, lowp> lowp_vec2;
 typedef vec<3, float, lowp> lowp_vec3;
 typedef vec<4, float, lowp> lowp_vec4;

 typedef vec<1, float, mediump> mediump_vec1;
 typedef vec<2, float, mediump> mediump_vec2;
 typedef vec<3, float, mediump> mediump_vec3;
 typedef vec<4, float, mediump> mediump_vec4;

 typedef vec<1, float, highp> highp_vec1;
 typedef vec<2, float, highp> highp_vec2;
 typedef vec<3, float, highp> highp_vec3;
 typedef vec<4, float, highp> highp_vec4;

 typedef vec<1, float, defaultp> vec1;
 typedef vec<2, float, defaultp> vec2;
 typedef vec<3, float, defaultp> vec3;
 typedef vec<4, float, defaultp> vec4;

 typedef vec<1, float, lowp> lowp_fvec1;
 typedef vec<2, float, lowp> lowp_fvec2;
 typedef vec<3, float, lowp> lowp_fvec3;
 typedef vec<4, float, lowp> lowp_fvec4;

 typedef vec<1, float, mediump> mediump_fvec1;
 typedef vec<2, float, mediump> mediump_fvec2;
 typedef vec<3, float, mediump> mediump_fvec3;
 typedef vec<4, float, mediump> mediump_fvec4;

 typedef vec<1, float, highp> highp_fvec1;
 typedef vec<2, float, highp> highp_fvec2;
 typedef vec<3, float, highp> highp_fvec3;
 typedef vec<4, float, highp> highp_fvec4;

 typedef vec<1, f32, defaultp> fvec1;
 typedef vec<2, f32, defaultp> fvec2;
 typedef vec<3, f32, defaultp> fvec3;
 typedef vec<4, f32, defaultp> fvec4;

 typedef vec<1, f32, lowp> lowp_f32vec1;
 typedef vec<2, f32, lowp> lowp_f32vec2;
 typedef vec<3, f32, lowp> lowp_f32vec3;
 typedef vec<4, f32, lowp> lowp_f32vec4;

 typedef vec<1, f32, mediump> mediump_f32vec1;
 typedef vec<2, f32, mediump> mediump_f32vec2;
 typedef vec<3, f32, mediump> mediump_f32vec3;
 typedef vec<4, f32, mediump> mediump_f32vec4;

 typedef vec<1, f32, highp> highp_f32vec1;
 typedef vec<2, f32, highp> highp_f32vec2;
 typedef vec<3, f32, highp> highp_f32vec3;
 typedef vec<4, f32, highp> highp_f32vec4;

 typedef vec<1, f32, defaultp> f32vec1;
 typedef vec<2, f32, defaultp> f32vec2;
 typedef vec<3, f32, defaultp> f32vec3;
 typedef vec<4, f32, defaultp> f32vec4;

 typedef vec<1, f64, lowp> lowp_dvec1;
 typedef vec<2, f64, lowp> lowp_dvec2;
 typedef vec<3, f64, lowp> lowp_dvec3;
 typedef vec<4, f64, lowp> lowp_dvec4;

 typedef vec<1, f64, mediump> mediump_dvec1;
 typedef vec<2, f64, mediump> mediump_dvec2;
 typedef vec<3, f64, mediump> mediump_dvec3;
 typedef vec<4, f64, mediump> mediump_dvec4;

 typedef vec<1, f64, highp> highp_dvec1;
 typedef vec<2, f64, highp> highp_dvec2;
 typedef vec<3, f64, highp> highp_dvec3;
 typedef vec<4, f64, highp> highp_dvec4;

 typedef vec<1, f64, defaultp> dvec1;
 typedef vec<2, f64, defaultp> dvec2;
 typedef vec<3, f64, defaultp> dvec3;
 typedef vec<4, f64, defaultp> dvec4;

 typedef vec<1, f64, lowp> lowp_f64vec1;
 typedef vec<2, f64, lowp> lowp_f64vec2;
 typedef vec<3, f64, lowp> lowp_f64vec3;
 typedef vec<4, f64, lowp> lowp_f64vec4;

 typedef vec<1, f64, mediump> mediump_f64vec1;
 typedef vec<2, f64, mediump> mediump_f64vec2;
 typedef vec<3, f64, mediump> mediump_f64vec3;
 typedef vec<4, f64, mediump> mediump_f64vec4;

 typedef vec<1, f64, highp> highp_f64vec1;
 typedef vec<2, f64, highp> highp_f64vec2;
 typedef vec<3, f64, highp> highp_f64vec3;
 typedef vec<4, f64, highp> highp_f64vec4;

 typedef vec<1, f64, defaultp> f64vec1;
 typedef vec<2, f64, defaultp> f64vec2;
 typedef vec<3, f64, defaultp> f64vec3;
 typedef vec<4, f64, defaultp> f64vec4;



 typedef mat<2, 2, f32, lowp> lowp_mat2;
 typedef mat<3, 3, f32, lowp> lowp_mat3;
 typedef mat<4, 4, f32, lowp> lowp_mat4;

 typedef mat<2, 2, f32, mediump> mediump_mat2;
 typedef mat<3, 3, f32, mediump> mediump_mat3;
 typedef mat<4, 4, f32, mediump> mediump_mat4;

 typedef mat<2, 2, f32, highp> highp_mat2;
 typedef mat<3, 3, f32, highp> highp_mat3;
 typedef mat<4, 4, f32, highp> highp_mat4;

 typedef mat<2, 2, f32, defaultp> mat2;
 typedef mat<3, 3, f32, defaultp> mat3;
 typedef mat<4, 4, f32, defaultp> mat4;

 typedef mat<2, 2, f32, lowp> lowp_fmat2;
 typedef mat<3, 3, f32, lowp> lowp_fmat3;
 typedef mat<4, 4, f32, lowp> lowp_fmat4;

 typedef mat<2, 2, f32, mediump> mediump_fmat2;
 typedef mat<3, 3, f32, mediump> mediump_fmat3;
 typedef mat<4, 4, f32, mediump> mediump_fmat4;

 typedef mat<2, 2, f32, highp> highp_fmat2;
 typedef mat<3, 3, f32, highp> highp_fmat3;
 typedef mat<4, 4, f32, highp> highp_fmat4;

 typedef mat<2, 2, f32, defaultp> fmat2;
 typedef mat<3, 3, f32, defaultp> fmat3;
 typedef mat<4, 4, f32, defaultp> fmat4;

 typedef mat<2, 2, f32, lowp> lowp_f32mat2;
 typedef mat<3, 3, f32, lowp> lowp_f32mat3;
 typedef mat<4, 4, f32, lowp> lowp_f32mat4;

 typedef mat<2, 2, f32, mediump> mediump_f32mat2;
 typedef mat<3, 3, f32, mediump> mediump_f32mat3;
 typedef mat<4, 4, f32, mediump> mediump_f32mat4;

 typedef mat<2, 2, f32, highp> highp_f32mat2;
 typedef mat<3, 3, f32, highp> highp_f32mat3;
 typedef mat<4, 4, f32, highp> highp_f32mat4;

 typedef mat<2, 2, f32, defaultp> f32mat2;
 typedef mat<3, 3, f32, defaultp> f32mat3;
 typedef mat<4, 4, f32, defaultp> f32mat4;

 typedef mat<2, 2, f64, lowp> lowp_dmat2;
 typedef mat<3, 3, f64, lowp> lowp_dmat3;
 typedef mat<4, 4, f64, lowp> lowp_dmat4;

 typedef mat<2, 2, f64, mediump> mediump_dmat2;
 typedef mat<3, 3, f64, mediump> mediump_dmat3;
 typedef mat<4, 4, f64, mediump> mediump_dmat4;

 typedef mat<2, 2, f64, highp> highp_dmat2;
 typedef mat<3, 3, f64, highp> highp_dmat3;
 typedef mat<4, 4, f64, highp> highp_dmat4;

 typedef mat<2, 2, f64, defaultp> dmat2;
 typedef mat<3, 3, f64, defaultp> dmat3;
 typedef mat<4, 4, f64, defaultp> dmat4;

 typedef mat<2, 2, f64, lowp> lowp_f64mat2;
 typedef mat<3, 3, f64, lowp> lowp_f64mat3;
 typedef mat<4, 4, f64, lowp> lowp_f64mat4;

 typedef mat<2, 2, f64, mediump> mediump_f64mat2;
 typedef mat<3, 3, f64, mediump> mediump_f64mat3;
 typedef mat<4, 4, f64, mediump> mediump_f64mat4;

 typedef mat<2, 2, f64, highp> highp_f64mat2;
 typedef mat<3, 3, f64, highp> highp_f64mat3;
 typedef mat<4, 4, f64, highp> highp_f64mat4;

 typedef mat<2, 2, f64, defaultp> f64mat2;
 typedef mat<3, 3, f64, defaultp> f64mat3;
 typedef mat<4, 4, f64, defaultp> f64mat4;



 typedef mat<2, 2, f32, lowp> lowp_mat2x2;
 typedef mat<2, 3, f32, lowp> lowp_mat2x3;
 typedef mat<2, 4, f32, lowp> lowp_mat2x4;
 typedef mat<3, 2, f32, lowp> lowp_mat3x2;
 typedef mat<3, 3, f32, lowp> lowp_mat3x3;
 typedef mat<3, 4, f32, lowp> lowp_mat3x4;
 typedef mat<4, 2, f32, lowp> lowp_mat4x2;
 typedef mat<4, 3, f32, lowp> lowp_mat4x3;
 typedef mat<4, 4, f32, lowp> lowp_mat4x4;

 typedef mat<2, 2, f32, mediump> mediump_mat2x2;
 typedef mat<2, 3, f32, mediump> mediump_mat2x3;
 typedef mat<2, 4, f32, mediump> mediump_mat2x4;
 typedef mat<3, 2, f32, mediump> mediump_mat3x2;
 typedef mat<3, 3, f32, mediump> mediump_mat3x3;
 typedef mat<3, 4, f32, mediump> mediump_mat3x4;
 typedef mat<4, 2, f32, mediump> mediump_mat4x2;
 typedef mat<4, 3, f32, mediump> mediump_mat4x3;
 typedef mat<4, 4, f32, mediump> mediump_mat4x4;

 typedef mat<2, 2, f32, highp> highp_mat2x2;
 typedef mat<2, 3, f32, highp> highp_mat2x3;
 typedef mat<2, 4, f32, highp> highp_mat2x4;
 typedef mat<3, 2, f32, highp> highp_mat3x2;
 typedef mat<3, 3, f32, highp> highp_mat3x3;
 typedef mat<3, 4, f32, highp> highp_mat3x4;
 typedef mat<4, 2, f32, highp> highp_mat4x2;
 typedef mat<4, 3, f32, highp> highp_mat4x3;
 typedef mat<4, 4, f32, highp> highp_mat4x4;

 typedef mat<2, 2, f32, defaultp> mat2x2;
 typedef mat<2, 3, f32, defaultp> mat2x3;
 typedef mat<2, 4, f32, defaultp> mat2x4;
 typedef mat<3, 2, f32, defaultp> mat3x2;
 typedef mat<3, 3, f32, defaultp> mat3x3;
 typedef mat<3, 4, f32, defaultp> mat3x4;
 typedef mat<4, 2, f32, defaultp> mat4x2;
 typedef mat<4, 3, f32, defaultp> mat4x3;
 typedef mat<4, 4, f32, defaultp> mat4x4;

 typedef mat<2, 2, f32, lowp> lowp_fmat2x2;
 typedef mat<2, 3, f32, lowp> lowp_fmat2x3;
 typedef mat<2, 4, f32, lowp> lowp_fmat2x4;
 typedef mat<3, 2, f32, lowp> lowp_fmat3x2;
 typedef mat<3, 3, f32, lowp> lowp_fmat3x3;
 typedef mat<3, 4, f32, lowp> lowp_fmat3x4;
 typedef mat<4, 2, f32, lowp> lowp_fmat4x2;
 typedef mat<4, 3, f32, lowp> lowp_fmat4x3;
 typedef mat<4, 4, f32, lowp> lowp_fmat4x4;

 typedef mat<2, 2, f32, mediump> mediump_fmat2x2;
 typedef mat<2, 3, f32, mediump> mediump_fmat2x3;
 typedef mat<2, 4, f32, mediump> mediump_fmat2x4;
 typedef mat<3, 2, f32, mediump> mediump_fmat3x2;
 typedef mat<3, 3, f32, mediump> mediump_fmat3x3;
 typedef mat<3, 4, f32, mediump> mediump_fmat3x4;
 typedef mat<4, 2, f32, mediump> mediump_fmat4x2;
 typedef mat<4, 3, f32, mediump> mediump_fmat4x3;
 typedef mat<4, 4, f32, mediump> mediump_fmat4x4;

 typedef mat<2, 2, f32, highp> highp_fmat2x2;
 typedef mat<2, 3, f32, highp> highp_fmat2x3;
 typedef mat<2, 4, f32, highp> highp_fmat2x4;
 typedef mat<3, 2, f32, highp> highp_fmat3x2;
 typedef mat<3, 3, f32, highp> highp_fmat3x3;
 typedef mat<3, 4, f32, highp> highp_fmat3x4;
 typedef mat<4, 2, f32, highp> highp_fmat4x2;
 typedef mat<4, 3, f32, highp> highp_fmat4x3;
 typedef mat<4, 4, f32, highp> highp_fmat4x4;

 typedef mat<2, 2, f32, defaultp> fmat2x2;
 typedef mat<2, 3, f32, defaultp> fmat2x3;
 typedef mat<2, 4, f32, defaultp> fmat2x4;
 typedef mat<3, 2, f32, defaultp> fmat3x2;
 typedef mat<3, 3, f32, defaultp> fmat3x3;
 typedef mat<3, 4, f32, defaultp> fmat3x4;
 typedef mat<4, 2, f32, defaultp> fmat4x2;
 typedef mat<4, 3, f32, defaultp> fmat4x3;
 typedef mat<4, 4, f32, defaultp> fmat4x4;

 typedef mat<2, 2, f32, lowp> lowp_f32mat2x2;
 typedef mat<2, 3, f32, lowp> lowp_f32mat2x3;
 typedef mat<2, 4, f32, lowp> lowp_f32mat2x4;
 typedef mat<3, 2, f32, lowp> lowp_f32mat3x2;
 typedef mat<3, 3, f32, lowp> lowp_f32mat3x3;
 typedef mat<3, 4, f32, lowp> lowp_f32mat3x4;
 typedef mat<4, 2, f32, lowp> lowp_f32mat4x2;
 typedef mat<4, 3, f32, lowp> lowp_f32mat4x3;
 typedef mat<4, 4, f32, lowp> lowp_f32mat4x4;

 typedef mat<2, 2, f32, mediump> mediump_f32mat2x2;
 typedef mat<2, 3, f32, mediump> mediump_f32mat2x3;
 typedef mat<2, 4, f32, mediump> mediump_f32mat2x4;
 typedef mat<3, 2, f32, mediump> mediump_f32mat3x2;
 typedef mat<3, 3, f32, mediump> mediump_f32mat3x3;
 typedef mat<3, 4, f32, mediump> mediump_f32mat3x4;
 typedef mat<4, 2, f32, mediump> mediump_f32mat4x2;
 typedef mat<4, 3, f32, mediump> mediump_f32mat4x3;
 typedef mat<4, 4, f32, mediump> mediump_f32mat4x4;

 typedef mat<2, 2, f32, highp> highp_f32mat2x2;
 typedef mat<2, 3, f32, highp> highp_f32mat2x3;
 typedef mat<2, 4, f32, highp> highp_f32mat2x4;
 typedef mat<3, 2, f32, highp> highp_f32mat3x2;
 typedef mat<3, 3, f32, highp> highp_f32mat3x3;
 typedef mat<3, 4, f32, highp> highp_f32mat3x4;
 typedef mat<4, 2, f32, highp> highp_f32mat4x2;
 typedef mat<4, 3, f32, highp> highp_f32mat4x3;
 typedef mat<4, 4, f32, highp> highp_f32mat4x4;

 typedef mat<2, 2, f32, defaultp> f32mat2x2;
 typedef mat<2, 3, f32, defaultp> f32mat2x3;
 typedef mat<2, 4, f32, defaultp> f32mat2x4;
 typedef mat<3, 2, f32, defaultp> f32mat3x2;
 typedef mat<3, 3, f32, defaultp> f32mat3x3;
 typedef mat<3, 4, f32, defaultp> f32mat3x4;
 typedef mat<4, 2, f32, defaultp> f32mat4x2;
 typedef mat<4, 3, f32, defaultp> f32mat4x3;
 typedef mat<4, 4, f32, defaultp> f32mat4x4;

 typedef mat<2, 2, double, lowp> lowp_dmat2x2;
 typedef mat<2, 3, double, lowp> lowp_dmat2x3;
 typedef mat<2, 4, double, lowp> lowp_dmat2x4;
 typedef mat<3, 2, double, lowp> lowp_dmat3x2;
 typedef mat<3, 3, double, lowp> lowp_dmat3x3;
 typedef mat<3, 4, double, lowp> lowp_dmat3x4;
 typedef mat<4, 2, double, lowp> lowp_dmat4x2;
 typedef mat<4, 3, double, lowp> lowp_dmat4x3;
 typedef mat<4, 4, double, lowp> lowp_dmat4x4;

 typedef mat<2, 2, double, mediump> mediump_dmat2x2;
 typedef mat<2, 3, double, mediump> mediump_dmat2x3;
 typedef mat<2, 4, double, mediump> mediump_dmat2x4;
 typedef mat<3, 2, double, mediump> mediump_dmat3x2;
 typedef mat<3, 3, double, mediump> mediump_dmat3x3;
 typedef mat<3, 4, double, mediump> mediump_dmat3x4;
 typedef mat<4, 2, double, mediump> mediump_dmat4x2;
 typedef mat<4, 3, double, mediump> mediump_dmat4x3;
 typedef mat<4, 4, double, mediump> mediump_dmat4x4;

 typedef mat<2, 2, double, highp> highp_dmat2x2;
 typedef mat<2, 3, double, highp> highp_dmat2x3;
 typedef mat<2, 4, double, highp> highp_dmat2x4;
 typedef mat<3, 2, double, highp> highp_dmat3x2;
 typedef mat<3, 3, double, highp> highp_dmat3x3;
 typedef mat<3, 4, double, highp> highp_dmat3x4;
 typedef mat<4, 2, double, highp> highp_dmat4x2;
 typedef mat<4, 3, double, highp> highp_dmat4x3;
 typedef mat<4, 4, double, highp> highp_dmat4x4;

 typedef mat<2, 2, double, defaultp> dmat2x2;
 typedef mat<2, 3, double, defaultp> dmat2x3;
 typedef mat<2, 4, double, defaultp> dmat2x4;
 typedef mat<3, 2, double, defaultp> dmat3x2;
 typedef mat<3, 3, double, defaultp> dmat3x3;
 typedef mat<3, 4, double, defaultp> dmat3x4;
 typedef mat<4, 2, double, defaultp> dmat4x2;
 typedef mat<4, 3, double, defaultp> dmat4x3;
 typedef mat<4, 4, double, defaultp> dmat4x4;

 typedef mat<2, 2, f64, lowp> lowp_f64mat2x2;
 typedef mat<2, 3, f64, lowp> lowp_f64mat2x3;
 typedef mat<2, 4, f64, lowp> lowp_f64mat2x4;
 typedef mat<3, 2, f64, lowp> lowp_f64mat3x2;
 typedef mat<3, 3, f64, lowp> lowp_f64mat3x3;
 typedef mat<3, 4, f64, lowp> lowp_f64mat3x4;
 typedef mat<4, 2, f64, lowp> lowp_f64mat4x2;
 typedef mat<4, 3, f64, lowp> lowp_f64mat4x3;
 typedef mat<4, 4, f64, lowp> lowp_f64mat4x4;

 typedef mat<2, 2, f64, mediump> mediump_f64mat2x2;
 typedef mat<2, 3, f64, mediump> mediump_f64mat2x3;
 typedef mat<2, 4, f64, mediump> mediump_f64mat2x4;
 typedef mat<3, 2, f64, mediump> mediump_f64mat3x2;
 typedef mat<3, 3, f64, mediump> mediump_f64mat3x3;
 typedef mat<3, 4, f64, mediump> mediump_f64mat3x4;
 typedef mat<4, 2, f64, mediump> mediump_f64mat4x2;
 typedef mat<4, 3, f64, mediump> mediump_f64mat4x3;
 typedef mat<4, 4, f64, mediump> mediump_f64mat4x4;

 typedef mat<2, 2, f64, highp> highp_f64mat2x2;
 typedef mat<2, 3, f64, highp> highp_f64mat2x3;
 typedef mat<2, 4, f64, highp> highp_f64mat2x4;
 typedef mat<3, 2, f64, highp> highp_f64mat3x2;
 typedef mat<3, 3, f64, highp> highp_f64mat3x3;
 typedef mat<3, 4, f64, highp> highp_f64mat3x4;
 typedef mat<4, 2, f64, highp> highp_f64mat4x2;
 typedef mat<4, 3, f64, highp> highp_f64mat4x3;
 typedef mat<4, 4, f64, highp> highp_f64mat4x4;

 typedef mat<2, 2, f64, defaultp> f64mat2x2;
 typedef mat<2, 3, f64, defaultp> f64mat2x3;
 typedef mat<2, 4, f64, defaultp> f64mat2x4;
 typedef mat<3, 2, f64, defaultp> f64mat3x2;
 typedef mat<3, 3, f64, defaultp> f64mat3x3;
 typedef mat<3, 4, f64, defaultp> f64mat3x4;
 typedef mat<4, 2, f64, defaultp> f64mat4x2;
 typedef mat<4, 3, f64, defaultp> f64mat4x3;
 typedef mat<4, 4, f64, defaultp> f64mat4x4;



 typedef mat<2, 2, int, lowp> lowp_imat2x2;
 typedef mat<2, 3, int, lowp> lowp_imat2x3;
 typedef mat<2, 4, int, lowp> lowp_imat2x4;
 typedef mat<3, 2, int, lowp> lowp_imat3x2;
 typedef mat<3, 3, int, lowp> lowp_imat3x3;
 typedef mat<3, 4, int, lowp> lowp_imat3x4;
 typedef mat<4, 2, int, lowp> lowp_imat4x2;
 typedef mat<4, 3, int, lowp> lowp_imat4x3;
 typedef mat<4, 4, int, lowp> lowp_imat4x4;

 typedef mat<2, 2, int, mediump> mediump_imat2x2;
 typedef mat<2, 3, int, mediump> mediump_imat2x3;
 typedef mat<2, 4, int, mediump> mediump_imat2x4;
 typedef mat<3, 2, int, mediump> mediump_imat3x2;
 typedef mat<3, 3, int, mediump> mediump_imat3x3;
 typedef mat<3, 4, int, mediump> mediump_imat3x4;
 typedef mat<4, 2, int, mediump> mediump_imat4x2;
 typedef mat<4, 3, int, mediump> mediump_imat4x3;
 typedef mat<4, 4, int, mediump> mediump_imat4x4;

 typedef mat<2, 2, int, highp> highp_imat2x2;
 typedef mat<2, 3, int, highp> highp_imat2x3;
 typedef mat<2, 4, int, highp> highp_imat2x4;
 typedef mat<3, 2, int, highp> highp_imat3x2;
 typedef mat<3, 3, int, highp> highp_imat3x3;
 typedef mat<3, 4, int, highp> highp_imat3x4;
 typedef mat<4, 2, int, highp> highp_imat4x2;
 typedef mat<4, 3, int, highp> highp_imat4x3;
 typedef mat<4, 4, int, highp> highp_imat4x4;

 typedef mat<2, 2, int, defaultp> imat2x2;
 typedef mat<2, 3, int, defaultp> imat2x3;
 typedef mat<2, 4, int, defaultp> imat2x4;
 typedef mat<3, 2, int, defaultp> imat3x2;
 typedef mat<3, 3, int, defaultp> imat3x3;
 typedef mat<3, 4, int, defaultp> imat3x4;
 typedef mat<4, 2, int, defaultp> imat4x2;
 typedef mat<4, 3, int, defaultp> imat4x3;
 typedef mat<4, 4, int, defaultp> imat4x4;


 typedef mat<2, 2, int8, lowp> lowp_i8mat2x2;
 typedef mat<2, 3, int8, lowp> lowp_i8mat2x3;
 typedef mat<2, 4, int8, lowp> lowp_i8mat2x4;
 typedef mat<3, 2, int8, lowp> lowp_i8mat3x2;
 typedef mat<3, 3, int8, lowp> lowp_i8mat3x3;
 typedef mat<3, 4, int8, lowp> lowp_i8mat3x4;
 typedef mat<4, 2, int8, lowp> lowp_i8mat4x2;
 typedef mat<4, 3, int8, lowp> lowp_i8mat4x3;
 typedef mat<4, 4, int8, lowp> lowp_i8mat4x4;

 typedef mat<2, 2, int8, mediump> mediump_i8mat2x2;
 typedef mat<2, 3, int8, mediump> mediump_i8mat2x3;
 typedef mat<2, 4, int8, mediump> mediump_i8mat2x4;
 typedef mat<3, 2, int8, mediump> mediump_i8mat3x2;
 typedef mat<3, 3, int8, mediump> mediump_i8mat3x3;
 typedef mat<3, 4, int8, mediump> mediump_i8mat3x4;
 typedef mat<4, 2, int8, mediump> mediump_i8mat4x2;
 typedef mat<4, 3, int8, mediump> mediump_i8mat4x3;
 typedef mat<4, 4, int8, mediump> mediump_i8mat4x4;

 typedef mat<2, 2, int8, highp> highp_i8mat2x2;
 typedef mat<2, 3, int8, highp> highp_i8mat2x3;
 typedef mat<2, 4, int8, highp> highp_i8mat2x4;
 typedef mat<3, 2, int8, highp> highp_i8mat3x2;
 typedef mat<3, 3, int8, highp> highp_i8mat3x3;
 typedef mat<3, 4, int8, highp> highp_i8mat3x4;
 typedef mat<4, 2, int8, highp> highp_i8mat4x2;
 typedef mat<4, 3, int8, highp> highp_i8mat4x3;
 typedef mat<4, 4, int8, highp> highp_i8mat4x4;

 typedef mat<2, 2, int8, defaultp> i8mat2x2;
 typedef mat<2, 3, int8, defaultp> i8mat2x3;
 typedef mat<2, 4, int8, defaultp> i8mat2x4;
 typedef mat<3, 2, int8, defaultp> i8mat3x2;
 typedef mat<3, 3, int8, defaultp> i8mat3x3;
 typedef mat<3, 4, int8, defaultp> i8mat3x4;
 typedef mat<4, 2, int8, defaultp> i8mat4x2;
 typedef mat<4, 3, int8, defaultp> i8mat4x3;
 typedef mat<4, 4, int8, defaultp> i8mat4x4;


 typedef mat<2, 2, int16, lowp> lowp_i16mat2x2;
 typedef mat<2, 3, int16, lowp> lowp_i16mat2x3;
 typedef mat<2, 4, int16, lowp> lowp_i16mat2x4;
 typedef mat<3, 2, int16, lowp> lowp_i16mat3x2;
 typedef mat<3, 3, int16, lowp> lowp_i16mat3x3;
 typedef mat<3, 4, int16, lowp> lowp_i16mat3x4;
 typedef mat<4, 2, int16, lowp> lowp_i16mat4x2;
 typedef mat<4, 3, int16, lowp> lowp_i16mat4x3;
 typedef mat<4, 4, int16, lowp> lowp_i16mat4x4;

 typedef mat<2, 2, int16, mediump> mediump_i16mat2x2;
 typedef mat<2, 3, int16, mediump> mediump_i16mat2x3;
 typedef mat<2, 4, int16, mediump> mediump_i16mat2x4;
 typedef mat<3, 2, int16, mediump> mediump_i16mat3x2;
 typedef mat<3, 3, int16, mediump> mediump_i16mat3x3;
 typedef mat<3, 4, int16, mediump> mediump_i16mat3x4;
 typedef mat<4, 2, int16, mediump> mediump_i16mat4x2;
 typedef mat<4, 3, int16, mediump> mediump_i16mat4x3;
 typedef mat<4, 4, int16, mediump> mediump_i16mat4x4;

 typedef mat<2, 2, int16, highp> highp_i16mat2x2;
 typedef mat<2, 3, int16, highp> highp_i16mat2x3;
 typedef mat<2, 4, int16, highp> highp_i16mat2x4;
 typedef mat<3, 2, int16, highp> highp_i16mat3x2;
 typedef mat<3, 3, int16, highp> highp_i16mat3x3;
 typedef mat<3, 4, int16, highp> highp_i16mat3x4;
 typedef mat<4, 2, int16, highp> highp_i16mat4x2;
 typedef mat<4, 3, int16, highp> highp_i16mat4x3;
 typedef mat<4, 4, int16, highp> highp_i16mat4x4;

 typedef mat<2, 2, int16, defaultp> i16mat2x2;
 typedef mat<2, 3, int16, defaultp> i16mat2x3;
 typedef mat<2, 4, int16, defaultp> i16mat2x4;
 typedef mat<3, 2, int16, defaultp> i16mat3x2;
 typedef mat<3, 3, int16, defaultp> i16mat3x3;
 typedef mat<3, 4, int16, defaultp> i16mat3x4;
 typedef mat<4, 2, int16, defaultp> i16mat4x2;
 typedef mat<4, 3, int16, defaultp> i16mat4x3;
 typedef mat<4, 4, int16, defaultp> i16mat4x4;


 typedef mat<2, 2, int32, lowp> lowp_i32mat2x2;
 typedef mat<2, 3, int32, lowp> lowp_i32mat2x3;
 typedef mat<2, 4, int32, lowp> lowp_i32mat2x4;
 typedef mat<3, 2, int32, lowp> lowp_i32mat3x2;
 typedef mat<3, 3, int32, lowp> lowp_i32mat3x3;
 typedef mat<3, 4, int32, lowp> lowp_i32mat3x4;
 typedef mat<4, 2, int32, lowp> lowp_i32mat4x2;
 typedef mat<4, 3, int32, lowp> lowp_i32mat4x3;
 typedef mat<4, 4, int32, lowp> lowp_i32mat4x4;

 typedef mat<2, 2, int32, mediump> mediump_i32mat2x2;
 typedef mat<2, 3, int32, mediump> mediump_i32mat2x3;
 typedef mat<2, 4, int32, mediump> mediump_i32mat2x4;
 typedef mat<3, 2, int32, mediump> mediump_i32mat3x2;
 typedef mat<3, 3, int32, mediump> mediump_i32mat3x3;
 typedef mat<3, 4, int32, mediump> mediump_i32mat3x4;
 typedef mat<4, 2, int32, mediump> mediump_i32mat4x2;
 typedef mat<4, 3, int32, mediump> mediump_i32mat4x3;
 typedef mat<4, 4, int32, mediump> mediump_i32mat4x4;

 typedef mat<2, 2, int32, highp> highp_i32mat2x2;
 typedef mat<2, 3, int32, highp> highp_i32mat2x3;
 typedef mat<2, 4, int32, highp> highp_i32mat2x4;
 typedef mat<3, 2, int32, highp> highp_i32mat3x2;
 typedef mat<3, 3, int32, highp> highp_i32mat3x3;
 typedef mat<3, 4, int32, highp> highp_i32mat3x4;
 typedef mat<4, 2, int32, highp> highp_i32mat4x2;
 typedef mat<4, 3, int32, highp> highp_i32mat4x3;
 typedef mat<4, 4, int32, highp> highp_i32mat4x4;

 typedef mat<2, 2, int32, defaultp> i32mat2x2;
 typedef mat<2, 3, int32, defaultp> i32mat2x3;
 typedef mat<2, 4, int32, defaultp> i32mat2x4;
 typedef mat<3, 2, int32, defaultp> i32mat3x2;
 typedef mat<3, 3, int32, defaultp> i32mat3x3;
 typedef mat<3, 4, int32, defaultp> i32mat3x4;
 typedef mat<4, 2, int32, defaultp> i32mat4x2;
 typedef mat<4, 3, int32, defaultp> i32mat4x3;
 typedef mat<4, 4, int32, defaultp> i32mat4x4;


 typedef mat<2, 2, int64, lowp> lowp_i64mat2x2;
 typedef mat<2, 3, int64, lowp> lowp_i64mat2x3;
 typedef mat<2, 4, int64, lowp> lowp_i64mat2x4;
 typedef mat<3, 2, int64, lowp> lowp_i64mat3x2;
 typedef mat<3, 3, int64, lowp> lowp_i64mat3x3;
 typedef mat<3, 4, int64, lowp> lowp_i64mat3x4;
 typedef mat<4, 2, int64, lowp> lowp_i64mat4x2;
 typedef mat<4, 3, int64, lowp> lowp_i64mat4x3;
 typedef mat<4, 4, int64, lowp> lowp_i64mat4x4;

 typedef mat<2, 2, int64, mediump> mediump_i64mat2x2;
 typedef mat<2, 3, int64, mediump> mediump_i64mat2x3;
 typedef mat<2, 4, int64, mediump> mediump_i64mat2x4;
 typedef mat<3, 2, int64, mediump> mediump_i64mat3x2;
 typedef mat<3, 3, int64, mediump> mediump_i64mat3x3;
 typedef mat<3, 4, int64, mediump> mediump_i64mat3x4;
 typedef mat<4, 2, int64, mediump> mediump_i64mat4x2;
 typedef mat<4, 3, int64, mediump> mediump_i64mat4x3;
 typedef mat<4, 4, int64, mediump> mediump_i64mat4x4;

 typedef mat<2, 2, int64, highp> highp_i64mat2x2;
 typedef mat<2, 3, int64, highp> highp_i64mat2x3;
 typedef mat<2, 4, int64, highp> highp_i64mat2x4;
 typedef mat<3, 2, int64, highp> highp_i64mat3x2;
 typedef mat<3, 3, int64, highp> highp_i64mat3x3;
 typedef mat<3, 4, int64, highp> highp_i64mat3x4;
 typedef mat<4, 2, int64, highp> highp_i64mat4x2;
 typedef mat<4, 3, int64, highp> highp_i64mat4x3;
 typedef mat<4, 4, int64, highp> highp_i64mat4x4;

 typedef mat<2, 2, int64, defaultp> i64mat2x2;
 typedef mat<2, 3, int64, defaultp> i64mat2x3;
 typedef mat<2, 4, int64, defaultp> i64mat2x4;
 typedef mat<3, 2, int64, defaultp> i64mat3x2;
 typedef mat<3, 3, int64, defaultp> i64mat3x3;
 typedef mat<3, 4, int64, defaultp> i64mat3x4;
 typedef mat<4, 2, int64, defaultp> i64mat4x2;
 typedef mat<4, 3, int64, defaultp> i64mat4x3;
 typedef mat<4, 4, int64, defaultp> i64mat4x4;




 typedef mat<2, 2, uint, lowp> lowp_umat2x2;
 typedef mat<2, 3, uint, lowp> lowp_umat2x3;
 typedef mat<2, 4, uint, lowp> lowp_umat2x4;
 typedef mat<3, 2, uint, lowp> lowp_umat3x2;
 typedef mat<3, 3, uint, lowp> lowp_umat3x3;
 typedef mat<3, 4, uint, lowp> lowp_umat3x4;
 typedef mat<4, 2, uint, lowp> lowp_umat4x2;
 typedef mat<4, 3, uint, lowp> lowp_umat4x3;
 typedef mat<4, 4, uint, lowp> lowp_umat4x4;

 typedef mat<2, 2, uint, mediump> mediump_umat2x2;
 typedef mat<2, 3, uint, mediump> mediump_umat2x3;
 typedef mat<2, 4, uint, mediump> mediump_umat2x4;
 typedef mat<3, 2, uint, mediump> mediump_umat3x2;
 typedef mat<3, 3, uint, mediump> mediump_umat3x3;
 typedef mat<3, 4, uint, mediump> mediump_umat3x4;
 typedef mat<4, 2, uint, mediump> mediump_umat4x2;
 typedef mat<4, 3, uint, mediump> mediump_umat4x3;
 typedef mat<4, 4, uint, mediump> mediump_umat4x4;

 typedef mat<2, 2, uint, highp> highp_umat2x2;
 typedef mat<2, 3, uint, highp> highp_umat2x3;
 typedef mat<2, 4, uint, highp> highp_umat2x4;
 typedef mat<3, 2, uint, highp> highp_umat3x2;
 typedef mat<3, 3, uint, highp> highp_umat3x3;
 typedef mat<3, 4, uint, highp> highp_umat3x4;
 typedef mat<4, 2, uint, highp> highp_umat4x2;
 typedef mat<4, 3, uint, highp> highp_umat4x3;
 typedef mat<4, 4, uint, highp> highp_umat4x4;

 typedef mat<2, 2, uint, defaultp> umat2x2;
 typedef mat<2, 3, uint, defaultp> umat2x3;
 typedef mat<2, 4, uint, defaultp> umat2x4;
 typedef mat<3, 2, uint, defaultp> umat3x2;
 typedef mat<3, 3, uint, defaultp> umat3x3;
 typedef mat<3, 4, uint, defaultp> umat3x4;
 typedef mat<4, 2, uint, defaultp> umat4x2;
 typedef mat<4, 3, uint, defaultp> umat4x3;
 typedef mat<4, 4, uint, defaultp> umat4x4;


 typedef mat<2, 2, uint8, lowp> lowp_u8mat2x2;
 typedef mat<2, 3, uint8, lowp> lowp_u8mat2x3;
 typedef mat<2, 4, uint8, lowp> lowp_u8mat2x4;
 typedef mat<3, 2, uint8, lowp> lowp_u8mat3x2;
 typedef mat<3, 3, uint8, lowp> lowp_u8mat3x3;
 typedef mat<3, 4, uint8, lowp> lowp_u8mat3x4;
 typedef mat<4, 2, uint8, lowp> lowp_u8mat4x2;
 typedef mat<4, 3, uint8, lowp> lowp_u8mat4x3;
 typedef mat<4, 4, uint8, lowp> lowp_u8mat4x4;

 typedef mat<2, 2, uint8, mediump> mediump_u8mat2x2;
 typedef mat<2, 3, uint8, mediump> mediump_u8mat2x3;
 typedef mat<2, 4, uint8, mediump> mediump_u8mat2x4;
 typedef mat<3, 2, uint8, mediump> mediump_u8mat3x2;
 typedef mat<3, 3, uint8, mediump> mediump_u8mat3x3;
 typedef mat<3, 4, uint8, mediump> mediump_u8mat3x4;
 typedef mat<4, 2, uint8, mediump> mediump_u8mat4x2;
 typedef mat<4, 3, uint8, mediump> mediump_u8mat4x3;
 typedef mat<4, 4, uint8, mediump> mediump_u8mat4x4;

 typedef mat<2, 2, uint8, highp> highp_u8mat2x2;
 typedef mat<2, 3, uint8, highp> highp_u8mat2x3;
 typedef mat<2, 4, uint8, highp> highp_u8mat2x4;
 typedef mat<3, 2, uint8, highp> highp_u8mat3x2;
 typedef mat<3, 3, uint8, highp> highp_u8mat3x3;
 typedef mat<3, 4, uint8, highp> highp_u8mat3x4;
 typedef mat<4, 2, uint8, highp> highp_u8mat4x2;
 typedef mat<4, 3, uint8, highp> highp_u8mat4x3;
 typedef mat<4, 4, uint8, highp> highp_u8mat4x4;

 typedef mat<2, 2, uint8, defaultp> u8mat2x2;
 typedef mat<2, 3, uint8, defaultp> u8mat2x3;
 typedef mat<2, 4, uint8, defaultp> u8mat2x4;
 typedef mat<3, 2, uint8, defaultp> u8mat3x2;
 typedef mat<3, 3, uint8, defaultp> u8mat3x3;
 typedef mat<3, 4, uint8, defaultp> u8mat3x4;
 typedef mat<4, 2, uint8, defaultp> u8mat4x2;
 typedef mat<4, 3, uint8, defaultp> u8mat4x3;
 typedef mat<4, 4, uint8, defaultp> u8mat4x4;


 typedef mat<2, 2, uint16, lowp> lowp_u16mat2x2;
 typedef mat<2, 3, uint16, lowp> lowp_u16mat2x3;
 typedef mat<2, 4, uint16, lowp> lowp_u16mat2x4;
 typedef mat<3, 2, uint16, lowp> lowp_u16mat3x2;
 typedef mat<3, 3, uint16, lowp> lowp_u16mat3x3;
 typedef mat<3, 4, uint16, lowp> lowp_u16mat3x4;
 typedef mat<4, 2, uint16, lowp> lowp_u16mat4x2;
 typedef mat<4, 3, uint16, lowp> lowp_u16mat4x3;
 typedef mat<4, 4, uint16, lowp> lowp_u16mat4x4;

 typedef mat<2, 2, uint16, mediump> mediump_u16mat2x2;
 typedef mat<2, 3, uint16, mediump> mediump_u16mat2x3;
 typedef mat<2, 4, uint16, mediump> mediump_u16mat2x4;
 typedef mat<3, 2, uint16, mediump> mediump_u16mat3x2;
 typedef mat<3, 3, uint16, mediump> mediump_u16mat3x3;
 typedef mat<3, 4, uint16, mediump> mediump_u16mat3x4;
 typedef mat<4, 2, uint16, mediump> mediump_u16mat4x2;
 typedef mat<4, 3, uint16, mediump> mediump_u16mat4x3;
 typedef mat<4, 4, uint16, mediump> mediump_u16mat4x4;

 typedef mat<2, 2, uint16, highp> highp_u16mat2x2;
 typedef mat<2, 3, uint16, highp> highp_u16mat2x3;
 typedef mat<2, 4, uint16, highp> highp_u16mat2x4;
 typedef mat<3, 2, uint16, highp> highp_u16mat3x2;
 typedef mat<3, 3, uint16, highp> highp_u16mat3x3;
 typedef mat<3, 4, uint16, highp> highp_u16mat3x4;
 typedef mat<4, 2, uint16, highp> highp_u16mat4x2;
 typedef mat<4, 3, uint16, highp> highp_u16mat4x3;
 typedef mat<4, 4, uint16, highp> highp_u16mat4x4;

 typedef mat<2, 2, uint16, defaultp> u16mat2x2;
 typedef mat<2, 3, uint16, defaultp> u16mat2x3;
 typedef mat<2, 4, uint16, defaultp> u16mat2x4;
 typedef mat<3, 2, uint16, defaultp> u16mat3x2;
 typedef mat<3, 3, uint16, defaultp> u16mat3x3;
 typedef mat<3, 4, uint16, defaultp> u16mat3x4;
 typedef mat<4, 2, uint16, defaultp> u16mat4x2;
 typedef mat<4, 3, uint16, defaultp> u16mat4x3;
 typedef mat<4, 4, uint16, defaultp> u16mat4x4;


 typedef mat<2, 2, uint32, lowp> lowp_u32mat2x2;
 typedef mat<2, 3, uint32, lowp> lowp_u32mat2x3;
 typedef mat<2, 4, uint32, lowp> lowp_u32mat2x4;
 typedef mat<3, 2, uint32, lowp> lowp_u32mat3x2;
 typedef mat<3, 3, uint32, lowp> lowp_u32mat3x3;
 typedef mat<3, 4, uint32, lowp> lowp_u32mat3x4;
 typedef mat<4, 2, uint32, lowp> lowp_u32mat4x2;
 typedef mat<4, 3, uint32, lowp> lowp_u32mat4x3;
 typedef mat<4, 4, uint32, lowp> lowp_u32mat4x4;

 typedef mat<2, 2, uint32, mediump> mediump_u32mat2x2;
 typedef mat<2, 3, uint32, mediump> mediump_u32mat2x3;
 typedef mat<2, 4, uint32, mediump> mediump_u32mat2x4;
 typedef mat<3, 2, uint32, mediump> mediump_u32mat3x2;
 typedef mat<3, 3, uint32, mediump> mediump_u32mat3x3;
 typedef mat<3, 4, uint32, mediump> mediump_u32mat3x4;
 typedef mat<4, 2, uint32, mediump> mediump_u32mat4x2;
 typedef mat<4, 3, uint32, mediump> mediump_u32mat4x3;
 typedef mat<4, 4, uint32, mediump> mediump_u32mat4x4;

 typedef mat<2, 2, uint32, highp> highp_u32mat2x2;
 typedef mat<2, 3, uint32, highp> highp_u32mat2x3;
 typedef mat<2, 4, uint32, highp> highp_u32mat2x4;
 typedef mat<3, 2, uint32, highp> highp_u32mat3x2;
 typedef mat<3, 3, uint32, highp> highp_u32mat3x3;
 typedef mat<3, 4, uint32, highp> highp_u32mat3x4;
 typedef mat<4, 2, uint32, highp> highp_u32mat4x2;
 typedef mat<4, 3, uint32, highp> highp_u32mat4x3;
 typedef mat<4, 4, uint32, highp> highp_u32mat4x4;

 typedef mat<2, 2, uint32, defaultp> u32mat2x2;
 typedef mat<2, 3, uint32, defaultp> u32mat2x3;
 typedef mat<2, 4, uint32, defaultp> u32mat2x4;
 typedef mat<3, 2, uint32, defaultp> u32mat3x2;
 typedef mat<3, 3, uint32, defaultp> u32mat3x3;
 typedef mat<3, 4, uint32, defaultp> u32mat3x4;
 typedef mat<4, 2, uint32, defaultp> u32mat4x2;
 typedef mat<4, 3, uint32, defaultp> u32mat4x3;
 typedef mat<4, 4, uint32, defaultp> u32mat4x4;


 typedef mat<2, 2, uint64, lowp> lowp_u64mat2x2;
 typedef mat<2, 3, uint64, lowp> lowp_u64mat2x3;
 typedef mat<2, 4, uint64, lowp> lowp_u64mat2x4;
 typedef mat<3, 2, uint64, lowp> lowp_u64mat3x2;
 typedef mat<3, 3, uint64, lowp> lowp_u64mat3x3;
 typedef mat<3, 4, uint64, lowp> lowp_u64mat3x4;
 typedef mat<4, 2, uint64, lowp> lowp_u64mat4x2;
 typedef mat<4, 3, uint64, lowp> lowp_u64mat4x3;
 typedef mat<4, 4, uint64, lowp> lowp_u64mat4x4;

 typedef mat<2, 2, uint64, mediump> mediump_u64mat2x2;
 typedef mat<2, 3, uint64, mediump> mediump_u64mat2x3;
 typedef mat<2, 4, uint64, mediump> mediump_u64mat2x4;
 typedef mat<3, 2, uint64, mediump> mediump_u64mat3x2;
 typedef mat<3, 3, uint64, mediump> mediump_u64mat3x3;
 typedef mat<3, 4, uint64, mediump> mediump_u64mat3x4;
 typedef mat<4, 2, uint64, mediump> mediump_u64mat4x2;
 typedef mat<4, 3, uint64, mediump> mediump_u64mat4x3;
 typedef mat<4, 4, uint64, mediump> mediump_u64mat4x4;

 typedef mat<2, 2, uint64, highp> highp_u64mat2x2;
 typedef mat<2, 3, uint64, highp> highp_u64mat2x3;
 typedef mat<2, 4, uint64, highp> highp_u64mat2x4;
 typedef mat<3, 2, uint64, highp> highp_u64mat3x2;
 typedef mat<3, 3, uint64, highp> highp_u64mat3x3;
 typedef mat<3, 4, uint64, highp> highp_u64mat3x4;
 typedef mat<4, 2, uint64, highp> highp_u64mat4x2;
 typedef mat<4, 3, uint64, highp> highp_u64mat4x3;
 typedef mat<4, 4, uint64, highp> highp_u64mat4x4;

 typedef mat<2, 2, uint64, defaultp> u64mat2x2;
 typedef mat<2, 3, uint64, defaultp> u64mat2x3;
 typedef mat<2, 4, uint64, defaultp> u64mat2x4;
 typedef mat<3, 2, uint64, defaultp> u64mat3x2;
 typedef mat<3, 3, uint64, defaultp> u64mat3x3;
 typedef mat<3, 4, uint64, defaultp> u64mat3x4;
 typedef mat<4, 2, uint64, defaultp> u64mat4x2;
 typedef mat<4, 3, uint64, defaultp> u64mat4x3;
 typedef mat<4, 4, uint64, defaultp> u64mat4x4;



 typedef qua<float, lowp> lowp_quat;
 typedef qua<float, mediump> mediump_quat;
 typedef qua<float, highp> highp_quat;
 typedef qua<float, defaultp> quat;

 typedef qua<float, lowp> lowp_fquat;
 typedef qua<float, mediump> mediump_fquat;
 typedef qua<float, highp> highp_fquat;
 typedef qua<float, defaultp> fquat;

 typedef qua<f32, lowp> lowp_f32quat;
 typedef qua<f32, mediump> mediump_f32quat;
 typedef qua<f32, highp> highp_f32quat;
 typedef qua<f32, defaultp> f32quat;

 typedef qua<double, lowp> lowp_dquat;
 typedef qua<double, mediump> mediump_dquat;
 typedef qua<double, highp> highp_dquat;
 typedef qua<double, defaultp> dquat;

 typedef qua<f64, lowp> lowp_f64quat;
 typedef qua<f64, mediump> mediump_f64quat;
 typedef qua<f64, highp> highp_f64quat;
 typedef qua<f64, defaultp> f64quat;
}
# 116 "/usr/include/glm/glm.hpp" 2 3 4

# 1 "/usr/include/glm/vec2.hpp" 1 3 4



       
# 1 "/usr/include/glm/ext/vector_bool2.hpp" 1 3 4



       
# 1 "/usr/include/glm/detail/type_vec2.hpp" 1 3 4



       
# 14 "/usr/include/glm/detail/type_vec2.hpp" 3 4
namespace glm
{
 template<typename T, qualifier Q>
 struct vec<2, T, Q>
 {


  typedef T value_type;
  typedef vec<2, T, Q> type;
  typedef vec<2, bool, Q> bool_type;





#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpedantic"
# 68 "/usr/include/glm/detail/type_vec2.hpp" 3 4
   union {T x, r, s;};
   union {T y, g, t;};
# 80 "/usr/include/glm/detail/type_vec2.hpp" 3 4
#pragma GCC diagnostic pop
# 89 "/usr/include/glm/detail/type_vec2.hpp" 3 4
  typedef length_t length_type;
  [[nodiscard]] static constexpr length_type length(){return 2;}

  [[nodiscard]] constexpr T& operator[](length_type i);
  [[nodiscard]] constexpr T const& operator[](length_type i) const;



  constexpr vec() = default;
  constexpr vec(vec const& v) = default;
  template<qualifier P>
  constexpr vec(vec<2, T, P> const& v);



  constexpr explicit vec(T scalar);
  constexpr vec(T x, T y);



  template<typename U, qualifier P>
  constexpr explicit vec(vec<1, U, P> const& v);


  template<typename A, typename B>
  constexpr vec(A x, B y);
  template<typename A, typename B>
  constexpr vec(vec<1, A, Q> const& x, B y);
  template<typename A, typename B>
  constexpr vec(A x, vec<1, B, Q> const& y);
  template<typename A, typename B>
  constexpr vec(vec<1, A, Q> const& x, vec<1, B, Q> const& y);




  template<typename U, qualifier P>
  constexpr vec(vec<3, U, P> const& v);

  template<typename U, qualifier P>
  constexpr vec(vec<4, U, P> const& v);


  template<typename U, qualifier P>
  constexpr vec(vec<2, U, P> const& v);
# 146 "/usr/include/glm/detail/type_vec2.hpp" 3 4
  constexpr vec<2, T, Q> & operator=(vec const& v) = default;

  template<typename U>
  constexpr vec<2, T, Q> & operator=(vec<2, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator+=(U scalar);
  template<typename U>
  constexpr vec<2, T, Q> & operator+=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator+=(vec<2, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator-=(U scalar);
  template<typename U>
  constexpr vec<2, T, Q> & operator-=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator-=(vec<2, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator*=(U scalar);
  template<typename U>
  constexpr vec<2, T, Q> & operator*=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator*=(vec<2, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator/=(U scalar);
  template<typename U>
  constexpr vec<2, T, Q> & operator/=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator/=(vec<2, U, Q> const& v);



  constexpr vec<2, T, Q> & operator++();
  constexpr vec<2, T, Q> & operator--();
  [[nodiscard]] constexpr vec<2, T, Q> operator++(int);
  [[nodiscard]] constexpr vec<2, T, Q> operator--(int);



  template<typename U>
  constexpr vec<2, T, Q> & operator%=(U scalar);
  template<typename U>
  constexpr vec<2, T, Q> & operator%=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator%=(vec<2, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator&=(U scalar);
  template<typename U>
  constexpr vec<2, T, Q> & operator&=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator&=(vec<2, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator|=(U scalar);
  template<typename U>
  constexpr vec<2, T, Q> & operator|=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator|=(vec<2, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator^=(U scalar);
  template<typename U>
  constexpr vec<2, T, Q> & operator^=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator^=(vec<2, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator<<=(U scalar);
  template<typename U>
  constexpr vec<2, T, Q> & operator<<=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator<<=(vec<2, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator>>=(U scalar);
  template<typename U>
  constexpr vec<2, T, Q> & operator>>=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<2, T, Q> & operator>>=(vec<2, U, Q> const& v);
 };



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator+(vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator-(vec<2, T, Q> const& v);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator+(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator+(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator+(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator+(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator+(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator-(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator-(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator-(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator-(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator-(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator*(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator*(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator*(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator*(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator*(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator/(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator/(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator/(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator/(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator/(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator%(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator%(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator%(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator%(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator%(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator&(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator&(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator&(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator&(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator&(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator|(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator|(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator|(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator|(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator|(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator^(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator^(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator^(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator^(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator^(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator<<(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator<<(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator<<(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator<<(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator<<(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator>>(vec<2, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator>>(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator>>(T scalar, vec<2, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator>>(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator>>(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<2, T, Q> operator~(vec<2, T, Q> const& v);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator==(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator!=(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2);

 template<qualifier Q>
 [[nodiscard]] constexpr vec<2, bool, Q> operator&&(vec<2, bool, Q> const& v1, vec<2, bool, Q> const& v2);

 template<qualifier Q>
 [[nodiscard]] constexpr vec<2, bool, Q> operator||(vec<2, bool, Q> const& v1, vec<2, bool, Q> const& v2);
}


# 1 "/usr/include/glm/detail/type_vec2.inl" 1 3 4


# 1 "/usr/include/glm/detail/compute_vector_relational.hpp" 1 3 4
       


# 1 "/usr/include/glm/detail/setup.hpp" 1 3 4
# 5 "/usr/include/glm/detail/compute_vector_relational.hpp" 2 3 4


namespace glm{
namespace detail
{
 template <typename T, bool isFloat>
 struct compute_equal
 {
  inline constexpr static bool call(T a, T b)
  {
   return a == b;
  }
 };
# 29 "/usr/include/glm/detail/compute_vector_relational.hpp" 3 4
}
}
# 4 "/usr/include/glm/detail/type_vec2.inl" 2 3 4

namespace glm
{
# 25 "/usr/include/glm/detail/type_vec2.inl" 3 4
 template<typename T, qualifier Q>
 template<qualifier P>
 inline constexpr vec<2, T, Q>::vec(vec<2, T, P> const& v)
  : x(v.x), y(v.y)
 {}



 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q>::vec(T scalar)
  : x(scalar), y(scalar)
 {}

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q>::vec(T _x, T _y)
  : x(_x), y(_y)
 {}



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr vec<2, T, Q>::vec(vec<1, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.x))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B>
 inline constexpr vec<2, T, Q>::vec(A _x, B _y)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B>
 inline constexpr vec<2, T, Q>::vec(vec<1, A, Q> const& _x, B _y)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B>
 inline constexpr vec<2, T, Q>::vec(A _x, vec<1, B, Q> const& _y)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y.x))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B>
 inline constexpr vec<2, T, Q>::vec(vec<1, A, Q> const& _x, vec<1, B, Q> const& _y)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y.x))
 {}



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr vec<2, T, Q>::vec(vec<2, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.y))
 {}

 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr vec<2, T, Q>::vec(vec<3, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.y))
 {}

 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr vec<2, T, Q>::vec(vec<4, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.y))
 {}



 template<typename T, qualifier Q>
 inline constexpr T & vec<2, T, Q>::operator[](typename vec<2, T, Q>::length_type i)
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));
  switch(i)
  {
  default:
  case 0:
   return x;
  case 1:
   return y;
  }
 }

 template<typename T, qualifier Q>
 inline constexpr T const& vec<2, T, Q>::operator[](typename vec<2, T, Q>::length_type i) const
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));
  switch(i)
  {
  default:
  case 0:
   return x;
  case 1:
   return y;
  }
 }
# 145 "/usr/include/glm/detail/type_vec2.inl" 3 4
 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator=(vec<2, U, Q> const& v)
 {
  this->x = static_cast<T>(v.x);
  this->y = static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator+=(U scalar)
 {
  this->x += static_cast<T>(scalar);
  this->y += static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator+=(vec<1, U, Q> const& v)
 {
  this->x += static_cast<T>(v.x);
  this->y += static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator+=(vec<2, U, Q> const& v)
 {
  this->x += static_cast<T>(v.x);
  this->y += static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator-=(U scalar)
 {
  this->x -= static_cast<T>(scalar);
  this->y -= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator-=(vec<1, U, Q> const& v)
 {
  this->x -= static_cast<T>(v.x);
  this->y -= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator-=(vec<2, U, Q> const& v)
 {
  this->x -= static_cast<T>(v.x);
  this->y -= static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator*=(U scalar)
 {
  this->x *= static_cast<T>(scalar);
  this->y *= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator*=(vec<1, U, Q> const& v)
 {
  this->x *= static_cast<T>(v.x);
  this->y *= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator*=(vec<2, U, Q> const& v)
 {
  this->x *= static_cast<T>(v.x);
  this->y *= static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator/=(U scalar)
 {
  this->x /= static_cast<T>(scalar);
  this->y /= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator/=(vec<1, U, Q> const& v)
 {
  this->x /= static_cast<T>(v.x);
  this->y /= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator/=(vec<2, U, Q> const& v)
 {
  this->x /= static_cast<T>(v.x);
  this->y /= static_cast<T>(v.y);
  return *this;
 }



 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator++()
 {
  ++this->x;
  ++this->y;
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator--()
 {
  --this->x;
  --this->y;
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> vec<2, T, Q>::operator++(int)
 {
  vec<2, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> vec<2, T, Q>::operator--(int)
 {
  vec<2, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator%=(U scalar)
 {
  this->x %= static_cast<T>(scalar);
  this->y %= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator%=(vec<1, U, Q> const& v)
 {
  this->x %= static_cast<T>(v.x);
  this->y %= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator%=(vec<2, U, Q> const& v)
 {
  this->x %= static_cast<T>(v.x);
  this->y %= static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator&=(U scalar)
 {
  this->x &= static_cast<T>(scalar);
  this->y &= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator&=(vec<1, U, Q> const& v)
 {
  this->x &= static_cast<T>(v.x);
  this->y &= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator&=(vec<2, U, Q> const& v)
 {
  this->x &= static_cast<T>(v.x);
  this->y &= static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator|=(U scalar)
 {
  this->x |= static_cast<T>(scalar);
  this->y |= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator|=(vec<1, U, Q> const& v)
 {
  this->x |= static_cast<T>(v.x);
  this->y |= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator|=(vec<2, U, Q> const& v)
 {
  this->x |= static_cast<T>(v.x);
  this->y |= static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator^=(U scalar)
 {
  this->x ^= static_cast<T>(scalar);
  this->y ^= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator^=(vec<1, U, Q> const& v)
 {
  this->x ^= static_cast<T>(v.x);
  this->y ^= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator^=(vec<2, U, Q> const& v)
 {
  this->x ^= static_cast<T>(v.x);
  this->y ^= static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator<<=(U scalar)
 {
  this->x <<= static_cast<T>(scalar);
  this->y <<= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator<<=(vec<1, U, Q> const& v)
 {
  this->x <<= static_cast<T>(v.x);
  this->y <<= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator<<=(vec<2, U, Q> const& v)
 {
  this->x <<= static_cast<T>(v.x);
  this->y <<= static_cast<T>(v.y);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator>>=(U scalar)
 {
  this->x >>= static_cast<T>(scalar);
  this->y >>= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator>>=(vec<1, U, Q> const& v)
 {
  this->x >>= static_cast<T>(v.x);
  this->y >>= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<2, T, Q> & vec<2, T, Q>::operator>>=(vec<2, U, Q> const& v)
 {
  this->x >>= static_cast<T>(v.x);
  this->y >>= static_cast<T>(v.y);
  return *this;
 }



 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator+(vec<2, T, Q> const& v)
 {
  return v;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator-(vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   -v.x,
   -v.y);
 }



 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator+(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x + scalar,
   v.y + scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator+(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x + v2.x,
   v1.y + v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator+(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar + v.x,
   scalar + v.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator+(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x + v2.x,
   v1.x + v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator+(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x + v2.x,
   v1.y + v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator-(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x - scalar,
   v.y - scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator-(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x - v2.x,
   v1.y - v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator-(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar - v.x,
   scalar - v.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator-(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x - v2.x,
   v1.x - v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator-(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x - v2.x,
   v1.y - v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator*(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x * scalar,
   v.y * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator*(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x * v2.x,
   v1.y * v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator*(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar * v.x,
   scalar * v.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator*(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x * v2.x,
   v1.x * v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator*(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x * v2.x,
   v1.y * v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator/(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x / scalar,
   v.y / scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator/(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x / v2.x,
   v1.y / v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator/(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar / v.x,
   scalar / v.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator/(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x / v2.x,
   v1.x / v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator/(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x / v2.x,
   v1.y / v2.y);
 }



 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator%(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x % scalar,
   v.y % scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator%(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x % v2.x,
   v1.y % v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator%(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar % v.x,
   scalar % v.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator%(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x % v2.x,
   v1.x % v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator%(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x % v2.x,
   v1.y % v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator&(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x & scalar,
   v.y & scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator&(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x & v2.x,
   v1.y & v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator&(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar & v.x,
   scalar & v.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator&(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x & v2.x,
   v1.x & v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator&(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x & v2.x,
   v1.y & v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator|(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x | scalar,
   v.y | scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator|(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x | v2.x,
   v1.y | v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator|(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar | v.x,
   scalar | v.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator|(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x | v2.x,
   v1.x | v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator|(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x | v2.x,
   v1.y | v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator^(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x ^ scalar,
   v.y ^ scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator^(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x ^ v2.x,
   v1.y ^ v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator^(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar ^ v.x,
   scalar ^ v.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator^(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x ^ v2.x,
   v1.x ^ v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator^(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x ^ v2.x,
   v1.y ^ v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator<<(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x << scalar,
   v.y << scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator<<(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x << v2.x,
   v1.y << v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator<<(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar << v.x,
   scalar << v.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator<<(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x << v2.x,
   v1.x << v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator<<(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x << v2.x,
   v1.y << v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator>>(vec<2, T, Q> const& v, T scalar)
 {
  return vec<2, T, Q>(
   v.x >> scalar,
   v.y >> scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator>>(vec<2, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x >> v2.x,
   v1.y >> v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator>>(T scalar, vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   scalar >> v.x,
   scalar >> v.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator>>(vec<1, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x >> v2.x,
   v1.x >> v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator>>(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return vec<2, T, Q>(
   v1.x >> v2.x,
   v1.y >> v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<2, T, Q> operator~(vec<2, T, Q> const& v)
 {
  return vec<2, T, Q>(
   ~v.x,
   ~v.y);
 }



 template<typename T, qualifier Q>
 inline constexpr bool operator==(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return
   detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.x, v2.x) &&
   detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.y, v2.y);
 }

 template<typename T, qualifier Q>
 inline constexpr bool operator!=(vec<2, T, Q> const& v1, vec<2, T, Q> const& v2)
 {
  return !(v1 == v2);
 }

 template<qualifier Q>
 inline constexpr vec<2, bool, Q> operator&&(vec<2, bool, Q> const& v1, vec<2, bool, Q> const& v2)
 {
  return vec<2, bool, Q>(v1.x && v2.x, v1.y && v2.y);
 }

 template<qualifier Q>
 inline constexpr vec<2, bool, Q> operator||(vec<2, bool, Q> const& v1, vec<2, bool, Q> const& v2)
 {
  return vec<2, bool, Q>(v1.x || v2.x, v1.y || v2.y);
 }
}
# 402 "/usr/include/glm/detail/type_vec2.hpp" 2 3 4
# 6 "/usr/include/glm/ext/vector_bool2.hpp" 2 3 4

namespace glm
{






 typedef vec<2, bool, defaultp> bvec2;


}
# 6 "/usr/include/glm/vec2.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_bool2_precision.hpp" 1 3 4



       


namespace glm
{







 typedef vec<2, bool, highp> highp_bvec2;





 typedef vec<2, bool, mediump> mediump_bvec2;





 typedef vec<2, bool, lowp> lowp_bvec2;


}
# 7 "/usr/include/glm/vec2.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_float2.hpp" 1 3 4



       


namespace glm
{






 typedef vec<2, float, defaultp> vec2;


}
# 8 "/usr/include/glm/vec2.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_float2_precision.hpp" 1 3 4



       


namespace glm
{







 typedef vec<2, float, highp> highp_vec2;





 typedef vec<2, float, mediump> mediump_vec2;





 typedef vec<2, float, lowp> lowp_vec2;


}
# 9 "/usr/include/glm/vec2.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_double2.hpp" 1 3 4



       


namespace glm
{






 typedef vec<2, double, defaultp> dvec2;


}
# 10 "/usr/include/glm/vec2.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_double2_precision.hpp" 1 3 4



       


namespace glm
{







 typedef vec<2, double, highp> highp_dvec2;





 typedef vec<2, double, mediump> mediump_dvec2;





 typedef vec<2, double, lowp> lowp_dvec2;


}
# 11 "/usr/include/glm/vec2.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_int2.hpp" 1 3 4



       


namespace glm
{






 typedef vec<2, int, defaultp> ivec2;


}
# 12 "/usr/include/glm/vec2.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_int2_sized.hpp" 1 3 4
# 14 "/usr/include/glm/ext/vector_int2_sized.hpp" 3 4
       


# 1 "/usr/include/glm/ext/scalar_int_sized.hpp" 1 3 4
# 13 "/usr/include/glm/ext/scalar_int_sized.hpp" 3 4
       

# 1 "/usr/include/glm/detail/setup.hpp" 1 3 4
# 16 "/usr/include/glm/ext/scalar_int_sized.hpp" 2 3 4





namespace glm{
namespace detail
{

  typedef std::int8_t int8;
  typedef std::int16_t int16;
  typedef std::int32_t int32;






 template<>
 struct is_int<int8>
 {
  enum test {value = ~0};
 };

 template<>
 struct is_int<int16>
 {
  enum test {value = ~0};
 };

 template<>
 struct is_int<int64>
 {
  enum test {value = ~0};
 };
}






 typedef detail::int8 int8;


 typedef detail::int16 int16;


 typedef detail::int32 int32;


 typedef detail::int64 int64;


}
# 18 "/usr/include/glm/ext/vector_int2_sized.hpp" 2 3 4





namespace glm
{






 typedef vec<2, int8, defaultp> i8vec2;




 typedef vec<2, int16, defaultp> i16vec2;




 typedef vec<2, int32, defaultp> i32vec2;




 typedef vec<2, int64, defaultp> i64vec2;


}
# 13 "/usr/include/glm/vec2.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_uint2.hpp" 1 3 4



       


namespace glm
{






 typedef vec<2, unsigned int, defaultp> uvec2;


}
# 14 "/usr/include/glm/vec2.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_uint2_sized.hpp" 1 3 4
# 14 "/usr/include/glm/ext/vector_uint2_sized.hpp" 3 4
       


# 1 "/usr/include/glm/ext/scalar_uint_sized.hpp" 1 3 4
# 13 "/usr/include/glm/ext/scalar_uint_sized.hpp" 3 4
       

# 1 "/usr/include/glm/detail/setup.hpp" 1 3 4
# 16 "/usr/include/glm/ext/scalar_uint_sized.hpp" 2 3 4





namespace glm{
namespace detail
{

  typedef std::uint8_t uint8;
  typedef std::uint16_t uint16;
  typedef std::uint32_t uint32;






 template<>
 struct is_int<uint8>
 {
  enum test {value = ~0};
 };

 template<>
 struct is_int<uint16>
 {
  enum test {value = ~0};
 };

 template<>
 struct is_int<uint64>
 {
  enum test {value = ~0};
 };
}






 typedef detail::uint8 uint8;


 typedef detail::uint16 uint16;


 typedef detail::uint32 uint32;


 typedef detail::uint64 uint64;


}
# 18 "/usr/include/glm/ext/vector_uint2_sized.hpp" 2 3 4





namespace glm
{






 typedef vec<2, uint8, defaultp> u8vec2;




 typedef vec<2, uint16, defaultp> u16vec2;




 typedef vec<2, uint32, defaultp> u32vec2;




 typedef vec<2, uint64, defaultp> u64vec2;


}
# 15 "/usr/include/glm/vec2.hpp" 2 3 4
# 118 "/usr/include/glm/glm.hpp" 2 3 4
# 1 "/usr/include/glm/vec3.hpp" 1 3 4



       
# 1 "/usr/include/glm/ext/vector_bool3.hpp" 1 3 4



       
# 1 "/usr/include/glm/detail/type_vec3.hpp" 1 3 4



       
# 14 "/usr/include/glm/detail/type_vec3.hpp" 3 4
namespace glm
{
 template<typename T, qualifier Q>
 struct vec<3, T, Q>
 {


  typedef T value_type;
  typedef vec<3, T, Q> type;
  typedef vec<3, bool, Q> bool_type;





#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpedantic"
# 72 "/usr/include/glm/detail/type_vec3.hpp" 3 4
   union { T x, r, s; };
   union { T y, g, t; };
   union { T z, b, p; };
# 85 "/usr/include/glm/detail/type_vec3.hpp" 3 4
#pragma GCC diagnostic pop
# 94 "/usr/include/glm/detail/type_vec3.hpp" 3 4
  typedef length_t length_type;
  [[nodiscard]] static constexpr length_type length(){return 3;}

  [[nodiscard]] constexpr T & operator[](length_type i);
  [[nodiscard]] constexpr T const& operator[](length_type i) const;



  constexpr vec() = default;
  constexpr vec(vec const& v) = default;
  template<qualifier P>
  constexpr vec(vec<3, T, P> const& v);



  constexpr explicit vec(T scalar);
  constexpr vec(T a, T b, T c);



  template<typename U, qualifier P>
  constexpr explicit vec(vec<1, U, P> const& v);


  template<typename X, typename Y, typename Z>
  constexpr vec(X x, Y y, Z z);
  template<typename X, typename Y, typename Z>
  constexpr vec(vec<1, X, Q> const& _x, Y _y, Z _z);
  template<typename X, typename Y, typename Z>
  constexpr vec(X _x, vec<1, Y, Q> const& _y, Z _z);
  template<typename X, typename Y, typename Z>
  constexpr vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, Z _z);
  template<typename X, typename Y, typename Z>
  constexpr vec(X _x, Y _y, vec<1, Z, Q> const& _z);
  template<typename X, typename Y, typename Z>
  constexpr vec(vec<1, X, Q> const& _x, Y _y, vec<1, Z, Q> const& _z);
  template<typename X, typename Y, typename Z>
  constexpr vec(X _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z);
  template<typename X, typename Y, typename Z>
  constexpr vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z);




  template<typename A, typename B, qualifier P>
  constexpr vec(vec<2, A, P> const& _xy, B _z);

  template<typename A, typename B, qualifier P>
  constexpr vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z);

  template<typename A, typename B, qualifier P>
  constexpr vec(A _x, vec<2, B, P> const& _yz);

  template<typename A, typename B, qualifier P>
  constexpr vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz);

  template<typename U, qualifier P>
  constexpr vec(vec<4, U, P> const& v);


  template<typename U, qualifier P>
  constexpr vec(vec<3, U, P> const& v);
# 180 "/usr/include/glm/detail/type_vec3.hpp" 3 4
  constexpr vec<3, T, Q>& operator=(vec<3, T, Q> const& v) = default;

  template<typename U>
  constexpr vec<3, T, Q> & operator=(vec<3, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator+=(U scalar);
  template<typename U>
  constexpr vec<3, T, Q> & operator+=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator+=(vec<3, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator-=(U scalar);
  template<typename U>
  constexpr vec<3, T, Q> & operator-=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator-=(vec<3, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator*=(U scalar);
  template<typename U>
  constexpr vec<3, T, Q> & operator*=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator*=(vec<3, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator/=(U scalar);
  template<typename U>
  constexpr vec<3, T, Q> & operator/=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator/=(vec<3, U, Q> const& v);



  constexpr vec<3, T, Q> & operator++();
  constexpr vec<3, T, Q> & operator--();
  [[nodiscard]] constexpr vec<3, T, Q> operator++(int);
  [[nodiscard]] constexpr vec<3, T, Q> operator--(int);



  template<typename U>
  constexpr vec<3, T, Q> & operator%=(U scalar);
  template<typename U>
  constexpr vec<3, T, Q> & operator%=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator%=(vec<3, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator&=(U scalar);
  template<typename U>
  constexpr vec<3, T, Q> & operator&=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator&=(vec<3, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator|=(U scalar);
  template<typename U>
  constexpr vec<3, T, Q> & operator|=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator|=(vec<3, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator^=(U scalar);
  template<typename U>
  constexpr vec<3, T, Q> & operator^=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator^=(vec<3, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator<<=(U scalar);
  template<typename U>
  constexpr vec<3, T, Q> & operator<<=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator<<=(vec<3, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator>>=(U scalar);
  template<typename U>
  constexpr vec<3, T, Q> & operator>>=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<3, T, Q> & operator>>=(vec<3, U, Q> const& v);
 };



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator+(vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator-(vec<3, T, Q> const& v);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator+(vec<3, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator+(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator+(T scalar, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator+(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator+(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator-(vec<3, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator-(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator-(T scalar, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator-(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator-(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator*(vec<3, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator*(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator*(T scalar, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator*(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator*(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator/(vec<3, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator/(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator/(T scalar, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator/(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator/(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator%(vec<3, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator%(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator%(T scalar, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator%(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator%(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator&(vec<3, T, Q> const& v1, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator&(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator&(T scalar, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator&(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator&(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator|(vec<3, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator|(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator|(T scalar, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator|(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator|(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator^(vec<3, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator^(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator^(T scalar, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator^(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator^(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator<<(vec<3, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator<<(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator<<(T scalar, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator<<(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator<<(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator>>(vec<3, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator>>(vec<3, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator>>(T scalar, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator>>(vec<1, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator>>(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator~(vec<3, T, Q> const& v);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator==(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator!=(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2);

 template<qualifier Q>
 [[nodiscard]] constexpr vec<3, bool, Q> operator&&(vec<3, bool, Q> const& v1, vec<3, bool, Q> const& v2);

 template<qualifier Q>
 [[nodiscard]] constexpr vec<3, bool, Q> operator||(vec<3, bool, Q> const& v1, vec<3, bool, Q> const& v2);
}


# 1 "/usr/include/glm/detail/type_vec3.inl" 1 3 4




namespace glm
{
# 25 "/usr/include/glm/detail/type_vec3.inl" 3 4
 template<typename T, qualifier Q>
 template<qualifier P>
 inline constexpr vec<3, T, Q>::vec(vec<3, T, P> const& v)
  : x(v.x), y(v.y), z(v.z)
 {}



 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q>::vec(T scalar)
  : x(scalar), y(scalar), z(scalar)
 {}

 template <typename T, qualifier Q>
 inline constexpr vec<3, T, Q>::vec(T _x, T _y, T _z)
  : x(_x), y(_y), z(_z)
 {}



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr vec<3, T, Q>::vec(vec<1, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.x))
  , z(static_cast<T>(v.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z>
 inline constexpr vec<3, T, Q>::vec(X _x, Y _y, Z _z)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z>
 inline constexpr vec<3, T, Q>::vec(vec<1, X, Q> const& _x, Y _y, Z _z)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z>
 inline constexpr vec<3, T, Q>::vec(X _x, vec<1, Y, Q> const& _y, Z _z)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z>
 inline constexpr vec<3, T, Q>::vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, Z _z)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z>
 inline constexpr vec<3, T, Q>::vec(X _x, Y _y, vec<1, Z, Q> const& _z)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z>
 inline constexpr vec<3, T, Q>::vec(vec<1, X, Q> const& _x, Y _y, vec<1, Z, Q> const& _z)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z>
 inline constexpr vec<3, T, Q>::vec(X _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z>
 inline constexpr vec<3, T, Q>::vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z.x))
 {}



 template<typename T, qualifier Q>
 template<typename A, typename B, qualifier P>
 inline constexpr vec<3, T, Q>::vec(vec<2, A, P> const& _xy, B _z)
  : x(static_cast<T>(_xy.x))
  , y(static_cast<T>(_xy.y))
  , z(static_cast<T>(_z))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, qualifier P>
 inline constexpr vec<3, T, Q>::vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z)
  : x(static_cast<T>(_xy.x))
  , y(static_cast<T>(_xy.y))
  , z(static_cast<T>(_z.x))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, qualifier P>
 inline constexpr vec<3, T, Q>::vec(A _x, vec<2, B, P> const& _yz)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_yz.x))
  , z(static_cast<T>(_yz.y))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, qualifier P>
 inline constexpr vec<3, T, Q>::vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_yz.x))
  , z(static_cast<T>(_yz.y))
 {}

 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr vec<3, T, Q>::vec(vec<3, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.y))
  , z(static_cast<T>(v.z))
 {}

 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr vec<3, T, Q>::vec(vec<4, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.y))
  , z(static_cast<T>(v.z))
 {}



 template<typename T, qualifier Q>
 inline constexpr T & vec<3, T, Q>::operator[](typename vec<3, T, Q>::length_type i)
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));
  switch(i)
  {
  default:
   case 0:
  return x;
   case 1:
  return y;
   case 2:
  return z;
  }
 }

 template<typename T, qualifier Q>
 inline constexpr T const& vec<3, T, Q>::operator[](typename vec<3, T, Q>::length_type i) const
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));
  switch(i)
  {
  default:
  case 0:
   return x;
  case 1:
   return y;
  case 2:
   return z;
  }
 }
# 214 "/usr/include/glm/detail/type_vec3.inl" 3 4
 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q>& vec<3, T, Q>::operator=(vec<3, U, Q> const& v)
 {
  this->x = static_cast<T>(v.x);
  this->y = static_cast<T>(v.y);
  this->z = static_cast<T>(v.z);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator+=(U scalar)
 {
  this->x += static_cast<T>(scalar);
  this->y += static_cast<T>(scalar);
  this->z += static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator+=(vec<1, U, Q> const& v)
 {
  this->x += static_cast<T>(v.x);
  this->y += static_cast<T>(v.x);
  this->z += static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator+=(vec<3, U, Q> const& v)
 {
  this->x += static_cast<T>(v.x);
  this->y += static_cast<T>(v.y);
  this->z += static_cast<T>(v.z);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator-=(U scalar)
 {
  this->x -= static_cast<T>(scalar);
  this->y -= static_cast<T>(scalar);
  this->z -= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator-=(vec<1, U, Q> const& v)
 {
  this->x -= static_cast<T>(v.x);
  this->y -= static_cast<T>(v.x);
  this->z -= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator-=(vec<3, U, Q> const& v)
 {
  this->x -= static_cast<T>(v.x);
  this->y -= static_cast<T>(v.y);
  this->z -= static_cast<T>(v.z);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator*=(U scalar)
 {
  this->x *= static_cast<T>(scalar);
  this->y *= static_cast<T>(scalar);
  this->z *= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator*=(vec<1, U, Q> const& v)
 {
  this->x *= static_cast<T>(v.x);
  this->y *= static_cast<T>(v.x);
  this->z *= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator*=(vec<3, U, Q> const& v)
 {
  this->x *= static_cast<T>(v.x);
  this->y *= static_cast<T>(v.y);
  this->z *= static_cast<T>(v.z);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator/=(U v)
 {
  this->x /= static_cast<T>(v);
  this->y /= static_cast<T>(v);
  this->z /= static_cast<T>(v);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator/=(vec<1, U, Q> const& v)
 {
  this->x /= static_cast<T>(v.x);
  this->y /= static_cast<T>(v.x);
  this->z /= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator/=(vec<3, U, Q> const& v)
 {
  this->x /= static_cast<T>(v.x);
  this->y /= static_cast<T>(v.y);
  this->z /= static_cast<T>(v.z);
  return *this;
 }



 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator++()
 {
  ++this->x;
  ++this->y;
  ++this->z;
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator--()
 {
  --this->x;
  --this->y;
  --this->z;
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> vec<3, T, Q>::operator++(int)
 {
  vec<3, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> vec<3, T, Q>::operator--(int)
 {
  vec<3, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator%=(U scalar)
 {
  this->x %= scalar;
  this->y %= scalar;
  this->z %= scalar;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator%=(vec<1, U, Q> const& v)
 {
  this->x %= v.x;
  this->y %= v.x;
  this->z %= v.x;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator%=(vec<3, U, Q> const& v)
 {
  this->x %= v.x;
  this->y %= v.y;
  this->z %= v.z;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator&=(U scalar)
 {
  this->x &= scalar;
  this->y &= scalar;
  this->z &= scalar;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator&=(vec<1, U, Q> const& v)
 {
  this->x &= v.x;
  this->y &= v.x;
  this->z &= v.x;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator&=(vec<3, U, Q> const& v)
 {
  this->x &= v.x;
  this->y &= v.y;
  this->z &= v.z;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator|=(U scalar)
 {
  this->x |= scalar;
  this->y |= scalar;
  this->z |= scalar;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator|=(vec<1, U, Q> const& v)
 {
  this->x |= v.x;
  this->y |= v.x;
  this->z |= v.x;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator|=(vec<3, U, Q> const& v)
 {
  this->x |= v.x;
  this->y |= v.y;
  this->z |= v.z;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator^=(U scalar)
 {
  this->x ^= scalar;
  this->y ^= scalar;
  this->z ^= scalar;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator^=(vec<1, U, Q> const& v)
 {
  this->x ^= v.x;
  this->y ^= v.x;
  this->z ^= v.x;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator^=(vec<3, U, Q> const& v)
 {
  this->x ^= v.x;
  this->y ^= v.y;
  this->z ^= v.z;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator<<=(U scalar)
 {
  this->x <<= scalar;
  this->y <<= scalar;
  this->z <<= scalar;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator<<=(vec<1, U, Q> const& v)
 {
  this->x <<= static_cast<T>(v.x);
  this->y <<= static_cast<T>(v.x);
  this->z <<= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator<<=(vec<3, U, Q> const& v)
 {
  this->x <<= static_cast<T>(v.x);
  this->y <<= static_cast<T>(v.y);
  this->z <<= static_cast<T>(v.z);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator>>=(U scalar)
 {
  this->x >>= static_cast<T>(scalar);
  this->y >>= static_cast<T>(scalar);
  this->z >>= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator>>=(vec<1, U, Q> const& v)
 {
  this->x >>= static_cast<T>(v.x);
  this->y >>= static_cast<T>(v.x);
  this->z >>= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<3, T, Q> & vec<3, T, Q>::operator>>=(vec<3, U, Q> const& v)
 {
  this->x >>= static_cast<T>(v.x);
  this->y >>= static_cast<T>(v.y);
  this->z >>= static_cast<T>(v.z);
  return *this;
 }



 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator+(vec<3, T, Q> const& v)
 {
  return v;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator-(vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   -v.x,
   -v.y,
   -v.z);
 }



 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator+(vec<3, T, Q> const& v, T scalar)
 {
  return vec<3, T, Q>(
   v.x + scalar,
   v.y + scalar,
   v.z + scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator+(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<3, T, Q>(
   v.x + scalar.x,
   v.y + scalar.x,
   v.z + scalar.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator+(T scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar + v.x,
   scalar + v.y,
   scalar + v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator+(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar.x + v.x,
   scalar.x + v.y,
   scalar.x + v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator+(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return vec<3, T, Q>(
   v1.x + v2.x,
   v1.y + v2.y,
   v1.z + v2.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator-(vec<3, T, Q> const& v, T scalar)
 {
  return vec<3, T, Q>(
   v.x - scalar,
   v.y - scalar,
   v.z - scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator-(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<3, T, Q>(
   v.x - scalar.x,
   v.y - scalar.x,
   v.z - scalar.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator-(T scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar - v.x,
   scalar - v.y,
   scalar - v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator-(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar.x - v.x,
   scalar.x - v.y,
   scalar.x - v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator-(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return vec<3, T, Q>(
   v1.x - v2.x,
   v1.y - v2.y,
   v1.z - v2.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator*(vec<3, T, Q> const& v, T scalar)
 {
  return vec<3, T, Q>(
   v.x * scalar,
   v.y * scalar,
   v.z * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator*(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<3, T, Q>(
   v.x * scalar.x,
   v.y * scalar.x,
   v.z * scalar.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator*(T scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar * v.x,
   scalar * v.y,
   scalar * v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator*(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar.x * v.x,
   scalar.x * v.y,
   scalar.x * v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator*(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return vec<3, T, Q>(
   v1.x * v2.x,
   v1.y * v2.y,
   v1.z * v2.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator/(vec<3, T, Q> const& v, T scalar)
 {
  return vec<3, T, Q>(
   v.x / scalar,
   v.y / scalar,
   v.z / scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator/(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<3, T, Q>(
   v.x / scalar.x,
   v.y / scalar.x,
   v.z / scalar.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator/(T scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar / v.x,
   scalar / v.y,
   scalar / v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator/(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar.x / v.x,
   scalar.x / v.y,
   scalar.x / v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator/(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return vec<3, T, Q>(
   v1.x / v2.x,
   v1.y / v2.y,
   v1.z / v2.z);
 }



 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator%(vec<3, T, Q> const& v, T scalar)
 {
  return vec<3, T, Q>(
   v.x % scalar,
   v.y % scalar,
   v.z % scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator%(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<3, T, Q>(
   v.x % scalar.x,
   v.y % scalar.x,
   v.z % scalar.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator%(T scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar % v.x,
   scalar % v.y,
   scalar % v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator%(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar.x % v.x,
   scalar.x % v.y,
   scalar.x % v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator%(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return vec<3, T, Q>(
   v1.x % v2.x,
   v1.y % v2.y,
   v1.z % v2.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator&(vec<3, T, Q> const& v, T scalar)
 {
  return vec<3, T, Q>(
   v.x & scalar,
   v.y & scalar,
   v.z & scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator&(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<3, T, Q>(
   v.x & scalar.x,
   v.y & scalar.x,
   v.z & scalar.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator&(T scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar & v.x,
   scalar & v.y,
   scalar & v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator&(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar.x & v.x,
   scalar.x & v.y,
   scalar.x & v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator&(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return vec<3, T, Q>(
   v1.x & v2.x,
   v1.y & v2.y,
   v1.z & v2.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator|(vec<3, T, Q> const& v, T scalar)
 {
  return vec<3, T, Q>(
   v.x | scalar,
   v.y | scalar,
   v.z | scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator|(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<3, T, Q>(
   v.x | scalar.x,
   v.y | scalar.x,
   v.z | scalar.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator|(T scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar | v.x,
   scalar | v.y,
   scalar | v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator|(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar.x | v.x,
   scalar.x | v.y,
   scalar.x | v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator|(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return vec<3, T, Q>(
   v1.x | v2.x,
   v1.y | v2.y,
   v1.z | v2.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator^(vec<3, T, Q> const& v, T scalar)
 {
  return vec<3, T, Q>(
   v.x ^ scalar,
   v.y ^ scalar,
   v.z ^ scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator^(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<3, T, Q>(
   v.x ^ scalar.x,
   v.y ^ scalar.x,
   v.z ^ scalar.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator^(T scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar ^ v.x,
   scalar ^ v.y,
   scalar ^ v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator^(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar.x ^ v.x,
   scalar.x ^ v.y,
   scalar.x ^ v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator^(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return vec<3, T, Q>(
   v1.x ^ v2.x,
   v1.y ^ v2.y,
   v1.z ^ v2.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator<<(vec<3, T, Q> const& v, T scalar)
 {
  return vec<3, T, Q>(
   v.x << scalar,
   v.y << scalar,
   v.z << scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator<<(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<3, T, Q>(
   v.x << scalar.x,
   v.y << scalar.x,
   v.z << scalar.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator<<(T scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar << v.x,
   scalar << v.y,
   scalar << v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator<<(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar.x << v.x,
   scalar.x << v.y,
   scalar.x << v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator<<(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return vec<3, T, Q>(
   v1.x << v2.x,
   v1.y << v2.y,
   v1.z << v2.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator>>(vec<3, T, Q> const& v, T scalar)
 {
  return vec<3, T, Q>(
   v.x >> scalar,
   v.y >> scalar,
   v.z >> scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator>>(vec<3, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<3, T, Q>(
   v.x >> scalar.x,
   v.y >> scalar.x,
   v.z >> scalar.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator>>(T scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar >> v.x,
   scalar >> v.y,
   scalar >> v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator>>(vec<1, T, Q> const& scalar, vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   scalar.x >> v.x,
   scalar.x >> v.y,
   scalar.x >> v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator>>(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return vec<3, T, Q>(
   v1.x >> v2.x,
   v1.y >> v2.y,
   v1.z >> v2.z);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator~(vec<3, T, Q> const& v)
 {
  return vec<3, T, Q>(
   ~v.x,
   ~v.y,
   ~v.z);
 }



 template<typename T, qualifier Q>
 inline constexpr bool operator==(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return
   detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.x, v2.x) &&
   detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.y, v2.y) &&
   detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.z, v2.z);
 }

 template<typename T, qualifier Q>
 inline constexpr bool operator!=(vec<3, T, Q> const& v1, vec<3, T, Q> const& v2)
 {
  return !(v1 == v2);
 }

 template<qualifier Q>
 inline constexpr vec<3, bool, Q> operator&&(vec<3, bool, Q> const& v1, vec<3, bool, Q> const& v2)
 {
  return vec<3, bool, Q>(v1.x && v2.x, v1.y && v2.y, v1.z && v2.z);
 }

 template<qualifier Q>
 inline constexpr vec<3, bool, Q> operator||(vec<3, bool, Q> const& v1, vec<3, bool, Q> const& v2)
 {
  return vec<3, bool, Q>(v1.x || v2.x, v1.y || v2.y, v1.z || v2.z);
 }
}
# 436 "/usr/include/glm/detail/type_vec3.hpp" 2 3 4
# 6 "/usr/include/glm/ext/vector_bool3.hpp" 2 3 4

namespace glm
{






 typedef vec<3, bool, defaultp> bvec3;


}
# 6 "/usr/include/glm/vec3.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_bool3_precision.hpp" 1 3 4



       


namespace glm
{







 typedef vec<3, bool, highp> highp_bvec3;





 typedef vec<3, bool, mediump> mediump_bvec3;





 typedef vec<3, bool, lowp> lowp_bvec3;


}
# 7 "/usr/include/glm/vec3.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_float3.hpp" 1 3 4



       


namespace glm
{






 typedef vec<3, float, defaultp> vec3;


}
# 8 "/usr/include/glm/vec3.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_float3_precision.hpp" 1 3 4



       


namespace glm
{







 typedef vec<3, float, highp> highp_vec3;





 typedef vec<3, float, mediump> mediump_vec3;





 typedef vec<3, float, lowp> lowp_vec3;


}
# 9 "/usr/include/glm/vec3.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_double3.hpp" 1 3 4



       


namespace glm
{






 typedef vec<3, double, defaultp> dvec3;


}
# 10 "/usr/include/glm/vec3.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_double3_precision.hpp" 1 3 4



       


namespace glm
{
# 17 "/usr/include/glm/ext/vector_double3_precision.hpp" 3 4
 typedef vec<3, double, highp> highp_dvec3;






 typedef vec<3, double, mediump> mediump_dvec3;






 typedef vec<3, double, lowp> lowp_dvec3;


}
# 11 "/usr/include/glm/vec3.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_int3.hpp" 1 3 4



       


namespace glm
{






 typedef vec<3, int, defaultp> ivec3;


}
# 12 "/usr/include/glm/vec3.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_int3_sized.hpp" 1 3 4
# 14 "/usr/include/glm/ext/vector_int3_sized.hpp" 3 4
       
# 23 "/usr/include/glm/ext/vector_int3_sized.hpp" 3 4
namespace glm
{






 typedef vec<3, int8, defaultp> i8vec3;




 typedef vec<3, int16, defaultp> i16vec3;




 typedef vec<3, int32, defaultp> i32vec3;




 typedef vec<3, int64, defaultp> i64vec3;


}
# 13 "/usr/include/glm/vec3.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_uint3.hpp" 1 3 4



       


namespace glm
{






 typedef vec<3, unsigned int, defaultp> uvec3;


}
# 14 "/usr/include/glm/vec3.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_uint3_sized.hpp" 1 3 4
# 14 "/usr/include/glm/ext/vector_uint3_sized.hpp" 3 4
       
# 23 "/usr/include/glm/ext/vector_uint3_sized.hpp" 3 4
namespace glm
{






 typedef vec<3, uint8, defaultp> u8vec3;




 typedef vec<3, uint16, defaultp> u16vec3;




 typedef vec<3, uint32, defaultp> u32vec3;




 typedef vec<3, uint64, defaultp> u64vec3;


}
# 15 "/usr/include/glm/vec3.hpp" 2 3 4
# 119 "/usr/include/glm/glm.hpp" 2 3 4
# 1 "/usr/include/glm/vec4.hpp" 1 3 4



       
# 1 "/usr/include/glm/ext/vector_bool4.hpp" 1 3 4



       
# 1 "/usr/include/glm/detail/type_vec4.hpp" 1 3 4



       
# 14 "/usr/include/glm/detail/type_vec4.hpp" 3 4
namespace glm
{
 template<typename T, qualifier Q>
 struct vec<4, T, Q>
 {


  typedef T value_type;
  typedef vec<4, T, Q> type;
  typedef vec<4, bool, Q> bool_type;





#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpedantic"
# 68 "/usr/include/glm/detail/type_vec4.hpp" 3 4
   union { T x, r, s; };
   union { T y, g, t; };
   union { T z, b, p; };
   union { T w, a, q; };
# 82 "/usr/include/glm/detail/type_vec4.hpp" 3 4
#pragma GCC diagnostic pop







  typedef length_t length_type;


  [[nodiscard]] static constexpr length_type length(){return 4;}

  [[nodiscard]] constexpr T & operator[](length_type i);
  [[nodiscard]] constexpr T const& operator[](length_type i) const;



  constexpr vec() = default;
  constexpr vec(vec<4, T, Q> const& v) = default;
  template<qualifier P>
  constexpr vec(vec<4, T, P> const& v);



  constexpr explicit vec(T scalar);
  constexpr vec(T x, T y, T z, T w);



  template<typename U, qualifier P>
  constexpr explicit vec(vec<1, U, P> const& v);


  template<typename X, typename Y, typename Z, typename W>
  constexpr vec(X _x, Y _y, Z _z, W _w);
  template<typename X, typename Y, typename Z, typename W>
  constexpr vec(vec<1, X, Q> const& _x, Y _y, Z _z, W _w);
  template<typename X, typename Y, typename Z, typename W>
  constexpr vec(X _x, vec<1, Y, Q> const& _y, Z _z, W _w);
  template<typename X, typename Y, typename Z, typename W>
  constexpr vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, Z _z, W _w);
  template<typename X, typename Y, typename Z, typename W>
  constexpr vec(X _x, Y _y, vec<1, Z, Q> const& _z, W _w);
  template<typename X, typename Y, typename Z, typename W>
  constexpr vec(vec<1, X, Q> const& _x, Y _y, vec<1, Z, Q> const& _z, W _w);
  template<typename X, typename Y, typename Z, typename W>
  constexpr vec(X _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, W _w);
  template<typename X, typename Y, typename Z, typename W>
  constexpr vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, W _w);
  template<typename X, typename Y, typename Z, typename W>
  constexpr vec(vec<1, X, Q> const& _x, Y _y, Z _z, vec<1, W, Q> const& _w);
  template<typename X, typename Y, typename Z, typename W>
  constexpr vec(X _x, vec<1, Y, Q> const& _y, Z _z, vec<1, W, Q> const& _w);
  template<typename X, typename Y, typename Z, typename W>
  constexpr vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, Z _z, vec<1, W, Q> const& _w);
  template<typename X, typename Y, typename Z, typename W>
  constexpr vec(X _x, Y _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w);
  template<typename X, typename Y, typename Z, typename W>
  constexpr vec(vec<1, X, Q> const& _x, Y _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w);
  template<typename X, typename Y, typename Z, typename W>
  constexpr vec(X _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w);
  template<typename X, typename Y, typename Z, typename W>
  constexpr vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w);




  template<typename A, typename B, typename C, qualifier P>
  constexpr vec(vec<2, A, P> const& _xy, B _z, C _w);

  template<typename A, typename B, typename C, qualifier P>
  constexpr vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z, C _w);

  template<typename A, typename B, typename C, qualifier P>
  constexpr vec(vec<2, A, P> const& _xy, B _z, vec<1, C, P> const& _w);

  template<typename A, typename B, typename C, qualifier P>
  constexpr vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z, vec<1, C, P> const& _w);

  template<typename A, typename B, typename C, qualifier P>
  constexpr vec(A _x, vec<2, B, P> const& _yz, C _w);

  template<typename A, typename B, typename C, qualifier P>
  constexpr vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz, C _w);

  template<typename A, typename B, typename C, qualifier P>
  constexpr vec(A _x, vec<2, B, P> const& _yz, vec<1, C, P> const& _w);

  template<typename A, typename B, typename C, qualifier P>
  constexpr vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz, vec<1, C, P> const& _w);

  template<typename A, typename B, typename C, qualifier P>
  constexpr vec(A _x, B _y, vec<2, C, P> const& _zw);

  template<typename A, typename B, typename C, qualifier P>
  constexpr vec(vec<1, A, P> const& _x, B _y, vec<2, C, P> const& _zw);

  template<typename A, typename B, typename C, qualifier P>
  constexpr vec(A _x, vec<1, B, P> const& _y, vec<2, C, P> const& _zw);

  template<typename A, typename B, typename C, qualifier P>
  constexpr vec(vec<1, A, P> const& _x, vec<1, B, P> const& _y, vec<2, C, P> const& _zw);

  template<typename A, typename B, qualifier P>
  constexpr vec(vec<3, A, P> const& _xyz, B _w);

  template<typename A, typename B, qualifier P>
  constexpr vec(vec<3, A, P> const& _xyz, vec<1, B, P> const& _w);

  template<typename A, typename B, qualifier P>
  constexpr vec(A _x, vec<3, B, P> const& _yzw);

  template<typename A, typename B, qualifier P>
  constexpr vec(vec<1, A, P> const& _x, vec<3, B, P> const& _yzw);

  template<typename A, typename B, qualifier P>
  constexpr vec(vec<2, A, P> const& _xy, vec<2, B, P> const& _zw);


  template<typename U, qualifier P>
  constexpr vec(vec<4, U, P> const& v);
# 252 "/usr/include/glm/detail/type_vec4.hpp" 3 4
  constexpr vec<4, T, Q>& operator=(vec<4, T, Q> const& v) = default;

  template<typename U>
  constexpr vec<4, T, Q>& operator=(vec<4, U, Q> const& v);
  template<typename U>
  constexpr vec<4, T, Q>& operator+=(U scalar);
  template<typename U>
  constexpr vec<4, T, Q>& operator+=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<4, T, Q>& operator+=(vec<4, U, Q> const& v);
  template<typename U>
  constexpr vec<4, T, Q>& operator-=(U scalar);
  template<typename U>
  constexpr vec<4, T, Q>& operator-=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<4, T, Q>& operator-=(vec<4, U, Q> const& v);
  template<typename U>
  constexpr vec<4, T, Q>& operator*=(U scalar);
  template<typename U>
  constexpr vec<4, T, Q>& operator*=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<4, T, Q>& operator*=(vec<4, U, Q> const& v);
  template<typename U>
  constexpr vec<4, T, Q>& operator/=(U scalar);
  template<typename U>
  constexpr vec<4, T, Q>& operator/=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<4, T, Q>& operator/=(vec<4, U, Q> const& v);



  constexpr vec<4, T, Q> & operator++();
  constexpr vec<4, T, Q> & operator--();
  [[nodiscard]] constexpr vec<4, T, Q> operator++(int);
  [[nodiscard]] constexpr vec<4, T, Q> operator--(int);



  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator%=(U scalar);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator%=(vec<1, U, Q> const& v);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator%=(vec<4, U, Q> const& v);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator&=(U scalar);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator&=(vec<1, U, Q> const& v);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator&=(vec<4, U, Q> const& v);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator|=(U scalar);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator|=(vec<1, U, Q> const& v);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator|=(vec<4, U, Q> const& v);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator^=(U scalar);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator^=(vec<1, U, Q> const& v);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator^=(vec<4, U, Q> const& v);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator<<=(U scalar);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator<<=(vec<1, U, Q> const& v);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator<<=(vec<4, U, Q> const& v);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator>>=(U scalar);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator>>=(vec<1, U, Q> const& v);
  template<typename U>
  [[nodiscard]] constexpr vec<4, T, Q> & operator>>=(vec<4, U, Q> const& v);
 };



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator+(vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator-(vec<4, T, Q> const& v);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator+(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator+(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator+(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator+(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator+(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator-(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator-(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator-(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator-(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator-(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator*(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator*(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator*(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator*(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator*(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator/(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator/(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator/(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator/(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator/(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator%(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator%(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator%(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator%(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator%(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator&(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator&(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator&(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator&(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator&(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator|(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator|(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator|(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator|(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator|(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator^(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator^(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator^(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator^(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator^(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator<<(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator<<(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator<<(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator<<(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator<<(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator>>(vec<4, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator>>(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator>>(T scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator>>(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator>>(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator~(vec<4, T, Q> const& v);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator==(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator!=(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2);

 template<qualifier Q>
 [[nodiscard]] constexpr vec<4, bool, Q> operator&&(vec<4, bool, Q> const& v1, vec<4, bool, Q> const& v2);

 template<qualifier Q>
 [[nodiscard]] constexpr vec<4, bool, Q> operator||(vec<4, bool, Q> const& v1, vec<4, bool, Q> const& v2);
}


# 1 "/usr/include/glm/detail/type_vec4.inl" 1 3 4




namespace glm{
namespace detail
{
 template<typename T, qualifier Q, bool Aligned>
 struct compute_vec4_add
 {
  inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_vec4_sub
 {
  inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_vec4_mul
 {
  inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x * b.x, a.y * b.y, a.z * b.z, a.w * b.w);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_vec4_div
 {
  inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x / b.x, a.y / b.y, a.z / b.z, a.w / b.w);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_vec4_mod
 {
  inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x % b.x, a.y % b.y, a.z % b.z, a.w % b.w);
  }
 };

 template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_and
 {
  inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x & b.x, a.y & b.y, a.z & b.z, a.w & b.w);
  }
 };

 template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_or
 {
  inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x | b.x, a.y | b.y, a.z | b.z, a.w | b.w);
  }
 };

 template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_xor
 {
  inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x ^ b.x, a.y ^ b.y, a.z ^ b.z, a.w ^ b.w);
  }
 };

 template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_shift_left
 {
  inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x << b.x, a.y << b.y, a.z << b.z, a.w << b.w);
  }
 };

 template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_shift_right
 {
  inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(a.x >> b.x, a.y >> b.y, a.z >> b.z, a.w >> b.w);
  }
 };

 template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_equal
 {
  inline constexpr static bool call(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
  {
   return
    detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.x, v2.x) &&
    detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.y, v2.y) &&
    detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.z, v2.z) &&
    detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.w, v2.w);
  }
 };

 template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_nequal
 {
  inline constexpr static bool call(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
  {
   return !compute_vec4_equal<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(v1, v2);
  }
 };

 template<typename T, qualifier Q, int IsInt, std::size_t Size, bool Aligned>
 struct compute_vec4_bitwise_not
 {
  inline constexpr static vec<4, T, Q> call(vec<4, T, Q> const& v)
  {
   return vec<4, T, Q>(~v.x, ~v.y, ~v.z, ~v.w);
  }
 };
}
# 148 "/usr/include/glm/detail/type_vec4.inl" 3 4
 template<typename T, qualifier Q>
 template<qualifier P>
 inline constexpr vec<4, T, Q>::vec(vec<4, T, P> const& v)
  : x(v.x), y(v.y), z(v.z), w(v.w)
 {}



 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q>::vec(T scalar)
  : x(scalar), y(scalar), z(scalar), w(scalar)
 {}

 template <typename T, qualifier Q>
 inline constexpr vec<4, T, Q>::vec(T _x, T _y, T _z, T _w)
  : x(_x), y(_y), z(_z), w(_w)
 {}



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr vec<4, T, Q>::vec(vec<1, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.x))
  , z(static_cast<T>(v.x))
  , w(static_cast<T>(v.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline constexpr vec<4, T, Q>::vec(X _x, Y _y, Z _z, W _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline constexpr vec<4, T, Q>::vec(vec<1, X, Q> const& _x, Y _y, Z _z, W _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline constexpr vec<4, T, Q>::vec(X _x, vec<1, Y, Q> const& _y, Z _z, W _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline constexpr vec<4, T, Q>::vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, Z _z, W _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline constexpr vec<4, T, Q>::vec(X _x, Y _y, vec<1, Z, Q> const& _z, W _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline constexpr vec<4, T, Q>::vec(vec<1, X, Q> const& _x, Y _y, vec<1, Z, Q> const& _z, W _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline constexpr vec<4, T, Q>::vec(X _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, W _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline constexpr vec<4, T, Q>::vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, W _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline constexpr vec<4, T, Q>::vec(vec<1, X, Q> const& _x, Y _y, Z _z, vec<1, W, Q> const& _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline constexpr vec<4, T, Q>::vec(X _x, vec<1, Y, Q> const& _y, Z _z, vec<1, W, Q> const& _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline constexpr vec<4, T, Q>::vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, Z _z, vec<1, W, Q> const& _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline constexpr vec<4, T, Q>::vec(X _x, Y _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline constexpr vec<4, T, Q>::vec(vec<1, X, Q> const& _x, Y _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline constexpr vec<4, T, Q>::vec(X _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename X, typename Y, typename Z, typename W>
 inline constexpr vec<4, T, Q>::vec(vec<1, X, Q> const& _x, vec<1, Y, Q> const& _y, vec<1, Z, Q> const& _z, vec<1, W, Q> const& _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w.x))
 {}



 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline constexpr vec<4, T, Q>::vec(vec<2, A, P> const& _xy, B _z, C _w)
  : x(static_cast<T>(_xy.x))
  , y(static_cast<T>(_xy.y))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline constexpr vec<4, T, Q>::vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z, C _w)
  : x(static_cast<T>(_xy.x))
  , y(static_cast<T>(_xy.y))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline constexpr vec<4, T, Q>::vec(vec<2, A, P> const& _xy, B _z, vec<1, C, P> const& _w)
  : x(static_cast<T>(_xy.x))
  , y(static_cast<T>(_xy.y))
  , z(static_cast<T>(_z))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline constexpr vec<4, T, Q>::vec(vec<2, A, P> const& _xy, vec<1, B, P> const& _z, vec<1, C, P> const& _w)
  : x(static_cast<T>(_xy.x))
  , y(static_cast<T>(_xy.y))
  , z(static_cast<T>(_z.x))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline constexpr vec<4, T, Q>::vec(A _x, vec<2, B, P> const& _yz, C _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_yz.x))
  , z(static_cast<T>(_yz.y))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline constexpr vec<4, T, Q>::vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz, C _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_yz.x))
  , z(static_cast<T>(_yz.y))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline constexpr vec<4, T, Q>::vec(A _x, vec<2, B, P> const& _yz, vec<1, C, P> const& _w)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_yz.x))
  , z(static_cast<T>(_yz.y))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline constexpr vec<4, T, Q>::vec(vec<1, A, P> const& _x, vec<2, B, P> const& _yz, vec<1, C, P> const& _w)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_yz.x))
  , z(static_cast<T>(_yz.y))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline constexpr vec<4, T, Q>::vec(A _x, B _y, vec<2, C, P> const& _zw)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_zw.x))
  , w(static_cast<T>(_zw.y))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline constexpr vec<4, T, Q>::vec(vec<1, A, P> const& _x, B _y, vec<2, C, P> const& _zw)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y))
  , z(static_cast<T>(_zw.x))
  , w(static_cast<T>(_zw.y))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline constexpr vec<4, T, Q>::vec(A _x, vec<1, B, P> const& _y, vec<2, C, P> const& _zw)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_zw.x))
  , w(static_cast<T>(_zw.y))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, typename C, qualifier P>
 inline constexpr vec<4, T, Q>::vec(vec<1, A, P> const& _x, vec<1, B, P> const& _y, vec<2, C, P> const& _zw)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_y.x))
  , z(static_cast<T>(_zw.x))
  , w(static_cast<T>(_zw.y))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, qualifier P>
 inline constexpr vec<4, T, Q>::vec(vec<3, A, P> const& _xyz, B _w)
  : x(static_cast<T>(_xyz.x))
  , y(static_cast<T>(_xyz.y))
  , z(static_cast<T>(_xyz.z))
  , w(static_cast<T>(_w))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, qualifier P>
 inline constexpr vec<4, T, Q>::vec(vec<3, A, P> const& _xyz, vec<1, B, P> const& _w)
  : x(static_cast<T>(_xyz.x))
  , y(static_cast<T>(_xyz.y))
  , z(static_cast<T>(_xyz.z))
  , w(static_cast<T>(_w.x))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, qualifier P>
 inline constexpr vec<4, T, Q>::vec(A _x, vec<3, B, P> const& _yzw)
  : x(static_cast<T>(_x))
  , y(static_cast<T>(_yzw.x))
  , z(static_cast<T>(_yzw.y))
  , w(static_cast<T>(_yzw.z))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, qualifier P>
 inline constexpr vec<4, T, Q>::vec(vec<1, A, P> const& _x, vec<3, B, P> const& _yzw)
  : x(static_cast<T>(_x.x))
  , y(static_cast<T>(_yzw.x))
  , z(static_cast<T>(_yzw.y))
  , w(static_cast<T>(_yzw.z))
 {}

 template<typename T, qualifier Q>
 template<typename A, typename B, qualifier P>
 inline constexpr vec<4, T, Q>::vec(vec<2, A, P> const& _xy, vec<2, B, P> const& _zw)
  : x(static_cast<T>(_xy.x))
  , y(static_cast<T>(_xy.y))
  , z(static_cast<T>(_zw.x))
  , w(static_cast<T>(_zw.y))
 {}

 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr vec<4, T, Q>::vec(vec<4, U, P> const& v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.y))
  , z(static_cast<T>(v.z))
  , w(static_cast<T>(v.w))
 {}



 template<typename T, qualifier Q>
 inline constexpr T& vec<4, T, Q>::operator[](typename vec<4, T, Q>::length_type i)
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));
  switch(i)
  {
  default:
  case 0:
   return x;
  case 1:
   return y;
  case 2:
   return z;
  case 3:
   return w;
  }
 }

 template<typename T, qualifier Q>
 inline constexpr T const& vec<4, T, Q>::operator[](typename vec<4, T, Q>::length_type i) const
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));
  switch(i)
  {
  default:
  case 0:
   return x;
  case 1:
   return y;
  case 2:
   return z;
  case 3:
   return w;
  }
 }
# 528 "/usr/include/glm/detail/type_vec4.inl" 3 4
 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q>& vec<4, T, Q>::operator=(vec<4, U, Q> const& v)
 {
  this->x = static_cast<T>(v.x);
  this->y = static_cast<T>(v.y);
  this->z = static_cast<T>(v.z);
  this->w = static_cast<T>(v.w);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator+=(U scalar)
 {
  return (*this = detail::compute_vec4_add<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator+=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_add<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v.x)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator+=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_add<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator-=(U scalar)
 {
  return (*this = detail::compute_vec4_sub<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator-=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_sub<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v.x)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator-=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_sub<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator*=(U scalar)
 {
  return (*this = detail::compute_vec4_mul<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator*=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_mul<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v.x)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator*=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_mul<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator/=(U scalar)
 {
  return (*this = detail::compute_vec4_div<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator/=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_div<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v.x)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator/=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_div<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }



 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator++()
 {
  ++this->x;
  ++this->y;
  ++this->z;
  ++this->w;
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator--()
 {
  --this->x;
  --this->y;
  --this->z;
  --this->w;
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> vec<4, T, Q>::operator++(int)
 {
  vec<4, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> vec<4, T, Q>::operator--(int)
 {
  vec<4, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator%=(U scalar)
 {
  return (*this = detail::compute_vec4_mod<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator%=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_mod<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator%=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_mod<T, Q, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator&=(U scalar)
 {
  return (*this = detail::compute_vec4_and<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator&=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_and<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator&=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_and<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator|=(U scalar)
 {
  return (*this = detail::compute_vec4_or<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator|=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_or<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator|=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_or<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator^=(U scalar)
 {
  return (*this = detail::compute_vec4_xor<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator^=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_xor<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator^=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_xor<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator<<=(U scalar)
 {
  return (*this = detail::compute_vec4_shift_left<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator<<=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_shift_left<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator<<=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_shift_left<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator>>=(U scalar)
 {
  return (*this = detail::compute_vec4_shift_right<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(scalar)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator>>=(vec<1, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_shift_right<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<4, T, Q> & vec<4, T, Q>::operator>>=(vec<4, U, Q> const& v)
 {
  return (*this = detail::compute_vec4_shift_right<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(*this, vec<4, T, Q>(v)));
 }



 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator+(vec<4, T, Q> const& v)
 {
  return v;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator-(vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(0) -= v;
 }



 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator+(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) += scalar;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator+(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) += v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator+(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(v) += scalar;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator+(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v2) += v1;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator+(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) += v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator-(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) -= scalar;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator-(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) -= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator-(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar) -= v;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator-(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1.x) -= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator-(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) -= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator*(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) *= scalar;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator*(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) *= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator*(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(v) *= scalar;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator*(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v2) *= v1;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator*(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) *= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator/(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) /= scalar;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator/(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) /= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator/(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar) /= v;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator/(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1.x) /= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator/(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) /= v2;
 }



 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator%(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) %= scalar;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator%(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) %= v2.x;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator%(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar) %= v;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator%(vec<1, T, Q> const& scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar.x) %= v;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator%(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) %= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator&(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) &= scalar;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator&(vec<4, T, Q> const& v, vec<1, T, Q> const& scalar)
 {
  return vec<4, T, Q>(v) &= scalar;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator&(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar) &= v;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator&(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1.x) &= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator&(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) &= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator|(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) |= scalar;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator|(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) |= v2.x;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator|(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar) |= v;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator|(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1.x) |= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator|(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) |= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator^(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) ^= scalar;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator^(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) ^= v2.x;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator^(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar) ^= v;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator^(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1.x) ^= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator^(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) ^= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator<<(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) <<= scalar;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator<<(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) <<= v2.x;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator<<(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar) <<= v;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator<<(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1.x) <<= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator<<(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) <<= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator>>(vec<4, T, Q> const& v, T scalar)
 {
  return vec<4, T, Q>(v) >>= scalar;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator>>(vec<4, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) >>= v2.x;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator>>(T scalar, vec<4, T, Q> const& v)
 {
  return vec<4, T, Q>(scalar) >>= v;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator>>(vec<1, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1.x) >>= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator>>(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return vec<4, T, Q>(v1) >>= v2;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator~(vec<4, T, Q> const& v)
 {
  return detail::compute_vec4_bitwise_not<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(v);
 }



 template<typename T, qualifier Q>
 inline constexpr bool operator==(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return detail::compute_vec4_equal<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(v1, v2);
 }

 template<typename T, qualifier Q>
 inline constexpr bool operator!=(vec<4, T, Q> const& v1, vec<4, T, Q> const& v2)
 {
  return detail::compute_vec4_nequal<T, Q, detail::is_int<T>::value, sizeof(T) * 8, detail::is_aligned<Q>::value>::call(v1, v2);
 }

 template<qualifier Q>
 inline constexpr vec<4, bool, Q> operator&&(vec<4, bool, Q> const& v1, vec<4, bool, Q> const& v2)
 {
  return vec<4, bool, Q>(v1.x && v2.x, v1.y && v2.y, v1.z && v2.z, v1.w && v2.w);
 }

 template<qualifier Q>
 inline constexpr vec<4, bool, Q> operator||(vec<4, bool, Q> const& v1, vec<4, bool, Q> const& v2)
 {
  return vec<4, bool, Q>(v1.x || v2.x, v1.y || v2.y, v1.z || v2.z, v1.w || v2.w);
 }
}
# 508 "/usr/include/glm/detail/type_vec4.hpp" 2 3 4
# 6 "/usr/include/glm/ext/vector_bool4.hpp" 2 3 4

namespace glm
{






 typedef vec<4, bool, defaultp> bvec4;


}
# 6 "/usr/include/glm/vec4.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_bool4_precision.hpp" 1 3 4



       


namespace glm
{







 typedef vec<4, bool, highp> highp_bvec4;





 typedef vec<4, bool, mediump> mediump_bvec4;





 typedef vec<4, bool, lowp> lowp_bvec4;


}
# 7 "/usr/include/glm/vec4.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_float4.hpp" 1 3 4



       


namespace glm
{






 typedef vec<4, float, defaultp> vec4;


}
# 8 "/usr/include/glm/vec4.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_float4_precision.hpp" 1 3 4



       


namespace glm
{







 typedef vec<4, float, highp> highp_vec4;





 typedef vec<4, float, mediump> mediump_vec4;





 typedef vec<4, float, lowp> lowp_vec4;


}
# 9 "/usr/include/glm/vec4.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_double4.hpp" 1 3 4



       


namespace glm
{






 typedef vec<4, double, defaultp> dvec4;


}
# 10 "/usr/include/glm/vec4.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_double4_precision.hpp" 1 3 4



       
# 1 "/usr/include/glm/detail/setup.hpp" 1 3 4
# 6 "/usr/include/glm/ext/vector_double4_precision.hpp" 2 3 4


namespace glm
{
# 18 "/usr/include/glm/ext/vector_double4_precision.hpp" 3 4
 typedef vec<4, double, highp> highp_dvec4;






 typedef vec<4, double, mediump> mediump_dvec4;






 typedef vec<4, double, lowp> lowp_dvec4;


}
# 11 "/usr/include/glm/vec4.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_int4.hpp" 1 3 4



       


namespace glm
{






 typedef vec<4, int, defaultp> ivec4;


}
# 12 "/usr/include/glm/vec4.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_int4_sized.hpp" 1 3 4
# 14 "/usr/include/glm/ext/vector_int4_sized.hpp" 3 4
       
# 23 "/usr/include/glm/ext/vector_int4_sized.hpp" 3 4
namespace glm
{






 typedef vec<4, int8, defaultp> i8vec4;




 typedef vec<4, int16, defaultp> i16vec4;




 typedef vec<4, int32, defaultp> i32vec4;




 typedef vec<4, int64, defaultp> i64vec4;


}
# 13 "/usr/include/glm/vec4.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_uint4.hpp" 1 3 4



       


namespace glm
{






 typedef vec<4, unsigned int, defaultp> uvec4;


}
# 14 "/usr/include/glm/vec4.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_uint4_sized.hpp" 1 3 4
# 14 "/usr/include/glm/ext/vector_uint4_sized.hpp" 3 4
       
# 23 "/usr/include/glm/ext/vector_uint4_sized.hpp" 3 4
namespace glm
{






 typedef vec<4, uint8, defaultp> u8vec4;




 typedef vec<4, uint16, defaultp> u16vec4;




 typedef vec<4, uint32, defaultp> u32vec4;




 typedef vec<4, uint64, defaultp> u64vec4;


}
# 15 "/usr/include/glm/vec4.hpp" 2 3 4
# 120 "/usr/include/glm/glm.hpp" 2 3 4
# 1 "/usr/include/glm/mat2x2.hpp" 1 3 4



       
# 1 "/usr/include/glm/ext/matrix_double2x2.hpp" 1 3 4



       
# 1 "/usr/include/glm/detail/type_mat2x2.hpp" 1 3 4



       





namespace glm
{
 template<typename T, qualifier Q>
 struct mat<2, 2, T, Q>
 {
  typedef vec<2, T, Q> col_type;
  typedef vec<2, T, Q> row_type;
  typedef mat<2, 2, T, Q> type;
  typedef mat<2, 2, T, Q> transpose_type;
  typedef T value_type;

 private:
  col_type value[2];

 public:


  typedef length_t length_type;
  [[nodiscard]] static constexpr length_type length() { return 2; }

  [[nodiscard]] constexpr col_type & operator[](length_type i) noexcept;
  [[nodiscard]] constexpr col_type const& operator[](length_type i) const noexcept;



  constexpr mat() = default;
  template<qualifier P>
  constexpr mat(mat<2, 2, T, P> const& m);

  constexpr mat(T scalar);
  constexpr mat(
   T const& x1, T const& y1,
   T const& x2, T const& y2);
  constexpr mat(
   col_type const& v1,
   col_type const& v2);



  template<typename U, typename V, typename M, typename N>
  constexpr mat(
   U const& x1, V const& y1,
   M const& x2, N const& y2);

  template<typename U, typename V>
  constexpr mat(
   vec<2, U, Q> const& v1,
   vec<2, V, Q> const& v2);



  template<typename U, qualifier P>
  constexpr mat(mat<2, 2, U, P> const& m);

  constexpr mat(mat<3, 3, T, Q> const& x);
  constexpr mat(mat<4, 4, T, Q> const& x);
  constexpr mat(mat<2, 3, T, Q> const& x);
  constexpr mat(mat<3, 2, T, Q> const& x);
  constexpr mat(mat<2, 4, T, Q> const& x);
  constexpr mat(mat<4, 2, T, Q> const& x);
  constexpr mat(mat<3, 4, T, Q> const& x);
  constexpr mat(mat<4, 3, T, Q> const& x);



  template<typename U>
  constexpr mat<2, 2, T, Q> & operator=(mat<2, 2, U, Q> const& m);
  template<typename U>
  constexpr mat<2, 2, T, Q> & operator+=(U s);
  template<typename U>
  constexpr mat<2, 2, T, Q> & operator+=(mat<2, 2, U, Q> const& m);
  template<typename U>
  constexpr mat<2, 2, T, Q> & operator-=(U s);
  template<typename U>
  constexpr mat<2, 2, T, Q> & operator-=(mat<2, 2, U, Q> const& m);
  template<typename U>
  constexpr mat<2, 2, T, Q> & operator*=(U s);
  template<typename U>
  constexpr mat<2, 2, T, Q> & operator*=(mat<2, 2, U, Q> const& m);
  template<typename U>
  constexpr mat<2, 2, T, Q> & operator/=(U s);
  template<typename U>
  constexpr mat<2, 2, T, Q> & operator/=(mat<2, 2, U, Q> const& m);



  constexpr mat<2, 2, T, Q> & operator++ ();
  constexpr mat<2, 2, T, Q> & operator-- ();
  [[nodiscard]] constexpr mat<2, 2, T, Q> operator++(int);
  [[nodiscard]] constexpr mat<2, 2, T, Q> operator--(int);
 };



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 2, T, Q> operator+(mat<2, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 2, T, Q> operator-(mat<2, 2, T, Q> const& m);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 2, T, Q> operator+(mat<2, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 2, T, Q> operator+(T scalar, mat<2, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 2, T, Q> operator+(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 2, T, Q> operator-(mat<2, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 2, T, Q> operator-(T scalar, mat<2, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 2, T, Q> operator-(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 2, T, Q> operator*(mat<2, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 2, T, Q> operator*(T scalar, mat<2, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<2, 2, T, Q>::col_type operator*(mat<2, 2, T, Q> const& m, typename mat<2, 2, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<2, 2, T, Q>::row_type operator*(typename mat<2, 2, T, Q>::col_type const& v, mat<2, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 2, T, Q> operator*(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 2, T, Q> operator*(mat<2, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 2, T, Q> operator*(mat<2, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 2, T, Q> operator/(mat<2, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 2, T, Q> operator/(T scalar, mat<2, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<2, 2, T, Q>::col_type operator/(mat<2, 2, T, Q> const& m, typename mat<2, 2, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<2, 2, T, Q>::row_type operator/(typename mat<2, 2, T, Q>::col_type const& v, mat<2, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 2, T, Q> operator/(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator==(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator!=(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2);
}


# 1 "/usr/include/glm/detail/type_mat2x2.inl" 1 3 4
# 1 "/usr/include/glm/matrix.hpp" 1 3 4
# 13 "/usr/include/glm/matrix.hpp" 3 4
       



# 1 "/usr/include/glm/detail/setup.hpp" 1 3 4
# 18 "/usr/include/glm/matrix.hpp" 2 3 4




# 1 "/usr/include/glm/mat2x3.hpp" 1 3 4



       
# 1 "/usr/include/glm/ext/matrix_double2x3.hpp" 1 3 4



       
# 1 "/usr/include/glm/detail/type_mat2x3.hpp" 1 3 4



       






namespace glm
{
 template<typename T, qualifier Q>
 struct mat<2, 3, T, Q>
 {
  typedef vec<3, T, Q> col_type;
  typedef vec<2, T, Q> row_type;
  typedef mat<2, 3, T, Q> type;
  typedef mat<3, 2, T, Q> transpose_type;
  typedef T value_type;

 private:
  col_type value[2];

 public:


  typedef length_t length_type;
  [[nodiscard]] static constexpr length_type length() { return 2; }

  [[nodiscard]] constexpr col_type & operator[](length_type i) noexcept;
  [[nodiscard]] constexpr col_type const& operator[](length_type i) const noexcept;



  constexpr mat() = default;
  template<qualifier P>
  constexpr mat(mat<2, 3, T, P> const& m);

  constexpr mat(T scalar);
  constexpr mat(
   T x0, T y0, T z0,
   T x1, T y1, T z1);
  constexpr mat(
   col_type const& v0,
   col_type const& v1);



  template<typename X1, typename Y1, typename Z1, typename X2, typename Y2, typename Z2>
  constexpr mat(
   X1 x1, Y1 y1, Z1 z1,
   X2 x2, Y2 y2, Z2 z2);

  template<typename U, typename V>
  constexpr mat(
   vec<3, U, Q> const& v1,
   vec<3, V, Q> const& v2);



  template<typename U, qualifier P>
  constexpr mat(mat<2, 3, U, P> const& m);

  constexpr mat(mat<2, 2, T, Q> const& x);
  constexpr mat(mat<3, 3, T, Q> const& x);
  constexpr mat(mat<4, 4, T, Q> const& x);
  constexpr mat(mat<2, 4, T, Q> const& x);
  constexpr mat(mat<3, 2, T, Q> const& x);
  constexpr mat(mat<3, 4, T, Q> const& x);
  constexpr mat(mat<4, 2, T, Q> const& x);
  constexpr mat(mat<4, 3, T, Q> const& x);



  template<typename U>
  constexpr mat<2, 3, T, Q> & operator=(mat<2, 3, U, Q> const& m);
  template<typename U>
  constexpr mat<2, 3, T, Q> & operator+=(U s);
  template<typename U>
  constexpr mat<2, 3, T, Q> & operator+=(mat<2, 3, U, Q> const& m);
  template<typename U>
  constexpr mat<2, 3, T, Q> & operator-=(U s);
  template<typename U>
  constexpr mat<2, 3, T, Q> & operator-=(mat<2, 3, U, Q> const& m);
  template<typename U>
  constexpr mat<2, 3, T, Q> & operator*=(U s);
  template<typename U>
  constexpr mat<2, 3, T, Q> & operator/=(U s);



  constexpr mat<2, 3, T, Q> & operator++ ();
  constexpr mat<2, 3, T, Q> & operator-- ();
  [[nodiscard]] constexpr mat<2, 3, T, Q> operator++(int);
  [[nodiscard]] constexpr mat<2, 3, T, Q> operator--(int);
 };



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 3, T, Q> operator+(mat<2, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 3, T, Q> operator-(mat<2, 3, T, Q> const& m);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 3, T, Q> operator+(mat<2, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 3, T, Q> operator+(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 3, T, Q> operator-(mat<2, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 3, T, Q> operator-(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 3, T, Q> operator*(mat<2, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 3, T, Q> operator*(T scalar, mat<2, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<2, 3, T, Q>::col_type operator*(mat<2, 3, T, Q> const& m, typename mat<2, 3, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<2, 3, T, Q>::row_type operator*(typename mat<2, 3, T, Q>::col_type const& v, mat<2, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 3, T, Q> operator*(mat<2, 3, T, Q> const& m1, mat<2, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 3, T, Q> operator*(mat<2, 3, T, Q> const& m1, mat<3, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 3, T, Q> operator*(mat<2, 3, T, Q> const& m1, mat<4, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 3, T, Q> operator/(mat<2, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 3, T, Q> operator/(T scalar, mat<2, 3, T, Q> const& m);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator==(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator!=(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2);
}


# 1 "/usr/include/glm/detail/type_mat2x3.inl" 1 3 4
namespace glm
{
# 19 "/usr/include/glm/detail/type_mat2x3.inl" 3 4
 template<typename T, qualifier Q>
 template<qualifier P>
 inline constexpr mat<2, 3, T, Q>::mat(mat<2, 3, T, P> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q>::mat(T scalar)

   : value{col_type(scalar, 0, 0), col_type(0, scalar, 0)}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q>::mat
 (
  T x0, T y0, T z0,
  T x1, T y1, T z1
 )

   : value{col_type(x0, y0, z0), col_type(x1, y1, z1)}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q>::mat(col_type const& v0, col_type const& v1)

   : value{col_type(v0), col_type(v1)}

 {




 }



 template<typename T, qualifier Q>
 template<
  typename X1, typename Y1, typename Z1,
  typename X2, typename Y2, typename Z2>
 inline constexpr mat<2, 3, T, Q>::mat
 (
  X1 x1, Y1 y1, Z1 z1,
  X2 x2, Y2 y2, Z2 z2
 )

   : value{col_type(x1, y1, z1), col_type(x2, y2, z2)}

 {




 }

 template<typename T, qualifier Q>
 template<typename V1, typename V2>
 inline constexpr mat<2, 3, T, Q>::mat(vec<3, V1, Q> const& v1, vec<3, V2, Q> const& v2)

   : value{col_type(v1), col_type(v2)}

 {




 }



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr mat<2, 3, T, Q>::mat(mat<2, 3, U, P> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q>::mat(mat<2, 2, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0)}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q>::mat(mat<3, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q>::mat(mat<4, 4, T, Q> const& m)

  : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q>::mat(mat<2, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q>::mat(mat<3, 2, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0)}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q>::mat(mat<3, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q>::mat(mat<4, 2, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0)}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q>::mat(mat<4, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }



 template<typename T, qualifier Q>
 inline constexpr typename mat<2, 3, T, Q>::col_type & mat<2, 3, T, Q>::operator[](typename mat<2, 3, T, Q>::length_type i) noexcept
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));
  return this->value[i];
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<2, 3, T, Q>::col_type const& mat<2, 3, T, Q>::operator[](typename mat<2, 3, T, Q>::length_type i) const noexcept
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));
  return this->value[i];
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 3, T, Q>& mat<2, 3, T, Q>::operator=(mat<2, 3, U, Q> const& m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 3, T, Q> & mat<2, 3, T, Q>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 3, T, Q>& mat<2, 3, T, Q>::operator+=(mat<2, 3, U, Q> const& m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 3, T, Q>& mat<2, 3, T, Q>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 3, T, Q>& mat<2, 3, T, Q>::operator-=(mat<2, 3, U, Q> const& m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 3, T, Q>& mat<2, 3, T, Q>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 3, T, Q> & mat<2, 3, T, Q>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  return *this;
 }



 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> & mat<2, 3, T, Q>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> & mat<2, 3, T, Q>::operator--()
 {
  --this->value[0];
  --this->value[1];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> mat<2, 3, T, Q>::operator++(int)
 {
  mat<2, 3, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> mat<2, 3, T, Q>::operator--(int)
 {
  mat<2, 3, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> operator+(mat<2, 3, T, Q> const& m)
 {
  return m;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> operator-(mat<2, 3, T, Q> const& m)
 {
  return mat<2, 3, T, Q>(
   -m[0],
   -m[1]);
 }



 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> operator+(mat<2, 3, T, Q> const& m, T scalar)
 {
  return mat<2, 3, T, Q>(
   m[0] + scalar,
   m[1] + scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> operator+(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
 {
  return mat<2, 3, T, Q>(
   m1[0] + m2[0],
   m1[1] + m2[1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> operator-(mat<2, 3, T, Q> const& m, T scalar)
 {
  return mat<2, 3, T, Q>(
   m[0] - scalar,
   m[1] - scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> operator-(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
 {
  return mat<2, 3, T, Q>(
   m1[0] - m2[0],
   m1[1] - m2[1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> operator*(mat<2, 3, T, Q> const& m, T scalar)
 {
  return mat<2, 3, T, Q>(
   m[0] * scalar,
   m[1] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> operator*(T scalar, mat<2, 3, T, Q> const& m)
 {
  return mat<2, 3, T, Q>(
   m[0] * scalar,
   m[1] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<2, 3, T, Q>::col_type operator*
 (
  mat<2, 3, T, Q> const& m,
  typename mat<2, 3, T, Q>::row_type const& v)
 {
  return typename mat<2, 3, T, Q>::col_type(
   m[0][0] * v.x + m[1][0] * v.y,
   m[0][1] * v.x + m[1][1] * v.y,
   m[0][2] * v.x + m[1][2] * v.y);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<2, 3, T, Q>::row_type operator*
 (
  typename mat<2, 3, T, Q>::col_type const& v,
  mat<2, 3, T, Q> const& m)
 {
  return typename mat<2, 3, T, Q>::row_type(
   v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2],
   v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> operator*(mat<2, 3, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
 {
  return mat<2, 3, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> operator*(mat<2, 3, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
 {
  T SrcA00 = m1[0][0];
  T SrcA01 = m1[0][1];
  T SrcA02 = m1[0][2];
  T SrcA10 = m1[1][0];
  T SrcA11 = m1[1][1];
  T SrcA12 = m1[1][2];

  T SrcB00 = m2[0][0];
  T SrcB01 = m2[0][1];
  T SrcB10 = m2[1][0];
  T SrcB11 = m2[1][1];
  T SrcB20 = m2[2][0];
  T SrcB21 = m2[2][1];

  mat<3, 3, T, Q> Result;
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> operator*(mat<2, 3, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
 {
  return mat<4, 3, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1],
   m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> operator/(mat<2, 3, T, Q> const& m, T scalar)
 {
  return mat<2, 3, T, Q>(
   m[0] / scalar,
   m[1] / scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> operator/(T scalar, mat<2, 3, T, Q> const& m)
 {
  return mat<2, 3, T, Q>(
   scalar / m[0],
   scalar / m[1]);
 }



 template<typename T, qualifier Q>
 inline constexpr bool operator==(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]);
 }

 template<typename T, qualifier Q>
 inline constexpr bool operator!=(mat<2, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]);
 }
}
# 159 "/usr/include/glm/detail/type_mat2x3.hpp" 2 3 4
# 6 "/usr/include/glm/ext/matrix_double2x3.hpp" 2 3 4

namespace glm
{






 typedef mat<2, 3, double, defaultp> dmat2x3;


}
# 6 "/usr/include/glm/mat2x3.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_double2x3_precision.hpp" 1 3 4



       


namespace glm
{







 typedef mat<2, 3, double, lowp> lowp_dmat2x3;





 typedef mat<2, 3, double, mediump> mediump_dmat2x3;





 typedef mat<2, 3, double, highp> highp_dmat2x3;


}
# 7 "/usr/include/glm/mat2x3.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_float2x3.hpp" 1 3 4



       


namespace glm
{






 typedef mat<2, 3, float, defaultp> mat2x3;


}
# 8 "/usr/include/glm/mat2x3.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_float2x3_precision.hpp" 1 3 4



       


namespace glm
{







 typedef mat<2, 3, float, lowp> lowp_mat2x3;





 typedef mat<2, 3, float, mediump> mediump_mat2x3;





 typedef mat<2, 3, float, highp> highp_mat2x3;


}
# 9 "/usr/include/glm/mat2x3.hpp" 2 3 4
# 23 "/usr/include/glm/matrix.hpp" 2 3 4
# 1 "/usr/include/glm/mat2x4.hpp" 1 3 4



       
# 1 "/usr/include/glm/ext/matrix_double2x4.hpp" 1 3 4



       
# 1 "/usr/include/glm/detail/type_mat2x4.hpp" 1 3 4



       






namespace glm
{
 template<typename T, qualifier Q>
 struct mat<2, 4, T, Q>
 {
  typedef vec<4, T, Q> col_type;
  typedef vec<2, T, Q> row_type;
  typedef mat<2, 4, T, Q> type;
  typedef mat<4, 2, T, Q> transpose_type;
  typedef T value_type;

 private:
  col_type value[2];

 public:


  typedef length_t length_type;
  [[nodiscard]] static constexpr length_type length() { return 2; }

  [[nodiscard]] constexpr col_type & operator[](length_type i) noexcept;
  [[nodiscard]] constexpr col_type const& operator[](length_type i) const noexcept;



  constexpr mat() = default;
  template<qualifier P>
  constexpr mat(mat<2, 4, T, P> const& m);

  constexpr mat(T scalar);
  constexpr mat(
   T x0, T y0, T z0, T w0,
   T x1, T y1, T z1, T w1);
  constexpr mat(
   col_type const& v0,
   col_type const& v1);



  template<
   typename X1, typename Y1, typename Z1, typename W1,
   typename X2, typename Y2, typename Z2, typename W2>
  constexpr mat(
   X1 x1, Y1 y1, Z1 z1, W1 w1,
   X2 x2, Y2 y2, Z2 z2, W2 w2);

  template<typename U, typename V>
  constexpr mat(
   vec<4, U, Q> const& v1,
   vec<4, V, Q> const& v2);



  template<typename U, qualifier P>
  constexpr mat(mat<2, 4, U, P> const& m);

  constexpr mat(mat<2, 2, T, Q> const& x);
  constexpr mat(mat<3, 3, T, Q> const& x);
  constexpr mat(mat<4, 4, T, Q> const& x);
  constexpr mat(mat<2, 3, T, Q> const& x);
  constexpr mat(mat<3, 2, T, Q> const& x);
  constexpr mat(mat<3, 4, T, Q> const& x);
  constexpr mat(mat<4, 2, T, Q> const& x);
  constexpr mat(mat<4, 3, T, Q> const& x);



  template<typename U>
  constexpr mat<2, 4, T, Q> & operator=(mat<2, 4, U, Q> const& m);
  template<typename U>
  constexpr mat<2, 4, T, Q> & operator+=(U s);
  template<typename U>
  constexpr mat<2, 4, T, Q> & operator+=(mat<2, 4, U, Q> const& m);
  template<typename U>
  constexpr mat<2, 4, T, Q> & operator-=(U s);
  template<typename U>
  constexpr mat<2, 4, T, Q> & operator-=(mat<2, 4, U, Q> const& m);
  template<typename U>
  constexpr mat<2, 4, T, Q> & operator*=(U s);
  template<typename U>
  constexpr mat<2, 4, T, Q> & operator/=(U s);



  constexpr mat<2, 4, T, Q> & operator++ ();
  constexpr mat<2, 4, T, Q> & operator-- ();
  [[nodiscard]] constexpr mat<2, 4, T, Q> operator++(int);
  [[nodiscard]] constexpr mat<2, 4, T, Q> operator--(int);
 };



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 4, T, Q> operator+(mat<2, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 4, T, Q> operator-(mat<2, 4, T, Q> const& m);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 4, T, Q> operator+(mat<2, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 4, T, Q> operator+(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 4, T, Q> operator-(mat<2, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 4, T, Q> operator-(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 4, T, Q> operator*(mat<2, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 4, T, Q> operator*(T scalar, mat<2, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<2, 4, T, Q>::col_type operator*(mat<2, 4, T, Q> const& m, typename mat<2, 4, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<2, 4, T, Q>::row_type operator*(typename mat<2, 4, T, Q>::col_type const& v, mat<2, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> operator*(mat<2, 4, T, Q> const& m1, mat<4, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 4, T, Q> operator*(mat<2, 4, T, Q> const& m1, mat<2, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 4, T, Q> operator*(mat<2, 4, T, Q> const& m1, mat<3, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 4, T, Q> operator/(mat<2, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 4, T, Q> operator/(T scalar, mat<2, 4, T, Q> const& m);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator==(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator!=(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2);
}


# 1 "/usr/include/glm/detail/type_mat2x4.inl" 1 3 4
namespace glm
{
# 19 "/usr/include/glm/detail/type_mat2x4.inl" 3 4
 template<typename T, qualifier Q>
 template<qualifier P>
 inline constexpr mat<2, 4, T, Q>::mat(mat<2, 4, T, P> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q>::mat(T s)

   : value{col_type(s, 0, 0, 0), col_type(0, s, 0, 0)}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q>::mat
 (
  T x0, T y0, T z0, T w0,
  T x1, T y1, T z1, T w1
 )

   : value{col_type(x0, y0, z0, w0), col_type(x1, y1, z1, w1)}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q>::mat(col_type const& v0, col_type const& v1)

   : value{col_type(v0), col_type(v1)}

 {




 }



 template<typename T, qualifier Q>
 template<
  typename X1, typename Y1, typename Z1, typename W1,
  typename X2, typename Y2, typename Z2, typename W2>
 inline constexpr mat<2, 4, T, Q>::mat
 (
  X1 x1, Y1 y1, Z1 z1, W1 w1,
  X2 x2, Y2 y2, Z2 z2, W2 w2
 )

   : value{
    col_type(x1, y1, z1, w1),
    col_type(x2, y2, z2, w2)}

 {




 }

 template<typename T, qualifier Q>
 template<typename V1, typename V2>
 inline constexpr mat<2, 4, T, Q>::mat(vec<4, V1, Q> const& v1, vec<4, V2, Q> const& v2)

   : value{col_type(v1), col_type(v2)}

 {




 }



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr mat<2, 4, T, Q>::mat(mat<2, 4, U, P> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q>::mat(mat<2, 2, T, Q> const& m)

   : value{col_type(m[0], 0, 0), col_type(m[1], 0, 0)}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q>::mat(mat<3, 3, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0)}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q>::mat(mat<4, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q>::mat(mat<2, 3, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0)}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q>::mat(mat<3, 2, T, Q> const& m)

   : value{col_type(m[0], 0, 0), col_type(m[1], 0, 0)}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q>::mat(mat<3, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q>::mat(mat<4, 2, T, Q> const& m)

   : value{col_type(m[0], 0, 0), col_type(m[1], 0, 0)}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q>::mat(mat<4, 3, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0)}

 {




 }



 template<typename T, qualifier Q>
 inline constexpr typename mat<2, 4, T, Q>::col_type & mat<2, 4, T, Q>::operator[](typename mat<2, 4, T, Q>::length_type i) noexcept
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));
  return this->value[i];
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<2, 4, T, Q>::col_type const& mat<2, 4, T, Q>::operator[](typename mat<2, 4, T, Q>::length_type i) const noexcept
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));
  return this->value[i];
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator=(mat<2, 4, U, Q> const& m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator+=(mat<2, 4, U, Q> const& m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator-=(mat<2, 4, U, Q> const& m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 4, T, Q> & mat<2, 4, T, Q>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  return *this;
 }



 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q>& mat<2, 4, T, Q>::operator--()
 {
  --this->value[0];
  --this->value[1];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q> mat<2, 4, T, Q>::operator++(int)
 {
  mat<2, 4, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q> mat<2, 4, T, Q>::operator--(int)
 {
  mat<2, 4, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q> operator+(mat<2, 4, T, Q> const& m)
 {
  return m;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q> operator-(mat<2, 4, T, Q> const& m)
 {
  return mat<2, 4, T, Q>(
   -m[0],
   -m[1]);
 }



 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q> operator+(mat<2, 4, T, Q> const& m, T scalar)
 {
  return mat<2, 4, T, Q>(
   m[0] + scalar,
   m[1] + scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q> operator+(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
 {
  return mat<2, 4, T, Q>(
   m1[0] + m2[0],
   m1[1] + m2[1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q> operator-(mat<2, 4, T, Q> const& m, T scalar)
 {
  return mat<2, 4, T, Q>(
   m[0] - scalar,
   m[1] - scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q> operator-(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
 {
  return mat<2, 4, T, Q>(
   m1[0] - m2[0],
   m1[1] - m2[1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q> operator*(mat<2, 4, T, Q> const& m, T scalar)
 {
  return mat<2, 4, T, Q>(
   m[0] * scalar,
   m[1] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q> operator*(T scalar, mat<2, 4, T, Q> const& m)
 {
  return mat<2, 4, T, Q>(
   m[0] * scalar,
   m[1] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<2, 4, T, Q>::col_type operator*(mat<2, 4, T, Q> const& m, typename mat<2, 4, T, Q>::row_type const& v)
 {
  return typename mat<2, 4, T, Q>::col_type(
   m[0][0] * v.x + m[1][0] * v.y,
   m[0][1] * v.x + m[1][1] * v.y,
   m[0][2] * v.x + m[1][2] * v.y,
   m[0][3] * v.x + m[1][3] * v.y);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<2, 4, T, Q>::row_type operator*(typename mat<2, 4, T, Q>::col_type const& v, mat<2, 4, T, Q> const& m)
 {
  return typename mat<2, 4, T, Q>::row_type(
   v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2] + v.w * m[0][3],
   v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2] + v.w * m[1][3]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> operator*(mat<2, 4, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
 {
  T SrcA00 = m1[0][0];
  T SrcA01 = m1[0][1];
  T SrcA02 = m1[0][2];
  T SrcA03 = m1[0][3];
  T SrcA10 = m1[1][0];
  T SrcA11 = m1[1][1];
  T SrcA12 = m1[1][2];
  T SrcA13 = m1[1][3];

  T SrcB00 = m2[0][0];
  T SrcB01 = m2[0][1];
  T SrcB10 = m2[1][0];
  T SrcB11 = m2[1][1];
  T SrcB20 = m2[2][0];
  T SrcB21 = m2[2][1];
  T SrcB30 = m2[3][0];
  T SrcB31 = m2[3][1];

  mat<4, 4, T, Q> Result;
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01;
  Result[0][3] = SrcA03 * SrcB00 + SrcA13 * SrcB01;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11;
  Result[1][3] = SrcA03 * SrcB10 + SrcA13 * SrcB11;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21;
  Result[2][3] = SrcA03 * SrcB20 + SrcA13 * SrcB21;
  Result[3][0] = SrcA00 * SrcB30 + SrcA10 * SrcB31;
  Result[3][1] = SrcA01 * SrcB30 + SrcA11 * SrcB31;
  Result[3][2] = SrcA02 * SrcB30 + SrcA12 * SrcB31;
  Result[3][3] = SrcA03 * SrcB30 + SrcA13 * SrcB31;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q> operator*(mat<2, 4, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
 {
  return mat<2, 4, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q> operator*(mat<2, 4, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
 {
  return mat<3, 4, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1],
   m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q> operator/(mat<2, 4, T, Q> const& m, T scalar)
 {
  return mat<2, 4, T, Q>(
   m[0] / scalar,
   m[1] / scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q> operator/(T scalar, mat<2, 4, T, Q> const& m)
 {
  return mat<2, 4, T, Q>(
   scalar / m[0],
   scalar / m[1]);
 }



 template<typename T, qualifier Q>
 inline constexpr bool operator==(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]);
 }

 template<typename T, qualifier Q>
 inline constexpr bool operator!=(mat<2, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]);
 }
}
# 161 "/usr/include/glm/detail/type_mat2x4.hpp" 2 3 4
# 6 "/usr/include/glm/ext/matrix_double2x4.hpp" 2 3 4

namespace glm
{






 typedef mat<2, 4, double, defaultp> dmat2x4;


}
# 6 "/usr/include/glm/mat2x4.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_double2x4_precision.hpp" 1 3 4



       


namespace glm
{







 typedef mat<2, 4, double, lowp> lowp_dmat2x4;





 typedef mat<2, 4, double, mediump> mediump_dmat2x4;





 typedef mat<2, 4, double, highp> highp_dmat2x4;


}
# 7 "/usr/include/glm/mat2x4.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_float2x4.hpp" 1 3 4



       


namespace glm
{






 typedef mat<2, 4, float, defaultp> mat2x4;


}
# 8 "/usr/include/glm/mat2x4.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_float2x4_precision.hpp" 1 3 4



       


namespace glm
{







 typedef mat<2, 4, float, lowp> lowp_mat2x4;





 typedef mat<2, 4, float, mediump> mediump_mat2x4;





 typedef mat<2, 4, float, highp> highp_mat2x4;


}
# 9 "/usr/include/glm/mat2x4.hpp" 2 3 4
# 24 "/usr/include/glm/matrix.hpp" 2 3 4
# 1 "/usr/include/glm/mat3x2.hpp" 1 3 4



       
# 1 "/usr/include/glm/ext/matrix_double3x2.hpp" 1 3 4



       
# 1 "/usr/include/glm/detail/type_mat3x2.hpp" 1 3 4



       






namespace glm
{
 template<typename T, qualifier Q>
 struct mat<3, 2, T, Q>
 {
  typedef vec<2, T, Q> col_type;
  typedef vec<3, T, Q> row_type;
  typedef mat<3, 2, T, Q> type;
  typedef mat<2, 3, T, Q> transpose_type;
  typedef T value_type;

 private:
  col_type value[3];

 public:


  typedef length_t length_type;
  [[nodiscard]] static constexpr length_type length() { return 3; }

  [[nodiscard]] constexpr col_type & operator[](length_type i) noexcept;
  [[nodiscard]] constexpr col_type const& operator[](length_type i) const noexcept;



  constexpr mat() = default;
  template<qualifier P>
  constexpr mat(mat<3, 2, T, P> const& m);

  constexpr mat(T scalar);
  constexpr mat(
   T x0, T y0,
   T x1, T y1,
   T x2, T y2);
  constexpr mat(
   col_type const& v0,
   col_type const& v1,
   col_type const& v2);



  template<
   typename X1, typename Y1,
   typename X2, typename Y2,
   typename X3, typename Y3>
   constexpr mat(
   X1 x1, Y1 y1,
   X2 x2, Y2 y2,
   X3 x3, Y3 y3);

  template<typename V1, typename V2, typename V3>
  constexpr mat(
   vec<2, V1, Q> const& v1,
   vec<2, V2, Q> const& v2,
   vec<2, V3, Q> const& v3);



  template<typename U, qualifier P>
  constexpr mat(mat<3, 2, U, P> const& m);

  constexpr mat(mat<2, 2, T, Q> const& x);
  constexpr mat(mat<3, 3, T, Q> const& x);
  constexpr mat(mat<4, 4, T, Q> const& x);
  constexpr mat(mat<2, 3, T, Q> const& x);
  constexpr mat(mat<2, 4, T, Q> const& x);
  constexpr mat(mat<3, 4, T, Q> const& x);
  constexpr mat(mat<4, 2, T, Q> const& x);
  constexpr mat(mat<4, 3, T, Q> const& x);



  template<typename U>
  constexpr mat<3, 2, T, Q> & operator=(mat<3, 2, U, Q> const& m);
  template<typename U>
  constexpr mat<3, 2, T, Q> & operator+=(U s);
  template<typename U>
  constexpr mat<3, 2, T, Q> & operator+=(mat<3, 2, U, Q> const& m);
  template<typename U>
  constexpr mat<3, 2, T, Q> & operator-=(U s);
  template<typename U>
  constexpr mat<3, 2, T, Q> & operator-=(mat<3, 2, U, Q> const& m);
  template<typename U>
  constexpr mat<3, 2, T, Q> & operator*=(U s);
  template<typename U>
  constexpr mat<3, 2, T, Q> & operator/=(U s);



  constexpr mat<3, 2, T, Q> & operator++ ();
  constexpr mat<3, 2, T, Q> & operator-- ();
  [[nodiscard]] constexpr mat<3, 2, T, Q> operator++(int);
  [[nodiscard]] constexpr mat<3, 2, T, Q> operator--(int);
 };



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 2, T, Q> operator+(mat<3, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 2, T, Q> operator-(mat<3, 2, T, Q> const& m);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 2, T, Q> operator+(mat<3, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 2, T, Q> operator+(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 2, T, Q> operator-(mat<3, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 2, T, Q> operator-(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 2, T, Q> operator*(mat<3, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 2, T, Q> operator*(T scalar, mat<3, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<3, 2, T, Q>::col_type operator*(mat<3, 2, T, Q> const& m, typename mat<3, 2, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<3, 2, T, Q>::row_type operator*(typename mat<3, 2, T, Q>::col_type const& v, mat<3, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 2, T, Q> operator*(mat<3, 2, T, Q> const& m1, mat<2, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 2, T, Q> operator*(mat<3, 2, T, Q> const& m1, mat<3, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 2, T, Q> operator*(mat<3, 2, T, Q> const& m1, mat<4, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 2, T, Q> operator/(mat<3, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 2, T, Q> operator/(T scalar, mat<3, 2, T, Q> const& m);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator==(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator!=(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2);

}


# 1 "/usr/include/glm/detail/type_mat3x2.inl" 1 3 4
namespace glm
{
# 20 "/usr/include/glm/detail/type_mat3x2.inl" 3 4
 template<typename T, qualifier Q>
 template<qualifier P>
 inline constexpr mat<3, 2, T, Q>::mat(mat<3, 2, T, P> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q>::mat(T s)

   : value{col_type(s, 0), col_type(0, s), col_type(0, 0)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q>::mat
 (
  T x0, T y0,
  T x1, T y1,
  T x2, T y2
 )

   : value{col_type(x0, y0), col_type(x1, y1), col_type(x2, y2)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q>::mat(col_type const& v0, col_type const& v1, col_type const& v2)

   : value{col_type(v0), col_type(v1), col_type(v2)}

 {





 }



 template<typename T, qualifier Q>
 template<
  typename X0, typename Y0,
  typename X1, typename Y1,
  typename X2, typename Y2>
 inline constexpr mat<3, 2, T, Q>::mat
 (
  X0 x0, Y0 y0,
  X1 x1, Y1 y1,
  X2 x2, Y2 y2
 )

   : value{col_type(x0, y0), col_type(x1, y1), col_type(x2, y2)}

 {





 }

 template<typename T, qualifier Q>
 template<typename V0, typename V1, typename V2>
 inline constexpr mat<3, 2, T, Q>::mat(vec<2, V0, Q> const& v0, vec<2, V1, Q> const& v1, vec<2, V2, Q> const& v2)

   : value{col_type(v0), col_type(v1), col_type(v2)}

 {





 }



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr mat<3, 2, T, Q>::mat(mat<3, 2, U, P> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q>::mat(mat<2, 2, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(0)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q>::mat(mat<3, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q>::mat(mat<4, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q>::mat(mat<2, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(0)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q>::mat(mat<2, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(0)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q>::mat(mat<3, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q>::mat(mat<4, 2, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q>::mat(mat<4, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }



 template<typename T, qualifier Q>
 inline constexpr typename mat<3, 2, T, Q>::col_type & mat<3, 2, T, Q>::operator[](typename mat<3, 2, T, Q>::length_type i) noexcept
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));
  return this->value[i];
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<3, 2, T, Q>::col_type const& mat<3, 2, T, Q>::operator[](typename mat<3, 2, T, Q>::length_type i) const noexcept
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));
  return this->value[i];
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator=(mat<3, 2, U, Q> const& m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator+=(mat<3, 2, U, Q> const& m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator-=(mat<3, 2, U, Q> const& m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 2, T, Q> & mat<3, 2, T, Q>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  return *this;
 }



 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q>& mat<3, 2, T, Q>::operator--()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q> mat<3, 2, T, Q>::operator++(int)
 {
  mat<3, 2, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q> mat<3, 2, T, Q>::operator--(int)
 {
  mat<3, 2, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q> operator+(mat<3, 2, T, Q> const& m)
 {
  return m;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q> operator-(mat<3, 2, T, Q> const& m)
 {
  return mat<3, 2, T, Q>(
   -m[0],
   -m[1],
   -m[2]);
 }



 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q> operator+(mat<3, 2, T, Q> const& m, T scalar)
 {
  return mat<3, 2, T, Q>(
   m[0] + scalar,
   m[1] + scalar,
   m[2] + scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q> operator+(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
 {
  return mat<3, 2, T, Q>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q> operator-(mat<3, 2, T, Q> const& m, T scalar)
 {
  return mat<3, 2, T, Q>(
   m[0] - scalar,
   m[1] - scalar,
   m[2] - scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q> operator-(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
 {
  return mat<3, 2, T, Q>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q> operator*(mat<3, 2, T, Q> const& m, T scalar)
 {
  return mat<3, 2, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q> operator*(T scalar, mat<3, 2, T, Q> const& m)
 {
  return mat<3, 2, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<3, 2, T, Q>::col_type operator*(mat<3, 2, T, Q> const& m, typename mat<3, 2, T, Q>::row_type const& v)
 {
  return typename mat<3, 2, T, Q>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<3, 2, T, Q>::row_type operator*(typename mat<3, 2, T, Q>::col_type const& v, mat<3, 2, T, Q> const& m)
 {
  return typename mat<3, 2, T, Q>::row_type(
   v.x * m[0][0] + v.y * m[0][1],
   v.x * m[1][0] + v.y * m[1][1],
   v.x * m[2][0] + v.y * m[2][1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> operator*(mat<3, 2, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
 {
  const T SrcA00 = m1[0][0];
  const T SrcA01 = m1[0][1];
  const T SrcA10 = m1[1][0];
  const T SrcA11 = m1[1][1];
  const T SrcA20 = m1[2][0];
  const T SrcA21 = m1[2][1];

  const T SrcB00 = m2[0][0];
  const T SrcB01 = m2[0][1];
  const T SrcB02 = m2[0][2];
  const T SrcB10 = m2[1][0];
  const T SrcB11 = m2[1][1];
  const T SrcB12 = m2[1][2];

  mat<2, 2, T, Q> Result;
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q> operator*(mat<3, 2, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
 {
  return mat<3, 2, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> operator*(mat<3, 2, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
 {
  return mat<4, 2, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q> operator/(mat<3, 2, T, Q> const& m, T scalar)
 {
  return mat<3, 2, T, Q>(
   m[0] / scalar,
   m[1] / scalar,
   m[2] / scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q> operator/(T scalar, mat<3, 2, T, Q> const& m)
 {
  return mat<3, 2, T, Q>(
   scalar / m[0],
   scalar / m[1],
   scalar / m[2]);
 }



 template<typename T, qualifier Q>
 inline constexpr bool operator==(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
 }

 template<typename T, qualifier Q>
 inline constexpr bool operator!=(mat<3, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
 }
}
# 167 "/usr/include/glm/detail/type_mat3x2.hpp" 2 3 4
# 6 "/usr/include/glm/ext/matrix_double3x2.hpp" 2 3 4

namespace glm
{






 typedef mat<3, 2, double, defaultp> dmat3x2;


}
# 6 "/usr/include/glm/mat3x2.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_double3x2_precision.hpp" 1 3 4



       


namespace glm
{







 typedef mat<3, 2, double, lowp> lowp_dmat3x2;





 typedef mat<3, 2, double, mediump> mediump_dmat3x2;





 typedef mat<3, 2, double, highp> highp_dmat3x2;


}
# 7 "/usr/include/glm/mat3x2.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_float3x2.hpp" 1 3 4



       


namespace glm
{






 typedef mat<3, 2, float, defaultp> mat3x2;


}
# 8 "/usr/include/glm/mat3x2.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_float3x2_precision.hpp" 1 3 4



       


namespace glm
{







 typedef mat<3, 2, float, lowp> lowp_mat3x2;





 typedef mat<3, 2, float, mediump> mediump_mat3x2;





 typedef mat<3, 2, float, highp> highp_mat3x2;


}
# 9 "/usr/include/glm/mat3x2.hpp" 2 3 4
# 25 "/usr/include/glm/matrix.hpp" 2 3 4
# 1 "/usr/include/glm/mat3x3.hpp" 1 3 4



       
# 1 "/usr/include/glm/ext/matrix_double3x3.hpp" 1 3 4



       
# 1 "/usr/include/glm/detail/type_mat3x3.hpp" 1 3 4



       





namespace glm
{
 template<typename T, qualifier Q>
 struct mat<3, 3, T, Q>
 {
  typedef vec<3, T, Q> col_type;
  typedef vec<3, T, Q> row_type;
  typedef mat<3, 3, T, Q> type;
  typedef mat<3, 3, T, Q> transpose_type;
  typedef T value_type;

 private:
  col_type value[3];

 public:


  typedef length_t length_type;
  [[nodiscard]] static constexpr length_type length() { return 3; }

  [[nodiscard]] constexpr col_type & operator[](length_type i) noexcept;
  [[nodiscard]] constexpr col_type const& operator[](length_type i) const noexcept;



  constexpr mat() = default;
  template<qualifier P>
  constexpr mat(mat<3, 3, T, P> const& m);

  constexpr mat(T scalar);
  constexpr mat(
   T x0, T y0, T z0,
   T x1, T y1, T z1,
   T x2, T y2, T z2);
  constexpr mat(
   col_type const& v0,
   col_type const& v1,
   col_type const& v2);



  template<
   typename X1, typename Y1, typename Z1,
   typename X2, typename Y2, typename Z2,
   typename X3, typename Y3, typename Z3>
  constexpr mat(
   X1 x1, Y1 y1, Z1 z1,
   X2 x2, Y2 y2, Z2 z2,
   X3 x3, Y3 y3, Z3 z3);

  template<typename V1, typename V2, typename V3>
  constexpr mat(
   vec<3, V1, Q> const& v1,
   vec<3, V2, Q> const& v2,
   vec<3, V3, Q> const& v3);



  template<typename U, qualifier P>
  constexpr mat(mat<3, 3, U, P> const& m);

  constexpr mat(mat<2, 2, T, Q> const& x);
  constexpr mat(mat<4, 4, T, Q> const& x);
  constexpr mat(mat<2, 3, T, Q> const& x);
  constexpr mat(mat<3, 2, T, Q> const& x);
  constexpr mat(mat<2, 4, T, Q> const& x);
  constexpr mat(mat<4, 2, T, Q> const& x);
  constexpr mat(mat<3, 4, T, Q> const& x);
  constexpr mat(mat<4, 3, T, Q> const& x);



  template<typename U>
  constexpr mat<3, 3, T, Q> & operator=(mat<3, 3, U, Q> const& m);
  template<typename U>
  constexpr mat<3, 3, T, Q> & operator+=(U s);
  template<typename U>
  constexpr mat<3, 3, T, Q> & operator+=(mat<3, 3, U, Q> const& m);
  template<typename U>
  constexpr mat<3, 3, T, Q> & operator-=(U s);
  template<typename U>
  constexpr mat<3, 3, T, Q> & operator-=(mat<3, 3, U, Q> const& m);
  template<typename U>
  constexpr mat<3, 3, T, Q> & operator*=(U s);
  template<typename U>
  constexpr mat<3, 3, T, Q> & operator*=(mat<3, 3, U, Q> const& m);
  template<typename U>
  constexpr mat<3, 3, T, Q> & operator/=(U s);
  template<typename U>
  constexpr mat<3, 3, T, Q> & operator/=(mat<3, 3, U, Q> const& m);



  constexpr mat<3, 3, T, Q> & operator++();
  constexpr mat<3, 3, T, Q> & operator--();
  [[nodiscard]] constexpr mat<3, 3, T, Q> operator++(int);
  [[nodiscard]] constexpr mat<3, 3, T, Q> operator--(int);
 };



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 3, T, Q> operator+(mat<3, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 3, T, Q> operator-(mat<3, 3, T, Q> const& m);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 3, T, Q> operator+(mat<3, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 3, T, Q> operator+(T scalar, mat<3, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 3, T, Q> operator+(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 3, T, Q> operator-(mat<3, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 3, T, Q> operator-(T scalar, mat<3, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 3, T, Q> operator-(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 3, T, Q> operator*(mat<3, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 3, T, Q> operator*(T scalar, mat<3, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<3, 3, T, Q>::col_type operator*(mat<3, 3, T, Q> const& m, typename mat<3, 3, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<3, 3, T, Q>::row_type operator*(typename mat<3, 3, T, Q>::col_type const& v, mat<3, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 3, T, Q> operator*(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 3, T, Q> operator*(mat<3, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 3, T, Q> operator*(mat<3, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 3, T, Q> operator/(mat<3, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 3, T, Q> operator/(T scalar, mat<3, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<3, 3, T, Q>::col_type operator/(mat<3, 3, T, Q> const& m, typename mat<3, 3, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<3, 3, T, Q>::row_type operator/(typename mat<3, 3, T, Q>::col_type const& v, mat<3, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 3, T, Q> operator/(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator==(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator!=(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2);
}


# 1 "/usr/include/glm/detail/type_mat3x3.inl" 1 3 4


namespace glm
{
# 22 "/usr/include/glm/detail/type_mat3x3.inl" 3 4
 template<typename T, qualifier Q>
 template<qualifier P>
 inline constexpr mat<3, 3, T, Q>::mat(mat<3, 3, T, P> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q>::mat(T s)

   : value{col_type(s, 0, 0), col_type(0, s, 0), col_type(0, 0, s)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q>::mat
 (
  T x0, T y0, T z0,
  T x1, T y1, T z1,
  T x2, T y2, T z2
 )

   : value{col_type(x0, y0, z0), col_type(x1, y1, z1), col_type(x2, y2, z2)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q>::mat(col_type const& v0, col_type const& v1, col_type const& v2)

   : value{col_type(v0), col_type(v1), col_type(v2)}

 {





 }



 template<typename T, qualifier Q>
 template<
  typename X1, typename Y1, typename Z1,
  typename X2, typename Y2, typename Z2,
  typename X3, typename Y3, typename Z3>
 inline constexpr mat<3, 3, T, Q>::mat
 (
  X1 x1, Y1 y1, Z1 z1,
  X2 x2, Y2 y2, Z2 z2,
  X3 x3, Y3 y3, Z3 z3
 )

   : value{col_type(x1, y1, z1), col_type(x2, y2, z2), col_type(x3, y3, z3)}

 {





 }

 template<typename T, qualifier Q>
 template<typename V1, typename V2, typename V3>
 inline constexpr mat<3, 3, T, Q>::mat(vec<3, V1, Q> const& v1, vec<3, V2, Q> const& v2, vec<3, V3, Q> const& v3)

   : value{col_type(v1), col_type(v2), col_type(v3)}

 {





 }



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr mat<3, 3, T, Q>::mat(mat<3, 3, U, P> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q>::mat(mat<2, 2, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0), col_type(0, 0, 1)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q>::mat(mat<4, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q>::mat(mat<2, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(0, 0, 1)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q>::mat(mat<3, 2, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 1)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q>::mat(mat<2, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(0, 0, 1)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q>::mat(mat<4, 2, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 1)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q>::mat(mat<3, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q>::mat(mat<4, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }



 template<typename T, qualifier Q>
 inline constexpr typename mat<3, 3, T, Q>::col_type & mat<3, 3, T, Q>::operator[](typename mat<3, 3, T, Q>::length_type i) noexcept
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));
  return this->value[i];
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<3, 3, T, Q>::col_type const& mat<3, 3, T, Q>::operator[](typename mat<3, 3, T, Q>::length_type i) const noexcept
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));
  return this->value[i];
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator=(mat<3, 3, U, Q> const& m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator+=(mat<3, 3, U, Q> const& m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator-=(mat<3, 3, U, Q> const& m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator*=(mat<3, 3, U, Q> const& m)
 {
  return (*this = *this * m);
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator/=(mat<3, 3, U, Q> const& m)
 {
  return *this *= inverse(m);
 }



 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> & mat<3, 3, T, Q>::operator--()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> mat<3, 3, T, Q>::operator++(int)
 {
  mat<3, 3, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> mat<3, 3, T, Q>::operator--(int)
 {
  mat<3, 3, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> operator+(mat<3, 3, T, Q> const& m)
 {
  return m;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> operator-(mat<3, 3, T, Q> const& m)
 {
  return mat<3, 3, T, Q>(
   -m[0],
   -m[1],
   -m[2]);
 }



 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> operator+(mat<3, 3, T, Q> const& m, T scalar)
 {
  return mat<3, 3, T, Q>(
   m[0] + scalar,
   m[1] + scalar,
   m[2] + scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> operator+(T scalar, mat<3, 3, T, Q> const& m)
 {
  return mat<3, 3, T, Q>(
   m[0] + scalar,
   m[1] + scalar,
   m[2] + scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> operator+(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
 {
  return mat<3, 3, T, Q>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> operator-(mat<3, 3, T, Q> const& m, T scalar)
 {
  return mat<3, 3, T, Q>(
   m[0] - scalar,
   m[1] - scalar,
   m[2] - scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> operator-(T scalar, mat<3, 3, T, Q> const& m)
 {
  return mat<3, 3, T, Q>(
   scalar - m[0],
   scalar - m[1],
   scalar - m[2]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> operator-(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
 {
  return mat<3, 3, T, Q>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> operator*(mat<3, 3, T, Q> const& m, T scalar)
 {
  return mat<3, 3, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> operator*(T scalar, mat<3, 3, T, Q> const& m)
 {
  return mat<3, 3, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<3, 3, T, Q>::col_type operator*(mat<3, 3, T, Q> const& m, typename mat<3, 3, T, Q>::row_type const& v)
 {
  return typename mat<3, 3, T, Q>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z,
   m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<3, 3, T, Q>::row_type operator*(typename mat<3, 3, T, Q>::col_type const& v, mat<3, 3, T, Q> const& m)
 {
  return typename mat<3, 3, T, Q>::row_type(
   m[0][0] * v.x + m[0][1] * v.y + m[0][2] * v.z,
   m[1][0] * v.x + m[1][1] * v.y + m[1][2] * v.z,
   m[2][0] * v.x + m[2][1] * v.y + m[2][2] * v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> operator*(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
 {
  T const SrcA00 = m1[0][0];
  T const SrcA01 = m1[0][1];
  T const SrcA02 = m1[0][2];
  T const SrcA10 = m1[1][0];
  T const SrcA11 = m1[1][1];
  T const SrcA12 = m1[1][2];
  T const SrcA20 = m1[2][0];
  T const SrcA21 = m1[2][1];
  T const SrcA22 = m1[2][2];

  T const SrcB00 = m2[0][0];
  T const SrcB01 = m2[0][1];
  T const SrcB02 = m2[0][2];
  T const SrcB10 = m2[1][0];
  T const SrcB11 = m2[1][1];
  T const SrcB12 = m2[1][2];
  T const SrcB20 = m2[2][0];
  T const SrcB21 = m2[2][1];
  T const SrcB22 = m2[2][2];

  mat<3, 3, T, Q> Result;
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> operator*(mat<3, 3, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
 {
  return mat<2, 3, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> operator*(mat<3, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
 {
  return mat<4, 3, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2],
   m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1] + m1[2][2] * m2[3][2]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> operator/(mat<3, 3, T, Q> const& m, T scalar)
 {
  return mat<3, 3, T, Q>(
   m[0] / scalar,
   m[1] / scalar,
   m[2] / scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> operator/(T scalar, mat<3, 3, T, Q> const& m)
 {
  return mat<3, 3, T, Q>(
   scalar / m[0],
   scalar / m[1],
   scalar / m[2]);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<3, 3, T, Q>::col_type operator/(mat<3, 3, T, Q> const& m, typename mat<3, 3, T, Q>::row_type const& v)
 {
  return inverse(m) * v;
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<3, 3, T, Q>::row_type operator/(typename mat<3, 3, T, Q>::col_type const& v, mat<3, 3, T, Q> const& m)
 {
  return v * inverse(m);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> operator/(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
 {
  mat<3, 3, T, Q> m1_copy(m1);
  return m1_copy /= m2;
 }



 template<typename T, qualifier Q>
 inline constexpr bool operator==(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
 }

 template<typename T, qualifier Q>
 inline constexpr bool operator!=(mat<3, 3, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
 }
}
# 184 "/usr/include/glm/detail/type_mat3x3.hpp" 2 3 4
# 6 "/usr/include/glm/ext/matrix_double3x3.hpp" 2 3 4

namespace glm
{






 typedef mat<3, 3, double, defaultp> dmat3x3;




 typedef mat<3, 3, double, defaultp> dmat3;


}
# 6 "/usr/include/glm/mat3x3.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_double3x3_precision.hpp" 1 3 4



       


namespace glm
{







 typedef mat<3, 3, double, lowp> lowp_dmat3;





 typedef mat<3, 3, double, mediump> mediump_dmat3;





 typedef mat<3, 3, double, highp> highp_dmat3;





 typedef mat<3, 3, double, lowp> lowp_dmat3x3;





 typedef mat<3, 3, double, mediump> mediump_dmat3x3;





 typedef mat<3, 3, double, highp> highp_dmat3x3;


}
# 7 "/usr/include/glm/mat3x3.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_float3x3.hpp" 1 3 4



       


namespace glm
{






 typedef mat<3, 3, float, defaultp> mat3x3;




 typedef mat<3, 3, float, defaultp> mat3;


}
# 8 "/usr/include/glm/mat3x3.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_float3x3_precision.hpp" 1 3 4



       


namespace glm
{







 typedef mat<3, 3, float, lowp> lowp_mat3;





 typedef mat<3, 3, float, mediump> mediump_mat3;





 typedef mat<3, 3, float, highp> highp_mat3;





 typedef mat<3, 3, float, lowp> lowp_mat3x3;





 typedef mat<3, 3, float, mediump> mediump_mat3x3;





 typedef mat<3, 3, float, highp> highp_mat3x3;


}
# 9 "/usr/include/glm/mat3x3.hpp" 2 3 4
# 26 "/usr/include/glm/matrix.hpp" 2 3 4
# 1 "/usr/include/glm/mat3x4.hpp" 1 3 4



       
# 1 "/usr/include/glm/ext/matrix_double3x4.hpp" 1 3 4



       
# 1 "/usr/include/glm/detail/type_mat3x4.hpp" 1 3 4



       






namespace glm
{
 template<typename T, qualifier Q>
 struct mat<3, 4, T, Q>
 {
  typedef vec<4, T, Q> col_type;
  typedef vec<3, T, Q> row_type;
  typedef mat<3, 4, T, Q> type;
  typedef mat<4, 3, T, Q> transpose_type;
  typedef T value_type;

 private:
  col_type value[3];

 public:


  typedef length_t length_type;
  [[nodiscard]] static constexpr length_type length() { return 3; }

  [[nodiscard]] constexpr col_type & operator[](length_type i) noexcept;
  [[nodiscard]] constexpr col_type const& operator[](length_type i) const noexcept;



  constexpr mat() = default;
  template<qualifier P>
  constexpr mat(mat<3, 4, T, P> const& m);

  constexpr mat(T scalar);
  constexpr mat(
   T x0, T y0, T z0, T w0,
   T x1, T y1, T z1, T w1,
   T x2, T y2, T z2, T w2);
  constexpr mat(
   col_type const& v0,
   col_type const& v1,
   col_type const& v2);



  template<
   typename X1, typename Y1, typename Z1, typename W1,
   typename X2, typename Y2, typename Z2, typename W2,
   typename X3, typename Y3, typename Z3, typename W3>
  constexpr mat(
   X1 x1, Y1 y1, Z1 z1, W1 w1,
   X2 x2, Y2 y2, Z2 z2, W2 w2,
   X3 x3, Y3 y3, Z3 z3, W3 w3);

  template<typename V1, typename V2, typename V3>
  constexpr mat(
   vec<4, V1, Q> const& v1,
   vec<4, V2, Q> const& v2,
   vec<4, V3, Q> const& v3);



  template<typename U, qualifier P>
  constexpr mat(mat<3, 4, U, P> const& m);

  constexpr mat(mat<2, 2, T, Q> const& x);
  constexpr mat(mat<3, 3, T, Q> const& x);
  constexpr mat(mat<4, 4, T, Q> const& x);
  constexpr mat(mat<2, 3, T, Q> const& x);
  constexpr mat(mat<3, 2, T, Q> const& x);
  constexpr mat(mat<2, 4, T, Q> const& x);
  constexpr mat(mat<4, 2, T, Q> const& x);
  constexpr mat(mat<4, 3, T, Q> const& x);



  template<typename U>
  constexpr mat<3, 4, T, Q> & operator=(mat<3, 4, U, Q> const& m);
  template<typename U>
  constexpr mat<3, 4, T, Q> & operator+=(U s);
  template<typename U>
  constexpr mat<3, 4, T, Q> & operator+=(mat<3, 4, U, Q> const& m);
  template<typename U>
  constexpr mat<3, 4, T, Q> & operator-=(U s);
  template<typename U>
  constexpr mat<3, 4, T, Q> & operator-=(mat<3, 4, U, Q> const& m);
  template<typename U>
  constexpr mat<3, 4, T, Q> & operator*=(U s);
  template<typename U>
  constexpr mat<3, 4, T, Q> & operator/=(U s);



  constexpr mat<3, 4, T, Q> & operator++();
  constexpr mat<3, 4, T, Q> & operator--();
  [[nodiscard]] constexpr mat<3, 4, T, Q> operator++(int);
  [[nodiscard]] constexpr mat<3, 4, T, Q> operator--(int);
 };



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 4, T, Q> operator+(mat<3, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 4, T, Q> operator-(mat<3, 4, T, Q> const& m);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 4, T, Q> operator+(mat<3, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 4, T, Q> operator+(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 4, T, Q> operator-(mat<3, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 4, T, Q> operator-(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 4, T, Q> operator*(mat<3, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 4, T, Q> operator*(T scalar, mat<3, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<3, 4, T, Q>::col_type operator*(mat<3, 4, T, Q> const& m, typename mat<3, 4, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<3, 4, T, Q>::row_type operator*(typename mat<3, 4, T, Q>::col_type const& v, mat<3, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> operator*(mat<3, 4, T, Q> const& m1, mat<4, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 4, T, Q> operator*(mat<3, 4, T, Q> const& m1, mat<2, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 4, T, Q> operator*(mat<3, 4, T, Q> const& m1, mat<3, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 4, T, Q> operator/(mat<3, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 4, T, Q> operator/(T scalar, mat<3, 4, T, Q> const& m);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator==(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator!=(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2);
}


# 1 "/usr/include/glm/detail/type_mat3x4.inl" 1 3 4
namespace glm
{
# 20 "/usr/include/glm/detail/type_mat3x4.inl" 3 4
 template<typename T, qualifier Q>
 template<qualifier P>
 inline constexpr mat<3, 4, T, Q>::mat(mat<3, 4, T, P> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q>::mat(T s)

   : value{col_type(s, 0, 0, 0), col_type(0, s, 0, 0), col_type(0, 0, s, 0)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q>::mat
 (
  T x0, T y0, T z0, T w0,
  T x1, T y1, T z1, T w1,
  T x2, T y2, T z2, T w2
 )

   : value{
    col_type(x0, y0, z0, w0),
    col_type(x1, y1, z1, w1),
    col_type(x2, y2, z2, w2)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q>::mat(col_type const& v0, col_type const& v1, col_type const& v2)

   : value{col_type(v0), col_type(v1), col_type(v2)}

 {





 }



 template<typename T, qualifier Q>
 template<
  typename X0, typename Y0, typename Z0, typename W0,
  typename X1, typename Y1, typename Z1, typename W1,
  typename X2, typename Y2, typename Z2, typename W2>
 inline constexpr mat<3, 4, T, Q>::mat
 (
  X0 x0, Y0 y0, Z0 z0, W0 w0,
  X1 x1, Y1 y1, Z1 z1, W1 w1,
  X2 x2, Y2 y2, Z2 z2, W2 w2
 )

   : value{
    col_type(x0, y0, z0, w0),
    col_type(x1, y1, z1, w1),
    col_type(x2, y2, z2, w2)}

 {





 }

 template<typename T, qualifier Q>
 template<typename V1, typename V2, typename V3>
 inline constexpr mat<3, 4, T, Q>::mat(vec<4, V1, Q> const& v0, vec<4, V2, Q> const& v1, vec<4, V3, Q> const& v2)

   : value{col_type(v0), col_type(v1), col_type(v2)}

 {





 }



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr mat<3, 4, T, Q>::mat(mat<3, 4, U, P> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q>::mat(mat<2, 2, T, Q> const& m)

   : value{col_type(m[0], 0, 0), col_type(m[1], 0, 0), col_type(0, 0, 1, 0)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q>::mat(mat<3, 3, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 0)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q>::mat(mat<4, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2])}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q>::mat(mat<2, 3, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0), col_type(0, 0, 1, 0)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q>::mat(mat<3, 2, T, Q> const& m)

   : value{col_type(m[0], 0, 0), col_type(m[1], 0, 0), col_type(m[2], 1, 0)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q>::mat(mat<2, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(0, 0, 1, 0)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q>::mat(mat<4, 2, T, Q> const& m)

   : value{col_type(m[0], 0, 0), col_type(m[1], 0, 0), col_type(m[2], 1, 0)}

 {





 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q>::mat(mat<4, 3, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 0)}

 {





 }



 template<typename T, qualifier Q>
 inline constexpr typename mat<3, 4, T, Q>::col_type & mat<3, 4, T, Q>::operator[](typename mat<3, 4, T, Q>::length_type i) noexcept
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));
  return this->value[i];
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<3, 4, T, Q>::col_type const& mat<3, 4, T, Q>::operator[](typename mat<3, 4, T, Q>::length_type i) const noexcept
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));
  return this->value[i];
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator=(mat<3, 4, U, Q> const& m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator+=(mat<3, 4, U, Q> const& m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator-=(mat<3, 4, U, Q> const& m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<3, 4, T, Q> & mat<3, 4, T, Q>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  return *this;
 }



 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q>& mat<3, 4, T, Q>::operator--()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q> mat<3, 4, T, Q>::operator++(int)
 {
  mat<3, 4, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q> mat<3, 4, T, Q>::operator--(int)
 {
  mat<3, 4, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q> operator+(mat<3, 4, T, Q> const& m)
 {
  return m;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q> operator-(mat<3, 4, T, Q> const& m)
 {
  return mat<3, 4, T, Q>(
   -m[0],
   -m[1],
   -m[2]);
 }



 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q> operator+(mat<3, 4, T, Q> const& m, T scalar)
 {
  return mat<3, 4, T, Q>(
   m[0] + scalar,
   m[1] + scalar,
   m[2] + scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q> operator+(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
 {
  return mat<3, 4, T, Q>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q> operator-(mat<3, 4, T, Q> const& m, T scalar)
 {
  return mat<3, 4, T, Q>(
   m[0] - scalar,
   m[1] - scalar,
   m[2] - scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q> operator-(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
 {
  return mat<3, 4, T, Q>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q> operator*(mat<3, 4, T, Q> const& m, T scalar)
 {
  return mat<3, 4, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q> operator*(T scalar, mat<3, 4, T, Q> const& m)
 {
  return mat<3, 4, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<3, 4, T, Q>::col_type operator*
 (
  mat<3, 4, T, Q> const& m,
  typename mat<3, 4, T, Q>::row_type const& v
 )
 {
  return typename mat<3, 4, T, Q>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z,
   m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z,
   m[0][3] * v.x + m[1][3] * v.y + m[2][3] * v.z);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<3, 4, T, Q>::row_type operator*
 (
  typename mat<3, 4, T, Q>::col_type const& v,
  mat<3, 4, T, Q> const& m
 )
 {
  return typename mat<3, 4, T, Q>::row_type(
   v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2] + v.w * m[0][3],
   v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2] + v.w * m[1][3],
   v.x * m[2][0] + v.y * m[2][1] + v.z * m[2][2] + v.w * m[2][3]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> operator*(mat<3, 4, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
 {
  const T SrcA00 = m1[0][0];
  const T SrcA01 = m1[0][1];
  const T SrcA02 = m1[0][2];
  const T SrcA03 = m1[0][3];
  const T SrcA10 = m1[1][0];
  const T SrcA11 = m1[1][1];
  const T SrcA12 = m1[1][2];
  const T SrcA13 = m1[1][3];
  const T SrcA20 = m1[2][0];
  const T SrcA21 = m1[2][1];
  const T SrcA22 = m1[2][2];
  const T SrcA23 = m1[2][3];

  const T SrcB00 = m2[0][0];
  const T SrcB01 = m2[0][1];
  const T SrcB02 = m2[0][2];
  const T SrcB10 = m2[1][0];
  const T SrcB11 = m2[1][1];
  const T SrcB12 = m2[1][2];
  const T SrcB20 = m2[2][0];
  const T SrcB21 = m2[2][1];
  const T SrcB22 = m2[2][2];
  const T SrcB30 = m2[3][0];
  const T SrcB31 = m2[3][1];
  const T SrcB32 = m2[3][2];

  mat<4, 4, T, Q> Result;
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02;
  Result[0][3] = SrcA03 * SrcB00 + SrcA13 * SrcB01 + SrcA23 * SrcB02;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12;
  Result[1][3] = SrcA03 * SrcB10 + SrcA13 * SrcB11 + SrcA23 * SrcB12;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22;
  Result[2][3] = SrcA03 * SrcB20 + SrcA13 * SrcB21 + SrcA23 * SrcB22;
  Result[3][0] = SrcA00 * SrcB30 + SrcA10 * SrcB31 + SrcA20 * SrcB32;
  Result[3][1] = SrcA01 * SrcB30 + SrcA11 * SrcB31 + SrcA21 * SrcB32;
  Result[3][2] = SrcA02 * SrcB30 + SrcA12 * SrcB31 + SrcA22 * SrcB32;
  Result[3][3] = SrcA03 * SrcB30 + SrcA13 * SrcB31 + SrcA23 * SrcB32;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q> operator*(mat<3, 4, T, Q> const& m1, mat<2, 3, T, Q> const& m2)
 {
  return mat<2, 4, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q> operator*(mat<3, 4, T, Q> const& m1, mat<3, 3, T, Q> const& m2)
 {
  return mat<3, 4, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2],
   m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1] + m1[2][3] * m2[2][2]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q> operator/(mat<3, 4, T, Q> const& m, T scalar)
 {
  return mat<3, 4, T, Q>(
   m[0] / scalar,
   m[1] / scalar,
   m[2] / scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q> operator/(T scalar, mat<3, 4, T, Q> const& m)
 {
  return mat<3, 4, T, Q>(
   scalar / m[0],
   scalar / m[1],
   scalar / m[2]);
 }



 template<typename T, qualifier Q>
 inline constexpr bool operator==(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
 }

 template<typename T, qualifier Q>
 inline constexpr bool operator!=(mat<3, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
 }
}
# 166 "/usr/include/glm/detail/type_mat3x4.hpp" 2 3 4
# 6 "/usr/include/glm/ext/matrix_double3x4.hpp" 2 3 4

namespace glm
{






 typedef mat<3, 4, double, defaultp> dmat3x4;


}
# 6 "/usr/include/glm/mat3x4.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_double3x4_precision.hpp" 1 3 4



       


namespace glm
{







 typedef mat<3, 4, double, lowp> lowp_dmat3x4;





 typedef mat<3, 4, double, mediump> mediump_dmat3x4;





 typedef mat<3, 4, double, highp> highp_dmat3x4;


}
# 7 "/usr/include/glm/mat3x4.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_float3x4.hpp" 1 3 4



       


namespace glm
{






 typedef mat<3, 4, float, defaultp> mat3x4;


}
# 8 "/usr/include/glm/mat3x4.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_float3x4_precision.hpp" 1 3 4



       


namespace glm
{







 typedef mat<3, 4, float, lowp> lowp_mat3x4;





 typedef mat<3, 4, float, mediump> mediump_mat3x4;





 typedef mat<3, 4, float, highp> highp_mat3x4;


}
# 9 "/usr/include/glm/mat3x4.hpp" 2 3 4
# 27 "/usr/include/glm/matrix.hpp" 2 3 4
# 1 "/usr/include/glm/mat4x2.hpp" 1 3 4



       
# 1 "/usr/include/glm/ext/matrix_double4x2.hpp" 1 3 4



       
# 1 "/usr/include/glm/detail/type_mat4x2.hpp" 1 3 4



       






namespace glm
{
 template<typename T, qualifier Q>
 struct mat<4, 2, T, Q>
 {
  typedef vec<2, T, Q> col_type;
  typedef vec<4, T, Q> row_type;
  typedef mat<4, 2, T, Q> type;
  typedef mat<2, 4, T, Q> transpose_type;
  typedef T value_type;

 private:
  col_type value[4];

 public:


  typedef length_t length_type;
  [[nodiscard]] static constexpr length_type length() { return 4; }

  [[nodiscard]] constexpr col_type & operator[](length_type i) noexcept;
  [[nodiscard]] constexpr col_type const& operator[](length_type i) const noexcept;



  constexpr mat() = default;
  template<qualifier P>
  constexpr mat(mat<4, 2, T, P> const& m);

  constexpr mat(T scalar);
  constexpr mat(
   T x0, T y0,
   T x1, T y1,
   T x2, T y2,
   T x3, T y3);
  constexpr mat(
   col_type const& v0,
   col_type const& v1,
   col_type const& v2,
   col_type const& v3);



  template<
   typename X0, typename Y0,
   typename X1, typename Y1,
   typename X2, typename Y2,
   typename X3, typename Y3>
  constexpr mat(
   X0 x0, Y0 y0,
   X1 x1, Y1 y1,
   X2 x2, Y2 y2,
   X3 x3, Y3 y3);

  template<typename V1, typename V2, typename V3, typename V4>
  constexpr mat(
   vec<2, V1, Q> const& v1,
   vec<2, V2, Q> const& v2,
   vec<2, V3, Q> const& v3,
   vec<2, V4, Q> const& v4);



  template<typename U, qualifier P>
  constexpr mat(mat<4, 2, U, P> const& m);

  constexpr mat(mat<2, 2, T, Q> const& x);
  constexpr mat(mat<3, 3, T, Q> const& x);
  constexpr mat(mat<4, 4, T, Q> const& x);
  constexpr mat(mat<2, 3, T, Q> const& x);
  constexpr mat(mat<3, 2, T, Q> const& x);
  constexpr mat(mat<2, 4, T, Q> const& x);
  constexpr mat(mat<4, 3, T, Q> const& x);
  constexpr mat(mat<3, 4, T, Q> const& x);



  template<typename U>
  constexpr mat<4, 2, T, Q> & operator=(mat<4, 2, U, Q> const& m);
  template<typename U>
  constexpr mat<4, 2, T, Q> & operator+=(U s);
  template<typename U>
  constexpr mat<4, 2, T, Q> & operator+=(mat<4, 2, U, Q> const& m);
  template<typename U>
  constexpr mat<4, 2, T, Q> & operator-=(U s);
  template<typename U>
  constexpr mat<4, 2, T, Q> & operator-=(mat<4, 2, U, Q> const& m);
  template<typename U>
  constexpr mat<4, 2, T, Q> & operator*=(U s);
  template<typename U>
  constexpr mat<4, 2, T, Q> & operator/=(U s);



  constexpr mat<4, 2, T, Q> & operator++ ();
  constexpr mat<4, 2, T, Q> & operator-- ();
  [[nodiscard]] constexpr mat<4, 2, T, Q> operator++(int);
  [[nodiscard]] constexpr mat<4, 2, T, Q> operator--(int);
 };



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 2, T, Q> operator+(mat<4, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 2, T, Q> operator-(mat<4, 2, T, Q> const& m);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 2, T, Q> operator+(mat<4, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 2, T, Q> operator+(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 2, T, Q> operator-(mat<4, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 2, T, Q> operator-(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 2, T, Q> operator*(mat<4, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 2, T, Q> operator*(T scalar, mat<4, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<4, 2, T, Q>::col_type operator*(mat<4, 2, T, Q> const& m, typename mat<4, 2, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<4, 2, T, Q>::row_type operator*(typename mat<4, 2, T, Q>::col_type const& v, mat<4, 2, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 2, T, Q> operator*(mat<4, 2, T, Q> const& m1, mat<2, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 2, T, Q> operator*(mat<4, 2, T, Q> const& m1, mat<3, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 2, T, Q> operator*(mat<4, 2, T, Q> const& m1, mat<4, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 2, T, Q> operator/(mat<4, 2, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 2, T, Q> operator/(T scalar, mat<4, 2, T, Q> const& m);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator==(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator!=(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2);
}


# 1 "/usr/include/glm/detail/type_mat4x2.inl" 1 3 4
namespace glm
{
# 21 "/usr/include/glm/detail/type_mat4x2.inl" 3 4
 template<typename T, qualifier Q>
 template<qualifier P>
 inline constexpr mat<4, 2, T, Q>::mat(mat<4, 2, T, P> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q>::mat(T s)

   : value{col_type(s, 0), col_type(0, s), col_type(0, 0), col_type(0, 0)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q>::mat
 (
  T x0, T y0,
  T x1, T y1,
  T x2, T y2,
  T x3, T y3
 )

   : value{col_type(x0, y0), col_type(x1, y1), col_type(x2, y2), col_type(x3, y3)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q>::mat(col_type const& v0, col_type const& v1, col_type const& v2, col_type const& v3)

   : value{col_type(v0), col_type(v1), col_type(v2), col_type(v3)}

 {






 }



 template<typename T, qualifier Q>
 template<
  typename X0, typename Y0,
  typename X1, typename Y1,
  typename X2, typename Y2,
  typename X3, typename Y3>
 inline constexpr mat<4, 2, T, Q>::mat
 (
  X0 x0, Y0 y0,
  X1 x1, Y1 y1,
  X2 x2, Y2 y2,
  X3 x3, Y3 y3
 )

   : value{col_type(x0, y0), col_type(x1, y1), col_type(x2, y2), col_type(x3, y3)}

 {






 }

 template<typename T, qualifier Q>
 template<typename V0, typename V1, typename V2, typename V3>
 inline constexpr mat<4, 2, T, Q>::mat(vec<2, V0, Q> const& v0, vec<2, V1, Q> const& v1, vec<2, V2, Q> const& v2, vec<2, V3, Q> const& v3)

   : value{col_type(v0), col_type(v1), col_type(v2), col_type(v3)}

 {






 }



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr mat<4, 2, T, Q>::mat(mat<4, 2, U, P> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q>::mat(mat<2, 2, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(0), col_type(0)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q>::mat(mat<3, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(0)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q>::mat(mat<4, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q>::mat(mat<2, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(0), col_type(0)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q>::mat(mat<3, 2, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(0)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q>::mat(mat<2, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(0), col_type(0)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q>::mat(mat<4, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q>::mat(mat<3, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(0)}

 {






 }



 template<typename T, qualifier Q>
 inline constexpr typename mat<4, 2, T, Q>::col_type & mat<4, 2, T, Q>::operator[](typename mat<4, 2, T, Q>::length_type i) noexcept
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));
  return this->value[i];
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<4, 2, T, Q>::col_type const& mat<4, 2, T, Q>::operator[](typename mat<4, 2, T, Q>::length_type i) const noexcept
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));
  return this->value[i];
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 2, T, Q>& mat<4, 2, T, Q>::operator=(mat<4, 2, U, Q> const& m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  this->value[3] = m[3];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  this->value[3] += s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator+=(mat<4, 2, U, Q> const& m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  this->value[3] += m[3];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  this->value[3] -= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator-=(mat<4, 2, U, Q> const& m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  this->value[3] -= m[3];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  this->value[3] *= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  this->value[3] /= s;
  return *this;
 }



 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  ++this->value[3];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> & mat<4, 2, T, Q>::operator--()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  --this->value[3];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> mat<4, 2, T, Q>::operator++(int)
 {
  mat<4, 2, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> mat<4, 2, T, Q>::operator--(int)
 {
  mat<4, 2, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> operator+(mat<4, 2, T, Q> const& m)
 {
  return m;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> operator-(mat<4, 2, T, Q> const& m)
 {
  return mat<4, 2, T, Q>(
   -m[0],
   -m[1],
   -m[2],
   -m[3]);
 }



 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> operator+(mat<4, 2, T, Q> const& m, T scalar)
 {
  return mat<4, 2, T, Q>(
   m[0] + scalar,
   m[1] + scalar,
   m[2] + scalar,
   m[3] + scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> operator+(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
 {
  return mat<4, 2, T, Q>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2],
   m1[3] + m2[3]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> operator-(mat<4, 2, T, Q> const& m, T scalar)
 {
  return mat<4, 2, T, Q>(
   m[0] - scalar,
   m[1] - scalar,
   m[2] - scalar,
   m[3] - scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> operator-(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
 {
  return mat<4, 2, T, Q>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2],
   m1[3] - m2[3]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> operator*(mat<4, 2, T, Q> const& m, T scalar)
 {
  return mat<4, 2, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar,
   m[3] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> operator*(T scalar, mat<4, 2, T, Q> const& m)
 {
  return mat<4, 2, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar,
   m[3] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<4, 2, T, Q>::col_type operator*(mat<4, 2, T, Q> const& m, typename mat<4, 2, T, Q>::row_type const& v)
 {
  return typename mat<4, 2, T, Q>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z + m[3][0] * v.w,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z + m[3][1] * v.w);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<4, 2, T, Q>::row_type operator*(typename mat<4, 2, T, Q>::col_type const& v, mat<4, 2, T, Q> const& m)
 {
  return typename mat<4, 2, T, Q>::row_type(
   v.x * m[0][0] + v.y * m[0][1],
   v.x * m[1][0] + v.y * m[1][1],
   v.x * m[2][0] + v.y * m[2][1],
   v.x * m[3][0] + v.y * m[3][1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> operator*(mat<4, 2, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
 {
  T const SrcA00 = m1[0][0];
  T const SrcA01 = m1[0][1];
  T const SrcA10 = m1[1][0];
  T const SrcA11 = m1[1][1];
  T const SrcA20 = m1[2][0];
  T const SrcA21 = m1[2][1];
  T const SrcA30 = m1[3][0];
  T const SrcA31 = m1[3][1];

  T const SrcB00 = m2[0][0];
  T const SrcB01 = m2[0][1];
  T const SrcB02 = m2[0][2];
  T const SrcB03 = m2[0][3];
  T const SrcB10 = m2[1][0];
  T const SrcB11 = m2[1][1];
  T const SrcB12 = m2[1][2];
  T const SrcB13 = m2[1][3];

  mat<2, 2, T, Q> Result;
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02 + SrcA30 * SrcB03;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02 + SrcA31 * SrcB03;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12 + SrcA30 * SrcB13;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12 + SrcA31 * SrcB13;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q> operator*(mat<4, 2, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
 {
  return mat<3, 2, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> operator*(mat<4, 2, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
 {
  return mat<4, 2, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2] + m1[3][0] * m2[3][3],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2] + m1[3][1] * m2[3][3]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> operator/(mat<4, 2, T, Q> const& m, T scalar)
 {
  return mat<4, 2, T, Q>(
   m[0] / scalar,
   m[1] / scalar,
   m[2] / scalar,
   m[3] / scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> operator/(T scalar, mat<4, 2, T, Q> const& m)
 {
  return mat<4, 2, T, Q>(
   scalar / m[0],
   scalar / m[1],
   scalar / m[2],
   scalar / m[3]);
 }



 template<typename T, qualifier Q>
 inline constexpr bool operator==(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
 }

 template<typename T, qualifier Q>
 inline constexpr bool operator!=(mat<4, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
 }
}
# 171 "/usr/include/glm/detail/type_mat4x2.hpp" 2 3 4
# 6 "/usr/include/glm/ext/matrix_double4x2.hpp" 2 3 4

namespace glm
{






 typedef mat<4, 2, double, defaultp> dmat4x2;


}
# 6 "/usr/include/glm/mat4x2.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_double4x2_precision.hpp" 1 3 4



       


namespace glm
{







 typedef mat<4, 2, double, lowp> lowp_dmat4x2;





 typedef mat<4, 2, double, mediump> mediump_dmat4x2;





 typedef mat<4, 2, double, highp> highp_dmat4x2;


}
# 7 "/usr/include/glm/mat4x2.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_float4x2.hpp" 1 3 4



       


namespace glm
{






 typedef mat<4, 2, float, defaultp> mat4x2;


}
# 8 "/usr/include/glm/mat4x2.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_float4x2_precision.hpp" 1 3 4



       


namespace glm
{







 typedef mat<4, 2, float, lowp> lowp_mat4x2;





 typedef mat<4, 2, float, mediump> mediump_mat4x2;





 typedef mat<4, 2, float, highp> highp_mat4x2;


}
# 9 "/usr/include/glm/mat4x2.hpp" 2 3 4
# 28 "/usr/include/glm/matrix.hpp" 2 3 4
# 1 "/usr/include/glm/mat4x3.hpp" 1 3 4



       
# 1 "/usr/include/glm/ext/matrix_double4x3.hpp" 1 3 4



       
# 1 "/usr/include/glm/detail/type_mat4x3.hpp" 1 3 4



       






namespace glm
{
 template<typename T, qualifier Q>
 struct mat<4, 3, T, Q>
 {
  typedef vec<3, T, Q> col_type;
  typedef vec<4, T, Q> row_type;
  typedef mat<4, 3, T, Q> type;
  typedef mat<3, 4, T, Q> transpose_type;
  typedef T value_type;

 private:
  col_type value[4];

 public:


  typedef length_t length_type;
  [[nodiscard]] static constexpr length_type length() { return 4; }

  [[nodiscard]] constexpr col_type & operator[](length_type i) noexcept;
  [[nodiscard]] constexpr col_type const& operator[](length_type i) const noexcept;



  constexpr mat() = default;
  template<qualifier P>
  constexpr mat(mat<4, 3, T, P> const& m);

  constexpr mat(T s);
  constexpr mat(
   T const& x0, T const& y0, T const& z0,
   T const& x1, T const& y1, T const& z1,
   T const& x2, T const& y2, T const& z2,
   T const& x3, T const& y3, T const& z3);
  constexpr mat(
   col_type const& v0,
   col_type const& v1,
   col_type const& v2,
   col_type const& v3);



  template<
   typename X1, typename Y1, typename Z1,
   typename X2, typename Y2, typename Z2,
   typename X3, typename Y3, typename Z3,
   typename X4, typename Y4, typename Z4>
  constexpr mat(
   X1 const& x1, Y1 const& y1, Z1 const& z1,
   X2 const& x2, Y2 const& y2, Z2 const& z2,
   X3 const& x3, Y3 const& y3, Z3 const& z3,
   X4 const& x4, Y4 const& y4, Z4 const& z4);

  template<typename V1, typename V2, typename V3, typename V4>
  constexpr mat(
   vec<3, V1, Q> const& v1,
   vec<3, V2, Q> const& v2,
   vec<3, V3, Q> const& v3,
   vec<3, V4, Q> const& v4);



  template<typename U, qualifier P>
  constexpr mat(mat<4, 3, U, P> const& m);

  constexpr mat(mat<2, 2, T, Q> const& x);
  constexpr mat(mat<3, 3, T, Q> const& x);
  constexpr mat(mat<4, 4, T, Q> const& x);
  constexpr mat(mat<2, 3, T, Q> const& x);
  constexpr mat(mat<3, 2, T, Q> const& x);
  constexpr mat(mat<2, 4, T, Q> const& x);
  constexpr mat(mat<4, 2, T, Q> const& x);
  constexpr mat(mat<3, 4, T, Q> const& x);



  template<typename U>
  constexpr mat<4, 3, T, Q> & operator=(mat<4, 3, U, Q> const& m);
  template<typename U>
  constexpr mat<4, 3, T, Q> & operator+=(U s);
  template<typename U>
  constexpr mat<4, 3, T, Q> & operator+=(mat<4, 3, U, Q> const& m);
  template<typename U>
  constexpr mat<4, 3, T, Q> & operator-=(U s);
  template<typename U>
  constexpr mat<4, 3, T, Q> & operator-=(mat<4, 3, U, Q> const& m);
  template<typename U>
  constexpr mat<4, 3, T, Q> & operator*=(U s);
  template<typename U>
  constexpr mat<4, 3, T, Q> & operator/=(U s);



  constexpr mat<4, 3, T, Q>& operator++();
  constexpr mat<4, 3, T, Q>& operator--();
  [[nodiscard]] constexpr mat<4, 3, T, Q> operator++(int);
  [[nodiscard]] constexpr mat<4, 3, T, Q> operator--(int);
 };



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 3, T, Q> operator+(mat<4, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 3, T, Q> operator-(mat<4, 3, T, Q> const& m);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 3, T, Q> operator+(mat<4, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 3, T, Q> operator+(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 3, T, Q> operator-(mat<4, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 3, T, Q> operator-(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 3, T, Q> operator*(mat<4, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 3, T, Q> operator*(T scalar, mat<4, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<4, 3, T, Q>::col_type operator*(mat<4, 3, T, Q> const& m, typename mat<4, 3, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<4, 3, T, Q>::row_type operator*(typename mat<4, 3, T, Q>::col_type const& v, mat<4, 3, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 3, T, Q> operator*(mat<4, 3, T, Q> const& m1, mat<2, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 3, T, Q> operator*(mat<4, 3, T, Q> const& m1, mat<3, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 3, T, Q> operator*(mat<4, 3, T, Q> const& m1, mat<4, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 3, T, Q> operator/(mat<4, 3, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 3, T, Q> operator/(T scalar, mat<4, 3, T, Q> const& m);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator==(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator!=(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2);
}


# 1 "/usr/include/glm/detail/type_mat4x3.inl" 1 3 4
namespace glm
{
# 21 "/usr/include/glm/detail/type_mat4x3.inl" 3 4
 template<typename T, qualifier Q>
 template<qualifier P>
 inline constexpr mat<4, 3, T, Q>::mat(mat<4, 3, T, P> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q>::mat(T s)

   : value{col_type(s, 0, 0), col_type(0, s, 0), col_type(0, 0, s), col_type(0, 0, 0)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q>::mat
 (
  T const& x0, T const& y0, T const& z0,
  T const& x1, T const& y1, T const& z1,
  T const& x2, T const& y2, T const& z2,
  T const& x3, T const& y3, T const& z3
 )

   : value{col_type(x0, y0, z0), col_type(x1, y1, z1), col_type(x2, y2, z2), col_type(x3, y3, z3)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q>::mat(col_type const& v0, col_type const& v1, col_type const& v2, col_type const& v3)

   : value{col_type(v0), col_type(v1), col_type(v2), col_type(v3)}

 {






 }



 template<typename T, qualifier Q>
 template<
  typename X0, typename Y0, typename Z0,
  typename X1, typename Y1, typename Z1,
  typename X2, typename Y2, typename Z2,
  typename X3, typename Y3, typename Z3>
 inline constexpr mat<4, 3, T, Q>::mat
 (
  X0 const& x0, Y0 const& y0, Z0 const& z0,
  X1 const& x1, Y1 const& y1, Z1 const& z1,
  X2 const& x2, Y2 const& y2, Z2 const& z2,
  X3 const& x3, Y3 const& y3, Z3 const& z3
 )

   : value{col_type(x0, y0, z0), col_type(x1, y1, z1), col_type(x2, y2, z2), col_type(x3, y3, z3)}

 {






 }

 template<typename T, qualifier Q>
 template<typename V1, typename V2, typename V3, typename V4>
 inline constexpr mat<4, 3, T, Q>::mat(vec<3, V1, Q> const& v1, vec<3, V2, Q> const& v2, vec<3, V3, Q> const& v3, vec<3, V4, Q> const& v4)

   : value{col_type(v1), col_type(v2), col_type(v3), col_type(v4)}

 {






 }



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr mat<4, 3, T, Q>::mat(mat<4, 3, U, P> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q>::mat(mat<2, 2, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0), col_type(0, 0, 1), col_type(0)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q>::mat(mat<3, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(0)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q>::mat(mat<4, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q>::mat(mat<2, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(0, 0, 1), col_type(0)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q>::mat(mat<3, 2, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 1), col_type(0)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q>::mat(mat<2, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(0, 0, 1), col_type(0)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q>::mat(mat<4, 2, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 1), col_type(m[3], 0)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q>::mat(mat<3, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(0)}

 {






 }



 template<typename T, qualifier Q>
 inline constexpr typename mat<4, 3, T, Q>::col_type & mat<4, 3, T, Q>::operator[](typename mat<4, 3, T, Q>::length_type i) noexcept
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));
  return this->value[i];
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<4, 3, T, Q>::col_type const& mat<4, 3, T, Q>::operator[](typename mat<4, 3, T, Q>::length_type i) const noexcept
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));
  return this->value[i];
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 3, T, Q>& mat<4, 3, T, Q>::operator=(mat<4, 3, U, Q> const& m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  this->value[3] = m[3];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  this->value[3] += s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator+=(mat<4, 3, U, Q> const& m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  this->value[3] += m[3];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  this->value[3] -= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator-=(mat<4, 3, U, Q> const& m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  this->value[3] -= m[3];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  this->value[3] *= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  this->value[3] /= s;
  return *this;
 }



 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  ++this->value[3];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> & mat<4, 3, T, Q>::operator--()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  --this->value[3];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> mat<4, 3, T, Q>::operator++(int)
 {
  mat<4, 3, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> mat<4, 3, T, Q>::operator--(int)
 {
  mat<4, 3, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> operator+(mat<4, 3, T, Q> const& m)
 {
  return m;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> operator-(mat<4, 3, T, Q> const& m)
 {
  return mat<4, 3, T, Q>(
   -m[0],
   -m[1],
   -m[2],
   -m[3]);
 }



 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> operator+(mat<4, 3, T, Q> const& m, T scalar)
 {
  return mat<4, 3, T, Q>(
   m[0] + scalar,
   m[1] + scalar,
   m[2] + scalar,
   m[3] + scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> operator+(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
 {
  return mat<4, 3, T, Q>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2],
   m1[3] + m2[3]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> operator-(mat<4, 3, T, Q> const& m, T scalar)
 {
  return mat<4, 3, T, Q>(
   m[0] - scalar,
   m[1] - scalar,
   m[2] - scalar,
   m[3] - scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> operator-(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
 {
  return mat<4, 3, T, Q>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2],
   m1[3] - m2[3]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> operator*(mat<4, 3, T, Q> const& m, T scalar)
 {
  return mat<4, 3, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar,
   m[3] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> operator*(T scalar, mat<4, 3, T, Q> const& m)
 {
  return mat<4, 3, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar,
   m[3] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<4, 3, T, Q>::col_type operator*
 (
  mat<4, 3, T, Q> const& m,
  typename mat<4, 3, T, Q>::row_type const& v)
 {
  return typename mat<4, 3, T, Q>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z + m[3][0] * v.w,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z + m[3][1] * v.w,
   m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z + m[3][2] * v.w);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<4, 3, T, Q>::row_type operator*
 (
  typename mat<4, 3, T, Q>::col_type const& v,
  mat<4, 3, T, Q> const& m)
 {
  return typename mat<4, 3, T, Q>::row_type(
   v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2],
   v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2],
   v.x * m[2][0] + v.y * m[2][1] + v.z * m[2][2],
   v.x * m[3][0] + v.y * m[3][1] + v.z * m[3][2]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 3, T, Q> operator*(mat<4, 3, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
 {
  return mat<2, 3, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 3, T, Q> operator*(mat<4, 3, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
 {
  T const SrcA00 = m1[0][0];
  T const SrcA01 = m1[0][1];
  T const SrcA02 = m1[0][2];
  T const SrcA10 = m1[1][0];
  T const SrcA11 = m1[1][1];
  T const SrcA12 = m1[1][2];
  T const SrcA20 = m1[2][0];
  T const SrcA21 = m1[2][1];
  T const SrcA22 = m1[2][2];
  T const SrcA30 = m1[3][0];
  T const SrcA31 = m1[3][1];
  T const SrcA32 = m1[3][2];

  T const SrcB00 = m2[0][0];
  T const SrcB01 = m2[0][1];
  T const SrcB02 = m2[0][2];
  T const SrcB03 = m2[0][3];
  T const SrcB10 = m2[1][0];
  T const SrcB11 = m2[1][1];
  T const SrcB12 = m2[1][2];
  T const SrcB13 = m2[1][3];
  T const SrcB20 = m2[2][0];
  T const SrcB21 = m2[2][1];
  T const SrcB22 = m2[2][2];
  T const SrcB23 = m2[2][3];

  mat<3, 3, T, Q> Result;
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02 + SrcA30 * SrcB03;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02 + SrcA31 * SrcB03;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02 + SrcA32 * SrcB03;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12 + SrcA30 * SrcB13;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12 + SrcA31 * SrcB13;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12 + SrcA32 * SrcB13;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22 + SrcA30 * SrcB23;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22 + SrcA31 * SrcB23;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22 + SrcA32 * SrcB23;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> operator*(mat<4, 3, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
 {
  return mat<4, 3, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2] + m1[3][2] * m2[2][3],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2] + m1[3][0] * m2[3][3],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2] + m1[3][1] * m2[3][3],
   m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1] + m1[2][2] * m2[3][2] + m1[3][2] * m2[3][3]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> operator/(mat<4, 3, T, Q> const& m, T scalar)
 {
  return mat<4, 3, T, Q>(
   m[0] / scalar,
   m[1] / scalar,
   m[2] / scalar,
   m[3] / scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 3, T, Q> operator/(T scalar, mat<4, 3, T, Q> const& m)
 {
  return mat<4, 3, T, Q>(
   scalar / m[0],
   scalar / m[1],
   scalar / m[2],
   scalar / m[3]);
 }



 template<typename T, qualifier Q>
 inline constexpr bool operator==(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
 }

 template<typename T, qualifier Q>
 inline constexpr bool operator!=(mat<4, 3, T, Q> const& m1, mat<4, 3, T, Q> const& m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
 }
}
# 171 "/usr/include/glm/detail/type_mat4x3.hpp" 2 3 4
# 6 "/usr/include/glm/ext/matrix_double4x3.hpp" 2 3 4

namespace glm
{






 typedef mat<4, 3, double, defaultp> dmat4x3;


}
# 6 "/usr/include/glm/mat4x3.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_double4x3_precision.hpp" 1 3 4



       


namespace glm
{







 typedef mat<4, 3, double, lowp> lowp_dmat4x3;





 typedef mat<4, 3, double, mediump> mediump_dmat4x3;





 typedef mat<4, 3, double, highp> highp_dmat4x3;


}
# 7 "/usr/include/glm/mat4x3.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_float4x3.hpp" 1 3 4



       


namespace glm
{






 typedef mat<4, 3, float, defaultp> mat4x3;


}
# 8 "/usr/include/glm/mat4x3.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_float4x3_precision.hpp" 1 3 4



       


namespace glm
{







 typedef mat<4, 3, float, lowp> lowp_mat4x3;





 typedef mat<4, 3, float, mediump> mediump_mat4x3;





 typedef mat<4, 3, float, highp> highp_mat4x3;


}
# 9 "/usr/include/glm/mat4x3.hpp" 2 3 4
# 29 "/usr/include/glm/matrix.hpp" 2 3 4
# 1 "/usr/include/glm/mat4x4.hpp" 1 3 4



       
# 1 "/usr/include/glm/ext/matrix_double4x4.hpp" 1 3 4



       
# 1 "/usr/include/glm/detail/type_mat4x4.hpp" 1 3 4



       





namespace glm
{
 template<typename T, qualifier Q>
 struct mat<4, 4, T, Q>
 {
  typedef vec<4, T, Q> col_type;
  typedef vec<4, T, Q> row_type;
  typedef mat<4, 4, T, Q> type;
  typedef mat<4, 4, T, Q> transpose_type;
  typedef T value_type;

 private:
  col_type value[4];

 public:


  typedef length_t length_type;
  [[nodiscard]] static constexpr length_type length(){return 4;}

  [[nodiscard]] constexpr col_type & operator[](length_type i) noexcept;
  [[nodiscard]] constexpr col_type const& operator[](length_type i) const noexcept;



  constexpr mat() = default;
  template<qualifier P>
  constexpr mat(mat<4, 4, T, P> const& m);

  constexpr mat(T s);
  constexpr mat(
   T const& x0, T const& y0, T const& z0, T const& w0,
   T const& x1, T const& y1, T const& z1, T const& w1,
   T const& x2, T const& y2, T const& z2, T const& w2,
   T const& x3, T const& y3, T const& z3, T const& w3);
  constexpr mat(
   col_type const& v0,
   col_type const& v1,
   col_type const& v2,
   col_type const& v3);



  template<
   typename X1, typename Y1, typename Z1, typename W1,
   typename X2, typename Y2, typename Z2, typename W2,
   typename X3, typename Y3, typename Z3, typename W3,
   typename X4, typename Y4, typename Z4, typename W4>
  constexpr mat(
   X1 const& x1, Y1 const& y1, Z1 const& z1, W1 const& w1,
   X2 const& x2, Y2 const& y2, Z2 const& z2, W2 const& w2,
   X3 const& x3, Y3 const& y3, Z3 const& z3, W3 const& w3,
   X4 const& x4, Y4 const& y4, Z4 const& z4, W4 const& w4);

  template<typename V1, typename V2, typename V3, typename V4>
  constexpr mat(
   vec<4, V1, Q> const& v1,
   vec<4, V2, Q> const& v2,
   vec<4, V3, Q> const& v3,
   vec<4, V4, Q> const& v4);



  template<typename U, qualifier P>
  constexpr mat(mat<4, 4, U, P> const& m);

  constexpr mat(mat<2, 2, T, Q> const& x);
  constexpr mat(mat<3, 3, T, Q> const& x);
  constexpr mat(mat<2, 3, T, Q> const& x);
  constexpr mat(mat<3, 2, T, Q> const& x);
  constexpr mat(mat<2, 4, T, Q> const& x);
  constexpr mat(mat<4, 2, T, Q> const& x);
  constexpr mat(mat<3, 4, T, Q> const& x);
  constexpr mat(mat<4, 3, T, Q> const& x);



  template<typename U>
  constexpr mat<4, 4, T, Q> & operator=(mat<4, 4, U, Q> const& m);
  template<typename U>
  constexpr mat<4, 4, T, Q> & operator+=(U s);
  template<typename U>
  constexpr mat<4, 4, T, Q> & operator+=(mat<4, 4, U, Q> const& m);
  template<typename U>
  constexpr mat<4, 4, T, Q> & operator-=(U s);
  template<typename U>
  constexpr mat<4, 4, T, Q> & operator-=(mat<4, 4, U, Q> const& m);
  template<typename U>
  constexpr mat<4, 4, T, Q> & operator*=(U s);
  template<typename U>
  constexpr mat<4, 4, T, Q> & operator*=(mat<4, 4, U, Q> const& m);
  template<typename U>
  constexpr mat<4, 4, T, Q> & operator/=(U s);
  template<typename U>
  constexpr mat<4, 4, T, Q> & operator/=(mat<4, 4, U, Q> const& m);



  constexpr mat<4, 4, T, Q> & operator++();
  constexpr mat<4, 4, T, Q> & operator--();
  [[nodiscard]] constexpr mat<4, 4, T, Q> operator++(int);
  [[nodiscard]] constexpr mat<4, 4, T, Q> operator--(int);
 };



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> operator+(T scalar, mat<4, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> operator-(T scalar, mat<4, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> operator*(mat<4, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> operator*(T scalar, mat<4, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<4, 4, T, Q>::col_type operator*(mat<4, 4, T, Q> const& m, typename mat<4, 4, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<4, 4, T, Q>::row_type operator*(typename mat<4, 4, T, Q>::col_type const& v, mat<4, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<2, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<3, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> operator/(mat<4, 4, T, Q> const& m, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> operator/(T scalar, mat<4, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<4, 4, T, Q>::col_type operator/(mat<4, 4, T, Q> const& m, typename mat<4, 4, T, Q>::row_type const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr typename mat<4, 4, T, Q>::row_type operator/(typename mat<4, 4, T, Q>::col_type const& v, mat<4, 4, T, Q> const& m);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> operator/(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator==(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator!=(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2);
}


# 1 "/usr/include/glm/detail/type_mat4x4.inl" 1 3 4


namespace glm
{
# 23 "/usr/include/glm/detail/type_mat4x4.inl" 3 4
 template<typename T, qualifier Q>
 template<qualifier P>
 inline constexpr mat<4, 4, T, Q>::mat(mat<4, 4, T, P> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q>::mat(T s)

   : value{col_type(s, 0, 0, 0), col_type(0, s, 0, 0), col_type(0, 0, s, 0), col_type(0, 0, 0, s)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q>::mat
 (
  T const& x0, T const& y0, T const& z0, T const& w0,
  T const& x1, T const& y1, T const& z1, T const& w1,
  T const& x2, T const& y2, T const& z2, T const& w2,
  T const& x3, T const& y3, T const& z3, T const& w3
 )

   : value{
    col_type(x0, y0, z0, w0),
    col_type(x1, y1, z1, w1),
    col_type(x2, y2, z2, w2),
    col_type(x3, y3, z3, w3)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q>::mat(col_type const& v0, col_type const& v1, col_type const& v2, col_type const& v3)

   : value{col_type(v0), col_type(v1), col_type(v2), col_type(v3)}

 {






 }

 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr mat<4, 4, T, Q>::mat(mat<4, 4, U, P> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(m[3])}

 {






 }



 template<typename T, qualifier Q>
 template<
  typename X1, typename Y1, typename Z1, typename W1,
  typename X2, typename Y2, typename Z2, typename W2,
  typename X3, typename Y3, typename Z3, typename W3,
  typename X4, typename Y4, typename Z4, typename W4>
 inline constexpr mat<4, 4, T, Q>::mat
 (
  X1 const& x1, Y1 const& y1, Z1 const& z1, W1 const& w1,
  X2 const& x2, Y2 const& y2, Z2 const& z2, W2 const& w2,
  X3 const& x3, Y3 const& y3, Z3 const& z3, W3 const& w3,
  X4 const& x4, Y4 const& y4, Z4 const& z4, W4 const& w4
 )

   : value{col_type(x1, y1, z1, w1), col_type(x2, y2, z2, w2), col_type(x3, y3, z3, w3), col_type(x4, y4, z4, w4)}

 {
  static_assert(std::numeric_limits<X1>::is_iec559 || std::numeric_limits<X1>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 1st parameter type invalid.");
  static_assert(std::numeric_limits<Y1>::is_iec559 || std::numeric_limits<Y1>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 2nd parameter type invalid.");
  static_assert(std::numeric_limits<Z1>::is_iec559 || std::numeric_limits<Z1>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 3rd parameter type invalid.");
  static_assert(std::numeric_limits<W1>::is_iec559 || std::numeric_limits<W1>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 4th parameter type invalid.");

  static_assert(std::numeric_limits<X2>::is_iec559 || std::numeric_limits<X2>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 5th parameter type invalid.");
  static_assert(std::numeric_limits<Y2>::is_iec559 || std::numeric_limits<Y2>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 6th parameter type invalid.");
  static_assert(std::numeric_limits<Z2>::is_iec559 || std::numeric_limits<Z2>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 7th parameter type invalid.");
  static_assert(std::numeric_limits<W2>::is_iec559 || std::numeric_limits<W2>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 8th parameter type invalid.");

  static_assert(std::numeric_limits<X3>::is_iec559 || std::numeric_limits<X3>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 9th parameter type invalid.");
  static_assert(std::numeric_limits<Y3>::is_iec559 || std::numeric_limits<Y3>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 10th parameter type invalid.");
  static_assert(std::numeric_limits<Z3>::is_iec559 || std::numeric_limits<Z3>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 11th parameter type invalid.");
  static_assert(std::numeric_limits<W3>::is_iec559 || std::numeric_limits<W3>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 12th parameter type invalid.");

  static_assert(std::numeric_limits<X4>::is_iec559 || std::numeric_limits<X4>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 13th parameter type invalid.");
  static_assert(std::numeric_limits<Y4>::is_iec559 || std::numeric_limits<Y4>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 14th parameter type invalid.");
  static_assert(std::numeric_limits<Z4>::is_iec559 || std::numeric_limits<Z4>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 15th parameter type invalid.");
  static_assert(std::numeric_limits<W4>::is_iec559 || std::numeric_limits<W4>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 16th parameter type invalid.");







 }

 template<typename T, qualifier Q>
 template<typename V1, typename V2, typename V3, typename V4>
 inline constexpr mat<4, 4, T, Q>::mat(vec<4, V1, Q> const& v1, vec<4, V2, Q> const& v2, vec<4, V3, Q> const& v3, vec<4, V4, Q> const& v4)

   : value{col_type(v1), col_type(v2), col_type(v3), col_type(v4)}

 {
  static_assert(std::numeric_limits<V1>::is_iec559 || std::numeric_limits<V1>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 1st parameter type invalid.");
  static_assert(std::numeric_limits<V2>::is_iec559 || std::numeric_limits<V2>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 2nd parameter type invalid.");
  static_assert(std::numeric_limits<V3>::is_iec559 || std::numeric_limits<V3>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 3rd parameter type invalid.");
  static_assert(std::numeric_limits<V4>::is_iec559 || std::numeric_limits<V4>::is_integer || 0, "*mat4x4 constructor only takes float and integer types, 4th parameter type invalid.");







 }



 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q>::mat(mat<2, 2, T, Q> const& m)

   : value{col_type(m[0], 0, 0), col_type(m[1], 0, 0), col_type(0, 0, 1, 0), col_type(0, 0, 0, 1)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q>::mat(mat<3, 3, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 0), col_type(0, 0, 0, 1)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q>::mat(mat<2, 3, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0), col_type(0, 0, 1, 0), col_type(0, 0, 0, 1)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q>::mat(mat<3, 2, T, Q> const& m)

   : value{col_type(m[0], 0, 0), col_type(m[1], 0, 0), col_type(m[2], 1, 0), col_type(0, 0, 0, 1)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q>::mat(mat<2, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(0, 0, 1, 0), col_type(0, 0, 0, 1)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q>::mat(mat<4, 2, T, Q> const& m)

   : value{col_type(m[0], 0, 0), col_type(m[1], 0, 0), col_type(0, 0, 1, 0), col_type(0, 0, 0, 1)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q>::mat(mat<3, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1]), col_type(m[2]), col_type(0, 0, 0, 1)}

 {






 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q>::mat(mat<4, 3, T, Q> const& m)

   : value{col_type(m[0], 0), col_type(m[1], 0), col_type(m[2], 0), col_type(m[3], 1)}

 {






 }



 template<typename T, qualifier Q>
 inline constexpr typename mat<4, 4, T, Q>::col_type & mat<4, 4, T, Q>::operator[](typename mat<4, 4, T, Q>::length_type i) noexcept
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));
  return this->value[i];
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<4, 4, T, Q>::col_type const& mat<4, 4, T, Q>::operator[](typename mat<4, 4, T, Q>::length_type i) const noexcept
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));
  return this->value[i];
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 4, T, Q>& mat<4, 4, T, Q>::operator=(mat<4, 4, U, Q> const& m)
 {


  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  this->value[3] = m[3];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 4, T, Q>& mat<4, 4, T, Q>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  this->value[3] += s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 4, T, Q>& mat<4, 4, T, Q>::operator+=(mat<4, 4, U, Q> const& m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  this->value[3] += m[3];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  this->value[3] -= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator-=(mat<4, 4, U, Q> const& m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  this->value[3] -= m[3];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  this->value[3] *= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator*=(mat<4, 4, U, Q> const& m)
 {
  return (*this = *this * m);
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  this->value[3] /= s;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator/=(mat<4, 4, U, Q> const& m)
 {
  return *this *= inverse(m);
 }



 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  ++this->value[3];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> & mat<4, 4, T, Q>::operator--()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  --this->value[3];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> mat<4, 4, T, Q>::operator++(int)
 {
  mat<4, 4, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> mat<4, 4, T, Q>::operator--(int)
 {
  mat<4, 4, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m)
 {
  return m;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m)
 {
  return mat<4, 4, T, Q>(
   -m[0],
   -m[1],
   -m[2],
   -m[3]);
 }



 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m, T scalar)
 {
  return mat<4, 4, T, Q>(
   m[0] + scalar,
   m[1] + scalar,
   m[2] + scalar,
   m[3] + scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> operator+(T scalar, mat<4, 4, T, Q> const& m)
 {
  return mat<4, 4, T, Q>(
   m[0] + scalar,
   m[1] + scalar,
   m[2] + scalar,
   m[3] + scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> operator+(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
 {
  return mat<4, 4, T, Q>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2],
   m1[3] + m2[3]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m, T scalar)
 {
  return mat<4, 4, T, Q>(
   m[0] - scalar,
   m[1] - scalar,
   m[2] - scalar,
   m[3] - scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> operator-(T scalar, mat<4, 4, T, Q> const& m)
 {
  return mat<4, 4, T, Q>(
   scalar - m[0],
   scalar - m[1],
   scalar - m[2],
   scalar - m[3]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> operator-(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
 {
  return mat<4, 4, T, Q>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2],
   m1[3] - m2[3]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> operator*(mat<4, 4, T, Q> const& m, T scalar)
 {
  return mat<4, 4, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar,
   m[3] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> operator*(T scalar, mat<4, 4, T, Q> const& m)
 {
  return mat<4, 4, T, Q>(
   m[0] * scalar,
   m[1] * scalar,
   m[2] * scalar,
   m[3] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<4, 4, T, Q>::col_type operator*
 (
  mat<4, 4, T, Q> const& m,
  typename mat<4, 4, T, Q>::row_type const& v
 )
 {
# 561 "/usr/include/glm/detail/type_mat4x4.inl" 3 4
  typename mat<4, 4, T, Q>::col_type const Mov0(v[0]);
  typename mat<4, 4, T, Q>::col_type const Mov1(v[1]);
  typename mat<4, 4, T, Q>::col_type const Mul0 = m[0] * Mov0;
  typename mat<4, 4, T, Q>::col_type const Mul1 = m[1] * Mov1;
  typename mat<4, 4, T, Q>::col_type const Add0 = Mul0 + Mul1;
  typename mat<4, 4, T, Q>::col_type const Mov2(v[2]);
  typename mat<4, 4, T, Q>::col_type const Mov3(v[3]);
  typename mat<4, 4, T, Q>::col_type const Mul2 = m[2] * Mov2;
  typename mat<4, 4, T, Q>::col_type const Mul3 = m[3] * Mov3;
  typename mat<4, 4, T, Q>::col_type const Add1 = Mul2 + Mul3;
  typename mat<4, 4, T, Q>::col_type const Add2 = Add0 + Add1;
  return Add2;
# 581 "/usr/include/glm/detail/type_mat4x4.inl" 3 4
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<4, 4, T, Q>::row_type operator*
 (
  typename mat<4, 4, T, Q>::col_type const& v,
  mat<4, 4, T, Q> const& m
 )
 {
  return typename mat<4, 4, T, Q>::row_type(
   m[0][0] * v[0] + m[0][1] * v[1] + m[0][2] * v[2] + m[0][3] * v[3],
   m[1][0] * v[0] + m[1][1] * v[1] + m[1][2] * v[2] + m[1][3] * v[3],
   m[2][0] * v[0] + m[2][1] * v[1] + m[2][2] * v[2] + m[2][3] * v[3],
   m[3][0] * v[0] + m[3][1] * v[1] + m[3][2] * v[2] + m[3][3] * v[3]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<2, 4, T, Q> const& m2)
 {
  return mat<2, 4, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2] + m1[3][3] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2] + m1[3][3] * m2[1][3]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<3, 4, T, Q> const& m2)
 {
  return mat<3, 4, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2] + m1[3][3] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2] + m1[3][3] * m2[1][3],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2] + m1[3][2] * m2[2][3],
   m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1] + m1[2][3] * m2[2][2] + m1[3][3] * m2[2][3]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> operator*(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
 {
  typename mat<4, 4, T, Q>::col_type const SrcA0 = m1[0];
  typename mat<4, 4, T, Q>::col_type const SrcA1 = m1[1];
  typename mat<4, 4, T, Q>::col_type const SrcA2 = m1[2];
  typename mat<4, 4, T, Q>::col_type const SrcA3 = m1[3];

  typename mat<4, 4, T, Q>::col_type const SrcB0 = m2[0];
  typename mat<4, 4, T, Q>::col_type const SrcB1 = m2[1];
  typename mat<4, 4, T, Q>::col_type const SrcB2 = m2[2];
  typename mat<4, 4, T, Q>::col_type const SrcB3 = m2[3];

  mat<4, 4, T, Q> Result;
  Result[0] = SrcA0 * SrcB0[0] + SrcA1 * SrcB0[1] + SrcA2 * SrcB0[2] + SrcA3 * SrcB0[3];
  Result[1] = SrcA0 * SrcB1[0] + SrcA1 * SrcB1[1] + SrcA2 * SrcB1[2] + SrcA3 * SrcB1[3];
  Result[2] = SrcA0 * SrcB2[0] + SrcA1 * SrcB2[1] + SrcA2 * SrcB2[2] + SrcA3 * SrcB2[3];
  Result[3] = SrcA0 * SrcB3[0] + SrcA1 * SrcB3[1] + SrcA2 * SrcB3[2] + SrcA3 * SrcB3[3];
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> operator/(mat<4, 4, T, Q> const& m, T scalar)
 {
  return mat<4, 4, T, Q>(
   m[0] / scalar,
   m[1] / scalar,
   m[2] / scalar,
   m[3] / scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> operator/(T scalar, mat<4, 4, T, Q> const& m)
 {
  return mat<4, 4, T, Q>(
   scalar / m[0],
   scalar / m[1],
   scalar / m[2],
   scalar / m[3]);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<4, 4, T, Q>::col_type operator/(mat<4, 4, T, Q> const& m, typename mat<4, 4, T, Q>::row_type const& v)
 {
  return inverse(m) * v;
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<4, 4, T, Q>::row_type operator/(typename mat<4, 4, T, Q>::col_type const& v, mat<4, 4, T, Q> const& m)
 {
  return v * inverse(m);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> operator/(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
 {
  mat<4, 4, T, Q> m1_copy(m1);
  return m1_copy /= m2;
 }



 template<typename T, qualifier Q>
 inline constexpr bool operator==(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
 }

 template<typename T, qualifier Q>
 inline constexpr bool operator!=(mat<4, 4, T, Q> const& m1, mat<4, 4, T, Q> const& m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
 }
}
# 189 "/usr/include/glm/detail/type_mat4x4.hpp" 2 3 4
# 6 "/usr/include/glm/ext/matrix_double4x4.hpp" 2 3 4

namespace glm
{






 typedef mat<4, 4, double, defaultp> dmat4x4;




 typedef mat<4, 4, double, defaultp> dmat4;


}
# 6 "/usr/include/glm/mat4x4.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_double4x4_precision.hpp" 1 3 4



       


namespace glm
{







 typedef mat<4, 4, double, lowp> lowp_dmat4;





 typedef mat<4, 4, double, mediump> mediump_dmat4;





 typedef mat<4, 4, double, highp> highp_dmat4;





 typedef mat<4, 4, double, lowp> lowp_dmat4x4;





 typedef mat<4, 4, double, mediump> mediump_dmat4x4;





 typedef mat<4, 4, double, highp> highp_dmat4x4;


}
# 7 "/usr/include/glm/mat4x4.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_float4x4.hpp" 1 3 4



       


namespace glm
{






 typedef mat<4, 4, float, defaultp> mat4x4;




 typedef mat<4, 4, float, defaultp> mat4;


}
# 8 "/usr/include/glm/mat4x4.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_float4x4_precision.hpp" 1 3 4



       


namespace glm
{







 typedef mat<4, 4, float, lowp> lowp_mat4;





 typedef mat<4, 4, float, mediump> mediump_mat4;





 typedef mat<4, 4, float, highp> highp_mat4;





 typedef mat<4, 4, float, lowp> lowp_mat4x4;





 typedef mat<4, 4, float, mediump> mediump_mat4x4;





 typedef mat<4, 4, float, highp> highp_mat4x4;


}
# 9 "/usr/include/glm/mat4x4.hpp" 2 3 4
# 30 "/usr/include/glm/matrix.hpp" 2 3 4

namespace glm {
namespace detail
{
 template<length_t C, length_t R, typename T, qualifier Q>
 struct outerProduct_trait{};

 template<typename T, qualifier Q>
 struct outerProduct_trait<2, 2, T, Q>
 {
  typedef mat<2, 2, T, Q> type;
 };

 template<typename T, qualifier Q>
 struct outerProduct_trait<2, 3, T, Q>
 {
  typedef mat<3, 2, T, Q> type;
 };

 template<typename T, qualifier Q>
 struct outerProduct_trait<2, 4, T, Q>
 {
  typedef mat<4, 2, T, Q> type;
 };

 template<typename T, qualifier Q>
 struct outerProduct_trait<3, 2, T, Q>
 {
  typedef mat<2, 3, T, Q> type;
 };

 template<typename T, qualifier Q>
 struct outerProduct_trait<3, 3, T, Q>
 {
  typedef mat<3, 3, T, Q> type;
 };

 template<typename T, qualifier Q>
 struct outerProduct_trait<3, 4, T, Q>
 {
  typedef mat<4, 3, T, Q> type;
 };

 template<typename T, qualifier Q>
 struct outerProduct_trait<4, 2, T, Q>
 {
  typedef mat<2, 4, T, Q> type;
 };

 template<typename T, qualifier Q>
 struct outerProduct_trait<4, 3, T, Q>
 {
  typedef mat<3, 4, T, Q> type;
 };

 template<typename T, qualifier Q>
 struct outerProduct_trait<4, 4, T, Q>
 {
  typedef mat<4, 4, T, Q> type;
 };
}
# 105 "/usr/include/glm/matrix.hpp" 3 4
 template<length_t C, length_t R, typename T, qualifier Q>
 [[nodiscard]] mat<C, R, T, Q> matrixCompMult(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y);
# 119 "/usr/include/glm/matrix.hpp" 3 4
 template<length_t C, length_t R, typename T, qualifier Q>
 [[nodiscard]] typename detail::outerProduct_trait<C, R, T, Q>::type outerProduct(vec<C, T, Q> const& c, vec<R, T, Q> const& r);
# 131 "/usr/include/glm/matrix.hpp" 3 4
 template<length_t C, length_t R, typename T, qualifier Q>
 [[nodiscard]] typename mat<C, R, T, Q>::transpose_type transpose(mat<C, R, T, Q> const& x);
# 143 "/usr/include/glm/matrix.hpp" 3 4
 template<length_t C, length_t R, typename T, qualifier Q>
 [[nodiscard]] T determinant(mat<C, R, T, Q> const& m);
# 155 "/usr/include/glm/matrix.hpp" 3 4
 template<length_t C, length_t R, typename T, qualifier Q>
 [[nodiscard]] mat<C, R, T, Q> inverse(mat<C, R, T, Q> const& m);


}

# 1 "/usr/include/glm/detail/func_matrix.inl" 1 3 4
# 1 "/usr/include/glm/geometric.hpp" 1 3 4
# 13 "/usr/include/glm/geometric.hpp" 3 4
       



namespace glm
{
# 29 "/usr/include/glm/geometric.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] T length(vec<L, T, Q> const& x);
# 39 "/usr/include/glm/geometric.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] T distance(vec<L, T, Q> const& p0, vec<L, T, Q> const& p1);
# 49 "/usr/include/glm/geometric.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr T dot(vec<L, T, Q> const& x, vec<L, T, Q> const& y);







 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> cross(vec<3, T, Q> const& x, vec<3, T, Q> const& y);
# 69 "/usr/include/glm/geometric.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> normalize(vec<L, T, Q> const& x);
# 79 "/usr/include/glm/geometric.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> faceforward(
  vec<L, T, Q> const& N,
  vec<L, T, Q> const& I,
  vec<L, T, Q> const& Nref);
# 93 "/usr/include/glm/geometric.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> reflect(
  vec<L, T, Q> const& I,
  vec<L, T, Q> const& N);
# 107 "/usr/include/glm/geometric.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> refract(
  vec<L, T, Q> const& I,
  vec<L, T, Q> const& N,
  T eta);


}

# 1 "/usr/include/glm/detail/func_geometric.inl" 1 3 4
# 1 "/usr/include/glm/exponential.hpp" 1 3 4
# 15 "/usr/include/glm/exponential.hpp" 3 4
       

# 1 "/usr/include/glm/detail/type_vec1.hpp" 1 3 4



       
# 14 "/usr/include/glm/detail/type_vec1.hpp" 3 4
namespace glm
{
 template<typename T, qualifier Q>
 struct vec<1, T, Q>
 {


  typedef T value_type;
  typedef vec<1, T, Q> type;
  typedef vec<1, bool, Q> bool_type;





#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpedantic"
# 66 "/usr/include/glm/detail/type_vec1.hpp" 3 4
   union {T x, r, s;};
# 78 "/usr/include/glm/detail/type_vec1.hpp" 3 4
#pragma GCC diagnostic pop
# 87 "/usr/include/glm/detail/type_vec1.hpp" 3 4
  typedef length_t length_type;
  [[nodiscard]] static constexpr length_type length(){return 1;}

  [[nodiscard]] constexpr T & operator[](length_type i);
  [[nodiscard]] constexpr T const& operator[](length_type i) const;



  constexpr vec() = default;
  constexpr vec(vec const& v) = default;
  template<qualifier P>
  constexpr vec(vec<1, T, P> const& v);



  constexpr explicit vec(T scalar);




  template<typename U, qualifier P>
  constexpr vec(vec<2, U, P> const& v);

  template<typename U, qualifier P>
  constexpr vec(vec<3, U, P> const& v);

  template<typename U, qualifier P>
  constexpr vec(vec<4, U, P> const& v);


  template<typename U, qualifier P>
  constexpr vec(vec<1, U, P> const& v);
# 132 "/usr/include/glm/detail/type_vec1.hpp" 3 4
  constexpr vec<1, T, Q> & operator=(vec const& v) = default;

  template<typename U>
  constexpr vec<1, T, Q> & operator=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<1, T, Q> & operator+=(U scalar);
  template<typename U>
  constexpr vec<1, T, Q> & operator+=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<1, T, Q> & operator-=(U scalar);
  template<typename U>
  constexpr vec<1, T, Q> & operator-=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<1, T, Q> & operator*=(U scalar);
  template<typename U>
  constexpr vec<1, T, Q> & operator*=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<1, T, Q> & operator/=(U scalar);
  template<typename U>
  constexpr vec<1, T, Q> & operator/=(vec<1, U, Q> const& v);



  constexpr vec<1, T, Q> & operator++();
  constexpr vec<1, T, Q> & operator--();
  [[nodiscard]] constexpr vec<1, T, Q> operator++(int);
  [[nodiscard]] constexpr vec<1, T, Q> operator--(int);



  template<typename U>
  constexpr vec<1, T, Q> & operator%=(U scalar);
  template<typename U>
  constexpr vec<1, T, Q> & operator%=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<1, T, Q> & operator&=(U scalar);
  template<typename U>
  constexpr vec<1, T, Q> & operator&=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<1, T, Q> & operator|=(U scalar);
  template<typename U>
  constexpr vec<1, T, Q> & operator|=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<1, T, Q> & operator^=(U scalar);
  template<typename U>
  constexpr vec<1, T, Q> & operator^=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<1, T, Q> & operator<<=(U scalar);
  template<typename U>
  constexpr vec<1, T, Q> & operator<<=(vec<1, U, Q> const& v);
  template<typename U>
  constexpr vec<1, T, Q> & operator>>=(U scalar);
  template<typename U>
  constexpr vec<1, T, Q> & operator>>=(vec<1, U, Q> const& v);
 };



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator+(vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator-(vec<1, T, Q> const& v);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator+(vec<1, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator+(T scalar, vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator+(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator-(vec<1, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator-(T scalar, vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator-(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator*(vec<1, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator*(T scalar, vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator*(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator/(vec<1, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator/(T scalar, vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator/(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator%(vec<1, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator%(T scalar, vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator%(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator&(vec<1, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator&(T scalar, vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator&(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator|(vec<1, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator|(T scalar, vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator|(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator^(vec<1, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator^(T scalar, vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator^(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator<<(vec<1, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator<<(T scalar, vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator<<(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator>>(vec<1, T, Q> const& v, T scalar);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator>>(T scalar, vec<1, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator>>(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<1, T, Q> operator~(vec<1, T, Q> const& v);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator==(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator!=(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2);

 template<qualifier Q>
 [[nodiscard]] constexpr vec<1, bool, Q> operator&&(vec<1, bool, Q> const& v1, vec<1, bool, Q> const& v2);

 template<qualifier Q>
 [[nodiscard]] constexpr vec<1, bool, Q> operator||(vec<1, bool, Q> const& v1, vec<1, bool, Q> const& v2);
}


# 1 "/usr/include/glm/detail/type_vec1.inl" 1 3 4




namespace glm
{
# 25 "/usr/include/glm/detail/type_vec1.inl" 3 4
 template<typename T, qualifier Q>
 template<qualifier P>
 inline constexpr vec<1, T, Q>::vec(vec<1, T, P> const& v)
  : x(v.x)
 {}



 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q>::vec(T scalar)
  : x(scalar)
 {}



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr vec<1, T, Q>::vec(vec<1, U, P> const& v)
  : x(static_cast<T>(v.x))
 {}

 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr vec<1, T, Q>::vec(vec<2, U, P> const& v)
  : x(static_cast<T>(v.x))
 {}

 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr vec<1, T, Q>::vec(vec<3, U, P> const& v)
  : x(static_cast<T>(v.x))
 {}

 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr vec<1, T, Q>::vec(vec<4, U, P> const& v)
  : x(static_cast<T>(v.x))
 {}



 template<typename T, qualifier Q>
 inline constexpr T & vec<1, T, Q>::operator[](typename vec<1, T, Q>::length_type)
 {
  return x;
 }

 template<typename T, qualifier Q>
 inline constexpr T const& vec<1, T, Q>::operator[](typename vec<1, T, Q>::length_type) const
 {
  return x;
 }
# 89 "/usr/include/glm/detail/type_vec1.inl" 3 4
 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator=(vec<1, U, Q> const& v)
 {
  this->x = static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator+=(U scalar)
 {
  this->x += static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator+=(vec<1, U, Q> const& v)
 {
  this->x += static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator-=(U scalar)
 {
  this->x -= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator-=(vec<1, U, Q> const& v)
 {
  this->x -= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator*=(U scalar)
 {
  this->x *= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator*=(vec<1, U, Q> const& v)
 {
  this->x *= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator/=(U scalar)
 {
  this->x /= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator/=(vec<1, U, Q> const& v)
 {
  this->x /= static_cast<T>(v.x);
  return *this;
 }



 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator++()
 {
  ++this->x;
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator--()
 {
  --this->x;
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> vec<1, T, Q>::operator++(int)
 {
  vec<1, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> vec<1, T, Q>::operator--(int)
 {
  vec<1, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator%=(U scalar)
 {
  this->x %= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator%=(vec<1, U, Q> const& v)
 {
  this->x %= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator&=(U scalar)
 {
  this->x &= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator&=(vec<1, U, Q> const& v)
 {
  this->x &= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator|=(U scalar)
 {
  this->x |= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator|=(vec<1, U, Q> const& v)
 {
  this->x |= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator^=(U scalar)
 {
  this->x ^= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator^=(vec<1, U, Q> const& v)
 {
  this->x ^= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator<<=(U scalar)
 {
  this->x <<= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator<<=(vec<1, U, Q> const& v)
 {
  this->x <<= static_cast<T>(v.x);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator>>=(U scalar)
 {
  this->x >>= static_cast<T>(scalar);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr vec<1, T, Q> & vec<1, T, Q>::operator>>=(vec<1, U, Q> const& v)
 {
  this->x >>= static_cast<T>(v.x);
  return *this;
 }



 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator+(vec<1, T, Q> const& v)
 {
  return v;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator-(vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   -v.x);
 }



 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator+(vec<1, T, Q> const& v, T scalar)
 {
  return vec<1, T, Q>(
   v.x + scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator+(T scalar, vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   scalar + v.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator+(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<1, T, Q>(
   v1.x + v2.x);
 }


 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator-(vec<1, T, Q> const& v, T scalar)
 {
  return vec<1, T, Q>(
   v.x - scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator-(T scalar, vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   scalar - v.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator-(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<1, T, Q>(
   v1.x - v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator*(vec<1, T, Q> const& v, T scalar)
 {
  return vec<1, T, Q>(
   v.x * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator*(T scalar, vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   scalar * v.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator*(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<1, T, Q>(
   v1.x * v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator/(vec<1, T, Q> const& v, T scalar)
 {
  return vec<1, T, Q>(
   v.x / scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator/(T scalar, vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   scalar / v.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator/(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<1, T, Q>(
   v1.x / v2.x);
 }



 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator%(vec<1, T, Q> const& v, T scalar)
 {
  return vec<1, T, Q>(
   v.x % scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator%(T scalar, vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   scalar % v.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator%(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<1, T, Q>(
   v1.x % v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator&(vec<1, T, Q> const& v, T scalar)
 {
  return vec<1, T, Q>(
   v.x & scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator&(T scalar, vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   scalar & v.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator&(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<1, T, Q>(
   v1.x & v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator|(vec<1, T, Q> const& v, T scalar)
 {
  return vec<1, T, Q>(
   v.x | scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator|(T scalar, vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   scalar | v.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator|(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<1, T, Q>(
   v1.x | v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator^(vec<1, T, Q> const& v, T scalar)
 {
  return vec<1, T, Q>(
   v.x ^ scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator^(T scalar, vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   scalar ^ v.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator^(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<1, T, Q>(
   v1.x ^ v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator<<(vec<1, T, Q> const& v, T scalar)
 {
  return vec<1, T, Q>(
   static_cast<T>(v.x << scalar));
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator<<(T scalar, vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   static_cast<T>(scalar << v.x));
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator<<(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<1, T, Q>(
   static_cast<T>(v1.x << v2.x));
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator>>(vec<1, T, Q> const& v, T scalar)
 {
  return vec<1, T, Q>(
   static_cast<T>(v.x >> scalar));
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator>>(T scalar, vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   static_cast<T>(scalar >> v.x));
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator>>(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return vec<1, T, Q>(
   static_cast<T>(v1.x >> v2.x));
 }

 template<typename T, qualifier Q>
 inline constexpr vec<1, T, Q> operator~(vec<1, T, Q> const& v)
 {
  return vec<1, T, Q>(
   ~v.x);
 }



 template<typename T, qualifier Q>
 inline constexpr bool operator==(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return detail::compute_equal<T, std::numeric_limits<T>::is_iec559>::call(v1.x, v2.x);
 }

 template<typename T, qualifier Q>
 inline constexpr bool operator!=(vec<1, T, Q> const& v1, vec<1, T, Q> const& v2)
 {
  return !(v1 == v2);
 }

 template<qualifier Q>
 inline constexpr vec<1, bool, Q> operator&&(vec<1, bool, Q> const& v1, vec<1, bool, Q> const& v2)
 {
  return vec<1, bool, Q>(v1.x && v2.x);
 }

 template<qualifier Q>
 inline constexpr vec<1, bool, Q> operator||(vec<1, bool, Q> const& v1, vec<1, bool, Q> const& v2)
 {
  return vec<1, bool, Q>(v1.x || v2.x);
 }
}
# 308 "/usr/include/glm/detail/type_vec1.hpp" 2 3 4
# 18 "/usr/include/glm/exponential.hpp" 2 3 4



# 1 "/usr/include/c++/14.2.1/cmath" 1 3 4
# 39 "/usr/include/c++/14.2.1/cmath" 3 4
       
# 40 "/usr/include/c++/14.2.1/cmath" 3
# 22 "/usr/include/glm/exponential.hpp" 2 3 4

namespace glm
{
# 35 "/usr/include/glm/exponential.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> pow(vec<L, T, Q> const& base, vec<L, T, Q> const& exponent);
# 46 "/usr/include/glm/exponential.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> exp(vec<L, T, Q> const& v);
# 59 "/usr/include/glm/exponential.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> log(vec<L, T, Q> const& v);
# 70 "/usr/include/glm/exponential.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> exp2(vec<L, T, Q> const& v);
# 82 "/usr/include/glm/exponential.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> log2(vec<L, T, Q> const& v);
# 93 "/usr/include/glm/exponential.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> sqrt(vec<L, T, Q> const& v);
# 104 "/usr/include/glm/exponential.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> inversesqrt(vec<L, T, Q> const& v);


}

# 1 "/usr/include/glm/detail/func_exponential.inl" 1 3 4



# 1 "/usr/include/glm/vector_relational.hpp" 1 3 4
# 20 "/usr/include/glm/vector_relational.hpp" 3 4
       


# 1 "/usr/include/glm/detail/setup.hpp" 1 3 4
# 24 "/usr/include/glm/vector_relational.hpp" 2 3 4

namespace glm
{
# 37 "/usr/include/glm/vector_relational.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, bool, Q> lessThan(vec<L, T, Q> const& x, vec<L, T, Q> const& y);
# 47 "/usr/include/glm/vector_relational.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, bool, Q> lessThanEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y);
# 57 "/usr/include/glm/vector_relational.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, bool, Q> greaterThan(vec<L, T, Q> const& x, vec<L, T, Q> const& y);
# 67 "/usr/include/glm/vector_relational.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, bool, Q> greaterThanEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y);
# 77 "/usr/include/glm/vector_relational.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y);
# 87 "/usr/include/glm/vector_relational.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y);







 template<length_t L, qualifier Q>
 [[nodiscard]] constexpr bool any(vec<L, bool, Q> const& v);







 template<length_t L, qualifier Q>
 [[nodiscard]] constexpr bool all(vec<L, bool, Q> const& v);
# 115 "/usr/include/glm/vector_relational.hpp" 3 4
 template<length_t L, qualifier Q>
 [[nodiscard]] constexpr vec<L, bool, Q> not_(vec<L, bool, Q> const& v);


}

# 1 "/usr/include/glm/detail/func_vector_relational.inl" 1 3 4
namespace glm
{
 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, bool, Q> lessThan(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
 {
  vec<L, bool, Q> Result(true);
  for(length_t i = 0; i < L; ++i)
   Result[i] = x[i] < y[i];
  return Result;
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, bool, Q> lessThanEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
 {
  vec<L, bool, Q> Result(true);
  for(length_t i = 0; i < L; ++i)
   Result[i] = x[i] <= y[i];
  return Result;
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, bool, Q> greaterThan(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
 {
  vec<L, bool, Q> Result(true);
  for(length_t i = 0; i < L; ++i)
   Result[i] = x[i] > y[i];
  return Result;
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, bool, Q> greaterThanEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
 {
  vec<L, bool, Q> Result(true);
  for(length_t i = 0; i < L; ++i)
   Result[i] = x[i] >= y[i];
  return Result;
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
 {
  vec<L, bool, Q> Result(true);
  for(length_t i = 0; i < L; ++i)
   Result[i] = x[i] == y[i];
  return Result;
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
 {
  vec<L, bool, Q> Result(true);
  for(length_t i = 0; i < L; ++i)
   Result[i] = x[i] != y[i];
  return Result;
 }

 template<length_t L, qualifier Q>
 inline constexpr bool any(vec<L, bool, Q> const& v)
 {
  bool Result = false;
  for(length_t i = 0; i < L; ++i)
   Result = Result || v[i];
  return Result;
 }

 template<length_t L, qualifier Q>
 inline constexpr bool all(vec<L, bool, Q> const& v)
 {
  bool Result = true;
  for(length_t i = 0; i < L; ++i)
   Result = Result && v[i];
  return Result;
 }

 template<length_t L, qualifier Q>
 inline constexpr vec<L, bool, Q> not_(vec<L, bool, Q> const& v)
 {
  vec<L, bool, Q> Result(true);
  for(length_t i = 0; i < L; ++i)
   Result[i] = !v[i];
  return Result;
 }
}
# 122 "/usr/include/glm/vector_relational.hpp" 2 3 4
# 5 "/usr/include/glm/detail/func_exponential.inl" 2 3 4
# 1 "/usr/include/glm/detail/_vectorize.hpp" 1 3 4
       

namespace glm{
namespace detail
{
 template<template<length_t L, typename T, qualifier Q> class vec, length_t L, typename R, typename T, qualifier Q>
 struct functor1{};

 template<template<length_t L, typename T, qualifier Q> class vec, typename R, typename T, qualifier Q>
 struct functor1<vec, 1, R, T, Q>
 {
  inline constexpr static vec<1, R, Q> call(R (*Func) (T x), vec<1, T, Q> const& v)
  {
   return vec<1, R, Q>(Func(v.x));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, typename R, typename T, qualifier Q>
 struct functor1<vec, 2, R, T, Q>
 {
  inline constexpr static vec<2, R, Q> call(R (*Func) (T x), vec<2, T, Q> const& v)
  {
   return vec<2, R, Q>(Func(v.x), Func(v.y));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, typename R, typename T, qualifier Q>
 struct functor1<vec, 3, R, T, Q>
 {
  inline constexpr static vec<3, R, Q> call(R (*Func) (T x), vec<3, T, Q> const& v)
  {
   return vec<3, R, Q>(Func(v.x), Func(v.y), Func(v.z));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, typename R, typename T, qualifier Q>
 struct functor1<vec, 4, R, T, Q>
 {
  inline constexpr static vec<4, R, Q> call(R (*Func) (T x), vec<4, T, Q> const& v)
  {
   return vec<4, R, Q>(Func(v.x), Func(v.y), Func(v.z), Func(v.w));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, length_t L, typename T, qualifier Q>
 struct functor2{};

 template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
 struct functor2<vec, 1, T, Q>
 {
  inline static vec<1, T, Q> call(T (*Func) (T x, T y), vec<1, T, Q> const& a, vec<1, T, Q> const& b)
  {
   return vec<1, T, Q>(Func(a.x, b.x));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
 struct functor2<vec, 2, T, Q>
 {
  inline static vec<2, T, Q> call(T (*Func) (T x, T y), vec<2, T, Q> const& a, vec<2, T, Q> const& b)
  {
   return vec<2, T, Q>(Func(a.x, b.x), Func(a.y, b.y));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
 struct functor2<vec, 3, T, Q>
 {
  inline static vec<3, T, Q> call(T (*Func) (T x, T y), vec<3, T, Q> const& a, vec<3, T, Q> const& b)
  {
   return vec<3, T, Q>(Func(a.x, b.x), Func(a.y, b.y), Func(a.z, b.z));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
 struct functor2<vec, 4, T, Q>
 {
  inline static vec<4, T, Q> call(T (*Func) (T x, T y), vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   return vec<4, T, Q>(Func(a.x, b.x), Func(a.y, b.y), Func(a.z, b.z), Func(a.w, b.w));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, length_t L, typename T, qualifier Q>
 struct functor2_vec_sca{};

 template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
 struct functor2_vec_sca<vec, 1, T, Q>
 {
  inline static vec<1, T, Q> call(T (*Func) (T x, T y), vec<1, T, Q> const& a, T b)
  {
   return vec<1, T, Q>(Func(a.x, b));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
 struct functor2_vec_sca<vec, 2, T, Q>
 {
  inline static vec<2, T, Q> call(T (*Func) (T x, T y), vec<2, T, Q> const& a, T b)
  {
   return vec<2, T, Q>(Func(a.x, b), Func(a.y, b));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
 struct functor2_vec_sca<vec, 3, T, Q>
 {
  inline static vec<3, T, Q> call(T (*Func) (T x, T y), vec<3, T, Q> const& a, T b)
  {
   return vec<3, T, Q>(Func(a.x, b), Func(a.y, b), Func(a.z, b));
  }
 };

 template<template<length_t L, typename T, qualifier Q> class vec, typename T, qualifier Q>
 struct functor2_vec_sca<vec, 4, T, Q>
 {
  inline static vec<4, T, Q> call(T (*Func) (T x, T y), vec<4, T, Q> const& a, T b)
  {
   return vec<4, T, Q>(Func(a.x, b), Func(a.y, b), Func(a.z, b), Func(a.w, b));
  }
 };

 template<length_t L, typename T, qualifier Q>
 struct functor2_vec_int {};

 template<typename T, qualifier Q>
 struct functor2_vec_int<1, T, Q>
 {
  inline static vec<1, int, Q> call(int (*Func) (T x, int y), vec<1, T, Q> const& a, vec<1, int, Q> const& b)
  {
   return vec<1, int, Q>(Func(a.x, b.x));
  }
 };

 template<typename T, qualifier Q>
 struct functor2_vec_int<2, T, Q>
 {
  inline static vec<2, int, Q> call(int (*Func) (T x, int y), vec<2, T, Q> const& a, vec<2, int, Q> const& b)
  {
   return vec<2, int, Q>(Func(a.x, b.x), Func(a.y, b.y));
  }
 };

 template<typename T, qualifier Q>
 struct functor2_vec_int<3, T, Q>
 {
  inline static vec<3, int, Q> call(int (*Func) (T x, int y), vec<3, T, Q> const& a, vec<3, int, Q> const& b)
  {
   return vec<3, int, Q>(Func(a.x, b.x), Func(a.y, b.y), Func(a.z, b.z));
  }
 };

 template<typename T, qualifier Q>
 struct functor2_vec_int<4, T, Q>
 {
  inline static vec<4, int, Q> call(int (*Func) (T x, int y), vec<4, T, Q> const& a, vec<4, int, Q> const& b)
  {
   return vec<4, int, Q>(Func(a.x, b.x), Func(a.y, b.y), Func(a.z, b.z), Func(a.w, b.w));
  }
 };
}
}
# 6 "/usr/include/glm/detail/func_exponential.inl" 2 3 4

# 1 "/usr/include/c++/14.2.1/cmath" 1 3 4
# 39 "/usr/include/c++/14.2.1/cmath" 3 4
       
# 40 "/usr/include/c++/14.2.1/cmath" 3
# 8 "/usr/include/glm/detail/func_exponential.inl" 2 3 4
# 1 "/usr/include/c++/14.2.1/cassert" 1 3 4
# 41 "/usr/include/c++/14.2.1/cassert" 3 4
       
# 42 "/usr/include/c++/14.2.1/cassert" 3


# 1 "/usr/include/assert.h" 1 3 4
# 64 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     noexcept (true) __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     noexcept (true) __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     noexcept (true) __attribute__ ((__noreturn__));


}
# 45 "/usr/include/c++/14.2.1/cassert" 2 3
# 9 "/usr/include/glm/detail/func_exponential.inl" 2 3 4

namespace glm{
namespace detail
{

  using std::log2;
# 23 "/usr/include/glm/detail/func_exponential.inl" 3 4
 template<length_t L, typename T, qualifier Q, bool isFloat, bool Aligned>
 struct compute_log2
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& v)
  {
   static_assert(std::numeric_limits<T>::is_iec559 || 0, "'log2' only accept floating-point inputs. Include <glm/gtc/integer.hpp> for integer inputs.");

   return detail::functor1<vec, L, T, T, Q>::call(log2, v);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_sqrt
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   return detail::functor1<vec, L, T, T, Q>::call(std::sqrt, x);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_inversesqrt
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   return static_cast<T>(1) / sqrt(x);
  }
 };

 template<length_t L, bool Aligned>
 struct compute_inversesqrt<L, float, lowp, Aligned>
 {
  inline static vec<L, float, lowp> call(vec<L, float, lowp> const& x)
  {
   vec<L, float, lowp> tmp(x);
   vec<L, float, lowp> xhalf(tmp * 0.5f);
   vec<L, uint, lowp>* p = reinterpret_cast<vec<L, uint, lowp>*>(const_cast<vec<L, float, lowp>*>(&x));
   vec<L, uint, lowp> i = vec<L, uint, lowp>(0x5f375a86) - (*p >> vec<L, uint, lowp>(1));
   vec<L, float, lowp>* ptmp = reinterpret_cast<vec<L, float, lowp>*>(&i);
   tmp = *ptmp;
   tmp = tmp * (1.5f - xhalf * tmp * tmp);
   return tmp;
  }
 };
}


 using std::pow;
 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> pow(vec<L, T, Q> const& base, vec<L, T, Q> const& exponent)
 {
  return detail::functor2<vec, L, T, Q>::call(pow, base, exponent);
 }


 using std::exp;
 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> exp(vec<L, T, Q> const& x)
 {
  return detail::functor1<vec, L, T, T, Q>::call(exp, x);
 }


 using std::log;
 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> log(vec<L, T, Q> const& x)
 {
  return detail::functor1<vec, L, T, T, Q>::call(log, x);
 }


    using std::exp2;
# 106 "/usr/include/glm/detail/func_exponential.inl" 3 4
 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> exp2(vec<L, T, Q> const& x)
 {
  return detail::functor1<vec, L, T, T, Q>::call(exp2, x);
 }


 template<typename genType>
 inline genType log2(genType x)
 {
  return log2(vec<1, genType>(x)).x;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> log2(vec<L, T, Q> const& x)
 {
  return detail::compute_log2<L, T, Q, std::numeric_limits<T>::is_iec559, detail::is_aligned<Q>::value>::call(x);
 }


 using std::sqrt;
 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> sqrt(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'sqrt' only accept floating-point inputs");
  return detail::compute_sqrt<L, T, Q, detail::is_aligned<Q>::value>::call(x);
 }


 template<typename genType>
 inline genType inversesqrt(genType x)
 {
  return static_cast<genType>(1) / sqrt(x);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> inversesqrt(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'inversesqrt' only accept floating-point inputs");
  return detail::compute_inversesqrt<L, T, Q, detail::is_aligned<Q>::value>::call(x);
 }
}
# 111 "/usr/include/glm/exponential.hpp" 2 3 4
# 2 "/usr/include/glm/detail/func_geometric.inl" 2 3 4
# 1 "/usr/include/glm/common.hpp" 1 3 4
# 15 "/usr/include/glm/common.hpp" 3 4
       


# 1 "/usr/include/glm/detail/_fixes.hpp" 1 3 4
# 1 "/usr/include/c++/14.2.1/cmath" 1 3 4
# 39 "/usr/include/c++/14.2.1/cmath" 3 4
       
# 40 "/usr/include/c++/14.2.1/cmath" 3
# 2 "/usr/include/glm/detail/_fixes.hpp" 2 3 4
# 19 "/usr/include/glm/common.hpp" 2 3 4

namespace glm
{
# 31 "/usr/include/glm/common.hpp" 3 4
 template<typename genType>
 [[nodiscard]] constexpr genType abs(genType x);
# 42 "/usr/include/glm/common.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, T, Q> abs(vec<L, T, Q> const& x);
# 53 "/usr/include/glm/common.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, T, Q> sign(vec<L, T, Q> const& x);
# 64 "/usr/include/glm/common.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> floor(vec<L, T, Q> const& x);
# 76 "/usr/include/glm/common.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> trunc(vec<L, T, Q> const& x);
# 91 "/usr/include/glm/common.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> round(vec<L, T, Q> const& x);
# 105 "/usr/include/glm/common.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> roundEven(vec<L, T, Q> const& x);
# 117 "/usr/include/glm/common.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> ceil(vec<L, T, Q> const& x);







 template<typename genType>
 [[nodiscard]] genType fract(genType x);
# 137 "/usr/include/glm/common.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> fract(vec<L, T, Q> const& x);

 template<typename genType>
 [[nodiscard]] genType mod(genType x, genType y);

 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> mod(vec<L, T, Q> const& x, T y);
# 155 "/usr/include/glm/common.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> mod(vec<L, T, Q> const& x, vec<L, T, Q> const& y);
# 167 "/usr/include/glm/common.hpp" 3 4
 template<typename genType>
 [[nodiscard]] genType modf(genType x, genType& i);







 template<typename genType>
 [[nodiscard]] constexpr genType min(genType x, genType y);
# 187 "/usr/include/glm/common.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, T, Q> min(vec<L, T, Q> const& x, T y);
# 198 "/usr/include/glm/common.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, T, Q> min(vec<L, T, Q> const& x, vec<L, T, Q> const& y);







 template<typename genType>
 [[nodiscard]] constexpr genType max(genType x, genType y);
# 218 "/usr/include/glm/common.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, T, Q> max(vec<L, T, Q> const& x, T y);
# 229 "/usr/include/glm/common.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, T, Q> max(vec<L, T, Q> const& x, vec<L, T, Q> const& y);
# 239 "/usr/include/glm/common.hpp" 3 4
 template<typename genType>
 [[nodiscard]] constexpr genType clamp(genType x, genType minVal, genType maxVal);
# 251 "/usr/include/glm/common.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, T, Q> clamp(vec<L, T, Q> const& x, T minVal, T maxVal);
# 263 "/usr/include/glm/common.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, T, Q> clamp(vec<L, T, Q> const& x, vec<L, T, Q> const& minVal, vec<L, T, Q> const& maxVal);
# 308 "/usr/include/glm/common.hpp" 3 4
 template<typename genTypeT, typename genTypeU>
 [[nodiscard]] constexpr genTypeT mix(genTypeT x, genTypeT y, genTypeU a);

 template<length_t L, typename T, typename U, qualifier Q>
 [[nodiscard]] constexpr vec<L, T, Q> mix(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, U, Q> const& a);

 template<length_t L, typename T, typename U, qualifier Q>
 [[nodiscard]] constexpr vec<L, T, Q> mix(vec<L, T, Q> const& x, vec<L, T, Q> const& y, U a);





 template<typename genType>
 [[nodiscard]] genType step(genType edge, genType x);
# 332 "/usr/include/glm/common.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> step(T edge, vec<L, T, Q> const& x);
# 343 "/usr/include/glm/common.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> step(vec<L, T, Q> const& edge, vec<L, T, Q> const& x);
# 360 "/usr/include/glm/common.hpp" 3 4
 template<typename genType>
 [[nodiscard]] genType smoothstep(genType edge0, genType edge1, genType x);

 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> smoothstep(T edge0, T edge1, vec<L, T, Q> const& x);

 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> smoothstep(vec<L, T, Q> const& edge0, vec<L, T, Q> const& edge1, vec<L, T, Q> const& x);
# 383 "/usr/include/glm/common.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, bool, Q> isnan(vec<L, T, Q> const& x);
# 398 "/usr/include/glm/common.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, bool, Q> isinf(vec<L, T, Q> const& x);







 [[nodiscard]] int floatBitsToInt(float v);
# 418 "/usr/include/glm/common.hpp" 3 4
 template<length_t L, qualifier Q>
 [[nodiscard]] vec<L, int, Q> floatBitsToInt(vec<L, float, Q> const& v);







 [[nodiscard]] uint floatBitsToUint(float v);
# 438 "/usr/include/glm/common.hpp" 3 4
 template<length_t L, qualifier Q>
 [[nodiscard]] vec<L, uint, Q> floatBitsToUint(vec<L, float, Q> const& v);
# 449 "/usr/include/glm/common.hpp" 3 4
 [[nodiscard]] float intBitsToFloat(int v);
# 462 "/usr/include/glm/common.hpp" 3 4
 template<length_t L, qualifier Q>
 [[nodiscard]] vec<L, float, Q> intBitsToFloat(vec<L, int, Q> const& v);
# 473 "/usr/include/glm/common.hpp" 3 4
 [[nodiscard]] float uintBitsToFloat(uint v);
# 486 "/usr/include/glm/common.hpp" 3 4
 template<length_t L, qualifier Q>
 [[nodiscard]] vec<L, float, Q> uintBitsToFloat(vec<L, uint, Q> const& v);







 template<typename genType>
 [[nodiscard]] genType fma(genType const& a, genType const& b, genType const& c);
# 512 "/usr/include/glm/common.hpp" 3 4
 template<typename genType>
 [[nodiscard]] genType frexp(genType x, int& exp);

 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> frexp(vec<L, T, Q> const& v, vec<L, int, Q>& exp);
# 529 "/usr/include/glm/common.hpp" 3 4
 template<typename genType>
 [[nodiscard]] genType ldexp(genType const& x, int const& exp);

 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> ldexp(vec<L, T, Q> const& v, vec<L, int, Q> const& exp);


}

# 1 "/usr/include/glm/detail/func_common.inl" 1 3 4




# 1 "/usr/include/glm/detail/compute_common.hpp" 1 3 4
       

# 1 "/usr/include/glm/detail/setup.hpp" 1 3 4
# 4 "/usr/include/glm/detail/compute_common.hpp" 2 3 4


namespace glm{
namespace detail
{
 template<typename genFIType, bool >
 struct compute_abs
 {};

 template<typename genFIType>
 struct compute_abs<genFIType, true>
 {
  inline constexpr static genFIType call(genFIType x)
  {
   static_assert(std::numeric_limits<genFIType>::is_iec559 || 0 || std::numeric_limits<genFIType>::is_signed, "'abs' only accept floating-point and integer scalar or vector inputs")

                                                                           ;

   return x >= genFIType(0) ? x : -x;

  }
 };
# 38 "/usr/include/glm/detail/compute_common.hpp" 3 4
 template<typename genFIType>
 struct compute_abs<genFIType, false>
 {
  inline constexpr static genFIType call(genFIType x)
  {
   static_assert((!std::numeric_limits<genFIType>::is_signed && std::numeric_limits<genFIType>::is_integer), "'abs' only accept floating-point and integer scalar or vector inputs")

                                                                           ;
   return x;
  }
 };
}
}
# 6 "/usr/include/glm/detail/func_common.inl" 2 3 4







namespace glm
{

 template<typename genType>
 inline constexpr genType min(genType x, genType y)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0 || std::numeric_limits<genType>::is_integer, "'min' only accept floating-point or integer inputs");
  return (y < x) ? y : x;
 }


 template<typename genType>
 inline constexpr genType max(genType x, genType y)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0 || std::numeric_limits<genType>::is_integer, "'max' only accept floating-point or integer inputs");

  return (x < y) ? y : x;
 }


 template<>
 inline constexpr int abs(int x)
 {
  int const y = x >> (sizeof(int) * 8 - 1);
  return (x ^ y) - y;
 }



  using ::std::round;
# 55 "/usr/include/glm/detail/func_common.inl" 3 4
  using ::std::trunc;
# 66 "/usr/include/glm/detail/func_common.inl" 3 4
}

namespace glm{
namespace detail
{
 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_abs_vector
 {
  inline constexpr static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   return detail::functor1<vec, L, T, T, Q>::call(abs, x);
  }
 };

 template<length_t L, typename T, typename U, qualifier Q, bool Aligned>
 struct compute_mix_vector
 {
  inline constexpr static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, U, Q> const& a)
  {
   static_assert(std::numeric_limits<U>::is_iec559 || 0 || 0, "'mix' only accept floating-point inputs for the interpolator a");

   return vec<L, T, Q>(vec<L, U, Q>(x) * (static_cast<U>(1) - a) + vec<L, U, Q>(y) * a);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_mix_vector<L, T, bool, Q, Aligned>
 {
  inline constexpr static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, bool, Q> const& a)
  {
   vec<L, T, Q> Result(0);
   for(length_t i = 0; i < x.length(); ++i)
    Result[i] = a[i] ? y[i] : x[i];
   return Result;
  }
 };

 template<length_t L, typename T, typename U, qualifier Q, bool Aligned>
 struct compute_mix_scalar
 {
  inline constexpr static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y, U const& a)
  {
   static_assert(std::numeric_limits<U>::is_iec559 || 0 || 0, "'mix' only accept floating-point inputs for the interpolator a");

   return vec<L, T, Q>(vec<L, U, Q>(x) * (static_cast<U>(1) - a) + vec<L, U, Q>(y) * a);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_mix_scalar<L, T, bool, Q, Aligned>
 {
  inline constexpr static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y, bool const& a)
  {
   return a ? y : x;
  }
 };

 template<typename T, typename U>
 struct compute_mix
 {
  inline constexpr static T call(T const& x, T const& y, U const& a)
  {
   static_assert(std::numeric_limits<U>::is_iec559 || 0 || 0, "'mix' only accept floating-point inputs for the interpolator a");

   return static_cast<T>(static_cast<U>(x) * (static_cast<U>(1) - a) + static_cast<U>(y) * a);
  }
 };

 template<typename T>
 struct compute_mix<T, bool>
 {
  inline constexpr static T call(T const& x, T const& y, bool const& a)
  {
   return a ? y : x;
  }
 };

 template<length_t L, typename T, qualifier Q, bool isFloat, bool Aligned>
 struct compute_sign
 {
  inline constexpr static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   return vec<L, T, Q>(glm::lessThan(vec<L, T, Q>(0), x)) - vec<L, T, Q>(glm::lessThan(x, vec<L, T, Q>(0)));
  }
 };


 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_sign<L, T, Q, false, Aligned>
 {
  inline constexpr static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   T const Shift(static_cast<T>(sizeof(T) * 8 - 1));
   vec<L, T, Q> const y(vec<L, typename detail::make_unsigned<T>::type, Q>(-x) >> typename detail::make_unsigned<T>::type(Shift));

   return (x >> Shift) | y;
  }
 };


 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_floor
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   return detail::functor1<vec, L, T, T, Q>::call(std::floor, x);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_ceil
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   return detail::functor1<vec, L, T, T, Q>::call(std::ceil, x);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_fract
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   return x - floor(x);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_trunc
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   return detail::functor1<vec, L, T, T, Q>::call(trunc, x);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_round
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x)
  {
   return detail::functor1<vec, L, T, T, Q>::call(round, x);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_mod
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& a, vec<L, T, Q> const& b)
  {
   static_assert(std::numeric_limits<T>::is_iec559 || 0, "'mod' only accept floating-point inputs. Include <glm/gtc/integer.hpp> for integer inputs.");
   return a - b * floor(a / b);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_min_vector
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
  {
   return detail::functor2<vec, L, T, Q>::call(min, x, y);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_max_vector
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
  {
   return detail::functor2<vec, L, T, Q>::call(max, x, y);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_clamp_vector
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x, vec<L, T, Q> const& minVal, vec<L, T, Q> const& maxVal)
  {
   return min(max(x, minVal), maxVal);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_step_vector
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& edge, vec<L, T, Q> const& x)
  {
   return mix(vec<L, T, Q>(1), vec<L, T, Q>(0), glm::lessThan(x, edge));
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_smoothstep_vector
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& edge0, vec<L, T, Q> const& edge1, vec<L, T, Q> const& x)
  {
   static_assert(std::numeric_limits<T>::is_iec559 || 0 || 0, "'smoothstep' only accept floating-point inputs");
   vec<L, T, Q> const tmp(clamp((x - edge0) / (edge1 - edge0), static_cast<T>(0), static_cast<T>(1)));
   return tmp * tmp * (static_cast<T>(3) - static_cast<T>(2) * tmp);
  }
 };
}

 template<typename genFIType>
 inline constexpr genFIType abs(genFIType x)
 {
  return detail::compute_abs<genFIType, std::numeric_limits<genFIType>::is_signed>::call(x);
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, T, Q> abs(vec<L, T, Q> const& x)
 {
  return detail::compute_abs_vector<L, T, Q, detail::is_aligned<Q>::value>::call(x);
 }



 template<typename genFIType>
 inline constexpr genFIType sign(genFIType x)
 {
  static_assert(std::numeric_limits<genFIType>::is_iec559 || 0 || (std::numeric_limits<genFIType>::is_signed && std::numeric_limits<genFIType>::is_integer), "'sign' only accept signed inputs")

                                      ;

  return detail::compute_sign<1, genFIType, defaultp,
                                    std::numeric_limits<genFIType>::is_iec559, detail::is_aligned<highp>::value>::call(vec<1, genFIType>(x)).x;
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, T, Q> sign(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0 || (std::numeric_limits<T>::is_signed && std::numeric_limits<T>::is_integer), "'sign' only accept signed inputs")

                                      ;

  return detail::compute_sign<L, T, Q, std::numeric_limits<T>::is_iec559, detail::is_aligned<Q>::value>::call(x);
 }


 using ::std::floor;
 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> floor(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'floor' only accept floating-point inputs.");
  return detail::compute_floor<L, T, Q, detail::is_aligned<Q>::value>::call(x);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> trunc(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'trunc' only accept floating-point inputs");
  return detail::compute_trunc<L, T, Q, detail::is_aligned<Q>::value>::call(x);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> round(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'round' only accept floating-point inputs");
  return detail::compute_round<L, T, Q, detail::is_aligned<Q>::value>::call(x);
 }
# 339 "/usr/include/glm/detail/func_common.inl" 3 4
 template<typename genType>
 inline genType roundEven(genType x)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'roundEven' only accept floating-point inputs");

  int Integer = static_cast<int>(x);
  genType IntegerPart = static_cast<genType>(Integer);
  genType FractionalPart = fract(x);

  if(FractionalPart > static_cast<genType>(0.5) || FractionalPart < static_cast<genType>(0.5))
  {
   return round(x);
  }
  else if((Integer % 2) == 0)
  {
   return IntegerPart;
  }
  else if(x <= static_cast<genType>(0))
  {
   return IntegerPart - static_cast<genType>(1);
  }
  else
  {
   return IntegerPart + static_cast<genType>(1);
  }




 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> roundEven(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'roundEven' only accept floating-point inputs");
  return detail::functor1<vec, L, T, T, Q>::call(roundEven, x);
 }


 using ::std::ceil;
 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> ceil(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'ceil' only accept floating-point inputs");
  return detail::compute_ceil<L, T, Q, detail::is_aligned<Q>::value>::call(x);
 }


 template<typename genType>
 inline genType fract(genType x)
 {
  return fract(vec<1, genType>(x)).x;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> fract(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'fract' only accept floating-point inputs");
  return detail::compute_fract<L, T, Q, detail::is_aligned<Q>::value>::call(x);
 }


 template<typename genType>
 inline genType mod(genType x, genType y)
 {





   return mod(vec<1, genType, defaultp>(x), y).x;

 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> mod(vec<L, T, Q> const& x, T y)
 {
  return detail::compute_mod<L, T, Q, detail::is_aligned<Q>::value>::call(x, vec<L, T, Q>(y));
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> mod(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
 {
  return detail::compute_mod<L, T, Q, detail::is_aligned<Q>::value>::call(x, y);
 }


 template<typename genType>
 inline genType modf(genType x, genType & i)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'modf' only accept floating-point inputs");
  return std::modf(x, &i);
 }

 template<typename T, qualifier Q>
 inline vec<1, T, Q> modf(vec<1, T, Q> const& x, vec<1, T, Q> & i)
 {
  return vec<1, T, Q>(
   modf(x.x, i.x));
 }

 template<typename T, qualifier Q>
 inline vec<2, T, Q> modf(vec<2, T, Q> const& x, vec<2, T, Q> & i)
 {
  return vec<2, T, Q>(
   modf(x.x, i.x),
   modf(x.y, i.y));
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> modf(vec<3, T, Q> const& x, vec<3, T, Q> & i)
 {
  return vec<3, T, Q>(
   modf(x.x, i.x),
   modf(x.y, i.y),
   modf(x.z, i.z));
 }

 template<typename T, qualifier Q>
 inline vec<4, T, Q> modf(vec<4, T, Q> const& x, vec<4, T, Q> & i)
 {
  return vec<4, T, Q>(
   modf(x.x, i.x),
   modf(x.y, i.y),
   modf(x.z, i.z),
   modf(x.w, i.w));
 }
# 476 "/usr/include/glm/detail/func_common.inl" 3 4
 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, T, Q> min(vec<L, T, Q> const& a, T b)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0 || std::numeric_limits<T>::is_integer, "'min' only accept floating-point or integer inputs");
  return detail::compute_min_vector<L, T, Q, detail::is_aligned<Q>::value>::call(a, vec<L, T, Q>(b));
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, T, Q> min(vec<L, T, Q> const& a, vec<L, T, Q> const& b)
 {
  return detail::compute_min_vector<L, T, Q, detail::is_aligned<Q>::value>::call(a, b);
 }


 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, T, Q> max(vec<L, T, Q> const& a, T b)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0 || std::numeric_limits<T>::is_integer, "'max' only accept floating-point or integer inputs");
  return detail::compute_max_vector<L, T, Q, detail::is_aligned<Q>::value>::call(a, vec<L, T, Q>(b));
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, T, Q> max(vec<L, T, Q> const& a, vec<L, T, Q> const& b)
 {
  return detail::compute_max_vector<L, T, Q, detail::is_aligned<Q>::value>::call(a, b);
 }


 template<typename genType>
 inline constexpr genType clamp(genType x, genType minVal, genType maxVal)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0 || std::numeric_limits<genType>::is_integer, "'clamp' only accept floating-point or integer inputs");
  return min(max(x, minVal), maxVal);
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, T, Q> clamp(vec<L, T, Q> const& x, T minVal, T maxVal)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0 || std::numeric_limits<T>::is_integer, "'clamp' only accept floating-point or integer inputs");
  return detail::compute_clamp_vector<L, T, Q, detail::is_aligned<Q>::value>::call(x, vec<L, T, Q>(minVal), vec<L, T, Q>(maxVal));
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, T, Q> clamp(vec<L, T, Q> const& x, vec<L, T, Q> const& minVal, vec<L, T, Q> const& maxVal)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0 || std::numeric_limits<T>::is_integer, "'clamp' only accept floating-point or integer inputs");
  return detail::compute_clamp_vector<L, T, Q, detail::is_aligned<Q>::value>::call(x, minVal, maxVal);
 }

 template<typename genTypeT, typename genTypeU>
 inline constexpr genTypeT mix(genTypeT x, genTypeT y, genTypeU a)
 {
  return detail::compute_mix<genTypeT, genTypeU>::call(x, y, a);
 }

 template<length_t L, typename T, typename U, qualifier Q>
 inline constexpr vec<L, T, Q> mix(vec<L, T, Q> const& x, vec<L, T, Q> const& y, U a)
 {
  return detail::compute_mix_scalar<L, T, U, Q, detail::is_aligned<Q>::value>::call(x, y, a);
 }

 template<length_t L, typename T, typename U, qualifier Q>
 inline constexpr vec<L, T, Q> mix(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, U, Q> const& a)
 {
  return detail::compute_mix_vector<L, T, U, Q, detail::is_aligned<Q>::value>::call(x, y, a);
 }


 template<typename genType>
 inline genType step(genType edge, genType x)
 {
  return mix(static_cast<genType>(1), static_cast<genType>(0), x < edge);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> step(T edge, vec<L, T, Q> const& x)
 {
  return detail::compute_step_vector<L, T, Q, detail::is_aligned<Q>::value>::call(vec<L, T, Q>(edge), x);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> step(vec<L, T, Q> const& edge, vec<L, T, Q> const& x)
 {
  return detail::compute_step_vector<L, T, Q, detail::is_aligned<Q>::value>::call(edge, x);
 }


 template<typename genType>
 inline genType smoothstep(genType edge0, genType edge1, genType x)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0 || 0, "'smoothstep' only accept floating-point inputs");

  genType const tmp(clamp((x - edge0) / (edge1 - edge0), genType(0), genType(1)));
  return tmp * tmp * (genType(3) - genType(2) * tmp);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> smoothstep(T edge0, T edge1, vec<L, T, Q> const& x)
 {
  return detail::compute_smoothstep_vector<L, T, Q, detail::is_aligned<Q>::value>::call(vec<L, T, Q>(edge0), vec<L, T, Q>(edge1), x);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> smoothstep(vec<L, T, Q> const& edge0, vec<L, T, Q> const& edge1, vec<L, T, Q> const& x)
 {
  return detail::compute_smoothstep_vector<L, T, Q, detail::is_aligned<Q>::value>::call(edge0, edge1, x);
 }


  using std::isnan;
# 612 "/usr/include/glm/detail/func_common.inl" 3 4
 template<length_t L, typename T, qualifier Q>
 inline vec<L, bool, Q> isnan(vec<L, T, Q> const& v)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'isnan' only accept floating-point inputs");

  vec<L, bool, Q> Result(0);
  for (length_t l = 0; l < v.length(); ++l)
   Result[l] = glm::isnan(v[l]);
  return Result;
 }


  using std::isinf;
# 654 "/usr/include/glm/detail/func_common.inl" 3 4
 template<length_t L, typename T, qualifier Q>
 inline vec<L, bool, Q> isinf(vec<L, T, Q> const& v)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'isinf' only accept floating-point inputs");

  vec<L, bool, Q> Result(0);
  for (length_t l = 0; l < v.length(); ++l)
   Result[l] = glm::isinf(v[l]);
  return Result;
 }

 inline int floatBitsToInt(float v)
 {
  union
  {
   float in;
   int out;
  } u;

  u.in = v;

  return u.out;
 }

 template<length_t L, qualifier Q>
 inline vec<L, int, Q> floatBitsToInt(vec<L, float, Q> const& v)
 {
  return detail::functor1<vec, L, int, float, Q>::call(floatBitsToInt, v);
 }

 inline uint floatBitsToUint(float v)
 {
  union
  {
   float in;
   uint out;
  } u;

  u.in = v;

  return u.out;
 }

 template<length_t L, qualifier Q>
 inline vec<L, uint, Q> floatBitsToUint(vec<L, float, Q> const& v)
 {
  return detail::functor1<vec, L, uint, float, Q>::call(floatBitsToUint, v);
 }

 inline float intBitsToFloat(int v)
 {
  union
  {
   int in;
   float out;
  } u;

  u.in = v;

  return u.out;
 }

 template<length_t L, qualifier Q>
 inline vec<L, float, Q> intBitsToFloat(vec<L, int, Q> const& v)
 {
  return detail::functor1<vec, L, float, int, Q>::call(intBitsToFloat, v);
 }

 inline float uintBitsToFloat(uint v)
 {
  union
  {
   uint in;
   float out;
  } u;

  u.in = v;

  return u.out;
 }

 template<length_t L, qualifier Q>
 inline vec<L, float, Q> uintBitsToFloat(vec<L, uint, Q> const& v)
 {
  return reinterpret_cast<vec<L, float, Q>&>(const_cast<vec<L, uint, Q>&>(v));
 }


  using std::fma;
# 751 "/usr/include/glm/detail/func_common.inl" 3 4
 template<typename genType>
 inline genType frexp(genType x, int& exp)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'frexp' only accept floating-point inputs");

  return std::frexp(x, &exp);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> frexp(vec<L, T, Q> const& v, vec<L, int, Q>& exp)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'frexp' only accept floating-point inputs");

  vec<L, T, Q> Result(0);
  for (length_t l = 0; l < v.length(); ++l)
   Result[l] = std::frexp(v[l], &exp[l]);
  return Result;
 }

 template<typename genType>
 inline genType ldexp(genType const& x, int const& exp)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'ldexp' only accept floating-point inputs");

  return std::ldexp(x, exp);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> ldexp(vec<L, T, Q> const& v, vec<L, int, Q> const& exp)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'ldexp' only accept floating-point inputs");

  vec<L, T, Q> Result(0);
  for (length_t l = 0; l < v.length(); ++l)
   Result[l] = std::ldexp(v[l], exp[l]);
  return Result;
 }
}
# 539 "/usr/include/glm/common.hpp" 2 3 4
# 3 "/usr/include/glm/detail/func_geometric.inl" 2 3 4

namespace glm{
namespace detail
{
 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_length
 {
  inline static T call(vec<L, T, Q> const& v)
  {
   return sqrt(dot(v, v));
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_distance
 {
  inline static T call(vec<L, T, Q> const& p0, vec<L, T, Q> const& p1)
  {
   return length(p1 - p0);
  }
 };

 template<typename V, typename T, bool Aligned>
 struct compute_dot{};

 template<typename T, qualifier Q, bool Aligned>
 struct compute_dot<vec<1, T, Q>, T, Aligned>
 {
  inline constexpr static T call(vec<1, T, Q> const& a, vec<1, T, Q> const& b)
  {
   return a.x * b.x;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_dot<vec<2, T, Q>, T, Aligned>
 {
  inline constexpr static T call(vec<2, T, Q> const& a, vec<2, T, Q> const& b)
  {
   vec<2, T, Q> tmp(a * b);
   return tmp.x + tmp.y;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_dot<vec<3, T, Q>, T, Aligned>
 {
  inline constexpr static T call(vec<3, T, Q> const& a, vec<3, T, Q> const& b)
  {
   vec<3, T, Q> tmp(a * b);
   return tmp.x + tmp.y + tmp.z;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_dot<vec<4, T, Q>, T, Aligned>
 {
  inline constexpr static T call(vec<4, T, Q> const& a, vec<4, T, Q> const& b)
  {
   vec<4, T, Q> tmp(a * b);
   return (tmp.x + tmp.y) + (tmp.z + tmp.w);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_cross
 {
  inline constexpr static vec<3, T, Q> call(vec<3, T, Q> const& x, vec<3, T, Q> const& y)
  {
   static_assert(std::numeric_limits<T>::is_iec559, "'cross' accepts only floating-point inputs");

   return vec<3, T, Q>(
    x.y * y.z - y.y * x.z,
    x.z * y.x - y.z * x.x,
    x.x * y.y - y.x * x.y);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_normalize
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& v)
  {
   static_assert(std::numeric_limits<T>::is_iec559, "'normalize' accepts only floating-point inputs");

   return v * inversesqrt(dot(v, v));
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_faceforward
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& N, vec<L, T, Q> const& I, vec<L, T, Q> const& Nref)
  {
   static_assert(std::numeric_limits<T>::is_iec559, "'normalize' accepts only floating-point inputs");

   return dot(Nref, I) < static_cast<T>(0) ? N : -N;
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_reflect
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& I, vec<L, T, Q> const& N)
  {
   return I - N * dot(N, I) * static_cast<T>(2);
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_refract
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& I, vec<L, T, Q> const& N, T eta)
  {
   T const dotValue(dot(N, I));
   T const k(static_cast<T>(1) - eta * eta * (static_cast<T>(1) - dotValue * dotValue));
   vec<L, T, Q> const Result =
                (k >= static_cast<T>(0)) ? (eta * I - (eta * dotValue + std::sqrt(k)) * N) : vec<L, T, Q>(0);
   return Result;
  }
 };
}


 template<typename genType>
 inline genType length(genType x)
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'length' accepts only floating-point inputs");

  return abs(x);
 }

 template<length_t L, typename T, qualifier Q>
 inline T length(vec<L, T, Q> const& v)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'length' accepts only floating-point inputs");

  return detail::compute_length<L, T, Q, detail::is_aligned<Q>::value>::call(v);
 }


 template<typename genType>
 inline genType distance(genType const& p0, genType const& p1)
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'distance' accepts only floating-point inputs");

  return length(p1 - p0);
 }

 template<length_t L, typename T, qualifier Q>
 inline T distance(vec<L, T, Q> const& p0, vec<L, T, Q> const& p1)
 {
  return detail::compute_distance<L, T, Q, detail::is_aligned<Q>::value>::call(p0, p1);
 }


 template<typename T>
 inline constexpr T dot(T x, T y)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'dot' accepts only floating-point inputs");
  return x * y;
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr T dot(vec<L, T, Q> const& x, vec<L, T, Q> const& y)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'dot' accepts only floating-point inputs");
  return detail::compute_dot<vec<L, T, Q>, T, detail::is_aligned<Q>::value>::call(x, y);
 }


 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> cross(vec<3, T, Q> const& x, vec<3, T, Q> const& y)
 {
  return detail::compute_cross<T, Q, detail::is_aligned<Q>::value>::call(x, y);
 }
# 189 "/usr/include/glm/detail/func_geometric.inl" 3 4
 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> normalize(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'normalize' accepts only floating-point inputs");

  return detail::compute_normalize<L, T, Q, detail::is_aligned<Q>::value>::call(x);
 }


 template<typename genType>
 inline genType faceforward(genType const& N, genType const& I, genType const& Nref)
 {
  return dot(Nref, I) < static_cast<genType>(0) ? N : -N;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> faceforward(vec<L, T, Q> const& N, vec<L, T, Q> const& I, vec<L, T, Q> const& Nref)
 {
  return detail::compute_faceforward<L, T, Q, detail::is_aligned<Q>::value>::call(N, I, Nref);
 }


 template<typename genType>
 inline genType reflect(genType const& I, genType const& N)
 {
  return I - N * dot(N, I) * genType(2);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> reflect(vec<L, T, Q> const& I, vec<L, T, Q> const& N)
 {
  return detail::compute_reflect<L, T, Q, detail::is_aligned<Q>::value>::call(I, N);
 }


 template<typename genType>
 inline genType refract(genType const& I, genType const& N, genType eta)
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'refract' accepts only floating-point inputs");
  genType const dotValue(dot(N, I));
  genType const k(static_cast<genType>(1) - eta * eta * (static_cast<genType>(1) - dotValue * dotValue));
  return (eta * I - (eta * dotValue + sqrt(k)) * N) * static_cast<genType>(k >= static_cast<genType>(0));
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> refract(vec<L, T, Q> const& I, vec<L, T, Q> const& N, T eta)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'refract' accepts only floating-point inputs");
  return detail::compute_refract<L, T, Q, detail::is_aligned<Q>::value>::call(I, N, eta);
 }
}
# 117 "/usr/include/glm/geometric.hpp" 2 3 4
# 2 "/usr/include/glm/detail/func_matrix.inl" 2 3 4


namespace glm{
namespace detail
{
 template<length_t C, length_t R, typename T, qualifier Q, bool Aligned>
 struct compute_matrixCompMult
 {
  inline static mat<C, R, T, Q> call(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y)
  {
   mat<C, R, T, Q> Result(1);
   for(length_t i = 0; i < Result.length(); ++i)
    Result[i] = x[i] * y[i];
   return Result;
  }
 };

 template<length_t C, length_t R, typename T, qualifier Q, bool IsFloat, bool Aligned>
 struct compute_matrixCompMult_type {
  inline static mat<C, R, T, Q> call(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y)
  {
   static_assert(std::numeric_limits<T>::is_iec559 || 0, "'matrixCompMult' only accept floating-point inputs, include <glm/ext/matrix_integer.hpp> to discard this restriction.")
                                                                                                                            ;
   return detail::compute_matrixCompMult<C, R, T, Q, detail::is_aligned<Q>::value>::call(x, y);
  }
 };

 template<length_t DA, length_t DB, typename T, qualifier Q>
 struct compute_outerProduct {
  inline static typename detail::outerProduct_trait<DA, DB, T, Q>::type call(vec<DA, T, Q> const& c, vec<DB, T, Q> const& r)
  {
   typename detail::outerProduct_trait<DA, DB, T, Q>::type m(0);
   for(length_t i = 0; i < m.length(); ++i)
    m[i] = c * r[i];
   return m;
  }
 };

 template<length_t DA, length_t DB, typename T, qualifier Q, bool IsFloat>
 struct compute_outerProduct_type {
  inline static typename detail::outerProduct_trait<DA, DB, T, Q>::type call(vec<DA, T, Q> const& c, vec<DB, T, Q> const& r)
  {
   static_assert(std::numeric_limits<T>::is_iec559 || 0, "'outerProduct' only accept floating-point inputs, include <glm/ext/matrix_integer.hpp> to discard this restriction.")
                                                                                                                          ;

   return detail::compute_outerProduct<DA, DB, T, Q>::call(c, r);
  }
 };

 template<length_t C, length_t R, typename T, qualifier Q, bool Aligned>
 struct compute_transpose{};

 template<typename T, qualifier Q, bool Aligned>
 struct compute_transpose<2, 2, T, Q, Aligned>
 {
  inline static mat<2, 2, T, Q> call(mat<2, 2, T, Q> const& m)
  {
   mat<2, 2, T, Q> Result(1);
   Result[0][0] = m[0][0];
   Result[0][1] = m[1][0];
   Result[1][0] = m[0][1];
   Result[1][1] = m[1][1];
   return Result;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_transpose<2, 3, T, Q, Aligned>
 {
  inline static mat<3, 2, T, Q> call(mat<2, 3, T, Q> const& m)
  {
   mat<3,2, T, Q> Result(1);
   Result[0][0] = m[0][0];
   Result[0][1] = m[1][0];
   Result[1][0] = m[0][1];
   Result[1][1] = m[1][1];
   Result[2][0] = m[0][2];
   Result[2][1] = m[1][2];
   return Result;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_transpose<2, 4, T, Q, Aligned>
 {
  inline static mat<4, 2, T, Q> call(mat<2, 4, T, Q> const& m)
  {
   mat<4, 2, T, Q> Result(1);
   Result[0][0] = m[0][0];
   Result[0][1] = m[1][0];
   Result[1][0] = m[0][1];
   Result[1][1] = m[1][1];
   Result[2][0] = m[0][2];
   Result[2][1] = m[1][2];
   Result[3][0] = m[0][3];
   Result[3][1] = m[1][3];
   return Result;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_transpose<3, 2, T, Q, Aligned>
 {
  inline static mat<2, 3, T, Q> call(mat<3, 2, T, Q> const& m)
  {
   mat<2, 3, T, Q> Result(1);
   Result[0][0] = m[0][0];
   Result[0][1] = m[1][0];
   Result[0][2] = m[2][0];
   Result[1][0] = m[0][1];
   Result[1][1] = m[1][1];
   Result[1][2] = m[2][1];
   return Result;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_transpose<3, 3, T, Q, Aligned>
 {
  inline static mat<3, 3, T, Q> call(mat<3, 3, T, Q> const& m)
  {
   mat<3, 3, T, Q> Result(1);
   Result[0][0] = m[0][0];
   Result[0][1] = m[1][0];
   Result[0][2] = m[2][0];

   Result[1][0] = m[0][1];
   Result[1][1] = m[1][1];
   Result[1][2] = m[2][1];

   Result[2][0] = m[0][2];
   Result[2][1] = m[1][2];
   Result[2][2] = m[2][2];
   return Result;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_transpose<3, 4, T, Q, Aligned>
 {
  inline static mat<4, 3, T, Q> call(mat<3, 4, T, Q> const& m)
  {
   mat<4, 3, T, Q> Result(1);
   Result[0][0] = m[0][0];
   Result[0][1] = m[1][0];
   Result[0][2] = m[2][0];
   Result[1][0] = m[0][1];
   Result[1][1] = m[1][1];
   Result[1][2] = m[2][1];
   Result[2][0] = m[0][2];
   Result[2][1] = m[1][2];
   Result[2][2] = m[2][2];
   Result[3][0] = m[0][3];
   Result[3][1] = m[1][3];
   Result[3][2] = m[2][3];
   return Result;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_transpose<4, 2, T, Q, Aligned>
 {
  inline static mat<2, 4, T, Q> call(mat<4, 2, T, Q> const& m)
  {
   mat<2, 4, T, Q> Result(1);
   Result[0][0] = m[0][0];
   Result[0][1] = m[1][0];
   Result[0][2] = m[2][0];
   Result[0][3] = m[3][0];
   Result[1][0] = m[0][1];
   Result[1][1] = m[1][1];
   Result[1][2] = m[2][1];
   Result[1][3] = m[3][1];
   return Result;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_transpose<4, 3, T, Q, Aligned>
 {
  inline static mat<3, 4, T, Q> call(mat<4, 3, T, Q> const& m)
  {
   mat<3, 4, T, Q> Result(1);
   Result[0][0] = m[0][0];
   Result[0][1] = m[1][0];
   Result[0][2] = m[2][0];
   Result[0][3] = m[3][0];
   Result[1][0] = m[0][1];
   Result[1][1] = m[1][1];
   Result[1][2] = m[2][1];
   Result[1][3] = m[3][1];
   Result[2][0] = m[0][2];
   Result[2][1] = m[1][2];
   Result[2][2] = m[2][2];
   Result[2][3] = m[3][2];
   return Result;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_transpose<4, 4, T, Q, Aligned>
 {
  inline static mat<4, 4, T, Q> call(mat<4, 4, T, Q> const& m)
  {
   mat<4, 4, T, Q> Result(1);
   Result[0][0] = m[0][0];
   Result[0][1] = m[1][0];
   Result[0][2] = m[2][0];
   Result[0][3] = m[3][0];

   Result[1][0] = m[0][1];
   Result[1][1] = m[1][1];
   Result[1][2] = m[2][1];
   Result[1][3] = m[3][1];

   Result[2][0] = m[0][2];
   Result[2][1] = m[1][2];
   Result[2][2] = m[2][2];
   Result[2][3] = m[3][2];

   Result[3][0] = m[0][3];
   Result[3][1] = m[1][3];
   Result[3][2] = m[2][3];
   Result[3][3] = m[3][3];
   return Result;
  }
 };

 template<length_t C, length_t R, typename T, qualifier Q, bool IsFloat, bool Aligned>
 struct compute_transpose_type {
  inline static mat<R, C, T, Q> call(mat<C, R, T, Q> const& m)
  {
   static_assert(std::numeric_limits<T>::is_iec559 || 0, "'transpose' only accept floating-point inputs, include <glm/ext/matrix_integer.hpp> to discard this restriction.")
                                                                                                                       ;
   return detail::compute_transpose<C, R, T, Q, detail::is_aligned<Q>::value>::call(m);
  }
 };

 template<length_t C, length_t R, typename T, qualifier Q, bool Aligned>
 struct compute_determinant{};

 template<typename T, qualifier Q, bool Aligned>
 struct compute_determinant<2, 2, T, Q, Aligned>
 {
  inline static T call(mat<2, 2, T, Q> const& m)
  {
   return m[0][0] * m[1][1] - m[1][0] * m[0][1];
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_determinant<3, 3, T, Q, Aligned>
 {
  inline static T call(mat<3, 3, T, Q> const& m)
  {
   return
    + m[0][0] * (m[1][1] * m[2][2] - m[2][1] * m[1][2])
    - m[1][0] * (m[0][1] * m[2][2] - m[2][1] * m[0][2])
    + m[2][0] * (m[0][1] * m[1][2] - m[1][1] * m[0][2]);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_determinant<4, 4, T, Q, Aligned>
 {
  inline static T call(mat<4, 4, T, Q> const& m)
  {
   T SubFactor00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];
   T SubFactor01 = m[2][1] * m[3][3] - m[3][1] * m[2][3];
   T SubFactor02 = m[2][1] * m[3][2] - m[3][1] * m[2][2];
   T SubFactor03 = m[2][0] * m[3][3] - m[3][0] * m[2][3];
   T SubFactor04 = m[2][0] * m[3][2] - m[3][0] * m[2][2];
   T SubFactor05 = m[2][0] * m[3][1] - m[3][0] * m[2][1];

   vec<4, T, Q> DetCof(
    + (m[1][1] * SubFactor00 - m[1][2] * SubFactor01 + m[1][3] * SubFactor02),
    - (m[1][0] * SubFactor00 - m[1][2] * SubFactor03 + m[1][3] * SubFactor04),
    + (m[1][0] * SubFactor01 - m[1][1] * SubFactor03 + m[1][3] * SubFactor05),
    - (m[1][0] * SubFactor02 - m[1][1] * SubFactor04 + m[1][2] * SubFactor05));

   return
    m[0][0] * DetCof[0] + m[0][1] * DetCof[1] +
    m[0][2] * DetCof[2] + m[0][3] * DetCof[3];
  }
 };

 template<length_t C, length_t R, typename T, qualifier Q, bool IsFloat, bool Aligned>
 struct compute_determinant_type{

  inline static T call(mat<C, R, T, Q> const& m)
  {
   static_assert(std::numeric_limits<T>::is_iec559 || 0, "'determinant' only accept floating-point inputs, include <glm/ext/matrix_integer.hpp> to discard this restriction.")
                                                                                                                         ;
   return detail::compute_determinant<C, R, T, Q, detail::is_aligned<Q>::value>::call(m);
  }
 };

 template<length_t C, length_t R, typename T, qualifier Q, bool Aligned>
 struct compute_inverse{};

 template<typename T, qualifier Q, bool Aligned>
 struct compute_inverse<2, 2, T, Q, Aligned>
 {
  inline static mat<2, 2, T, Q> call(mat<2, 2, T, Q> const& m)
  {
   T OneOverDeterminant = static_cast<T>(1) / (
    + m[0][0] * m[1][1]
    - m[1][0] * m[0][1]);

   mat<2, 2, T, Q> Inverse(
    + m[1][1] * OneOverDeterminant,
    - m[0][1] * OneOverDeterminant,
    - m[1][0] * OneOverDeterminant,
    + m[0][0] * OneOverDeterminant);

   return Inverse;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_inverse<3, 3, T, Q, Aligned>
 {
  inline static mat<3, 3, T, Q> call(mat<3, 3, T, Q> const& m)
  {
   T OneOverDeterminant = static_cast<T>(1) / (
    + m[0][0] * (m[1][1] * m[2][2] - m[2][1] * m[1][2])
    - m[1][0] * (m[0][1] * m[2][2] - m[2][1] * m[0][2])
    + m[2][0] * (m[0][1] * m[1][2] - m[1][1] * m[0][2]));

   mat<3, 3, T, Q> Inverse;
   Inverse[0][0] = + (m[1][1] * m[2][2] - m[2][1] * m[1][2]) * OneOverDeterminant;
   Inverse[1][0] = - (m[1][0] * m[2][2] - m[2][0] * m[1][2]) * OneOverDeterminant;
   Inverse[2][0] = + (m[1][0] * m[2][1] - m[2][0] * m[1][1]) * OneOverDeterminant;
   Inverse[0][1] = - (m[0][1] * m[2][2] - m[2][1] * m[0][2]) * OneOverDeterminant;
   Inverse[1][1] = + (m[0][0] * m[2][2] - m[2][0] * m[0][2]) * OneOverDeterminant;
   Inverse[2][1] = - (m[0][0] * m[2][1] - m[2][0] * m[0][1]) * OneOverDeterminant;
   Inverse[0][2] = + (m[0][1] * m[1][2] - m[1][1] * m[0][2]) * OneOverDeterminant;
   Inverse[1][2] = - (m[0][0] * m[1][2] - m[1][0] * m[0][2]) * OneOverDeterminant;
   Inverse[2][2] = + (m[0][0] * m[1][1] - m[1][0] * m[0][1]) * OneOverDeterminant;

   return Inverse;
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_inverse<4, 4, T, Q, Aligned>
 {
  inline static mat<4, 4, T, Q> call(mat<4, 4, T, Q> const& m)
  {
   T Coef00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];
   T Coef02 = m[1][2] * m[3][3] - m[3][2] * m[1][3];
   T Coef03 = m[1][2] * m[2][3] - m[2][2] * m[1][3];

   T Coef04 = m[2][1] * m[3][3] - m[3][1] * m[2][3];
   T Coef06 = m[1][1] * m[3][3] - m[3][1] * m[1][3];
   T Coef07 = m[1][1] * m[2][3] - m[2][1] * m[1][3];

   T Coef08 = m[2][1] * m[3][2] - m[3][1] * m[2][2];
   T Coef10 = m[1][1] * m[3][2] - m[3][1] * m[1][2];
   T Coef11 = m[1][1] * m[2][2] - m[2][1] * m[1][2];

   T Coef12 = m[2][0] * m[3][3] - m[3][0] * m[2][3];
   T Coef14 = m[1][0] * m[3][3] - m[3][0] * m[1][3];
   T Coef15 = m[1][0] * m[2][3] - m[2][0] * m[1][3];

   T Coef16 = m[2][0] * m[3][2] - m[3][0] * m[2][2];
   T Coef18 = m[1][0] * m[3][2] - m[3][0] * m[1][2];
   T Coef19 = m[1][0] * m[2][2] - m[2][0] * m[1][2];

   T Coef20 = m[2][0] * m[3][1] - m[3][0] * m[2][1];
   T Coef22 = m[1][0] * m[3][1] - m[3][0] * m[1][1];
   T Coef23 = m[1][0] * m[2][1] - m[2][0] * m[1][1];

   vec<4, T, Q> Fac0(Coef00, Coef00, Coef02, Coef03);
   vec<4, T, Q> Fac1(Coef04, Coef04, Coef06, Coef07);
   vec<4, T, Q> Fac2(Coef08, Coef08, Coef10, Coef11);
   vec<4, T, Q> Fac3(Coef12, Coef12, Coef14, Coef15);
   vec<4, T, Q> Fac4(Coef16, Coef16, Coef18, Coef19);
   vec<4, T, Q> Fac5(Coef20, Coef20, Coef22, Coef23);

   vec<4, T, Q> Vec0(m[1][0], m[0][0], m[0][0], m[0][0]);
   vec<4, T, Q> Vec1(m[1][1], m[0][1], m[0][1], m[0][1]);
   vec<4, T, Q> Vec2(m[1][2], m[0][2], m[0][2], m[0][2]);
   vec<4, T, Q> Vec3(m[1][3], m[0][3], m[0][3], m[0][3]);

   vec<4, T, Q> Inv0(Vec1 * Fac0 - Vec2 * Fac1 + Vec3 * Fac2);
   vec<4, T, Q> Inv1(Vec0 * Fac0 - Vec2 * Fac3 + Vec3 * Fac4);
   vec<4, T, Q> Inv2(Vec0 * Fac1 - Vec1 * Fac3 + Vec3 * Fac5);
   vec<4, T, Q> Inv3(Vec0 * Fac2 - Vec1 * Fac4 + Vec2 * Fac5);

   vec<4, T, Q> SignA(+1, -1, +1, -1);
   vec<4, T, Q> SignB(-1, +1, -1, +1);
   mat<4, 4, T, Q> Inverse(Inv0 * SignA, Inv1 * SignB, Inv2 * SignA, Inv3 * SignB);

   vec<4, T, Q> Row0(Inverse[0][0], Inverse[1][0], Inverse[2][0], Inverse[3][0]);

   vec<4, T, Q> Dot0(m[0] * Row0);
   T Dot1 = (Dot0.x + Dot0.y) + (Dot0.z + Dot0.w);

   T OneOverDeterminant = static_cast<T>(1) / Dot1;

   return Inverse * OneOverDeterminant;
  }
 };
}

 template<length_t C, length_t R, typename T, qualifier Q>
 inline mat<C, R, T, Q> matrixCompMult(mat<C, R, T, Q> const& x, mat<C, R, T, Q> const& y)
 {
  return detail::compute_matrixCompMult_type<C, R, T, Q, std::numeric_limits<T>::is_iec559, detail::is_aligned<Q>::value>::call(x, y);
 }

 template<length_t DA, length_t DB, typename T, qualifier Q>
 inline typename detail::outerProduct_trait<DA, DB, T, Q>::type outerProduct(vec<DA, T, Q> const& c, vec<DB, T, Q> const& r)
 {
  return detail::compute_outerProduct_type<DA, DB, T, Q, std::numeric_limits<T>::is_iec559>::call(c, r);
 }

 template<length_t C, length_t R, typename T, qualifier Q>
 inline typename mat<C, R, T, Q>::transpose_type transpose(mat<C, R, T, Q> const& m)
 {
  return detail::compute_transpose_type<C, R, T, Q, std::numeric_limits<T>::is_iec559, detail::is_aligned<Q>::value>::call(m);
 }

 template<length_t C, length_t R, typename T, qualifier Q>
 inline T determinant(mat<C, R, T, Q> const& m)
 {
  return detail::compute_determinant_type<C, R, T, Q, std::numeric_limits<T>::is_iec559, detail::is_aligned<Q>::value>::call(m);
 }

 template<length_t C, length_t R, typename T, qualifier Q>
 inline mat<C, R, T, Q> inverse(mat<C, R, T, Q> const& m)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'inverse' only accept floating-point inputs");
  return detail::compute_inverse<C, R, T, Q, detail::is_aligned<Q>::value>::call(m);
 }
}
# 162 "/usr/include/glm/matrix.hpp" 2 3 4
# 2 "/usr/include/glm/detail/type_mat2x2.inl" 2 3 4

namespace glm
{
# 21 "/usr/include/glm/detail/type_mat2x2.inl" 3 4
 template<typename T, qualifier Q>
 template<qualifier P>
 inline constexpr mat<2, 2, T, Q>::mat(mat<2, 2, T, P> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q>::mat(T scalar)

   : value{col_type(scalar, 0), col_type(0, scalar)}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q>::mat
 (
  T const& x0, T const& y0,
  T const& x1, T const& y1
 )

   : value{col_type(x0, y0), col_type(x1, y1)}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q>::mat(col_type const& v0, col_type const& v1)

   : value{v0, v1}

 {




 }



 template<typename T, qualifier Q>
 template<typename X1, typename Y1, typename X2, typename Y2>
 inline constexpr mat<2, 2, T, Q>::mat
 (
  X1 const& x1, Y1 const& y1,
  X2 const& x2, Y2 const& y2
 )

   : value{col_type(static_cast<T>(x1), value_type(y1)), col_type(static_cast<T>(x2), value_type(y2)) }

 {




 }

 template<typename T, qualifier Q>
 template<typename V1, typename V2>
 inline constexpr mat<2, 2, T, Q>::mat(vec<2, V1, Q> const& v1, vec<2, V2, Q> const& v2)

   : value{col_type(v1), col_type(v2)}

 {




 }



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr mat<2, 2, T, Q>::mat(mat<2, 2, U, P> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q>::mat(mat<3, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q>::mat(mat<4, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q>::mat(mat<2, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q>::mat(mat<3, 2, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q>::mat(mat<2, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q>::mat(mat<4, 2, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q>::mat(mat<3, 4, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q>::mat(mat<4, 3, T, Q> const& m)

   : value{col_type(m[0]), col_type(m[1])}

 {




 }



 template<typename T, qualifier Q>
 inline constexpr typename mat<2, 2, T, Q>::col_type& mat<2, 2, T, Q>::operator[](typename mat<2, 2, T, Q>::length_type i) noexcept
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));
  return this->value[i];
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<2, 2, T, Q>::col_type const& mat<2, 2, T, Q>::operator[](typename mat<2, 2, T, Q>::length_type i) const noexcept
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));
  return this->value[i];
 }



 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator=(mat<2, 2, U, Q> const& m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator+=(U scalar)
 {
  this->value[0] += scalar;
  this->value[1] += scalar;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator+=(mat<2, 2, U, Q> const& m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator-=(U scalar)
 {
  this->value[0] -= scalar;
  this->value[1] -= scalar;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator-=(mat<2, 2, U, Q> const& m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator*=(U scalar)
 {
  this->value[0] *= scalar;
  this->value[1] *= scalar;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator*=(mat<2, 2, U, Q> const& m)
 {
  return (*this = *this * m);
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator/=(U scalar)
 {
  this->value[0] /= scalar;
  this->value[1] /= scalar;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator/=(mat<2, 2, U, Q> const& m)
 {
  return *this *= inverse(m);
 }



 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q>& mat<2, 2, T, Q>::operator--()
 {
  --this->value[0];
  --this->value[1];
  return *this;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> mat<2, 2, T, Q>::operator++(int)
 {
  mat<2, 2, T, Q> Result(*this);
  ++*this;
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> mat<2, 2, T, Q>::operator--(int)
 {
  mat<2, 2, T, Q> Result(*this);
  --*this;
  return Result;
 }



 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> operator+(mat<2, 2, T, Q> const& m)
 {
  return m;
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> operator-(mat<2, 2, T, Q> const& m)
 {
  return mat<2, 2, T, Q>(
   -m[0],
   -m[1]);
 }



 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> operator+(mat<2, 2, T, Q> const& m, T scalar)
 {
  return mat<2, 2, T, Q>(
   m[0] + scalar,
   m[1] + scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> operator+(T scalar, mat<2, 2, T, Q> const& m)
 {
  return mat<2, 2, T, Q>(
   m[0] + scalar,
   m[1] + scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> operator+(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
 {
  return mat<2, 2, T, Q>(
   m1[0] + m2[0],
   m1[1] + m2[1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> operator-(mat<2, 2, T, Q> const& m, T scalar)
 {
  return mat<2, 2, T, Q>(
   m[0] - scalar,
   m[1] - scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> operator-(T scalar, mat<2, 2, T, Q> const& m)
 {
  return mat<2, 2, T, Q>(
   scalar - m[0],
   scalar - m[1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> operator-(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
 {
  return mat<2, 2, T, Q>(
   m1[0] - m2[0],
   m1[1] - m2[1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> operator*(mat<2, 2, T, Q> const& m, T scalar)
 {
  return mat<2, 2, T, Q>(
   m[0] * scalar,
   m[1] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> operator*(T scalar, mat<2, 2, T, Q> const& m)
 {
  return mat<2, 2, T, Q>(
   m[0] * scalar,
   m[1] * scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<2, 2, T, Q>::col_type operator*
 (
  mat<2, 2, T, Q> const& m,
  typename mat<2, 2, T, Q>::row_type const& v
 )
 {
  return vec<2, T, Q>(
   m[0][0] * v.x + m[1][0] * v.y,
   m[0][1] * v.x + m[1][1] * v.y);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<2, 2, T, Q>::row_type operator*
 (
  typename mat<2, 2, T, Q>::col_type const& v,
  mat<2, 2, T, Q> const& m
 )
 {
  return vec<2, T, Q>(
   v.x * m[0][0] + v.y * m[0][1],
   v.x * m[1][0] + v.y * m[1][1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> operator*(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
 {
  return mat<2, 2, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<3, 2, T, Q> operator*(mat<2, 2, T, Q> const& m1, mat<3, 2, T, Q> const& m2)
 {
  return mat<3, 2, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 2, T, Q> operator*(mat<2, 2, T, Q> const& m1, mat<4, 2, T, Q> const& m2)
 {
  return mat<4, 2, T, Q>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1]);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> operator/(mat<2, 2, T, Q> const& m, T scalar)
 {
  return mat<2, 2, T, Q>(
   m[0] / scalar,
   m[1] / scalar);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> operator/(T scalar, mat<2, 2, T, Q> const& m)
 {
  return mat<2, 2, T, Q>(
   scalar / m[0],
   scalar / m[1]);
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<2, 2, T, Q>::col_type operator/(mat<2, 2, T, Q> const& m, typename mat<2, 2, T, Q>::row_type const& v)
 {
  return inverse(m) * v;
 }

 template<typename T, qualifier Q>
 inline constexpr typename mat<2, 2, T, Q>::row_type operator/(typename mat<2, 2, T, Q>::col_type const& v, mat<2, 2, T, Q> const& m)
 {
  return v * inverse(m);
 }

 template<typename T, qualifier Q>
 inline constexpr mat<2, 2, T, Q> operator/(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
 {
  mat<2, 2, T, Q> m1_copy(m1);
  return m1_copy /= m2;
 }



 template<typename T, qualifier Q>
 inline constexpr bool operator==(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]);
 }

 template<typename T, qualifier Q>
 inline constexpr bool operator!=(mat<2, 2, T, Q> const& m1, mat<2, 2, T, Q> const& m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]);
 }
}
# 177 "/usr/include/glm/detail/type_mat2x2.hpp" 2 3 4
# 6 "/usr/include/glm/ext/matrix_double2x2.hpp" 2 3 4

namespace glm
{






 typedef mat<2, 2, double, defaultp> dmat2x2;




 typedef mat<2, 2, double, defaultp> dmat2;


}
# 6 "/usr/include/glm/mat2x2.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_double2x2_precision.hpp" 1 3 4



       


namespace glm
{







 typedef mat<2, 2, double, lowp> lowp_dmat2;





 typedef mat<2, 2, double, mediump> mediump_dmat2;





 typedef mat<2, 2, double, highp> highp_dmat2;





 typedef mat<2, 2, double, lowp> lowp_dmat2x2;





 typedef mat<2, 2, double, mediump> mediump_dmat2x2;





 typedef mat<2, 2, double, highp> highp_dmat2x2;


}
# 7 "/usr/include/glm/mat2x2.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_float2x2.hpp" 1 3 4



       


namespace glm
{






 typedef mat<2, 2, float, defaultp> mat2x2;




 typedef mat<2, 2, float, defaultp> mat2;


}
# 8 "/usr/include/glm/mat2x2.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_float2x2_precision.hpp" 1 3 4



       


namespace glm
{







 typedef mat<2, 2, float, lowp> lowp_mat2;





 typedef mat<2, 2, float, mediump> mediump_mat2;





 typedef mat<2, 2, float, highp> highp_mat2;





 typedef mat<2, 2, float, lowp> lowp_mat2x2;





 typedef mat<2, 2, float, mediump> mediump_mat2x2;





 typedef mat<2, 2, float, highp> highp_mat2x2;


}
# 9 "/usr/include/glm/mat2x2.hpp" 2 3 4
# 121 "/usr/include/glm/glm.hpp" 2 3 4
# 130 "/usr/include/glm/glm.hpp" 3 4
# 1 "/usr/include/glm/trigonometric.hpp" 1 3 4
# 19 "/usr/include/glm/trigonometric.hpp" 3 4
       

# 1 "/usr/include/glm/detail/setup.hpp" 1 3 4
# 22 "/usr/include/glm/trigonometric.hpp" 2 3 4


namespace glm
{
# 37 "/usr/include/glm/trigonometric.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, T, Q> radians(vec<L, T, Q> const& degrees);
# 48 "/usr/include/glm/trigonometric.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, T, Q> degrees(vec<L, T, Q> const& radians);
# 60 "/usr/include/glm/trigonometric.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> sin(vec<L, T, Q> const& angle);
# 72 "/usr/include/glm/trigonometric.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> cos(vec<L, T, Q> const& angle);
# 83 "/usr/include/glm/trigonometric.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> tan(vec<L, T, Q> const& angle);
# 96 "/usr/include/glm/trigonometric.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> asin(vec<L, T, Q> const& x);
# 109 "/usr/include/glm/trigonometric.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> acos(vec<L, T, Q> const& x);
# 124 "/usr/include/glm/trigonometric.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> atan(vec<L, T, Q> const& y, vec<L, T, Q> const& x);
# 136 "/usr/include/glm/trigonometric.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> atan(vec<L, T, Q> const& y_over_x);
# 147 "/usr/include/glm/trigonometric.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> sinh(vec<L, T, Q> const& angle);
# 158 "/usr/include/glm/trigonometric.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> cosh(vec<L, T, Q> const& angle);
# 169 "/usr/include/glm/trigonometric.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> tanh(vec<L, T, Q> const& angle);
# 180 "/usr/include/glm/trigonometric.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> asinh(vec<L, T, Q> const& x);
# 192 "/usr/include/glm/trigonometric.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> acosh(vec<L, T, Q> const& x);
# 204 "/usr/include/glm/trigonometric.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> atanh(vec<L, T, Q> const& x);


}

# 1 "/usr/include/glm/detail/func_trigonometric.inl" 1 3 4

# 1 "/usr/include/c++/14.2.1/cmath" 1 3 4
# 39 "/usr/include/c++/14.2.1/cmath" 3 4
       
# 40 "/usr/include/c++/14.2.1/cmath" 3
# 3 "/usr/include/glm/detail/func_trigonometric.inl" 2 3 4


namespace glm
{

 template<typename genType>
 inline constexpr genType radians(genType degrees)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'radians' only accept floating-point input");

  return degrees * static_cast<genType>(0.01745329251994329576923690768489);
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, T, Q> radians(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(radians, v);
 }


 template<typename genType>
 inline constexpr genType degrees(genType radians)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'degrees' only accept floating-point input");

  return radians * static_cast<genType>(57.295779513082320876798154814105);
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, T, Q> degrees(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(degrees, v);
 }


 using ::std::sin;

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> sin(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(sin, v);
 }


 using std::cos;

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> cos(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(cos, v);
 }


 using std::tan;

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> tan(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(tan, v);
 }


 using std::asin;

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> asin(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(asin, v);
 }


 using std::acos;

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> acos(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(acos, v);
 }


 template<typename genType>
 inline genType atan(genType y, genType x)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'atan' only accept floating-point input");

  return ::std::atan2(y, x);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> atan(vec<L, T, Q> const& y, vec<L, T, Q> const& x)
 {
  return detail::functor2<vec, L, T, Q>::call(::std::atan2, y, x);
 }

 using std::atan;

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> atan(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(atan, v);
 }


 using std::sinh;

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> sinh(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(sinh, v);
 }


 using std::cosh;

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> cosh(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(cosh, v);
 }


 using std::tanh;

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> tanh(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(tanh, v);
 }



  using std::asinh;
# 145 "/usr/include/glm/detail/func_trigonometric.inl" 3 4
 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> asinh(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(asinh, v);
 }



  using std::acosh;
# 166 "/usr/include/glm/detail/func_trigonometric.inl" 3 4
 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> acosh(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(acosh, v);
 }



  using std::atanh;
# 187 "/usr/include/glm/detail/func_trigonometric.inl" 3 4
 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> atanh(vec<L, T, Q> const& v)
 {
  return detail::functor1<vec, L, T, T, Q>::call(atanh, v);
 }
}
# 211 "/usr/include/glm/trigonometric.hpp" 2 3 4
# 131 "/usr/include/glm/glm.hpp" 2 3 4


# 1 "/usr/include/glm/packing.hpp" 1 3 4
# 16 "/usr/include/glm/packing.hpp" 3 4
       





namespace glm
{
# 38 "/usr/include/glm/packing.hpp" 3 4
 [[nodiscard]] uint packUnorm2x16(vec2 const& v);
# 51 "/usr/include/glm/packing.hpp" 3 4
 [[nodiscard]] uint packSnorm2x16(vec2 const& v);
# 64 "/usr/include/glm/packing.hpp" 3 4
 [[nodiscard]] uint packUnorm4x8(vec4 const& v);
# 77 "/usr/include/glm/packing.hpp" 3 4
 [[nodiscard]] uint packSnorm4x8(vec4 const& v);
# 90 "/usr/include/glm/packing.hpp" 3 4
 [[nodiscard]] vec2 unpackUnorm2x16(uint p);
# 103 "/usr/include/glm/packing.hpp" 3 4
 [[nodiscard]] vec2 unpackSnorm2x16(uint p);
# 116 "/usr/include/glm/packing.hpp" 3 4
 [[nodiscard]] vec4 unpackUnorm4x8(uint p);
# 129 "/usr/include/glm/packing.hpp" 3 4
 [[nodiscard]] vec4 unpackSnorm4x8(uint p);
# 139 "/usr/include/glm/packing.hpp" 3 4
 [[nodiscard]] double packDouble2x32(uvec2 const& v);
# 148 "/usr/include/glm/packing.hpp" 3 4
 [[nodiscard]] uvec2 unpackDouble2x32(double v);
# 158 "/usr/include/glm/packing.hpp" 3 4
 [[nodiscard]] uint packHalf2x16(vec2 const& v);
# 168 "/usr/include/glm/packing.hpp" 3 4
 [[nodiscard]] vec2 unpackHalf2x16(uint v);


}

# 1 "/usr/include/glm/detail/func_packing.inl" 1 3 4




# 1 "/usr/include/glm/detail/type_half.hpp" 1 3 4
       

# 1 "/usr/include/glm/detail/setup.hpp" 1 3 4
# 4 "/usr/include/glm/detail/type_half.hpp" 2 3 4

namespace glm{
namespace detail
{
 typedef short hdata;

 [[nodiscard]] float toFloat32(hdata value);
 [[nodiscard]] hdata toFloat16(float const& value);

}
}

# 1 "/usr/include/glm/detail/type_half.inl" 1 3 4
namespace glm{
namespace detail
{
 inline float overflow()
 {
  volatile float f = 1e10;

  for(int i = 0; i < 10; ++i)
   f = f * f;
  return f;
 }

 union uif32
 {
  inline uif32() :
   i(0)
  {}

  inline uif32(float f_) :
   f(f_)
  {}

  inline uif32(unsigned int i_) :
   i(i_)
  {}

  float f;
  unsigned int i;
 };

 inline float toFloat32(hdata value)
 {
  int s = (value >> 15) & 0x00000001;
  int e = (value >> 10) & 0x0000001f;
  int m = value & 0x000003ff;

  if(e == 0)
  {
   if(m == 0)
   {




    detail::uif32 result;
    result.i = static_cast<unsigned int>(s << 31);
    return result.f;
   }
   else
   {




    while(!(m & 0x00000400))
    {
     m <<= 1;
     e -= 1;
    }

    e += 1;
    m &= ~0x00000400;
   }
  }
  else if(e == 31)
  {
   if(m == 0)
   {




    uif32 result;
    result.i = static_cast<unsigned int>((s << 31) | 0x7f800000);
    return result.f;
   }
   else
   {




    uif32 result;
    result.i = static_cast<unsigned int>((s << 31) | 0x7f800000 | (m << 13));
    return result.f;
   }
  }





  e = e + (127 - 15);
  m = m << 13;





  uif32 Result;
  Result.i = static_cast<unsigned int>((s << 31) | (e << 23) | m);
  return Result.f;
 }

 inline hdata toFloat16(float const& f)
 {
  uif32 Entry;
  Entry.f = f;
  int i = static_cast<int>(Entry.i);
# 121 "/usr/include/glm/detail/type_half.inl" 3 4
  int s = (i >> 16) & 0x00008000;
  int e = ((i >> 23) & 0x000000ff) - (127 - 15);
  int m = i & 0x007fffff;





  if(e <= 0)
  {
   if(e < -10)
   {
# 141 "/usr/include/glm/detail/type_half.inl" 3 4
    return hdata(s);
   }
# 151 "/usr/include/glm/detail/type_half.inl" 3 4
   m = (m | 0x00800000) >> (1 - e);
# 162 "/usr/include/glm/detail/type_half.inl" 3 4
   if(m & 0x00001000)
    m += 0x00002000;





   return hdata(s | (m >> 13));
  }
  else if(e == 0xff - (127 - 15))
  {
   if(m == 0)
   {





    return hdata(s | 0x7c00);
   }
   else
   {
# 193 "/usr/include/glm/detail/type_half.inl" 3 4
    m >>= 13;

    return hdata(s | 0x7c00 | m | (m == 0));
   }
  }
  else
  {
# 209 "/usr/include/glm/detail/type_half.inl" 3 4
   if(m & 0x00001000)
   {
    m += 0x00002000;

    if(m & 0x00800000)
    {
     m = 0;
     e += 1;
    }
   }





   if (e > 30)
   {
    overflow();

    return hdata(s | 0x7c00);

   }





   return hdata(s | (e << 10) | (m >> 13));
  }
 }

}
}
# 17 "/usr/include/glm/detail/type_half.hpp" 2 3 4
# 6 "/usr/include/glm/detail/func_packing.inl" 2 3 4

namespace glm
{
 inline uint packUnorm2x16(vec2 const& v)
 {
  union
  {
   unsigned short in[2];
   uint out;
  } u;

  vec<2, unsigned short, defaultp> result(round(clamp(v, 0.0f, 1.0f) * 65535.0f));

  u.in[0] = result[0];
  u.in[1] = result[1];

  return u.out;
 }

 inline vec2 unpackUnorm2x16(uint p)
 {
  union
  {
   uint in;
   unsigned short out[2];
  } u;

  u.in = p;

  return vec2(u.out[0], u.out[1]) * 1.5259021896696421759365224689097e-5f;
 }

 inline uint packSnorm2x16(vec2 const& v)
 {
  union
  {
   signed short in[2];
   uint out;
  } u;

  vec<2, short, defaultp> result(round(clamp(v, -1.0f, 1.0f) * 32767.0f));

  u.in[0] = result[0];
  u.in[1] = result[1];

  return u.out;
 }

 inline vec2 unpackSnorm2x16(uint p)
 {
  union
  {
   uint in;
   signed short out[2];
  } u;

  u.in = p;

  return clamp(vec2(u.out[0], u.out[1]) * 3.0518509475997192297128208258309e-5f, -1.0f, 1.0f);
 }

 inline uint packUnorm4x8(vec4 const& v)
 {
  union
  {
   unsigned char in[4];
   uint out;
  } u;

  vec<4, unsigned char, defaultp> result(round(clamp(v, 0.0f, 1.0f) * 255.0f));

  u.in[0] = result[0];
  u.in[1] = result[1];
  u.in[2] = result[2];
  u.in[3] = result[3];

  return u.out;
 }

 inline vec4 unpackUnorm4x8(uint p)
 {
  union
  {
   uint in;
   unsigned char out[4];
  } u;

  u.in = p;

  return vec4(u.out[0], u.out[1], u.out[2], u.out[3]) * 0.0039215686274509803921568627451f;
 }

 inline uint packSnorm4x8(vec4 const& v)
 {
  union
  {
   signed char in[4];
   uint out;
  } u;

  vec<4, signed char, defaultp> result(round(clamp(v, -1.0f, 1.0f) * 127.0f));

  u.in[0] = result[0];
  u.in[1] = result[1];
  u.in[2] = result[2];
  u.in[3] = result[3];

  return u.out;
 }

 inline glm::vec4 unpackSnorm4x8(uint p)
 {
  union
  {
   uint in;
   signed char out[4];
  } u;

  u.in = p;

  return clamp(vec4(u.out[0], u.out[1], u.out[2], u.out[3]) * 0.0078740157480315f, -1.0f, 1.0f);
 }

 inline double packDouble2x32(uvec2 const& v)
 {
  union
  {
   uint in[2];
   double out;
  } u;

  u.in[0] = v[0];
  u.in[1] = v[1];

  return u.out;
 }

 inline uvec2 unpackDouble2x32(double v)
 {
  union
  {
   double in;
   uint out[2];
  } u;

  u.in = v;

  return uvec2(u.out[0], u.out[1]);
 }

 inline uint packHalf2x16(vec2 const& v)
 {
  union
  {
   signed short in[2];
   uint out;
  } u;

  u.in[0] = detail::toFloat16(v.x);
  u.in[1] = detail::toFloat16(v.y);

  return u.out;
 }

 inline vec2 unpackHalf2x16(uint v)
 {
  union
  {
   uint in;
   signed short out[2];
  } u;

  u.in = v;

  return vec2(
   detail::toFloat32(u.out[0]),
   detail::toFloat32(u.out[1]));
 }
}
# 174 "/usr/include/glm/packing.hpp" 2 3 4
# 134 "/usr/include/glm/glm.hpp" 2 3 4



# 1 "/usr/include/glm/integer.hpp" 1 3 4
# 17 "/usr/include/glm/integer.hpp" 3 4
       





namespace glm
{
# 36 "/usr/include/glm/integer.hpp" 3 4
 template<length_t L, qualifier Q>
 [[nodiscard]] vec<L, uint, Q> uaddCarry(
  vec<L, uint, Q> const& x,
  vec<L, uint, Q> const& y,
  vec<L, uint, Q> & carry);
# 50 "/usr/include/glm/integer.hpp" 3 4
 template<length_t L, qualifier Q>
 [[nodiscard]] vec<L, uint, Q> usubBorrow(
  vec<L, uint, Q> const& x,
  vec<L, uint, Q> const& y,
  vec<L, uint, Q> & borrow);
# 64 "/usr/include/glm/integer.hpp" 3 4
 template<length_t L, qualifier Q>
 void umulExtended(
  vec<L, uint, Q> const& x,
  vec<L, uint, Q> const& y,
  vec<L, uint, Q> & msb,
  vec<L, uint, Q> & lsb);
# 79 "/usr/include/glm/integer.hpp" 3 4
 template<length_t L, qualifier Q>
 void imulExtended(
  vec<L, int, Q> const& x,
  vec<L, int, Q> const& y,
  vec<L, int, Q> & msb,
  vec<L, int, Q> & lsb);
# 102 "/usr/include/glm/integer.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> bitfieldExtract(
  vec<L, T, Q> const& Value,
  int Offset,
  int Bits);
# 123 "/usr/include/glm/integer.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> bitfieldInsert(
  vec<L, T, Q> const& Base,
  vec<L, T, Q> const& Insert,
  int Offset,
  int Bits);
# 139 "/usr/include/glm/integer.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, T, Q> bitfieldReverse(vec<L, T, Q> const& v);







 template<typename genType>
 [[nodiscard]] int bitCount(genType v);
# 158 "/usr/include/glm/integer.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, int, Q> bitCount(vec<L, T, Q> const& v);
# 169 "/usr/include/glm/integer.hpp" 3 4
 template<typename genIUType>
 [[nodiscard]] int findLSB(genIUType x);
# 181 "/usr/include/glm/integer.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, int, Q> findLSB(vec<L, T, Q> const& v);
# 193 "/usr/include/glm/integer.hpp" 3 4
 template<typename genIUType>
 [[nodiscard]] int findMSB(genIUType x);
# 206 "/usr/include/glm/integer.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, int, Q> findMSB(vec<L, T, Q> const& v);


}

# 1 "/usr/include/glm/detail/func_integer.inl" 1 3 4
# 21 "/usr/include/glm/detail/func_integer.inl" 3 4
namespace glm{
namespace detail
{
 template<typename T>
 inline T mask(T Bits)
 {
  return Bits >= static_cast<T>(sizeof(T) * 8) ? ~static_cast<T>(0) : (static_cast<T>(1) << Bits) - static_cast<T>(1);
 }

 template<length_t L, typename T, qualifier Q, bool Aligned, bool EXEC>
 struct compute_bitfieldReverseStep
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& v, T, T)
  {
   return v;
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_bitfieldReverseStep<L, T, Q, Aligned, true>
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& v, T Mask, T Shift)
  {
   return (v & Mask) << Shift | (v & (~Mask)) >> Shift;
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned, bool EXEC>
 struct compute_bitfieldBitCountStep
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& v, T, T)
  {
   return v;
  }
 };

 template<length_t L, typename T, qualifier Q, bool Aligned>
 struct compute_bitfieldBitCountStep<L, T, Q, Aligned, true>
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& v, T Mask, T Shift)
  {
   return (v & Mask) + ((v >> Shift) & Mask);
  }
 };

 template<typename genIUType, size_t Bits>
 struct compute_findLSB
 {
  inline static int call(genIUType Value)
  {
   if(Value == 0)
    return -1;

   return glm::bitCount(~Value & (Value - static_cast<genIUType>(1)));
  }
 };
# 104 "/usr/include/glm/detail/func_integer.inl" 3 4
 template<length_t L, typename T, qualifier Q, bool EXEC = true>
 struct compute_findMSB_step_vec
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x, T Shift)
  {
   return x | (x >> Shift);
  }
 };

 template<length_t L, typename T, qualifier Q>
 struct compute_findMSB_step_vec<L, T, Q, false>
 {
  inline static vec<L, T, Q> call(vec<L, T, Q> const& x, T)
  {
   return x;
  }
 };

 template<length_t L, typename T, qualifier Q, int>
 struct compute_findMSB_vec
 {
  inline static vec<L, int, Q> call(vec<L, T, Q> const& v)
  {
   vec<L, T, Q> x(v);
   x = compute_findMSB_step_vec<L, T, Q, sizeof(T) * 8 >= 8>::call(x, static_cast<T>( 1));
   x = compute_findMSB_step_vec<L, T, Q, sizeof(T) * 8 >= 8>::call(x, static_cast<T>( 2));
   x = compute_findMSB_step_vec<L, T, Q, sizeof(T) * 8 >= 8>::call(x, static_cast<T>( 4));
   x = compute_findMSB_step_vec<L, T, Q, sizeof(T) * 8 >= 16>::call(x, static_cast<T>( 8));
   x = compute_findMSB_step_vec<L, T, Q, sizeof(T) * 8 >= 32>::call(x, static_cast<T>(16));
   x = compute_findMSB_step_vec<L, T, Q, sizeof(T) * 8 >= 64>::call(x, static_cast<T>(32));
   return vec<L, int, Q>(sizeof(T) * 8 - 1) - glm::bitCount(~x);
  }
 };
# 175 "/usr/include/glm/detail/func_integer.inl" 3 4
}


 inline uint uaddCarry(uint const& x, uint const& y, uint & Carry)
 {
  detail::uint64 const Value64(static_cast<detail::uint64>(x) + static_cast<detail::uint64>(y));
  detail::uint64 const Max32((static_cast<detail::uint64>(1) << static_cast<detail::uint64>(32)) - static_cast<detail::uint64>(1));
  Carry = Value64 > Max32 ? 1u : 0u;
  return static_cast<uint>(Value64 % (Max32 + static_cast<detail::uint64>(1)));
 }

 template<length_t L, qualifier Q>
 inline vec<L, uint, Q> uaddCarry(vec<L, uint, Q> const& x, vec<L, uint, Q> const& y, vec<L, uint, Q>& Carry)
 {
  vec<L, detail::uint64, Q> Value64(vec<L, detail::uint64, Q>(x) + vec<L, detail::uint64, Q>(y));
  vec<L, detail::uint64, Q> Max32((static_cast<detail::uint64>(1) << static_cast<detail::uint64>(32)) - static_cast<detail::uint64>(1));
  Carry = mix(vec<L, uint, Q>(0), vec<L, uint, Q>(1), greaterThan(Value64, Max32));
  return vec<L, uint, Q>(Value64 % (Max32 + static_cast<detail::uint64>(1)));
 }


 inline uint usubBorrow(uint const& x, uint const& y, uint & Borrow)
 {
  Borrow = x >= y ? static_cast<uint>(0) : static_cast<uint>(1);
  if(y >= x)
   return y - x;
  else
   return static_cast<uint>((static_cast<detail::int64>(1) << static_cast<detail::int64>(32)) + (static_cast<detail::int64>(y) - static_cast<detail::int64>(x)));
 }

 template<length_t L, qualifier Q>
 inline vec<L, uint, Q> usubBorrow(vec<L, uint, Q> const& x, vec<L, uint, Q> const& y, vec<L, uint, Q>& Borrow)
 {
  Borrow = mix(vec<L, uint, Q>(1), vec<L, uint, Q>(0), greaterThanEqual(x, y));
  vec<L, uint, Q> const YgeX(y - x);
  vec<L, uint, Q> const XgeY(vec<L, uint, Q>((static_cast<detail::int64>(1) << static_cast<detail::int64>(32)) + (vec<L, detail::int64, Q>(y) - vec<L, detail::int64, Q>(x))));
  return mix(XgeY, YgeX, greaterThanEqual(y, x));
 }


 inline void umulExtended(uint const& x, uint const& y, uint & msb, uint & lsb)
 {
  detail::uint64 Value64 = static_cast<detail::uint64>(x) * static_cast<detail::uint64>(y);
  msb = static_cast<uint>(Value64 >> static_cast<detail::uint64>(32));
  lsb = static_cast<uint>(Value64);
 }

 template<length_t L, qualifier Q>
 inline void umulExtended(vec<L, uint, Q> const& x, vec<L, uint, Q> const& y, vec<L, uint, Q>& msb, vec<L, uint, Q>& lsb)
 {
  vec<L, detail::uint64, Q> Value64(vec<L, detail::uint64, Q>(x) * vec<L, detail::uint64, Q>(y));
  msb = vec<L, uint, Q>(Value64 >> static_cast<detail::uint64>(32));
  lsb = vec<L, uint, Q>(Value64);
 }


 inline void imulExtended(int x, int y, int& msb, int& lsb)
 {
  detail::int64 Value64 = static_cast<detail::int64>(x) * static_cast<detail::int64>(y);
  msb = static_cast<int>(Value64 >> static_cast<detail::int64>(32));
  lsb = static_cast<int>(Value64);
 }

 template<length_t L, qualifier Q>
 inline void imulExtended(vec<L, int, Q> const& x, vec<L, int, Q> const& y, vec<L, int, Q>& msb, vec<L, int, Q>& lsb)
 {
  vec<L, detail::int64, Q> Value64(vec<L, detail::int64, Q>(x) * vec<L, detail::int64, Q>(y));
  lsb = vec<L, int, Q>(Value64 & static_cast<detail::int64>(0xFFFFFFFF));
  msb = vec<L, int, Q>((Value64 >> static_cast<detail::int64>(32)) & static_cast<detail::int64>(0xFFFFFFFF));
 }


 template<typename genIUType>
 inline genIUType bitfieldExtract(genIUType Value, int Offset, int Bits)
 {
  return bitfieldExtract(vec<1, genIUType>(Value), Offset, Bits).x;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> bitfieldExtract(vec<L, T, Q> const& Value, int Offset, int Bits)
 {
  static_assert(std::numeric_limits<T>::is_integer, "'bitfieldExtract' only accept integer inputs");

  return (Value >> static_cast<T>(Offset)) & static_cast<T>(detail::mask(Bits));
 }


 template<typename genIUType>
 inline genIUType bitfieldInsert(genIUType const& Base, genIUType const& Insert, int Offset, int Bits)
 {
  static_assert(std::numeric_limits<genIUType>::is_integer, "'bitfieldInsert' only accept integer values");

  return bitfieldInsert(vec<1, genIUType>(Base), vec<1, genIUType>(Insert), Offset, Bits).x;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> bitfieldInsert(vec<L, T, Q> const& Base, vec<L, T, Q> const& Insert, int Offset, int Bits)
 {
  static_assert(std::numeric_limits<T>::is_integer, "'bitfieldInsert' only accept integer values");

  T const Mask = detail::mask(static_cast<T>(Bits)) << Offset;
  return (Base & ~Mask) | ((Insert << static_cast<T>(Offset)) & Mask);
 }







 template<typename genIUType>
 inline genIUType bitfieldReverse(genIUType x)
 {
  static_assert(std::numeric_limits<genIUType>::is_integer, "'bitfieldReverse' only accept integer values");

  return bitfieldReverse(glm::vec<1, genIUType, glm::defaultp>(x)).x;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, T, Q> bitfieldReverse(vec<L, T, Q> const& v)
 {
  static_assert(std::numeric_limits<T>::is_integer, "'bitfieldReverse' only accept integer values");

  vec<L, T, Q> x(v);
  x = detail::compute_bitfieldReverseStep<L, T, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 2>::call(x, static_cast<T>(0x5555555555555555ull), static_cast<T>( 1));
  x = detail::compute_bitfieldReverseStep<L, T, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 4>::call(x, static_cast<T>(0x3333333333333333ull), static_cast<T>( 2));
  x = detail::compute_bitfieldReverseStep<L, T, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 8>::call(x, static_cast<T>(0x0F0F0F0F0F0F0F0Full), static_cast<T>( 4));
  x = detail::compute_bitfieldReverseStep<L, T, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 16>::call(x, static_cast<T>(0x00FF00FF00FF00FFull), static_cast<T>( 8));
  x = detail::compute_bitfieldReverseStep<L, T, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 32>::call(x, static_cast<T>(0x0000FFFF0000FFFFull), static_cast<T>(16));
  x = detail::compute_bitfieldReverseStep<L, T, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 64>::call(x, static_cast<T>(0x00000000FFFFFFFFull), static_cast<T>(32));
  return x;
 }






 template<typename genIUType>
 inline int bitCount(genIUType x)
 {
  static_assert(std::numeric_limits<genIUType>::is_integer, "'bitCount' only accept integer values");

  return bitCount(glm::vec<1, genIUType, glm::defaultp>(x)).x;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, int, Q> bitCount(vec<L, T, Q> const& v)
 {
  static_assert(std::numeric_limits<T>::is_integer, "'bitCount' only accept integer values");






  vec<L, typename detail::make_unsigned<T>::type, Q> x(v);
  x = detail::compute_bitfieldBitCountStep<L, typename detail::make_unsigned<T>::type, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 2>::call(x, typename detail::make_unsigned<T>::type(0x5555555555555555ull), typename detail::make_unsigned<T>::type( 1));
  x = detail::compute_bitfieldBitCountStep<L, typename detail::make_unsigned<T>::type, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 4>::call(x, typename detail::make_unsigned<T>::type(0x3333333333333333ull), typename detail::make_unsigned<T>::type( 2));
  x = detail::compute_bitfieldBitCountStep<L, typename detail::make_unsigned<T>::type, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 8>::call(x, typename detail::make_unsigned<T>::type(0x0F0F0F0F0F0F0F0Full), typename detail::make_unsigned<T>::type( 4));
  x = detail::compute_bitfieldBitCountStep<L, typename detail::make_unsigned<T>::type, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 16>::call(x, typename detail::make_unsigned<T>::type(0x00FF00FF00FF00FFull), typename detail::make_unsigned<T>::type( 8));
  x = detail::compute_bitfieldBitCountStep<L, typename detail::make_unsigned<T>::type, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 32>::call(x, typename detail::make_unsigned<T>::type(0x0000FFFF0000FFFFull), typename detail::make_unsigned<T>::type(16));
  x = detail::compute_bitfieldBitCountStep<L, typename detail::make_unsigned<T>::type, Q, detail::is_aligned<Q>::value, sizeof(T) * 8>= 64>::call(x, typename detail::make_unsigned<T>::type(0x00000000FFFFFFFFull), typename detail::make_unsigned<T>::type(32));
  return vec<L, int, Q>(x);




 }


 template<typename genIUType>
 inline int findLSB(genIUType Value)
 {
  static_assert(std::numeric_limits<genIUType>::is_integer, "'findLSB' only accept integer values");

  return detail::compute_findLSB<genIUType, sizeof(genIUType) * 8>::call(Value);
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, int, Q> findLSB(vec<L, T, Q> const& x)
 {
  static_assert(std::numeric_limits<T>::is_integer, "'findLSB' only accept integer values");

  return detail::functor1<vec, L, int, T, Q>::call(findLSB, x);
 }


 template<typename genIUType>
 inline int findMSB(genIUType v)
 {
  static_assert(std::numeric_limits<genIUType>::is_integer, "'findMSB' only accept integer values");

  return findMSB(vec<1, genIUType>(v)).x;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, int, Q> findMSB(vec<L, T, Q> const& v)
 {
  static_assert(std::numeric_limits<T>::is_integer, "'findMSB' only accept integer values");

  return detail::compute_findMSB_vec<L, T, Q, static_cast<int>(sizeof(T) * 8)>::call(v);
 }
}
# 213 "/usr/include/glm/integer.hpp" 2 3 4
# 138 "/usr/include/glm/glm.hpp" 2 3 4
# 4 "/home/devkon/CLionProjects/VertexLab/main.cpp" 2
# 1 "/usr/include/glm/gtc/matrix_transform.hpp" 1 3 4
# 21 "/usr/include/glm/gtc/matrix_transform.hpp" 3 4
       






# 1 "/usr/include/glm/ext/matrix_projection.hpp" 1 3 4
# 20 "/usr/include/glm/ext/matrix_projection.hpp" 3 4
       


# 1 "/usr/include/glm/gtc/constants.hpp" 1 3 4
# 13 "/usr/include/glm/gtc/constants.hpp" 3 4
       


# 1 "/usr/include/glm/ext/scalar_constants.hpp" 1 3 4
# 11 "/usr/include/glm/ext/scalar_constants.hpp" 3 4
       


# 1 "/usr/include/glm/detail/setup.hpp" 1 3 4
# 15 "/usr/include/glm/ext/scalar_constants.hpp" 2 3 4





namespace glm
{




 template<typename genType>
 [[nodiscard]] constexpr genType epsilon();


 template<typename genType>
 [[nodiscard]] constexpr genType pi();


 template<typename genType>
 [[nodiscard]] constexpr genType cos_one_over_two();


}

# 1 "/usr/include/glm/ext/scalar_constants.inl" 1 3 4


namespace glm
{
 template<typename genType>
 inline constexpr genType epsilon()
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'epsilon' only accepts floating-point inputs");
  return std::numeric_limits<genType>::epsilon();
 }

 template<typename genType>
 inline constexpr genType pi()
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || 0, "'pi' only accepts floating-point inputs");
  return static_cast<genType>(3.14159265358979323846264338327950288);
 }

 template<typename genType>
 inline constexpr genType cos_one_over_two()
 {
  return genType(0.877582561890372716130286068203503191);
 }
}
# 41 "/usr/include/glm/ext/scalar_constants.hpp" 2 3 4
# 17 "/usr/include/glm/gtc/constants.hpp" 2 3 4





namespace glm
{





 template<typename genType>
 [[nodiscard]] constexpr genType zero();



 template<typename genType>
 [[nodiscard]] constexpr genType one();



 template<typename genType>
 [[nodiscard]] constexpr genType two_pi();



 template<typename genType>
 [[nodiscard]] constexpr genType tau();



 template<typename genType>
 [[nodiscard]] constexpr genType root_pi();



 template<typename genType>
 [[nodiscard]] constexpr genType half_pi();



 template<typename genType>
 [[nodiscard]] constexpr genType three_over_two_pi();



 template<typename genType>
 [[nodiscard]] constexpr genType quarter_pi();



 template<typename genType>
 [[nodiscard]] constexpr genType one_over_pi();



 template<typename genType>
 [[nodiscard]] constexpr genType one_over_two_pi();



 template<typename genType>
 [[nodiscard]] constexpr genType two_over_pi();



 template<typename genType>
 [[nodiscard]] constexpr genType four_over_pi();



 template<typename genType>
 [[nodiscard]] constexpr genType two_over_root_pi();



 template<typename genType>
 [[nodiscard]] constexpr genType one_over_root_two();



 template<typename genType>
 [[nodiscard]] constexpr genType root_half_pi();



 template<typename genType>
 [[nodiscard]] constexpr genType root_two_pi();



 template<typename genType>
 [[nodiscard]] constexpr genType root_ln_four();



 template<typename genType>
 [[nodiscard]] constexpr genType e();



 template<typename genType>
 [[nodiscard]] constexpr genType euler();



 template<typename genType>
 [[nodiscard]] constexpr genType root_two();



 template<typename genType>
 [[nodiscard]] constexpr genType root_three();



 template<typename genType>
 [[nodiscard]] constexpr genType root_five();



 template<typename genType>
 [[nodiscard]] constexpr genType ln_two();



 template<typename genType>
 [[nodiscard]] constexpr genType ln_ten();



 template<typename genType>
 [[nodiscard]] constexpr genType ln_ln_two();



 template<typename genType>
 [[nodiscard]] constexpr genType third();



 template<typename genType>
 [[nodiscard]] constexpr genType two_thirds();



 template<typename genType>
 [[nodiscard]] constexpr genType golden_ratio();


}

# 1 "/usr/include/glm/gtc/constants.inl" 1 3 4


namespace glm
{
 template<typename genType>
 inline constexpr genType zero()
 {
  return genType(0);
 }

 template<typename genType>
 inline constexpr genType one()
 {
  return genType(1);
 }

 template<typename genType>
 inline constexpr genType two_pi()
 {
  return genType(6.28318530717958647692528676655900576);
 }

 template<typename genType>
 inline constexpr genType tau()
 {
  return two_pi<genType>();
 }

 template<typename genType>
 inline constexpr genType root_pi()
 {
  return genType(1.772453850905516027);
 }

 template<typename genType>
 inline constexpr genType half_pi()
 {
  return genType(1.57079632679489661923132169163975144);
 }

 template<typename genType>
 inline constexpr genType three_over_two_pi()
 {
  return genType(4.71238898038468985769396507491925432);
 }

 template<typename genType>
 inline constexpr genType quarter_pi()
 {
  return genType(0.785398163397448309615660845819875721);
 }

 template<typename genType>
 inline constexpr genType one_over_pi()
 {
  return genType(0.318309886183790671537767526745028724);
 }

 template<typename genType>
 inline constexpr genType one_over_two_pi()
 {
  return genType(0.159154943091895335768883763372514362);
 }

 template<typename genType>
 inline constexpr genType two_over_pi()
 {
  return genType(0.636619772367581343075535053490057448);
 }

 template<typename genType>
 inline constexpr genType four_over_pi()
 {
  return genType(1.273239544735162686151070106980114898);
 }

 template<typename genType>
 inline constexpr genType two_over_root_pi()
 {
  return genType(1.12837916709551257389615890312154517);
 }

 template<typename genType>
 inline constexpr genType one_over_root_two()
 {
  return genType(0.707106781186547524400844362104849039);
 }

 template<typename genType>
 inline constexpr genType root_half_pi()
 {
  return genType(1.253314137315500251);
 }

 template<typename genType>
 inline constexpr genType root_two_pi()
 {
  return genType(2.506628274631000502);
 }

 template<typename genType>
 inline constexpr genType root_ln_four()
 {
  return genType(1.17741002251547469);
 }

 template<typename genType>
 inline constexpr genType e()
 {
  return genType(2.71828182845904523536);
 }

 template<typename genType>
 inline constexpr genType euler()
 {
  return genType(0.577215664901532860606);
 }

 template<typename genType>
 inline constexpr genType root_two()
 {
  return genType(1.41421356237309504880168872420969808);
 }

 template<typename genType>
 inline constexpr genType root_three()
 {
  return genType(1.73205080756887729352744634150587236);
 }

 template<typename genType>
 inline constexpr genType root_five()
 {
  return genType(2.23606797749978969640917366873127623);
 }

 template<typename genType>
 inline constexpr genType ln_two()
 {
  return genType(0.693147180559945309417232121458176568);
 }

 template<typename genType>
 inline constexpr genType ln_ten()
 {
  return genType(2.30258509299404568401799145468436421);
 }

 template<typename genType>
 inline constexpr genType ln_ln_two()
 {
  return genType(-0.3665129205816643);
 }

 template<typename genType>
 inline constexpr genType third()
 {
  return genType(0.3333333333333333333333333333333333333333);
 }

 template<typename genType>
 inline constexpr genType two_thirds()
 {
  return genType(0.666666666666666666666666666666666666667);
 }

 template<typename genType>
 inline constexpr genType golden_ratio()
 {
  return genType(1.61803398874989484820458683436563811);
 }

}
# 171 "/usr/include/glm/gtc/constants.hpp" 2 3 4
# 24 "/usr/include/glm/ext/matrix_projection.hpp" 2 3 4
# 32 "/usr/include/glm/ext/matrix_projection.hpp" 3 4
namespace glm
{
# 49 "/usr/include/glm/ext/matrix_projection.hpp" 3 4
 template<typename T, typename U, qualifier Q>
 [[nodiscard]] vec<3, T, Q> projectZO(
  vec<3, T, Q> const& obj, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport);
# 65 "/usr/include/glm/ext/matrix_projection.hpp" 3 4
 template<typename T, typename U, qualifier Q>
 [[nodiscard]] vec<3, T, Q> projectNO(
  vec<3, T, Q> const& obj, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport);
# 81 "/usr/include/glm/ext/matrix_projection.hpp" 3 4
 template<typename T, typename U, qualifier Q>
 [[nodiscard]] vec<3, T, Q> project(
  vec<3, T, Q> const& obj, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport);
# 97 "/usr/include/glm/ext/matrix_projection.hpp" 3 4
 template<typename T, typename U, qualifier Q>
 [[nodiscard]] vec<3, T, Q> unProjectZO(
  vec<3, T, Q> const& win, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport);
# 113 "/usr/include/glm/ext/matrix_projection.hpp" 3 4
 template<typename T, typename U, qualifier Q>
 [[nodiscard]] vec<3, T, Q> unProjectNO(
  vec<3, T, Q> const& win, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport);
# 129 "/usr/include/glm/ext/matrix_projection.hpp" 3 4
 template<typename T, typename U, qualifier Q>
 [[nodiscard]] vec<3, T, Q> unProject(
  vec<3, T, Q> const& win, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport);
# 142 "/usr/include/glm/ext/matrix_projection.hpp" 3 4
 template<typename T, qualifier Q, typename U>
 [[nodiscard]] mat<4, 4, T, Q> pickMatrix(
  vec<2, T, Q> const& center, vec<2, T, Q> const& delta, vec<4, U, Q> const& viewport);


}

# 1 "/usr/include/glm/ext/matrix_projection.inl" 1 3 4
namespace glm
{
 template<typename T, typename U, qualifier Q>
 inline vec<3, T, Q> projectZO(vec<3, T, Q> const& obj, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport)
 {
  vec<4, T, Q> tmp = vec<4, T, Q>(obj, static_cast<T>(1));
  tmp = model * tmp;
  tmp = proj * tmp;

  tmp /= tmp.w;
  tmp.x = tmp.x * static_cast<T>(0.5) + static_cast<T>(0.5);
  tmp.y = tmp.y * static_cast<T>(0.5) + static_cast<T>(0.5);

  tmp[0] = tmp[0] * T(viewport[2]) + T(viewport[0]);
  tmp[1] = tmp[1] * T(viewport[3]) + T(viewport[1]);

  return vec<3, T, Q>(tmp);
 }

 template<typename T, typename U, qualifier Q>
 inline vec<3, T, Q> projectNO(vec<3, T, Q> const& obj, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport)
 {
  vec<4, T, Q> tmp = vec<4, T, Q>(obj, static_cast<T>(1));
  tmp = model * tmp;
  tmp = proj * tmp;

  tmp /= tmp.w;
  tmp = tmp * static_cast<T>(0.5) + static_cast<T>(0.5);
  tmp[0] = tmp[0] * T(viewport[2]) + T(viewport[0]);
  tmp[1] = tmp[1] * T(viewport[3]) + T(viewport[1]);

  return vec<3, T, Q>(tmp);
 }

 template<typename T, typename U, qualifier Q>
 inline vec<3, T, Q> project(vec<3, T, Q> const& obj, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport)
 {



   return projectNO(obj, model, proj, viewport);

 }

 template<typename T, typename U, qualifier Q>
 inline vec<3, T, Q> unProjectZO(vec<3, T, Q> const& win, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport)
 {
  mat<4, 4, T, Q> Inverse = inverse(proj * model);

  vec<4, T, Q> tmp = vec<4, T, Q>(win, T(1));
  tmp.x = (tmp.x - T(viewport[0])) / T(viewport[2]);
  tmp.y = (tmp.y - T(viewport[1])) / T(viewport[3]);
  tmp.x = tmp.x * static_cast<T>(2) - static_cast<T>(1);
  tmp.y = tmp.y * static_cast<T>(2) - static_cast<T>(1);

  vec<4, T, Q> obj = Inverse * tmp;
  obj /= obj.w;

  return vec<3, T, Q>(obj);
 }

 template<typename T, typename U, qualifier Q>
 inline vec<3, T, Q> unProjectNO(vec<3, T, Q> const& win, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport)
 {
  mat<4, 4, T, Q> Inverse = inverse(proj * model);

  vec<4, T, Q> tmp = vec<4, T, Q>(win, T(1));
  tmp.x = (tmp.x - T(viewport[0])) / T(viewport[2]);
  tmp.y = (tmp.y - T(viewport[1])) / T(viewport[3]);
  tmp = tmp * static_cast<T>(2) - static_cast<T>(1);

  vec<4, T, Q> obj = Inverse * tmp;
  obj /= obj.w;

  return vec<3, T, Q>(obj);
 }

 template<typename T, typename U, qualifier Q>
 inline vec<3, T, Q> unProject(vec<3, T, Q> const& win, mat<4, 4, T, Q> const& model, mat<4, 4, T, Q> const& proj, vec<4, U, Q> const& viewport)
 {



   return unProjectNO(win, model, proj, viewport);

 }

 template<typename T, qualifier Q, typename U>
 inline mat<4, 4, T, Q> pickMatrix(vec<2, T, Q> const& center, vec<2, T, Q> const& delta, vec<4, U, Q> const& viewport)
 {
  (static_cast <bool> (delta.x > static_cast<T>(0) && delta.y > static_cast<T>(0)) ? void (0) : __assert_fail ("delta.x > static_cast<T>(0) && delta.y > static_cast<T>(0)", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__));
  mat<4, 4, T, Q> Result(static_cast<T>(1));

  if(!(delta.x > static_cast<T>(0) && delta.y > static_cast<T>(0)))
   return Result;

  vec<3, T, Q> Temp(
   (static_cast<T>(viewport[2]) - static_cast<T>(2) * (center.x - static_cast<T>(viewport[0]))) / delta.x,
   (static_cast<T>(viewport[3]) - static_cast<T>(2) * (center.y - static_cast<T>(viewport[1]))) / delta.y,
   static_cast<T>(0));


  Result = translate(Result, Temp);
  return scale(Result, vec<3, T, Q>(static_cast<T>(viewport[2]) / delta.x, static_cast<T>(viewport[3]) / delta.y, static_cast<T>(1)));
 }
}
# 150 "/usr/include/glm/ext/matrix_projection.hpp" 2 3 4
# 29 "/usr/include/glm/gtc/matrix_transform.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_clip_space.hpp" 1 3 4
# 20 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
       
# 31 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
namespace glm
{
# 42 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> ortho(
  T left, T right, T bottom, T top);







 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> orthoLH_ZO(
  T left, T right, T bottom, T top, T zNear, T zFar);







 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> orthoLH_NO(
  T left, T right, T bottom, T top, T zNear, T zFar);







 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> orthoRH_ZO(
  T left, T right, T bottom, T top, T zNear, T zFar);







 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> orthoRH_NO(
  T left, T right, T bottom, T top, T zNear, T zFar);







 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> orthoZO(
  T left, T right, T bottom, T top, T zNear, T zFar);







 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> orthoNO(
  T left, T right, T bottom, T top, T zNear, T zFar);
# 113 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> orthoLH(
  T left, T right, T bottom, T top, T zNear, T zFar);
# 124 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> orthoRH(
  T left, T right, T bottom, T top, T zNear, T zFar);
# 135 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> ortho(
  T left, T right, T bottom, T top, T zNear, T zFar);





 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> frustumLH_ZO(
  T left, T right, T bottom, T top, T near, T far);





 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> frustumLH_NO(
  T left, T right, T bottom, T top, T near, T far);





 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> frustumRH_ZO(
  T left, T right, T bottom, T top, T near, T far);





 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> frustumRH_NO(
  T left, T right, T bottom, T top, T near, T far);





 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> frustumZO(
  T left, T right, T bottom, T top, T near, T far);





 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> frustumNO(
  T left, T right, T bottom, T top, T near, T far);






 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> frustumLH(
  T left, T right, T bottom, T top, T near, T far);






 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> frustumRH(
  T left, T right, T bottom, T top, T near, T far);






 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> frustum(
  T left, T right, T bottom, T top, T near, T far);
# 224 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveRH_ZO(
  T fovy, T aspect, T near, T far);
# 237 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveRH_NO(
  T fovy, T aspect, T near, T far);
# 250 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveLH_ZO(
  T fovy, T aspect, T near, T far);
# 263 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveLH_NO(
  T fovy, T aspect, T near, T far);
# 276 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveZO(
  T fovy, T aspect, T near, T far);
# 289 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveNO(
  T fovy, T aspect, T near, T far);
# 303 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveRH(
  T fovy, T aspect, T near, T far);
# 317 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveLH(
  T fovy, T aspect, T near, T far);
# 331 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspective(
  T fovy, T aspect, T near, T far);
# 345 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveFovRH_ZO(
  T fov, T width, T height, T near, T far);
# 359 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveFovRH_NO(
  T fov, T width, T height, T near, T far);
# 373 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveFovLH_ZO(
  T fov, T width, T height, T near, T far);
# 387 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveFovLH_NO(
  T fov, T width, T height, T near, T far);
# 401 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveFovZO(
  T fov, T width, T height, T near, T far);
# 415 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveFovNO(
  T fov, T width, T height, T near, T far);
# 430 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveFovRH(
  T fov, T width, T height, T near, T far);
# 445 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveFovLH(
  T fov, T width, T height, T near, T far);
# 459 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> perspectiveFov(
  T fov, T width, T height, T near, T far);
# 470 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> infinitePerspectiveLH(
  T fovy, T aspect, T near);
# 481 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> infinitePerspectiveRH(
  T fovy, T aspect, T near);
# 492 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> infinitePerspective(
  T fovy, T aspect, T near);
# 503 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> tweakedInfinitePerspective(
  T fovy, T aspect, T near);
# 515 "/usr/include/glm/ext/matrix_clip_space.hpp" 3 4
 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> tweakedInfinitePerspective(
  T fovy, T aspect, T near, T ep);


}

# 1 "/usr/include/glm/ext/matrix_clip_space.inl" 1 3 4
namespace glm
{
 template<typename T>
 inline mat<4, 4, T, defaultp> ortho(T left, T right, T bottom, T top)
 {
  mat<4, 4, T, defaultp> Result(static_cast<T>(1));
  Result[0][0] = static_cast<T>(2) / (right - left);
  Result[1][1] = static_cast<T>(2) / (top - bottom);
  Result[2][2] = - static_cast<T>(1);
  Result[3][0] = - (right + left) / (right - left);
  Result[3][1] = - (top + bottom) / (top - bottom);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> orthoLH_ZO(T left, T right, T bottom, T top, T zNear, T zFar)
 {
  mat<4, 4, T, defaultp> Result(1);
  Result[0][0] = static_cast<T>(2) / (right - left);
  Result[1][1] = static_cast<T>(2) / (top - bottom);
  Result[2][2] = static_cast<T>(1) / (zFar - zNear);
  Result[3][0] = - (right + left) / (right - left);
  Result[3][1] = - (top + bottom) / (top - bottom);
  Result[3][2] = - zNear / (zFar - zNear);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> orthoLH_NO(T left, T right, T bottom, T top, T zNear, T zFar)
 {
  mat<4, 4, T, defaultp> Result(1);
  Result[0][0] = static_cast<T>(2) / (right - left);
  Result[1][1] = static_cast<T>(2) / (top - bottom);
  Result[2][2] = static_cast<T>(2) / (zFar - zNear);
  Result[3][0] = - (right + left) / (right - left);
  Result[3][1] = - (top + bottom) / (top - bottom);
  Result[3][2] = - (zFar + zNear) / (zFar - zNear);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> orthoRH_ZO(T left, T right, T bottom, T top, T zNear, T zFar)
 {
  mat<4, 4, T, defaultp> Result(1);
  Result[0][0] = static_cast<T>(2) / (right - left);
  Result[1][1] = static_cast<T>(2) / (top - bottom);
  Result[2][2] = - static_cast<T>(1) / (zFar - zNear);
  Result[3][0] = - (right + left) / (right - left);
  Result[3][1] = - (top + bottom) / (top - bottom);
  Result[3][2] = - zNear / (zFar - zNear);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> orthoRH_NO(T left, T right, T bottom, T top, T zNear, T zFar)
 {
  mat<4, 4, T, defaultp> Result(1);
  Result[0][0] = static_cast<T>(2) / (right - left);
  Result[1][1] = static_cast<T>(2) / (top - bottom);
  Result[2][2] = - static_cast<T>(2) / (zFar - zNear);
  Result[3][0] = - (right + left) / (right - left);
  Result[3][1] = - (top + bottom) / (top - bottom);
  Result[3][2] = - (zFar + zNear) / (zFar - zNear);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> orthoZO(T left, T right, T bottom, T top, T zNear, T zFar)
 {



   return orthoRH_ZO(left, right, bottom, top, zNear, zFar);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> orthoNO(T left, T right, T bottom, T top, T zNear, T zFar)
 {



   return orthoRH_NO(left, right, bottom, top, zNear, zFar);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> orthoLH(T left, T right, T bottom, T top, T zNear, T zFar)
 {



   return orthoLH_NO(left, right, bottom, top, zNear, zFar);


 }

 template<typename T>
 inline mat<4, 4, T, defaultp> orthoRH(T left, T right, T bottom, T top, T zNear, T zFar)
 {



   return orthoRH_NO(left, right, bottom, top, zNear, zFar);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> ortho(T left, T right, T bottom, T top, T zNear, T zFar)
 {







   return orthoRH_NO(left, right, bottom, top, zNear, zFar);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> frustumLH_ZO(T left, T right, T bottom, T top, T nearVal, T farVal)
 {
  mat<4, 4, T, defaultp> Result(0);
  Result[0][0] = (static_cast<T>(2) * nearVal) / (right - left);
  Result[1][1] = (static_cast<T>(2) * nearVal) / (top - bottom);
  Result[2][0] = -(right + left) / (right - left);
  Result[2][1] = -(top + bottom) / (top - bottom);
  Result[2][2] = farVal / (farVal - nearVal);
  Result[2][3] = static_cast<T>(1);
  Result[3][2] = -(farVal * nearVal) / (farVal - nearVal);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> frustumLH_NO(T left, T right, T bottom, T top, T nearVal, T farVal)
 {
  mat<4, 4, T, defaultp> Result(0);
  Result[0][0] = (static_cast<T>(2) * nearVal) / (right - left);
  Result[1][1] = (static_cast<T>(2) * nearVal) / (top - bottom);
  Result[2][0] = -(right + left) / (right - left);
  Result[2][1] = -(top + bottom) / (top - bottom);
  Result[2][2] = (farVal + nearVal) / (farVal - nearVal);
  Result[2][3] = static_cast<T>(1);
  Result[3][2] = - (static_cast<T>(2) * farVal * nearVal) / (farVal - nearVal);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> frustumRH_ZO(T left, T right, T bottom, T top, T nearVal, T farVal)
 {
  mat<4, 4, T, defaultp> Result(0);
  Result[0][0] = (static_cast<T>(2) * nearVal) / (right - left);
  Result[1][1] = (static_cast<T>(2) * nearVal) / (top - bottom);
  Result[2][0] = (right + left) / (right - left);
  Result[2][1] = (top + bottom) / (top - bottom);
  Result[2][2] = farVal / (nearVal - farVal);
  Result[2][3] = static_cast<T>(-1);
  Result[3][2] = -(farVal * nearVal) / (farVal - nearVal);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> frustumRH_NO(T left, T right, T bottom, T top, T nearVal, T farVal)
 {
  mat<4, 4, T, defaultp> Result(0);
  Result[0][0] = (static_cast<T>(2) * nearVal) / (right - left);
  Result[1][1] = (static_cast<T>(2) * nearVal) / (top - bottom);
  Result[2][0] = (right + left) / (right - left);
  Result[2][1] = (top + bottom) / (top - bottom);
  Result[2][2] = - (farVal + nearVal) / (farVal - nearVal);
  Result[2][3] = static_cast<T>(-1);
  Result[3][2] = - (static_cast<T>(2) * farVal * nearVal) / (farVal - nearVal);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> frustumZO(T left, T right, T bottom, T top, T nearVal, T farVal)
 {



   return frustumRH_ZO(left, right, bottom, top, nearVal, farVal);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> frustumNO(T left, T right, T bottom, T top, T nearVal, T farVal)
 {



   return frustumRH_NO(left, right, bottom, top, nearVal, farVal);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> frustumLH(T left, T right, T bottom, T top, T nearVal, T farVal)
 {



   return frustumLH_NO(left, right, bottom, top, nearVal, farVal);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> frustumRH(T left, T right, T bottom, T top, T nearVal, T farVal)
 {



   return frustumRH_NO(left, right, bottom, top, nearVal, farVal);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> frustum(T left, T right, T bottom, T top, T nearVal, T farVal)
 {







   return frustumRH_NO(left, right, bottom, top, nearVal, farVal);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveRH_ZO(T fovy, T aspect, T zNear, T zFar)
 {
  (static_cast <bool> (abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0)) ? void (0) : __assert_fail ("abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0)", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__));

  T const tanHalfFovy = tan(fovy / static_cast<T>(2));

  mat<4, 4, T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = static_cast<T>(1) / (aspect * tanHalfFovy);
  Result[1][1] = static_cast<T>(1) / (tanHalfFovy);
  Result[2][2] = zFar / (zNear - zFar);
  Result[2][3] = - static_cast<T>(1);
  Result[3][2] = -(zFar * zNear) / (zFar - zNear);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveRH_NO(T fovy, T aspect, T zNear, T zFar)
 {
  (static_cast <bool> (abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0)) ? void (0) : __assert_fail ("abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0)", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__));

  T const tanHalfFovy = tan(fovy / static_cast<T>(2));

  mat<4, 4, T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = static_cast<T>(1) / (aspect * tanHalfFovy);
  Result[1][1] = static_cast<T>(1) / (tanHalfFovy);
  Result[2][2] = - (zFar + zNear) / (zFar - zNear);
  Result[2][3] = - static_cast<T>(1);
  Result[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveLH_ZO(T fovy, T aspect, T zNear, T zFar)
 {
  (static_cast <bool> (abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0)) ? void (0) : __assert_fail ("abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0)", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__));

  T const tanHalfFovy = tan(fovy / static_cast<T>(2));

  mat<4, 4, T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = static_cast<T>(1) / (aspect * tanHalfFovy);
  Result[1][1] = static_cast<T>(1) / (tanHalfFovy);
  Result[2][2] = zFar / (zFar - zNear);
  Result[2][3] = static_cast<T>(1);
  Result[3][2] = -(zFar * zNear) / (zFar - zNear);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveLH_NO(T fovy, T aspect, T zNear, T zFar)
 {
  (static_cast <bool> (abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0)) ? void (0) : __assert_fail ("abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0)", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__));

  T const tanHalfFovy = tan(fovy / static_cast<T>(2));

  mat<4, 4, T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = static_cast<T>(1) / (aspect * tanHalfFovy);
  Result[1][1] = static_cast<T>(1) / (tanHalfFovy);
  Result[2][2] = (zFar + zNear) / (zFar - zNear);
  Result[2][3] = static_cast<T>(1);
  Result[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveZO(T fovy, T aspect, T zNear, T zFar)
 {



   return perspectiveRH_ZO(fovy, aspect, zNear, zFar);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveNO(T fovy, T aspect, T zNear, T zFar)
 {



   return perspectiveRH_NO(fovy, aspect, zNear, zFar);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveLH(T fovy, T aspect, T zNear, T zFar)
 {



   return perspectiveLH_NO(fovy, aspect, zNear, zFar);


 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveRH(T fovy, T aspect, T zNear, T zFar)
 {



   return perspectiveRH_NO(fovy, aspect, zNear, zFar);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspective(T fovy, T aspect, T zNear, T zFar)
 {







   return perspectiveRH_NO(fovy, aspect, zNear, zFar);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveFovRH_ZO(T fov, T width, T height, T zNear, T zFar)
 {
  (static_cast <bool> (width > static_cast<T>(0)) ? void (0) : __assert_fail ("width > static_cast<T>(0)", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__));
  (static_cast <bool> (height > static_cast<T>(0)) ? void (0) : __assert_fail ("height > static_cast<T>(0)", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__));
  (static_cast <bool> (fov > static_cast<T>(0)) ? void (0) : __assert_fail ("fov > static_cast<T>(0)", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__));

  T const rad = fov;
  T const h = glm::cos(static_cast<T>(0.5) * rad) / glm::sin(static_cast<T>(0.5) * rad);
  T const w = h * height / width;

  mat<4, 4, T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = w;
  Result[1][1] = h;
  Result[2][2] = zFar / (zNear - zFar);
  Result[2][3] = - static_cast<T>(1);
  Result[3][2] = -(zFar * zNear) / (zFar - zNear);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveFovRH_NO(T fov, T width, T height, T zNear, T zFar)
 {
  (static_cast <bool> (width > static_cast<T>(0)) ? void (0) : __assert_fail ("width > static_cast<T>(0)", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__));
  (static_cast <bool> (height > static_cast<T>(0)) ? void (0) : __assert_fail ("height > static_cast<T>(0)", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__));
  (static_cast <bool> (fov > static_cast<T>(0)) ? void (0) : __assert_fail ("fov > static_cast<T>(0)", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__));

  T const rad = fov;
  T const h = glm::cos(static_cast<T>(0.5) * rad) / glm::sin(static_cast<T>(0.5) * rad);
  T const w = h * height / width;

  mat<4, 4, T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = w;
  Result[1][1] = h;
  Result[2][2] = - (zFar + zNear) / (zFar - zNear);
  Result[2][3] = - static_cast<T>(1);
  Result[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveFovLH_ZO(T fov, T width, T height, T zNear, T zFar)
 {
  (static_cast <bool> (width > static_cast<T>(0)) ? void (0) : __assert_fail ("width > static_cast<T>(0)", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__));
  (static_cast <bool> (height > static_cast<T>(0)) ? void (0) : __assert_fail ("height > static_cast<T>(0)", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__));
  (static_cast <bool> (fov > static_cast<T>(0)) ? void (0) : __assert_fail ("fov > static_cast<T>(0)", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__));

  T const rad = fov;
  T const h = glm::cos(static_cast<T>(0.5) * rad) / glm::sin(static_cast<T>(0.5) * rad);
  T const w = h * height / width;

  mat<4, 4, T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = w;
  Result[1][1] = h;
  Result[2][2] = zFar / (zFar - zNear);
  Result[2][3] = static_cast<T>(1);
  Result[3][2] = -(zFar * zNear) / (zFar - zNear);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveFovLH_NO(T fov, T width, T height, T zNear, T zFar)
 {
  (static_cast <bool> (width > static_cast<T>(0)) ? void (0) : __assert_fail ("width > static_cast<T>(0)", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__));
  (static_cast <bool> (height > static_cast<T>(0)) ? void (0) : __assert_fail ("height > static_cast<T>(0)", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__));
  (static_cast <bool> (fov > static_cast<T>(0)) ? void (0) : __assert_fail ("fov > static_cast<T>(0)", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__));

  T const rad = fov;
  T const h = glm::cos(static_cast<T>(0.5) * rad) / glm::sin(static_cast<T>(0.5) * rad);
  T const w = h * height / width;

  mat<4, 4, T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = w;
  Result[1][1] = h;
  Result[2][2] = (zFar + zNear) / (zFar - zNear);
  Result[2][3] = static_cast<T>(1);
  Result[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveFovZO(T fov, T width, T height, T zNear, T zFar)
 {



   return perspectiveFovRH_ZO(fov, width, height, zNear, zFar);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveFovNO(T fov, T width, T height, T zNear, T zFar)
 {



   return perspectiveFovRH_NO(fov, width, height, zNear, zFar);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveFovLH(T fov, T width, T height, T zNear, T zFar)
 {



   return perspectiveFovLH_NO(fov, width, height, zNear, zFar);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveFovRH(T fov, T width, T height, T zNear, T zFar)
 {



   return perspectiveFovRH_NO(fov, width, height, zNear, zFar);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> perspectiveFov(T fov, T width, T height, T zNear, T zFar)
 {







   return perspectiveFovRH_NO(fov, width, height, zNear, zFar);

 }

 template<typename T>
 inline mat<4, 4, T, defaultp> infinitePerspectiveRH_NO(T fovy, T aspect, T zNear)
 {
  T const range = tan(fovy / static_cast<T>(2)) * zNear;
  T const left = -range * aspect;
  T const right = range * aspect;
  T const bottom = -range;
  T const top = range;

  mat<4, 4, T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = (static_cast<T>(2) * zNear) / (right - left);
  Result[1][1] = (static_cast<T>(2) * zNear) / (top - bottom);
  Result[2][2] = - static_cast<T>(1);
  Result[2][3] = - static_cast<T>(1);
  Result[3][2] = - static_cast<T>(2) * zNear;
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> infinitePerspectiveRH_ZO(T fovy, T aspect, T zNear)
 {
  T const range = tan(fovy / static_cast<T>(2)) * zNear;
  T const left = -range * aspect;
  T const right = range * aspect;
  T const bottom = -range;
  T const top = range;

  mat<4, 4, T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = (static_cast<T>(2) * zNear) / (right - left);
  Result[1][1] = (static_cast<T>(2) * zNear) / (top - bottom);
  Result[2][2] = - static_cast<T>(1);
  Result[2][3] = - static_cast<T>(1);
  Result[3][2] = - zNear;
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> infinitePerspectiveLH_NO(T fovy, T aspect, T zNear)
 {
  T const range = tan(fovy / static_cast<T>(2)) * zNear;
  T const left = -range * aspect;
  T const right = range * aspect;
  T const bottom = -range;
  T const top = range;

  mat<4, 4, T, defaultp> Result(T(0));
  Result[0][0] = (static_cast<T>(2) * zNear) / (right - left);
  Result[1][1] = (static_cast<T>(2) * zNear) / (top - bottom);
  Result[2][2] = static_cast<T>(1);
  Result[2][3] = static_cast<T>(1);
  Result[3][2] = - static_cast<T>(2) * zNear;
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> infinitePerspectiveLH_ZO(T fovy, T aspect, T zNear)
 {
  T const range = tan(fovy / static_cast<T>(2)) * zNear;
  T const left = -range * aspect;
  T const right = range * aspect;
  T const bottom = -range;
  T const top = range;

  mat<4, 4, T, defaultp> Result(T(0));
  Result[0][0] = (static_cast<T>(2) * zNear) / (right - left);
  Result[1][1] = (static_cast<T>(2) * zNear) / (top - bottom);
  Result[2][2] = static_cast<T>(1);
  Result[2][3] = static_cast<T>(1);
  Result[3][2] = - zNear;
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> infinitePerspective(T fovy, T aspect, T zNear)
 {







   return infinitePerspectiveRH_NO(fovy, aspect, zNear);

 }


 template<typename T>
 inline mat<4, 4, T, defaultp> tweakedInfinitePerspective(T fovy, T aspect, T zNear, T ep)
 {
  T const range = tan(fovy / static_cast<T>(2)) * zNear;
  T const left = -range * aspect;
  T const right = range * aspect;
  T const bottom = -range;
  T const top = range;

  mat<4, 4, T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = (static_cast<T>(2) * zNear) / (right - left);
  Result[1][1] = (static_cast<T>(2) * zNear) / (top - bottom);
  Result[2][2] = ep - static_cast<T>(1);
  Result[2][3] = static_cast<T>(-1);
  Result[3][2] = (ep - static_cast<T>(2)) * zNear;
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> tweakedInfinitePerspective(T fovy, T aspect, T zNear)
 {
  return tweakedInfinitePerspective(fovy, aspect, zNear, epsilon<T>());
 }
}
# 523 "/usr/include/glm/ext/matrix_clip_space.hpp" 2 3 4
# 30 "/usr/include/glm/gtc/matrix_transform.hpp" 2 3 4
# 1 "/usr/include/glm/ext/matrix_transform.hpp" 1 3 4
# 20 "/usr/include/glm/ext/matrix_transform.hpp" 3 4
       
# 32 "/usr/include/glm/ext/matrix_transform.hpp" 3 4
namespace glm
{




 template<typename genType>
 [[nodiscard]] constexpr genType identity();
# 63 "/usr/include/glm/ext/matrix_transform.hpp" 3 4
 template<typename T, qualifier Q>
 [[nodiscard]] constexpr mat<4, 4, T, Q> translate(
  mat<4, 4, T, Q> const& m, vec<3, T, Q> const& v);
# 79 "/usr/include/glm/ext/matrix_transform.hpp" 3 4
 template<typename T, qualifier Q>
 [[nodiscard]] mat<4, 4, T, Q> rotate(
  mat<4, 4, T, Q> const& m, T angle, vec<3, T, Q> const& axis);
# 94 "/usr/include/glm/ext/matrix_transform.hpp" 3 4
 template<typename T, qualifier Q>
 [[nodiscard]] mat<4, 4, T, Q> scale(
  mat<4, 4, T, Q> const& m, vec<3, T, Q> const& v);
# 121 "/usr/include/glm/ext/matrix_transform.hpp" 3 4
    template <typename T, qualifier Q>
    inline mat<4, 4, T, Q> shear(
        mat<4, 4, T, Q> const &m, vec<3, T, Q> const& p, vec<2, T, Q> const &l_x, vec<2, T, Q> const &l_y, vec<2, T, Q> const &l_z);
# 135 "/usr/include/glm/ext/matrix_transform.hpp" 3 4
 template<typename T, qualifier Q>
 [[nodiscard]] mat<4, 4, T, Q> lookAtRH(
  vec<3, T, Q> const& eye, vec<3, T, Q> const& center, vec<3, T, Q> const& up);
# 149 "/usr/include/glm/ext/matrix_transform.hpp" 3 4
 template<typename T, qualifier Q>
 [[nodiscard]] mat<4, 4, T, Q> lookAtLH(
  vec<3, T, Q> const& eye, vec<3, T, Q> const& center, vec<3, T, Q> const& up);
# 164 "/usr/include/glm/ext/matrix_transform.hpp" 3 4
 template<typename T, qualifier Q>
 [[nodiscard]] mat<4, 4, T, Q> lookAt(
  vec<3, T, Q> const& eye, vec<3, T, Q> const& center, vec<3, T, Q> const& up);


}

# 1 "/usr/include/glm/ext/matrix_transform.inl" 1 3 4
namespace glm
{
 template<typename genType>
 inline constexpr genType identity()
 {
  return detail::init_gentype<genType, detail::genTypeTrait<genType>::GENTYPE>::identity();
 }

 template<typename T, qualifier Q>
 inline constexpr mat<4, 4, T, Q> translate(mat<4, 4, T, Q> const& m, vec<3, T, Q> const& v)
 {
  mat<4, 4, T, Q> Result(m);
  Result[3] = m[0] * v[0] + m[1] * v[1] + m[2] * v[2] + m[3];
  return Result;
 }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q> rotate(mat<4, 4, T, Q> const& m, T angle, vec<3, T, Q> const& v)
 {
  T const a = angle;
  T const c = cos(a);
  T const s = sin(a);

  vec<3, T, Q> axis(normalize(v));
  vec<3, T, Q> temp((T(1) - c) * axis);

  mat<4, 4, T, Q> Rotate;
  Rotate[0][0] = c + temp[0] * axis[0];
  Rotate[0][1] = temp[0] * axis[1] + s * axis[2];
  Rotate[0][2] = temp[0] * axis[2] - s * axis[1];

  Rotate[1][0] = temp[1] * axis[0] - s * axis[2];
  Rotate[1][1] = c + temp[1] * axis[1];
  Rotate[1][2] = temp[1] * axis[2] + s * axis[0];

  Rotate[2][0] = temp[2] * axis[0] + s * axis[1];
  Rotate[2][1] = temp[2] * axis[1] - s * axis[0];
  Rotate[2][2] = c + temp[2] * axis[2];

  mat<4, 4, T, Q> Result;
  Result[0] = m[0] * Rotate[0][0] + m[1] * Rotate[0][1] + m[2] * Rotate[0][2];
  Result[1] = m[0] * Rotate[1][0] + m[1] * Rotate[1][1] + m[2] * Rotate[1][2];
  Result[2] = m[0] * Rotate[2][0] + m[1] * Rotate[2][1] + m[2] * Rotate[2][2];
  Result[3] = m[3];
  return Result;
 }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q> rotate_slow(mat<4, 4, T, Q> const& m, T angle, vec<3, T, Q> const& v)
 {
  T const a = angle;
  T const c = cos(a);
  T const s = sin(a);
  mat<4, 4, T, Q> Result;

  vec<3, T, Q> axis = normalize(v);

  Result[0][0] = c + (static_cast<T>(1) - c) * axis.x * axis.x;
  Result[0][1] = (static_cast<T>(1) - c) * axis.x * axis.y + s * axis.z;
  Result[0][2] = (static_cast<T>(1) - c) * axis.x * axis.z - s * axis.y;
  Result[0][3] = static_cast<T>(0);

  Result[1][0] = (static_cast<T>(1) - c) * axis.y * axis.x - s * axis.z;
  Result[1][1] = c + (static_cast<T>(1) - c) * axis.y * axis.y;
  Result[1][2] = (static_cast<T>(1) - c) * axis.y * axis.z + s * axis.x;
  Result[1][3] = static_cast<T>(0);

  Result[2][0] = (static_cast<T>(1) - c) * axis.z * axis.x + s * axis.y;
  Result[2][1] = (static_cast<T>(1) - c) * axis.z * axis.y - s * axis.x;
  Result[2][2] = c + (static_cast<T>(1) - c) * axis.z * axis.z;
  Result[2][3] = static_cast<T>(0);

  Result[3] = vec<4, T, Q>(0, 0, 0, 1);
  return m * Result;
 }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q> scale(mat<4, 4, T, Q> const& m, vec<3, T, Q> const& v)
 {
  mat<4, 4, T, Q> Result;
  Result[0] = m[0] * v[0];
  Result[1] = m[1] * v[1];
  Result[2] = m[2] * v[2];
  Result[3] = m[3];
  return Result;
 }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q> scale_slow(mat<4, 4, T, Q> const& m, vec<3, T, Q> const& v)
 {
  mat<4, 4, T, Q> Result(T(1));
  Result[0][0] = v.x;
  Result[1][1] = v.y;
  Result[2][2] = v.z;
  return m * Result;
 }

    template <typename T, qualifier Q>
    inline mat<4, 4, T, Q> shear(mat<4, 4, T, Q> const &m, vec<3, T, Q> const& p, vec<2, T, Q> const &l_x, vec<2, T, Q> const &l_y, vec<2, T, Q> const &l_z)
    {
        T const lambda_xy = l_x[0];
        T const lambda_xz = l_x[1];
        T const lambda_yx = l_y[0];
        T const lambda_yz = l_y[1];
        T const lambda_zx = l_z[0];
        T const lambda_zy = l_z[1];

        vec<3, T, Q> point_lambda = vec<3, T, Q>(
            (lambda_xy + lambda_xz), (lambda_yx + lambda_yz), (lambda_zx + lambda_zy)
        );

        mat<4, 4, T, Q> Shear = mat<4, 4, T, Q>(
            1 , lambda_yx , lambda_zx , 0,
            lambda_xy , 1 , lambda_zy , 0,
            lambda_xz , lambda_yz , 1 , 0,
            -point_lambda[0] * p[0], -point_lambda[1] * p[1], -point_lambda[2] * p[2], 1
        );

        mat<4, 4, T, Q> Result;
  Result[0] = m[0] * Shear[0][0] + m[1] * Shear[0][1] + m[2] * Shear[0][2] + m[3] * Shear[0][3];
  Result[1] = m[0] * Shear[1][0] + m[1] * Shear[1][1] + m[2] * Shear[1][2] + m[3] * Shear[1][3];
  Result[2] = m[0] * Shear[2][0] + m[1] * Shear[2][1] + m[2] * Shear[2][2] + m[3] * Shear[2][3];
  Result[3] = m[0] * Shear[3][0] + m[1] * Shear[3][1] + m[2] * Shear[3][2] + m[3] * Shear[3][3];
        return Result;
    }

    template <typename T, qualifier Q>
    inline mat<4, 4, T, Q> shear_slow(mat<4, 4, T, Q> const &m, vec<3, T, Q> const& p, vec<2, T, Q> const &l_x, vec<2, T, Q> const &l_y, vec<2, T, Q> const &l_z)
    {
        T const lambda_xy = static_cast<T>(l_x[0]);
        T const lambda_xz = static_cast<T>(l_x[1]);
        T const lambda_yx = static_cast<T>(l_y[0]);
        T const lambda_yz = static_cast<T>(l_y[1]);
        T const lambda_zx = static_cast<T>(l_z[0]);
        T const lambda_zy = static_cast<T>(l_z[1]);

        vec<3, T, Q> point_lambda = vec<3, T, Q>(
            static_cast<T>(lambda_xy + lambda_xz),
            static_cast<T>(lambda_yx + lambda_yz),
            static_cast<T>(lambda_zx + lambda_zy)
        );

        mat<4, 4, T, Q> Shear = mat<4, 4, T, Q>(
            1 , lambda_yx , lambda_zx , 0,
            lambda_xy , 1 , lambda_zy , 0,
            lambda_xz , lambda_yz , 1 , 0,
            -point_lambda[0] * p[0], -point_lambda[1] * p[1], -point_lambda[2] * p[2], 1
        );
        return m * Shear;
    }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q> lookAtRH(vec<3, T, Q> const& eye, vec<3, T, Q> const& center, vec<3, T, Q> const& up)
 {
  vec<3, T, Q> const f(normalize(center - eye));
  vec<3, T, Q> const s(normalize(cross(f, up)));
  vec<3, T, Q> const u(cross(s, f));

  mat<4, 4, T, Q> Result(1);
  Result[0][0] = s.x;
  Result[1][0] = s.y;
  Result[2][0] = s.z;
  Result[0][1] = u.x;
  Result[1][1] = u.y;
  Result[2][1] = u.z;
  Result[0][2] =-f.x;
  Result[1][2] =-f.y;
  Result[2][2] =-f.z;
  Result[3][0] =-dot(s, eye);
  Result[3][1] =-dot(u, eye);
  Result[3][2] = dot(f, eye);
  return Result;
 }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q> lookAtLH(vec<3, T, Q> const& eye, vec<3, T, Q> const& center, vec<3, T, Q> const& up)
 {
  vec<3, T, Q> const f(normalize(center - eye));
  vec<3, T, Q> const s(normalize(cross(up, f)));
  vec<3, T, Q> const u(cross(f, s));

  mat<4, 4, T, Q> Result(1);
  Result[0][0] = s.x;
  Result[1][0] = s.y;
  Result[2][0] = s.z;
  Result[0][1] = u.x;
  Result[1][1] = u.y;
  Result[2][1] = u.z;
  Result[0][2] = f.x;
  Result[1][2] = f.y;
  Result[2][2] = f.z;
  Result[3][0] = -dot(s, eye);
  Result[3][1] = -dot(u, eye);
  Result[3][2] = -dot(f, eye);
  return Result;
 }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q> lookAt(vec<3, T, Q> const& eye, vec<3, T, Q> const& center, vec<3, T, Q> const& up)
 {



            return lookAtRH(eye, center, up);

 }
}
# 172 "/usr/include/glm/ext/matrix_transform.hpp" 2 3 4
# 31 "/usr/include/glm/gtc/matrix_transform.hpp" 2 3 4





# 1 "/usr/include/glm/gtc/matrix_transform.inl" 1 3 4
# 37 "/usr/include/glm/gtc/matrix_transform.hpp" 2 3 4
# 5 "/home/devkon/CLionProjects/VertexLab/main.cpp" 2
# 1 "/usr/include/glm/gtc/type_ptr.hpp" 1 3 4
# 34 "/usr/include/glm/gtc/type_ptr.hpp" 3 4
       


# 1 "/usr/include/glm/gtc/quaternion.hpp" 1 3 4
# 14 "/usr/include/glm/gtc/quaternion.hpp" 3 4
       




# 1 "/usr/include/glm/ext/vector_relational.hpp" 1 3 4
# 18 "/usr/include/glm/ext/vector_relational.hpp" 3 4
       
# 27 "/usr/include/glm/ext/vector_relational.hpp" 3 4
namespace glm
{
# 38 "/usr/include/glm/ext/vector_relational.hpp" 3 4
 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y, T epsilon);







 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, T, Q> const& epsilon);







 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, T epsilon);







 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, T, Q> const& epsilon);







 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y, int ULPs);







 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, int, Q> const& ULPs);







 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, int ULPs);







 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, int, Q> const& ULPs);


}

# 1 "/usr/include/glm/ext/vector_relational.inl" 1 3 4



# 1 "/usr/include/glm/detail/type_float.hpp" 1 3 4
       

# 1 "/usr/include/glm/detail/setup.hpp" 1 3 4
# 4 "/usr/include/glm/detail/type_float.hpp" 2 3 4






namespace glm{
namespace detail
{
 template <typename T>
 union float_t
 {};


 template <>
 union float_t<float>
 {
  typedef int int_type;
  typedef float float_type;

  constexpr float_t(float_type Num = 0.0f) : f(Num) {}

  constexpr float_t& operator=(float_t const& x)
  {
   f = x.f;
   return *this;
  }


  constexpr bool negative() const { return i < 0; }
  constexpr int_type mantissa() const { return i & ((1 << 23) - 1); }
  constexpr int_type exponent() const { return (i >> 23) & ((1 << 8) - 1); }

  int_type i;
  float_type f;
 };

 template <>
 union float_t<double>
 {
  typedef detail::int64 int_type;
  typedef double float_type;

  constexpr float_t(float_type Num = static_cast<float_type>(0)) : f(Num) {}

  constexpr float_t& operator=(float_t const& x)
  {
   f = x.f;
   return *this;
  }


  constexpr bool negative() const { return i < 0; }
  constexpr int_type mantissa() const { return i & ((int_type(1) << 52) - 1); }
  constexpr int_type exponent() const { return (i >> 52) & ((int_type(1) << 11) - 1); }

  int_type i;
  float_type f;
 };
}
}
# 5 "/usr/include/glm/ext/vector_relational.inl" 2 3 4

namespace glm
{
 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y, T Epsilon)
 {
  return equal(x, y, vec<L, T, Q>(Epsilon));
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, T, Q> const& Epsilon)
 {
  return lessThanEqual(abs(x - y), Epsilon);
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, T Epsilon)
 {
  return notEqual(x, y, vec<L, T, Q>(Epsilon));
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, T, Q> const& Epsilon)
 {
  return greaterThan(abs(x - y), Epsilon);
 }


 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y, int MaxULPs)
 {
  return equal(x, y, vec<L, int, Q>(MaxULPs));
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, bool, Q> equal(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, int, Q> const& MaxULPs)
 {
  vec<L, bool, Q> Result(false);
  for(length_t i = 0; i < L; ++i)
  {
   detail::float_t<T> const a(x[i]);
   detail::float_t<T> const b(y[i]);


   if(a.negative() != b.negative())
   {

    Result[i] = a.mantissa() == b.mantissa() && a.exponent() == b.exponent();
   }
   else
   {

    typename detail::float_t<T>::int_type const DiffULPs = abs(a.i - b.i);
    Result[i] = DiffULPs <= MaxULPs[i];
   }
  }
  return Result;
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, int MaxULPs)
 {
  return notEqual(x, y, vec<L, int, Q>(MaxULPs));
 }

 template<length_t L, typename T, qualifier Q>
 inline constexpr vec<L, bool, Q> notEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, int, Q> const& MaxULPs)
 {
  return not_(equal(x, y, MaxULPs));
 }
}
# 108 "/usr/include/glm/ext/vector_relational.hpp" 2 3 4
# 20 "/usr/include/glm/gtc/quaternion.hpp" 2 3 4
# 1 "/usr/include/glm/ext/quaternion_common.hpp" 1 3 4
# 21 "/usr/include/glm/ext/quaternion_common.hpp" 3 4
       



# 1 "/usr/include/glm/ext/quaternion_geometric.hpp" 1 3 4
# 15 "/usr/include/glm/ext/quaternion_geometric.hpp" 3 4
       
# 26 "/usr/include/glm/ext/quaternion_geometric.hpp" 3 4
namespace glm
{
# 37 "/usr/include/glm/ext/quaternion_geometric.hpp" 3 4
 template<typename T, qualifier Q>
 [[nodiscard]] T length(qua<T, Q> const& q);







 template<typename T, qualifier Q>
 [[nodiscard]] qua<T, Q> normalize(qua<T, Q> const& q);







 template<typename T, qualifier Q>
 [[nodiscard]] constexpr T dot(qua<T, Q> const& x, qua<T, Q> const& y);







 template<typename T, qualifier Q>
 inline constexpr qua<T, Q> cross(qua<T, Q> const& q1, qua<T, Q> const& q2);


}

# 1 "/usr/include/glm/ext/quaternion_geometric.inl" 1 3 4
namespace glm
{
 template<typename T, qualifier Q>
 inline constexpr T dot(qua<T, Q> const& x, qua<T, Q> const& y)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'dot' accepts only floating-point inputs");
  return detail::compute_dot<qua<T, Q>, T, detail::is_aligned<Q>::value>::call(x, y);
 }

 template<typename T, qualifier Q>
 inline T length(qua<T, Q> const& q)
 {
  return glm::sqrt(dot(q, q));
 }

 template<typename T, qualifier Q>
 inline qua<T, Q> normalize(qua<T, Q> const& q)
 {
  T len = length(q);
  if(len <= static_cast<T>(0))
   return qua<T, Q>::wxyz(static_cast<T>(1), static_cast<T>(0), static_cast<T>(0), static_cast<T>(0));
  T oneOverLen = static_cast<T>(1) / len;
  return qua<T, Q>::wxyz(q.w * oneOverLen, q.x * oneOverLen, q.y * oneOverLen, q.z * oneOverLen);
 }

 template<typename T, qualifier Q>
 inline constexpr qua<T, Q> cross(qua<T, Q> const& q1, qua<T, Q> const& q2)
 {
  return qua<T, Q>::wxyz(
   q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z,
   q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,
   q1.w * q2.y + q1.y * q2.w + q1.z * q2.x - q1.x * q2.z,
   q1.w * q2.z + q1.z * q2.w + q1.x * q2.y - q1.y * q2.x);
 }
}
# 71 "/usr/include/glm/ext/quaternion_geometric.hpp" 2 3 4
# 26 "/usr/include/glm/ext/quaternion_common.hpp" 2 3 4
# 35 "/usr/include/glm/ext/quaternion_common.hpp" 3 4
namespace glm
{
# 52 "/usr/include/glm/ext/quaternion_common.hpp" 3 4
 template<typename T, qualifier Q>
 [[nodiscard]] qua<T, Q> mix(qua<T, Q> const& x, qua<T, Q> const& y, T a);
# 64 "/usr/include/glm/ext/quaternion_common.hpp" 3 4
 template<typename T, qualifier Q>
 [[nodiscard]] constexpr qua<T, Q> lerp(qua<T, Q> const& x, qua<T, Q> const& y, T a);
# 76 "/usr/include/glm/ext/quaternion_common.hpp" 3 4
 template<typename T, qualifier Q>
 [[nodiscard]] qua<T, Q> slerp(qua<T, Q> const& x, qua<T, Q> const& y, T a);
# 91 "/usr/include/glm/ext/quaternion_common.hpp" 3 4
    template<typename T, typename S, qualifier Q>
    [[nodiscard]] qua<T, Q> slerp(qua<T, Q> const& x, qua<T, Q> const& y, T a, S k);





 template<typename T, qualifier Q>
 [[nodiscard]] constexpr qua<T, Q> conjugate(qua<T, Q> const& q);





 template<typename T, qualifier Q>
 [[nodiscard]] constexpr qua<T, Q> inverse(qua<T, Q> const& q);
# 118 "/usr/include/glm/ext/quaternion_common.hpp" 3 4
 template<typename T, qualifier Q>
 [[nodiscard]] vec<4, bool, Q> isnan(qua<T, Q> const& x);
# 129 "/usr/include/glm/ext/quaternion_common.hpp" 3 4
 template<typename T, qualifier Q>
 [[nodiscard]] vec<4, bool, Q> isinf(qua<T, Q> const& x);


}

# 1 "/usr/include/glm/ext/quaternion_common.inl" 1 3 4
namespace glm
{
 template<typename T, qualifier Q>
 inline qua<T, Q> mix(qua<T, Q> const& x, qua<T, Q> const& y, T a)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'mix' only accept floating-point inputs");

  T const cosTheta = dot(x, y);


  if(cosTheta > static_cast<T>(1) - epsilon<T>())
  {

   return qua<T, Q>::wxyz(
    mix(x.w, y.w, a),
    mix(x.x, y.x, a),
    mix(x.y, y.y, a),
    mix(x.z, y.z, a));
  }
  else
  {

   T angle = acos(cosTheta);
   return (sin((static_cast<T>(1) - a) * angle) * x + sin(a * angle) * y) / sin(angle);
  }
 }

 template<typename T, qualifier Q>
 inline constexpr qua<T, Q> lerp(qua<T, Q> const& x, qua<T, Q> const& y, T a)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'lerp' only accept floating-point inputs");


  (static_cast <bool> (a >= static_cast<T>(0)) ? void (0) : __assert_fail ("a >= static_cast<T>(0)", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__));
  (static_cast <bool> (a <= static_cast<T>(1)) ? void (0) : __assert_fail ("a <= static_cast<T>(1)", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__));

  return x * (static_cast<T>(1) - a) + (y * a);
 }

 template<typename T, qualifier Q>
 inline qua<T, Q> slerp(qua<T, Q> const& x, qua<T, Q> const& y, T a)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'slerp' only accept floating-point inputs");

  qua<T, Q> z = y;

  T cosTheta = dot(x, y);



  if(cosTheta < static_cast<T>(0))
  {
   z = -y;
   cosTheta = -cosTheta;
  }


  if(cosTheta > static_cast<T>(1) - epsilon<T>())
  {

   return qua<T, Q>::wxyz(
    mix(x.w, z.w, a),
    mix(x.x, z.x, a),
    mix(x.y, z.y, a),
    mix(x.z, z.z, a));
  }
  else
  {

   T angle = acos(cosTheta);
   return (sin((static_cast<T>(1) - a) * angle) * x + sin(a * angle) * z) / sin(angle);
  }
 }

    template<typename T, typename S, qualifier Q>
    inline qua<T, Q> slerp(qua<T, Q> const& x, qua<T, Q> const& y, T a, S k)
    {
        static_assert(std::numeric_limits<T>::is_iec559 || 0, "'slerp' only accept floating-point inputs");
        static_assert(std::numeric_limits<S>::is_integer, "'slerp' only accept integer for spin count");

        qua<T, Q> z = y;

        T cosTheta = dot(x, y);



        if (cosTheta < static_cast<T>(0))
        {
            z = -y;
            cosTheta = -cosTheta;
        }


        if (cosTheta > static_cast<T>(1) - epsilon<T>())
        {

            return qua<T, Q>::wxyz(
                mix(x.w, z.w, a),
                mix(x.x, z.x, a),
                mix(x.y, z.y, a),
                mix(x.z, z.z, a));
        }
        else
        {

            T angle = acos(cosTheta);
            T phi = angle + static_cast<T>(k) * glm::pi<T>();
            return (sin(angle - a * phi)* x + sin(a * phi) * z) / sin(angle);
        }
    }

 template<typename T, qualifier Q>
 inline constexpr qua<T, Q> conjugate(qua<T, Q> const& q)
 {
  return qua<T, Q>::wxyz(q.w, -q.x, -q.y, -q.z);
 }

 template<typename T, qualifier Q>
 inline constexpr qua<T, Q> inverse(qua<T, Q> const& q)
 {
  return conjugate(q) / dot(q, q);
 }

 template<typename T, qualifier Q>
 inline vec<4, bool, Q> isnan(qua<T, Q> const& q)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'isnan' only accept floating-point inputs");

  return vec<4, bool, Q>(isnan(q.x), isnan(q.y), isnan(q.z), isnan(q.w));
 }

 template<typename T, qualifier Q>
 inline vec<4, bool, Q> isinf(qua<T, Q> const& q)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || 0, "'isinf' only accept floating-point inputs");

  return vec<4, bool, Q>(isinf(q.x), isinf(q.y), isinf(q.z), isinf(q.w));
 }
}
# 136 "/usr/include/glm/ext/quaternion_common.hpp" 2 3 4
# 21 "/usr/include/glm/gtc/quaternion.hpp" 2 3 4
# 1 "/usr/include/glm/ext/quaternion_float.hpp" 1 3 4
# 20 "/usr/include/glm/ext/quaternion_float.hpp" 3 4
       


# 1 "/usr/include/glm/detail/type_quat.hpp" 1 3 4



       







# 1 "/usr/include/glm/ext/quaternion_relational.hpp" 1 3 4
# 17 "/usr/include/glm/ext/quaternion_relational.hpp" 3 4
       
# 26 "/usr/include/glm/ext/quaternion_relational.hpp" 3 4
namespace glm
{







 template<typename T, qualifier Q>
 [[nodiscard]] vec<4, bool, Q> equal(qua<T, Q> const& x, qua<T, Q> const& y);





 template<typename T, qualifier Q>
 [[nodiscard]] vec<4, bool, Q> equal(qua<T, Q> const& x, qua<T, Q> const& y, T epsilon);





 template<typename T, qualifier Q>
 [[nodiscard]] vec<4, bool, Q> notEqual(qua<T, Q> const& x, qua<T, Q> const& y);





 template<typename T, qualifier Q>
 [[nodiscard]] vec<4, bool, Q> notEqual(qua<T, Q> const& x, qua<T, Q> const& y, T epsilon);


}

# 1 "/usr/include/glm/ext/quaternion_relational.inl" 1 3 4
namespace glm
{
 template<typename T, qualifier Q>
 inline vec<4, bool, Q> equal(qua<T, Q> const& x, qua<T, Q> const& y)
 {
  vec<4, bool, Q> Result;
  for(length_t i = 0; i < x.length(); ++i)
   Result[i] = x[i] == y[i];
  return Result;
 }

 template<typename T, qualifier Q>
 inline vec<4, bool, Q> equal(qua<T, Q> const& x, qua<T, Q> const& y, T epsilon)
 {
  vec<4, T, Q> v(x.x - y.x, x.y - y.y, x.z - y.z, x.w - y.w);
  return lessThan(abs(v), vec<4, T, Q>(epsilon));
 }

 template<typename T, qualifier Q>
 inline vec<4, bool, Q> notEqual(qua<T, Q> const& x, qua<T, Q> const& y)
 {
  vec<4, bool, Q> Result;
  for(length_t i = 0; i < x.length(); ++i)
   Result[i] = x[i] != y[i];
  return Result;
 }

 template<typename T, qualifier Q>
 inline vec<4, bool, Q> notEqual(qua<T, Q> const& x, qua<T, Q> const& y, T epsilon)
 {
  vec<4, T, Q> v(x.x - y.x, x.y - y.y, x.z - y.z, x.w - y.w);
  return greaterThanEqual(abs(v), vec<4, T, Q>(epsilon));
 }
}
# 63 "/usr/include/glm/ext/quaternion_relational.hpp" 2 3 4
# 13 "/usr/include/glm/detail/type_quat.hpp" 2 3 4



namespace glm
{


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpedantic"
# 32 "/usr/include/glm/detail/type_quat.hpp" 3 4
 template<typename T, qualifier Q>
 struct qua
 {


  typedef qua<T, Q> type;
  typedef T value_type;
# 57 "/usr/include/glm/detail/type_quat.hpp" 3 4
    T x, y, z, w;





  typedef length_t length_type;


  [[nodiscard]] static constexpr length_type length(){return 4;}

  [[nodiscard]] constexpr T & operator[](length_type i);
  [[nodiscard]] constexpr T const& operator[](length_type i) const;



  constexpr qua() = default;
  constexpr qua(qua<T, Q> const& q) = default;
  template<qualifier P>
  constexpr qua(qua<T, P> const& q);



  constexpr qua(T s, vec<3, T, Q> const& v);




  constexpr qua(T w, T x, T y, T z);


  [[nodiscard]] static constexpr qua<T, Q> wxyz(T w, T x, T y, T z);



  template<typename U, qualifier P>
  constexpr qua(qua<U, P> const& q);



   [[nodiscard]] explicit operator mat<3, 3, T, Q>() const;
   [[nodiscard]] explicit operator mat<4, 4, T, Q>() const;
# 107 "/usr/include/glm/detail/type_quat.hpp" 3 4
  qua(vec<3, T, Q> const& u, vec<3, T, Q> const& v);


  constexpr qua(vec<3, T, Q> const& eulerAngles);
  constexpr qua(mat<3, 3, T, Q> const& q);
  constexpr qua(mat<4, 4, T, Q> const& q);



  constexpr qua<T, Q>& operator=(qua<T, Q> const& q) = default;

  template<typename U>
  constexpr qua<T, Q>& operator=(qua<U, Q> const& q);
  template<typename U>
  constexpr qua<T, Q>& operator+=(qua<U, Q> const& q);
  template<typename U>
  constexpr qua<T, Q>& operator-=(qua<U, Q> const& q);
  template<typename U>
  constexpr qua<T, Q>& operator*=(qua<U, Q> const& q);
  template<typename U>
  constexpr qua<T, Q>& operator*=(U s);
  template<typename U>
  constexpr qua<T, Q>& operator/=(U s);
 };





#pragma GCC diagnostic pop







 template<typename T, qualifier Q>
 [[nodiscard]] constexpr qua<T, Q> operator+(qua<T, Q> const& q);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr qua<T, Q> operator-(qua<T, Q> const& q);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr qua<T, Q> operator+(qua<T, Q> const& q, qua<T, Q> const& p);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr qua<T, Q> operator-(qua<T, Q> const& q, qua<T, Q> const& p);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr qua<T, Q> operator*(qua<T, Q> const& q, qua<T, Q> const& p);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator*(qua<T, Q> const& q, vec<3, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<3, T, Q> operator*(vec<3, T, Q> const& v, qua<T, Q> const& q);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator*(qua<T, Q> const& q, vec<4, T, Q> const& v);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, T, Q> operator*(vec<4, T, Q> const& v, qua<T, Q> const& q);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr qua<T, Q> operator*(qua<T, Q> const& q, T const& s);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr qua<T, Q> operator*(T const& s, qua<T, Q> const& q);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr qua<T, Q> operator/(qua<T, Q> const& q, T const& s);



 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator==(qua<T, Q> const& q1, qua<T, Q> const& q2);

 template<typename T, qualifier Q>
 [[nodiscard]] constexpr bool operator!=(qua<T, Q> const& q1, qua<T, Q> const& q2);
}


# 1 "/usr/include/glm/detail/type_quat.inl" 1 3 4






namespace glm{
namespace detail
{
 template <typename T>
 struct genTypeTrait<qua<T> >
 {
  static const genTypeEnum GENTYPE = GENTYPE_QUAT;
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_dot<qua<T, Q>, T, Aligned>
 {
  inline constexpr static T call(qua<T, Q> const& a, qua<T, Q> const& b)
  {
   vec<4, T, Q> tmp(a.w * b.w, a.x * b.x, a.y * b.y, a.z * b.z);
   return (tmp.x + tmp.y) + (tmp.z + tmp.w);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_quat_add
 {
  inline constexpr static qua<T, Q> call(qua<T, Q> const& q, qua<T, Q> const& p)
  {
   return qua<T, Q>::wxyz(q.w + p.w, q.x + p.x, q.y + p.y, q.z + p.z);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_quat_sub
 {
  inline constexpr static qua<T, Q> call(qua<T, Q> const& q, qua<T, Q> const& p)
  {
   return qua<T, Q>::wxyz(q.w - p.w, q.x - p.x, q.y - p.y, q.z - p.z);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_quat_mul_scalar
 {
  inline constexpr static qua<T, Q> call(qua<T, Q> const& q, T s)
  {
   return qua<T, Q>::wxyz(q.w * s, q.x * s, q.y * s, q.z * s);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_quat_div_scalar
 {
  inline constexpr static qua<T, Q> call(qua<T, Q> const& q, T s)
  {
   return qua<T, Q>::wxyz(q.w / s, q.x / s, q.y / s, q.z / s);
  }
 };

 template<typename T, qualifier Q, bool Aligned>
 struct compute_quat_mul_vec4
 {
  inline constexpr static vec<4, T, Q> call(qua<T, Q> const& q, vec<4, T, Q> const& v)
  {
   return vec<4, T, Q>(q * vec<3, T, Q>(v), v.w);
  }
 };
}



 template<typename T, qualifier Q>
 inline constexpr T & qua<T, Q>::operator[](typename qua<T, Q>::length_type i)
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));



   return (&x)[i];

 }

 template<typename T, qualifier Q>
 inline constexpr T const& qua<T, Q>::operator[](typename qua<T, Q>::length_type i) const
 {
  ((static_cast <bool> ((i) >= 0 && (i) < (this->length())) ? void (0) : __assert_fail ("(i) >= 0 && (i) < (this->length())", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)));



   return (&x)[i];

 }
# 122 "/usr/include/glm/detail/type_quat.inl" 3 4
 template<typename T, qualifier Q>
 template<qualifier P>
 inline constexpr qua<T, Q>::qua(qua<T, P> const& q)



   : x(q.x), y(q.y), z(q.z), w(q.w)

 {}



 template<typename T, qualifier Q>
 inline constexpr qua<T, Q>::qua(T s, vec<3, T, Q> const& v)



   : x(v.x), y(v.y), z(v.z), w(s)

 {}

 template <typename T, qualifier Q>



 inline constexpr qua<T, Q>::qua(T _w, T _x, T _y, T _z)




   : x(_x), y(_y), z(_z), w(_w)

 {}

 template <typename T, qualifier Q>
 constexpr qua<T, Q> qua<T, Q>::wxyz(T w, T x, T y, T z) {



  return qua<T, Q>(w, x, y, z);

 }



 template<typename T, qualifier Q>
 template<typename U, qualifier P>
 inline constexpr qua<T, Q>::qua(qua<U, P> const& q)



   : x(static_cast<T>(q.x)), y(static_cast<T>(q.y)), z(static_cast<T>(q.z)), w(static_cast<T>(q.w))

 {}
# 195 "/usr/include/glm/detail/type_quat.inl" 3 4
 template<typename T, qualifier Q>
 inline qua<T, Q>::qua(vec<3, T, Q> const& u, vec<3, T, Q> const& v)
 {
  T norm_u_norm_v = sqrt(dot(u, u) * dot(v, v));
  T real_part = norm_u_norm_v + dot(u, v);
  vec<3, T, Q> t;

  if(real_part < static_cast<T>(1.e-6f) * norm_u_norm_v)
  {



   real_part = static_cast<T>(0);
   t = abs(u.x) > abs(u.z) ? vec<3, T, Q>(-u.y, u.x, static_cast<T>(0)) : vec<3, T, Q>(static_cast<T>(0), -u.z, u.y);
  }
  else
  {

   t = cross(u, v);
  }

  *this = normalize(qua<T, Q>::wxyz(real_part, t.x, t.y, t.z));
 }

 template<typename T, qualifier Q>
 inline constexpr qua<T, Q>::qua(vec<3, T, Q> const& eulerAngle)
 {
  vec<3, T, Q> c = glm::cos(eulerAngle * T(0.5));
  vec<3, T, Q> s = glm::sin(eulerAngle * T(0.5));

  this->w = c.x * c.y * c.z + s.x * s.y * s.z;
  this->x = s.x * c.y * c.z - c.x * s.y * s.z;
  this->y = c.x * s.y * c.z + s.x * c.y * s.z;
  this->z = c.x * c.y * s.z - s.x * s.y * c.z;
 }

 template<typename T, qualifier Q>
 inline constexpr qua<T, Q>::qua(mat<3, 3, T, Q> const& m)
 {
  *this = quat_cast(m);
 }

 template<typename T, qualifier Q>
 inline constexpr qua<T, Q>::qua(mat<4, 4, T, Q> const& m)
 {
  *this = quat_cast(m);
 }


 template<typename T, qualifier Q>
 inline qua<T, Q>::operator mat<3, 3, T, Q>() const
 {
  return mat3_cast(*this);
 }

 template<typename T, qualifier Q>
 inline qua<T, Q>::operator mat<4, 4, T, Q>() const
 {
  return mat4_cast(*this);
 }
# 271 "/usr/include/glm/detail/type_quat.inl" 3 4
 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr qua<T, Q> & qua<T, Q>::operator=(qua<U, Q> const& q)
 {
  this->w = static_cast<T>(q.w);
  this->x = static_cast<T>(q.x);
  this->y = static_cast<T>(q.y);
  this->z = static_cast<T>(q.z);
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr qua<T, Q> & qua<T, Q>::operator+=(qua<U, Q> const& q)
 {
  return (*this = detail::compute_quat_add<T, Q, detail::is_aligned<Q>::value>::call(*this, qua<T, Q>(q)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr qua<T, Q> & qua<T, Q>::operator-=(qua<U, Q> const& q)
 {
  return (*this = detail::compute_quat_sub<T, Q, detail::is_aligned<Q>::value>::call(*this, qua<T, Q>(q)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr qua<T, Q> & qua<T, Q>::operator*=(qua<U, Q> const& r)
 {
  qua<T, Q> const p(*this);
  qua<T, Q> const q(r);

  this->w = p.w * q.w - p.x * q.x - p.y * q.y - p.z * q.z;
  this->x = p.w * q.x + p.x * q.w + p.y * q.z - p.z * q.y;
  this->y = p.w * q.y + p.y * q.w + p.z * q.x - p.x * q.z;
  this->z = p.w * q.z + p.z * q.w + p.x * q.y - p.y * q.x;
  return *this;
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr qua<T, Q> & qua<T, Q>::operator*=(U s)
 {
  return (*this = detail::compute_quat_mul_scalar<T, Q, detail::is_aligned<Q>::value>::call(*this, static_cast<U>(s)));
 }

 template<typename T, qualifier Q>
 template<typename U>
 inline constexpr qua<T, Q> & qua<T, Q>::operator/=(U s)
 {
  return (*this = detail::compute_quat_div_scalar<T, Q, detail::is_aligned<Q>::value>::call(*this, static_cast<U>(s)));
 }



 template<typename T, qualifier Q>
 inline constexpr qua<T, Q> operator+(qua<T, Q> const& q)
 {
  return q;
 }

 template<typename T, qualifier Q>
 inline constexpr qua<T, Q> operator-(qua<T, Q> const& q)
 {
  return qua<T, Q>::wxyz(-q.w, -q.x, -q.y, -q.z);
 }



 template<typename T, qualifier Q>
 inline constexpr qua<T, Q> operator+(qua<T, Q> const& q, qua<T, Q> const& p)
 {
  return qua<T, Q>(q) += p;
 }

 template<typename T, qualifier Q>
 inline constexpr qua<T, Q> operator-(qua<T, Q> const& q, qua<T, Q> const& p)
 {
  return qua<T, Q>(q) -= p;
 }

 template<typename T, qualifier Q>
 inline constexpr qua<T, Q> operator*(qua<T, Q> const& q, qua<T, Q> const& p)
 {
  return qua<T, Q>(q) *= p;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator*(qua<T, Q> const& q, vec<3, T, Q> const& v)
 {
  vec<3, T, Q> const QuatVector(q.x, q.y, q.z);
  vec<3, T, Q> const uv(glm::cross(QuatVector, v));
  vec<3, T, Q> const uuv(glm::cross(QuatVector, uv));

  return v + ((uv * q.w) + uuv) * static_cast<T>(2);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<3, T, Q> operator*(vec<3, T, Q> const& v, qua<T, Q> const& q)
 {
  return glm::inverse(q) * v;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator*(qua<T, Q> const& q, vec<4, T, Q> const& v)
 {
  return detail::compute_quat_mul_vec4<T, Q, detail::is_aligned<Q>::value>::call(q, v);
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, T, Q> operator*(vec<4, T, Q> const& v, qua<T, Q> const& q)
 {
  return glm::inverse(q) * v;
 }

 template<typename T, qualifier Q>
 inline constexpr qua<T, Q> operator*(qua<T, Q> const& q, T const& s)
 {
  return qua<T, Q>::wxyz(
   q.w * s, q.x * s, q.y * s, q.z * s);
 }

 template<typename T, qualifier Q>
 inline constexpr qua<T, Q> operator*(T const& s, qua<T, Q> const& q)
 {
  return q * s;
 }

 template<typename T, qualifier Q>
 inline constexpr qua<T, Q> operator/(qua<T, Q> const& q, T const& s)
 {
  return qua<T, Q>::wxyz(
   q.w / s, q.x / s, q.y / s, q.z / s);
 }



 template<typename T, qualifier Q>
 inline constexpr bool operator==(qua<T, Q> const& q1, qua<T, Q> const& q2)
 {
  return q1.x == q2.x && q1.y == q2.y && q1.z == q2.z && q1.w == q2.w;
 }

 template<typename T, qualifier Q>
 inline constexpr bool operator!=(qua<T, Q> const& q1, qua<T, Q> const& q2)
 {
  return q1.x != q2.x || q1.y != q2.y || q1.z != q2.z || q1.w != q2.w;
 }
}
# 193 "/usr/include/glm/detail/type_quat.hpp" 2 3 4
# 24 "/usr/include/glm/ext/quaternion_float.hpp" 2 3 4





namespace glm
{




 typedef qua<float, defaultp> quat;


}
# 22 "/usr/include/glm/gtc/quaternion.hpp" 2 3 4
# 1 "/usr/include/glm/ext/quaternion_float_precision.hpp" 1 3 4
# 11 "/usr/include/glm/ext/quaternion_float_precision.hpp" 3 4
       
# 20 "/usr/include/glm/ext/quaternion_float_precision.hpp" 3 4
namespace glm
{




 typedef qua<float, lowp> lowp_quat;


 typedef qua<float, mediump> mediump_quat;


 typedef qua<float, highp> highp_quat;


}
# 23 "/usr/include/glm/gtc/quaternion.hpp" 2 3 4
# 1 "/usr/include/glm/ext/quaternion_double.hpp" 1 3 4
# 20 "/usr/include/glm/ext/quaternion_double.hpp" 3 4
       
# 29 "/usr/include/glm/ext/quaternion_double.hpp" 3 4
namespace glm
{




 typedef qua<double, defaultp> dquat;


}
# 24 "/usr/include/glm/gtc/quaternion.hpp" 2 3 4
# 1 "/usr/include/glm/ext/quaternion_double_precision.hpp" 1 3 4
# 11 "/usr/include/glm/ext/quaternion_double_precision.hpp" 3 4
       
# 20 "/usr/include/glm/ext/quaternion_double_precision.hpp" 3 4
namespace glm
{






 typedef qua<double, lowp> lowp_dquat;




 typedef qua<double, mediump> mediump_dquat;




 typedef qua<double, highp> highp_dquat;


}
# 25 "/usr/include/glm/gtc/quaternion.hpp" 2 3 4


# 1 "/usr/include/glm/ext/quaternion_trigonometric.hpp" 1 3 4
# 18 "/usr/include/glm/ext/quaternion_trigonometric.hpp" 3 4
       
# 31 "/usr/include/glm/ext/quaternion_trigonometric.hpp" 3 4
namespace glm
{
# 42 "/usr/include/glm/ext/quaternion_trigonometric.hpp" 3 4
 template<typename T, qualifier Q>
 [[nodiscard]] T angle(qua<T, Q> const& x);





 template<typename T, qualifier Q>
 [[nodiscard]] vec<3, T, Q> axis(qua<T, Q> const& x);
# 59 "/usr/include/glm/ext/quaternion_trigonometric.hpp" 3 4
 template<typename T, qualifier Q>
 [[nodiscard]] qua<T, Q> angleAxis(T const& angle, vec<3, T, Q> const& axis);


}

# 1 "/usr/include/glm/ext/quaternion_trigonometric.inl" 1 3 4


namespace glm
{
 template<typename T, qualifier Q>
 inline T angle(qua<T, Q> const& x)
 {
  if (abs(x.w) > cos_one_over_two<T>())
  {
   T const a = asin(sqrt(x.x * x.x + x.y * x.y + x.z * x.z)) * static_cast<T>(2);
   if(x.w < static_cast<T>(0))
    return pi<T>() * static_cast<T>(2) - a;
   return a;
  }

  return acos(x.w) * static_cast<T>(2);
 }

 template<typename T, qualifier Q>
 inline vec<3, T, Q> axis(qua<T, Q> const& x)
 {
  T const tmp1 = static_cast<T>(1) - x.w * x.w;
  if(tmp1 <= static_cast<T>(0))
   return vec<3, T, Q>(0, 0, 1);
  T const tmp2 = static_cast<T>(1) / sqrt(tmp1);
  return vec<3, T, Q>(x.x * tmp2, x.y * tmp2, x.z * tmp2);
 }

 template<typename T, qualifier Q>
 inline qua<T, Q> angleAxis(T const& angle, vec<3, T, Q> const& v)
 {
  T const a(angle);
  T const s = glm::sin(a * static_cast<T>(0.5));

  return qua<T, Q>(glm::cos(a * static_cast<T>(0.5)), v * s);
 }
}
# 66 "/usr/include/glm/ext/quaternion_trigonometric.hpp" 2 3 4
# 28 "/usr/include/glm/gtc/quaternion.hpp" 2 3 4
# 1 "/usr/include/glm/ext/quaternion_transform.hpp" 1 3 4
# 18 "/usr/include/glm/ext/quaternion_transform.hpp" 3 4
       
# 29 "/usr/include/glm/ext/quaternion_transform.hpp" 3 4
namespace glm
{
# 42 "/usr/include/glm/ext/quaternion_transform.hpp" 3 4
 template<typename T, qualifier Q>
 [[nodiscard]] qua<T, Q> rotate(qua<T, Q> const& q, T const& angle, vec<3, T, Q> const& axis);

}

# 1 "/usr/include/glm/ext/quaternion_transform.inl" 1 3 4
namespace glm
{
 template<typename T, qualifier Q>
 inline qua<T, Q> rotate(qua<T, Q> const& q, T const& angle, vec<3, T, Q> const& v)
 {
  vec<3, T, Q> Tmp = v;


  T len = glm::length(Tmp);
  if(abs(len - static_cast<T>(1)) > static_cast<T>(0.001))
  {
   T oneOverLen = static_cast<T>(1) / len;
   Tmp.x *= oneOverLen;
   Tmp.y *= oneOverLen;
   Tmp.z *= oneOverLen;
  }

  T const AngleRad(angle);
  T const Sin = sin(AngleRad * static_cast<T>(0.5));

  return q * qua<T, Q>::wxyz(cos(AngleRad * static_cast<T>(0.5)), Tmp.x * Sin, Tmp.y * Sin, Tmp.z * Sin);
 }
}
# 48 "/usr/include/glm/ext/quaternion_transform.hpp" 2 3 4
# 29 "/usr/include/glm/gtc/quaternion.hpp" 2 3 4
# 38 "/usr/include/glm/gtc/quaternion.hpp" 3 4
namespace glm
{
# 49 "/usr/include/glm/gtc/quaternion.hpp" 3 4
 template<typename T, qualifier Q>
 [[nodiscard]] vec<3, T, Q> eulerAngles(qua<T, Q> const& x);






 template<typename T, qualifier Q>
 [[nodiscard]] T roll(qua<T, Q> const& x);






 template<typename T, qualifier Q>
 [[nodiscard]] T pitch(qua<T, Q> const& x);






 template<typename T, qualifier Q>
 [[nodiscard]] T yaw(qua<T, Q> const& x);






 template<typename T, qualifier Q>
 [[nodiscard]] mat<3, 3, T, Q> mat3_cast(qua<T, Q> const& x);






 template<typename T, qualifier Q>
 [[nodiscard]] mat<4, 4, T, Q> mat4_cast(qua<T, Q> const& x);






 template<typename T, qualifier Q>
 [[nodiscard]] qua<T, Q> quat_cast(mat<3, 3, T, Q> const& x);






 template<typename T, qualifier Q>
 [[nodiscard]] qua<T, Q> quat_cast(mat<4, 4, T, Q> const& x);







 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, bool, Q> lessThan(qua<T, Q> const& x, qua<T, Q> const& y);







 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, bool, Q> lessThanEqual(qua<T, Q> const& x, qua<T, Q> const& y);







 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, bool, Q> greaterThan(qua<T, Q> const& x, qua<T, Q> const& y);







 template<typename T, qualifier Q>
 [[nodiscard]] constexpr vec<4, bool, Q> greaterThanEqual(qua<T, Q> const& x, qua<T, Q> const& y);





 template<typename T, qualifier Q>
 [[nodiscard]] qua<T, Q> quatLookAt(
  vec<3, T, Q> const& direction,
  vec<3, T, Q> const& up);





 template<typename T, qualifier Q>
 [[nodiscard]] qua<T, Q> quatLookAtRH(
  vec<3, T, Q> const& direction,
  vec<3, T, Q> const& up);





 template<typename T, qualifier Q>
 [[nodiscard]] qua<T, Q> quatLookAtLH(
  vec<3, T, Q> const& direction,
  vec<3, T, Q> const& up);

}

# 1 "/usr/include/glm/gtc/quaternion.inl" 1 3 4



# 1 "/usr/include/glm/gtc/epsilon.hpp" 1 3 4
# 14 "/usr/include/glm/gtc/epsilon.hpp" 3 4
       


# 1 "/usr/include/glm/detail/setup.hpp" 1 3 4
# 18 "/usr/include/glm/gtc/epsilon.hpp" 2 3 4






namespace glm
{







 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, bool, Q> epsilonEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, T const& epsilon);





 template<typename genType>
 [[nodiscard]] bool epsilonEqual(genType const& x, genType const& y, genType const& epsilon);





 template<length_t L, typename T, qualifier Q>
 [[nodiscard]] vec<L, bool, Q> epsilonNotEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, T const& epsilon);





 template<typename genType>
 [[nodiscard]] bool epsilonNotEqual(genType const& x, genType const& y, genType const& epsilon);


}

# 1 "/usr/include/glm/gtc/epsilon.inl" 1 3 4






namespace glm
{
 template<>
 inline bool epsilonEqual
 (
  float const& x,
  float const& y,
  float const& epsilon
 )
 {
  return abs(x - y) < epsilon;
 }

 template<>
 inline bool epsilonEqual
 (
  double const& x,
  double const& y,
  double const& epsilon
 )
 {
  return abs(x - y) < epsilon;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, bool, Q> epsilonEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, T const& epsilon)
 {
  return lessThan(abs(x - y), vec<L, T, Q>(epsilon));
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, bool, Q> epsilonEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, T, Q> const& epsilon)
 {
  return lessThan(abs(x - y), vec<L, T, Q>(epsilon));
 }

 template<>
 inline bool epsilonNotEqual(float const& x, float const& y, float const& epsilon)
 {
  return abs(x - y) >= epsilon;
 }

 template<>
 inline bool epsilonNotEqual(double const& x, double const& y, double const& epsilon)
 {
  return abs(x - y) >= epsilon;
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, bool, Q> epsilonNotEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, T const& epsilon)
 {
  return greaterThanEqual(abs(x - y), vec<L, T, Q>(epsilon));
 }

 template<length_t L, typename T, qualifier Q>
 inline vec<L, bool, Q> epsilonNotEqual(vec<L, T, Q> const& x, vec<L, T, Q> const& y, vec<L, T, Q> const& epsilon)
 {
  return greaterThanEqual(abs(x - y), vec<L, T, Q>(epsilon));
 }

 template<typename T, qualifier Q>
 inline vec<4, bool, Q> epsilonEqual(qua<T, Q> const& x, qua<T, Q> const& y, T const& epsilon)
 {
  vec<4, T, Q> v(x.x - y.x, x.y - y.y, x.z - y.z, x.w - y.w);
  return lessThan(abs(v), vec<4, T, Q>(epsilon));
 }

 template<typename T, qualifier Q>
 inline vec<4, bool, Q> epsilonNotEqual(qua<T, Q> const& x, qua<T, Q> const& y, T const& epsilon)
 {
  vec<4, T, Q> v(x.x - y.x, x.y - y.y, x.z - y.z, x.w - y.w);
  return greaterThanEqual(abs(v), vec<4, T, Q>(epsilon));
 }
}
# 61 "/usr/include/glm/gtc/epsilon.hpp" 2 3 4
# 5 "/usr/include/glm/gtc/quaternion.inl" 2 3 4


namespace glm
{
 template<typename T, qualifier Q>
 inline vec<3, T, Q> eulerAngles(qua<T, Q> const& x)
 {
  return vec<3, T, Q>(pitch(x), yaw(x), roll(x));
 }

 template<typename T, qualifier Q>
 inline T roll(qua<T, Q> const& q)
 {
  T const y = static_cast<T>(2) * (q.x * q.y + q.w * q.z);
  T const x = q.w * q.w + q.x * q.x - q.y * q.y - q.z * q.z;

  if(all(equal(vec<2, T, Q>(x, y), vec<2, T, Q>(0), epsilon<T>())))
   return static_cast<T>(0);

  return static_cast<T>(atan(y, x));
 }

 template<typename T, qualifier Q>
 inline T pitch(qua<T, Q> const& q)
 {

  T const y = static_cast<T>(2) * (q.y * q.z + q.w * q.x);
  T const x = q.w * q.w - q.x * q.x - q.y * q.y + q.z * q.z;

  if(all(equal(vec<2, T, Q>(x, y), vec<2, T, Q>(0), epsilon<T>())))
   return static_cast<T>(static_cast<T>(2) * atan(q.x, q.w));

  return static_cast<T>(atan(y, x));
 }

 template<typename T, qualifier Q>
 inline T yaw(qua<T, Q> const& q)
 {
  return asin(clamp(static_cast<T>(-2) * (q.x * q.z - q.w * q.y), static_cast<T>(-1), static_cast<T>(1)));
 }

 template<typename T, qualifier Q>
 inline mat<3, 3, T, Q> mat3_cast(qua<T, Q> const& q)
 {
  mat<3, 3, T, Q> Result(T(1));
  T qxx(q.x * q.x);
  T qyy(q.y * q.y);
  T qzz(q.z * q.z);
  T qxz(q.x * q.z);
  T qxy(q.x * q.y);
  T qyz(q.y * q.z);
  T qwx(q.w * q.x);
  T qwy(q.w * q.y);
  T qwz(q.w * q.z);

  Result[0][0] = T(1) - T(2) * (qyy + qzz);
  Result[0][1] = T(2) * (qxy + qwz);
  Result[0][2] = T(2) * (qxz - qwy);

  Result[1][0] = T(2) * (qxy - qwz);
  Result[1][1] = T(1) - T(2) * (qxx + qzz);
  Result[1][2] = T(2) * (qyz + qwx);

  Result[2][0] = T(2) * (qxz + qwy);
  Result[2][1] = T(2) * (qyz - qwx);
  Result[2][2] = T(1) - T(2) * (qxx + qyy);
  return Result;
 }

 template<typename T, qualifier Q>
 inline mat<4, 4, T, Q> mat4_cast(qua<T, Q> const& q)
 {
  return mat<4, 4, T, Q>(mat3_cast(q));
 }

 template<typename T, qualifier Q>
 inline qua<T, Q> quat_cast(mat<3, 3, T, Q> const& m)
 {
  T fourXSquaredMinus1 = m[0][0] - m[1][1] - m[2][2];
  T fourYSquaredMinus1 = m[1][1] - m[0][0] - m[2][2];
  T fourZSquaredMinus1 = m[2][2] - m[0][0] - m[1][1];
  T fourWSquaredMinus1 = m[0][0] + m[1][1] + m[2][2];

  int biggestIndex = 0;
  T fourBiggestSquaredMinus1 = fourWSquaredMinus1;
  if(fourXSquaredMinus1 > fourBiggestSquaredMinus1)
  {
   fourBiggestSquaredMinus1 = fourXSquaredMinus1;
   biggestIndex = 1;
  }
  if(fourYSquaredMinus1 > fourBiggestSquaredMinus1)
  {
   fourBiggestSquaredMinus1 = fourYSquaredMinus1;
   biggestIndex = 2;
  }
  if(fourZSquaredMinus1 > fourBiggestSquaredMinus1)
  {
   fourBiggestSquaredMinus1 = fourZSquaredMinus1;
   biggestIndex = 3;
  }

  T biggestVal = sqrt(fourBiggestSquaredMinus1 + static_cast<T>(1)) * static_cast<T>(0.5);
  T mult = static_cast<T>(0.25) / biggestVal;

  switch(biggestIndex)
  {
  case 0:
   return qua<T, Q>::wxyz(biggestVal, (m[1][2] - m[2][1]) * mult, (m[2][0] - m[0][2]) * mult, (m[0][1] - m[1][0]) * mult);
  case 1:
   return qua<T, Q>::wxyz((m[1][2] - m[2][1]) * mult, biggestVal, (m[0][1] + m[1][0]) * mult, (m[2][0] + m[0][2]) * mult);
  case 2:
   return qua<T, Q>::wxyz((m[2][0] - m[0][2]) * mult, (m[0][1] + m[1][0]) * mult, biggestVal, (m[1][2] + m[2][1]) * mult);
  case 3:
   return qua<T, Q>::wxyz((m[0][1] - m[1][0]) * mult, (m[2][0] + m[0][2]) * mult, (m[1][2] + m[2][1]) * mult, biggestVal);
  default:
   (static_cast <bool> (false) ? void (0) : __assert_fail ("false", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__));
   return qua<T, Q>::wxyz(1, 0, 0, 0);
  }
 }

 template<typename T, qualifier Q>
 inline qua<T, Q> quat_cast(mat<4, 4, T, Q> const& m4)
 {
  return quat_cast(mat<3, 3, T, Q>(m4));
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, bool, Q> lessThan(qua<T, Q> const& x, qua<T, Q> const& y)
 {
  vec<4, bool, Q> Result(false, false, false, false);
  for(length_t i = 0; i < x.length(); ++i)
   Result[i] = x[i] < y[i];
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, bool, Q> lessThanEqual(qua<T, Q> const& x, qua<T, Q> const& y)
 {
  vec<4, bool, Q> Result(false, false, false, false);
  for(length_t i = 0; i < x.length(); ++i)
   Result[i] = x[i] <= y[i];
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, bool, Q> greaterThan(qua<T, Q> const& x, qua<T, Q> const& y)
 {
  vec<4, bool, Q> Result(false, false, false, false);
  for(length_t i = 0; i < x.length(); ++i)
   Result[i] = x[i] > y[i];
  return Result;
 }

 template<typename T, qualifier Q>
 inline constexpr vec<4, bool, Q> greaterThanEqual(qua<T, Q> const& x, qua<T, Q> const& y)
 {
  vec<4, bool, Q> Result(false, false, false, false);
  for(length_t i = 0; i < x.length(); ++i)
   Result[i] = x[i] >= y[i];
  return Result;
 }


 template<typename T, qualifier Q>
 inline qua<T, Q> quatLookAt(vec<3, T, Q> const& direction, vec<3, T, Q> const& up)
 {



   return quatLookAtRH(direction, up);

 }

 template<typename T, qualifier Q>
 inline qua<T, Q> quatLookAtRH(vec<3, T, Q> const& direction, vec<3, T, Q> const& up)
 {
  mat<3, 3, T, Q> Result;

  Result[2] = -direction;
  vec<3, T, Q> const& Right = cross(up, Result[2]);
  Result[0] = Right * inversesqrt(max(static_cast<T>(0.00001), dot(Right, Right)));
  Result[1] = cross(Result[2], Result[0]);

  return quat_cast(Result);
 }

 template<typename T, qualifier Q>
 inline qua<T, Q> quatLookAtLH(vec<3, T, Q> const& direction, vec<3, T, Q> const& up)
 {
  mat<3, 3, T, Q> Result;

  Result[2] = direction;
  vec<3, T, Q> const& Right = cross(up, Result[2]);
  Result[0] = Right * inversesqrt(max(static_cast<T>(0.00001), dot(Right, Right)));
  Result[1] = cross(Result[2], Result[0]);

  return quat_cast(Result);
 }
}
# 174 "/usr/include/glm/gtc/quaternion.hpp" 2 3 4
# 38 "/usr/include/glm/gtc/type_ptr.hpp" 2 3 4
# 1 "/usr/include/glm/gtc/vec1.hpp" 1 3 4
# 13 "/usr/include/glm/gtc/vec1.hpp" 3 4
       


# 1 "/usr/include/glm/ext/vector_bool1.hpp" 1 3 4
# 13 "/usr/include/glm/ext/vector_bool1.hpp" 3 4
       







namespace glm
{




 typedef vec<1, bool, defaultp> bvec1;


}
# 17 "/usr/include/glm/gtc/vec1.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_bool1_precision.hpp" 1 3 4
# 11 "/usr/include/glm/ext/vector_bool1_precision.hpp" 3 4
       







namespace glm
{




 typedef vec<1, bool, highp> highp_bvec1;


 typedef vec<1, bool, mediump> mediump_bvec1;


 typedef vec<1, bool, lowp> lowp_bvec1;


}
# 18 "/usr/include/glm/gtc/vec1.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_float1.hpp" 1 3 4
# 14 "/usr/include/glm/ext/vector_float1.hpp" 3 4
       







namespace glm
{




 typedef vec<1, float, defaultp> vec1;


}
# 19 "/usr/include/glm/gtc/vec1.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_float1_precision.hpp" 1 3 4
# 13 "/usr/include/glm/ext/vector_float1_precision.hpp" 3 4
       







namespace glm
{




 typedef vec<1, float, highp> highp_vec1;


 typedef vec<1, float, mediump> mediump_vec1;


 typedef vec<1, float, lowp> lowp_vec1;


}
# 20 "/usr/include/glm/gtc/vec1.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_double1.hpp" 1 3 4
# 14 "/usr/include/glm/ext/vector_double1.hpp" 3 4
       







namespace glm
{




 typedef vec<1, double, defaultp> dvec1;


}
# 21 "/usr/include/glm/gtc/vec1.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_double1_precision.hpp" 1 3 4
# 13 "/usr/include/glm/ext/vector_double1_precision.hpp" 3 4
       







namespace glm
{




 typedef vec<1, double, highp> highp_dvec1;


 typedef vec<1, double, mediump> mediump_dvec1;


 typedef vec<1, double, lowp> lowp_dvec1;


}
# 22 "/usr/include/glm/gtc/vec1.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_int1.hpp" 1 3 4
# 14 "/usr/include/glm/ext/vector_int1.hpp" 3 4
       







namespace glm
{




 typedef vec<1, int, defaultp> ivec1;


}
# 23 "/usr/include/glm/gtc/vec1.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_int1_sized.hpp" 1 3 4
# 14 "/usr/include/glm/ext/vector_int1_sized.hpp" 3 4
       
# 23 "/usr/include/glm/ext/vector_int1_sized.hpp" 3 4
namespace glm
{






 typedef vec<1, int8, defaultp> i8vec1;




 typedef vec<1, int16, defaultp> i16vec1;




 typedef vec<1, int32, defaultp> i32vec1;




 typedef vec<1, int64, defaultp> i64vec1;


}
# 24 "/usr/include/glm/gtc/vec1.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_uint1.hpp" 1 3 4
# 14 "/usr/include/glm/ext/vector_uint1.hpp" 3 4
       







namespace glm
{




 typedef vec<1, unsigned int, defaultp> uvec1;


}
# 25 "/usr/include/glm/gtc/vec1.hpp" 2 3 4
# 1 "/usr/include/glm/ext/vector_uint1_sized.hpp" 1 3 4
# 14 "/usr/include/glm/ext/vector_uint1_sized.hpp" 3 4
       
# 23 "/usr/include/glm/ext/vector_uint1_sized.hpp" 3 4
namespace glm
{






 typedef vec<1, uint8, defaultp> u8vec1;




 typedef vec<1, uint16, defaultp> u16vec1;




 typedef vec<1, uint32, defaultp> u32vec1;




 typedef vec<1, uint64, defaultp> u64vec1;


}
# 26 "/usr/include/glm/gtc/vec1.hpp" 2 3 4
# 39 "/usr/include/glm/gtc/type_ptr.hpp" 2 3 4
# 51 "/usr/include/glm/gtc/type_ptr.hpp" 3 4
# 1 "/usr/include/c++/14.2.1/cstring" 1 3 4
# 39 "/usr/include/c++/14.2.1/cstring" 3 4
       
# 40 "/usr/include/c++/14.2.1/cstring" 3


# 1 "/usr/include/c++/14.2.1/bits/version.h" 1 3
# 47 "/usr/include/c++/14.2.1/bits/version.h" 3
       
# 48 "/usr/include/c++/14.2.1/bits/version.h" 3
# 43 "/usr/include/c++/14.2.1/cstring" 2 3
# 1 "/usr/include/string.h" 1 3 4
# 26 "/usr/include/string.h" 3 4
# 1 "/usr/include/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/string.h" 2 3 4

extern "C" {




# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/stddef.h" 1 3 4
# 34 "/usr/include/string.h" 2 3 4
# 43 "/usr/include/string.h" 3 4
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));





extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
    noexcept (true) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__access__ (__write_only__, 1, 4)));




extern void *memset (void *__s, int __c, size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 80 "/usr/include/string.h" 3 4
extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern void *memchr (void *__s, int __c, size_t __n)
      noexcept (true) __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const void *memchr (const void *__s, int __c, size_t __n)
      noexcept (true) __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 105 "/usr/include/string.h" 3 4
}
# 115 "/usr/include/string.h" 3 4
extern "C++" void *rawmemchr (void *__s, int __c)
     noexcept (true) __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const void *rawmemchr (const void *__s, int __c)
     noexcept (true) __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));







extern "C++" void *memrchr (void *__s, int __c, size_t __n)
      noexcept (true) __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)))
      __attribute__ ((__access__ (__read_only__, 1, 3)));
extern "C++" const void *memrchr (const void *__s, int __c, size_t __n)
      noexcept (true) __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)))
      __attribute__ ((__access__ (__read_only__, 1, 3)));
# 141 "/usr/include/string.h" 3 4
extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
    noexcept (true) __attribute__ ((__nonnull__ (2))) __attribute__ ((__access__ (__write_only__, 1, 3)));






extern int strcoll_l (const char *__s1, const char *__s2, locale_t __l)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    locale_t __l) noexcept (true) __attribute__ ((__nonnull__ (2, 4)))
     __attribute__ ((__access__ (__write_only__, 1, 3)));





extern char *strdup (const char *__s)
     noexcept (true) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     noexcept (true) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 224 "/usr/include/string.h" 3 4
extern "C++"
{
extern char *strchr (char *__s, int __c)
     noexcept (true) __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strchr (const char *__s, int __c)
     noexcept (true) __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 244 "/usr/include/string.h" 3 4
}






extern "C++"
{
extern char *strrchr (char *__s, int __c)
     noexcept (true) __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strrchr (const char *__s, int __c)
     noexcept (true) __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 271 "/usr/include/string.h" 3 4
}
# 281 "/usr/include/string.h" 3 4
extern "C++" char *strchrnul (char *__s, int __c)
     noexcept (true) __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const char *strchrnul (const char *__s, int __c)
     noexcept (true) __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 293 "/usr/include/string.h" 3 4
extern size_t strcspn (const char *__s, const char *__reject)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern "C++"
{
extern char *strpbrk (char *__s, const char *__accept)
     noexcept (true) __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strpbrk (const char *__s, const char *__accept)
     noexcept (true) __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 321 "/usr/include/string.h" 3 4
}






extern "C++"
{
extern char *strstr (char *__haystack, const char *__needle)
     noexcept (true) __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strstr (const char *__haystack, const char *__needle)
     noexcept (true) __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 348 "/usr/include/string.h" 3 4
}







extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     noexcept (true) __attribute__ ((__nonnull__ (2)));



extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     noexcept (true) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     noexcept (true) __attribute__ ((__nonnull__ (2, 3)));





extern "C++" char *strcasestr (char *__haystack, const char *__needle)
     noexcept (true) __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern "C++" const char *strcasestr (const char *__haystack,
         const char *__needle)
     noexcept (true) __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 389 "/usr/include/string.h" 3 4
extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)))
    __attribute__ ((__access__ (__read_only__, 1, 2)))
    __attribute__ ((__access__ (__read_only__, 3, 4)));



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));




extern size_t strlen (const char *__s)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern size_t strnlen (const char *__string, size_t __maxlen)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern char *strerror (int __errnum) noexcept (true);
# 444 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     noexcept (true) __attribute__ ((__nonnull__ (2))) __attribute__ ((__access__ (__write_only__, 2, 3)));




extern const char *strerrordesc_np (int __err) noexcept (true);

extern const char *strerrorname_np (int __err) noexcept (true);





extern char *strerror_l (int __errnum, locale_t __l) noexcept (true);



# 1 "/usr/include/strings.h" 1 3 4
# 23 "/usr/include/strings.h" 3 4
# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/stddef.h" 1 3 4
# 24 "/usr/include/strings.h" 2 3 4






extern "C" {



extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bcopy (const void *__src, void *__dest, size_t __n)
  noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1)));



extern "C++"
{
extern char *index (char *__s, int __c)
     noexcept (true) __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *index (const char *__s, int __c)
     noexcept (true) __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 66 "/usr/include/strings.h" 3 4
}







extern "C++"
{
extern char *rindex (char *__s, int __c)
     noexcept (true) __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *rindex (const char *__s, int __c)
     noexcept (true) __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 94 "/usr/include/strings.h" 3 4
}
# 104 "/usr/include/strings.h" 3 4
extern int ffs (int __i) noexcept (true) __attribute__ ((__const__));





extern int ffsl (long int __l) noexcept (true) __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     noexcept (true) __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));






extern int strcasecmp_l (const char *__s1, const char *__s2, locale_t __loc)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));



extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, locale_t __loc)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));


}
# 463 "/usr/include/string.h" 2 3 4



extern void explicit_bzero (void *__s, size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1)))
    __attribute__ ((__access__ (__write_only__, 1, 2)));



extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) noexcept (true);



extern const char *sigabbrev_np (int __sig) noexcept (true);


extern const char *sigdescr_np (int __sig) noexcept (true);



extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));




extern size_t strlcpy (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
  noexcept (true) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__access__ (__write_only__, 1, 3)));



extern size_t strlcat (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
  noexcept (true) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__access__ (__read_write__, 1, 3)));




extern int strverscmp (const char *__s1, const char *__s2)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) noexcept (true) __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1)))
    __attribute__ ((__access__ (__read_write__, 1, 2)));







extern "C++" char *basename (char *__filename)
     noexcept (true) __asm ("basename") __attribute__ ((__nonnull__ (1)));
extern "C++" const char *basename (const char *__filename)
     noexcept (true) __asm ("basename") __attribute__ ((__nonnull__ (1)));
# 552 "/usr/include/string.h" 3 4
}
# 44 "/usr/include/c++/14.2.1/cstring" 2 3
# 72 "/usr/include/c++/14.2.1/cstring" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::memchr;
  using ::memcmp;
  using ::memcpy;
  using ::memmove;
  using ::memset;
  using ::strcat;
  using ::strcmp;
  using ::strcoll;
  using ::strcpy;
  using ::strcspn;
  using ::strerror;
  using ::strlen;
  using ::strncat;
  using ::strncmp;
  using ::strncpy;
  using ::strspn;

  using ::strtok;

  using ::strxfrm;
  using ::strchr;
  using ::strpbrk;
  using ::strrchr;
  using ::strstr;
# 125 "/usr/include/c++/14.2.1/cstring" 3

}
}
# 52 "/usr/include/glm/gtc/type_ptr.hpp" 2 3 4





namespace glm
{





 template<typename genType>
 [[nodiscard]] typename genType::value_type const * value_ptr(genType const& v);



 template <typename T, qualifier Q>
 [[nodiscard]] vec<1, T, Q> make_vec1(vec<1, T, Q> const& v);



 template <typename T, qualifier Q>
 [[nodiscard]] vec<1, T, Q> make_vec1(vec<2, T, Q> const& v);



 template <typename T, qualifier Q>
 [[nodiscard]] vec<1, T, Q> make_vec1(vec<3, T, Q> const& v);



 template <typename T, qualifier Q>
 [[nodiscard]] vec<1, T, Q> make_vec1(vec<4, T, Q> const& v);



 template <typename T, qualifier Q>
 [[nodiscard]] vec<2, T, Q> make_vec2(vec<1, T, Q> const& v);



 template <typename T, qualifier Q>
 [[nodiscard]] vec<2, T, Q> make_vec2(vec<2, T, Q> const& v);



 template <typename T, qualifier Q>
 [[nodiscard]] vec<2, T, Q> make_vec2(vec<3, T, Q> const& v);



 template <typename T, qualifier Q>
 [[nodiscard]] vec<2, T, Q> make_vec2(vec<4, T, Q> const& v);



 template <typename T, qualifier Q>
 [[nodiscard]] vec<3, T, Q> make_vec3(vec<1, T, Q> const& v);



 template <typename T, qualifier Q>
 [[nodiscard]] vec<3, T, Q> make_vec3(vec<2, T, Q> const& v);



 template <typename T, qualifier Q>
 [[nodiscard]] vec<3, T, Q> make_vec3(vec<3, T, Q> const& v);



 template <typename T, qualifier Q>
 [[nodiscard]] vec<3, T, Q> make_vec3(vec<4, T, Q> const& v);



 template <typename T, qualifier Q>
 [[nodiscard]] vec<4, T, Q> make_vec4(vec<1, T, Q> const& v);



 template <typename T, qualifier Q>
 [[nodiscard]] vec<4, T, Q> make_vec4(vec<2, T, Q> const& v);



 template <typename T, qualifier Q>
 [[nodiscard]] vec<4, T, Q> make_vec4(vec<3, T, Q> const& v);



 template <typename T, qualifier Q>
 [[nodiscard]] vec<4, T, Q> make_vec4(vec<4, T, Q> const& v);



 template<typename T>
 [[nodiscard]] vec<2, T, defaultp> make_vec2(T const * const ptr);



 template<typename T>
 [[nodiscard]] vec<3, T, defaultp> make_vec3(T const * const ptr);



 template<typename T>
 [[nodiscard]] vec<4, T, defaultp> make_vec4(T const * const ptr);



 template<typename T>
 [[nodiscard]] mat<2, 2, T, defaultp> make_mat2x2(T const * const ptr);



 template<typename T>
 [[nodiscard]] mat<2, 3, T, defaultp> make_mat2x3(T const * const ptr);



 template<typename T>
 [[nodiscard]] mat<2, 4, T, defaultp> make_mat2x4(T const * const ptr);



 template<typename T>
 [[nodiscard]] mat<3, 2, T, defaultp> make_mat3x2(T const * const ptr);



 template<typename T>
 [[nodiscard]] mat<3, 3, T, defaultp> make_mat3x3(T const * const ptr);



 template<typename T>
 [[nodiscard]] mat<3, 4, T, defaultp> make_mat3x4(T const * const ptr);



 template<typename T>
 [[nodiscard]] mat<4, 2, T, defaultp> make_mat4x2(T const * const ptr);



 template<typename T>
 [[nodiscard]] mat<4, 3, T, defaultp> make_mat4x3(T const * const ptr);



 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> make_mat4x4(T const * const ptr);



 template<typename T>
 [[nodiscard]] mat<2, 2, T, defaultp> make_mat2(T const * const ptr);



 template<typename T>
 [[nodiscard]] mat<3, 3, T, defaultp> make_mat3(T const * const ptr);



 template<typename T>
 [[nodiscard]] mat<4, 4, T, defaultp> make_mat4(T const * const ptr);



 template<typename T>
 [[nodiscard]] qua<T, defaultp> make_quat(T const * const ptr);


}

# 1 "/usr/include/glm/gtc/type_ptr.inl" 1 3 4


# 1 "/usr/include/c++/14.2.1/cstring" 1 3 4
# 39 "/usr/include/c++/14.2.1/cstring" 3 4
       
# 40 "/usr/include/c++/14.2.1/cstring" 3


# 1 "/usr/include/c++/14.2.1/bits/version.h" 1 3
# 47 "/usr/include/c++/14.2.1/bits/version.h" 3
       
# 48 "/usr/include/c++/14.2.1/bits/version.h" 3
# 43 "/usr/include/c++/14.2.1/cstring" 2 3
# 4 "/usr/include/glm/gtc/type_ptr.inl" 2 3 4

namespace glm
{



 template<typename T, qualifier Q>
 inline T const* value_ptr(vec<2, T, Q> const& v)
 {
  return &(v.x);
 }

 template<typename T, qualifier Q>
 inline T* value_ptr(vec<2, T, Q>& v)
 {
  return &(v.x);
 }

 template<typename T, qualifier Q>
 inline T const * value_ptr(vec<3, T, Q> const& v)
 {
  return &(v.x);
 }

 template<typename T, qualifier Q>
 inline T* value_ptr(vec<3, T, Q>& v)
 {
  return &(v.x);
 }

 template<typename T, qualifier Q>
 inline T const* value_ptr(vec<4, T, Q> const& v)
 {
  return &(v.x);
 }

 template<typename T, qualifier Q>
 inline T* value_ptr(vec<4, T, Q>& v)
 {
  return &(v.x);
 }

 template<typename T, qualifier Q>
 inline T const* value_ptr(mat<2, 2, T, Q> const& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T* value_ptr(mat<2, 2, T, Q>& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T const* value_ptr(mat<3, 3, T, Q> const& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T* value_ptr(mat<3, 3, T, Q>& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T const* value_ptr(mat<4, 4, T, Q> const& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T* value_ptr(mat<4, 4, T, Q>& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T const* value_ptr(mat<2, 3, T, Q> const& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T* value_ptr(mat<2, 3, T, Q>& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T const* value_ptr(mat<3, 2, T, Q> const& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T* value_ptr(mat<3, 2, T, Q>& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T const* value_ptr(mat<2, 4, T, Q> const& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T* value_ptr(mat<2, 4, T, Q>& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T const* value_ptr(mat<4, 2, T, Q> const& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T* value_ptr(mat<4, 2, T, Q>& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T const* value_ptr(mat<3, 4, T, Q> const& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T* value_ptr(mat<3, 4, T, Q>& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T const* value_ptr(mat<4, 3, T, Q> const& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T * value_ptr(mat<4, 3, T, Q>& m)
 {
  return &(m[0].x);
 }

 template<typename T, qualifier Q>
 inline T const * value_ptr(qua<T, Q> const& q)
 {
  return &(q[0]);
 }

 template<typename T, qualifier Q>
 inline T* value_ptr(qua<T, Q>& q)
 {
  return &(q[0]);
 }

 template <typename T, qualifier Q>
 [[nodiscard]] vec<1, T, Q> make_vec1(vec<1, T, Q> const& v)
 {
  return v;
 }

 template <typename T, qualifier Q>
 [[nodiscard]] vec<1, T, Q> make_vec1(vec<2, T, Q> const& v)
 {
  return vec<1, T, Q>(v);
 }

 template <typename T, qualifier Q>
 [[nodiscard]] vec<1, T, Q> make_vec1(vec<3, T, Q> const& v)
 {
  return vec<1, T, Q>(v);
 }

 template <typename T, qualifier Q>
 [[nodiscard]] vec<1, T, Q> make_vec1(vec<4, T, Q> const& v)
 {
  return vec<1, T, Q>(v);
 }

 template <typename T, qualifier Q>
 [[nodiscard]] vec<2, T, Q> make_vec2(vec<1, T, Q> const& v)
 {
  return vec<2, T, Q>(v.x, static_cast<T>(0));
 }

 template <typename T, qualifier Q>
 [[nodiscard]] vec<2, T, Q> make_vec2(vec<2, T, Q> const& v)
 {
  return v;
 }

 template <typename T, qualifier Q>
 [[nodiscard]] vec<2, T, Q> make_vec2(vec<3, T, Q> const& v)
 {
  return vec<2, T, Q>(v);
 }

 template <typename T, qualifier Q>
 [[nodiscard]] vec<2, T, Q> make_vec2(vec<4, T, Q> const& v)
 {
  return vec<2, T, Q>(v);
 }

 template <typename T, qualifier Q>
 [[nodiscard]] vec<3, T, Q> make_vec3(vec<1, T, Q> const& v)
 {
  return vec<3, T, Q>(v.x, static_cast<T>(0), static_cast<T>(0));
 }

 template <typename T, qualifier Q>
 [[nodiscard]] vec<3, T, Q> make_vec3(vec<2, T, Q> const& v)
 {
  return vec<3, T, Q>(v.x, v.y, static_cast<T>(0));
 }

 template <typename T, qualifier Q>
 [[nodiscard]] vec<3, T, Q> make_vec3(vec<3, T, Q> const& v)
 {
  return v;
 }

 template <typename T, qualifier Q>
 [[nodiscard]] vec<3, T, Q> make_vec3(vec<4, T, Q> const& v)
 {
  return vec<3, T, Q>(v);
 }

 template <typename T, qualifier Q>
 [[nodiscard]] vec<4, T, Q> make_vec4(vec<1, T, Q> const& v)
 {
  return vec<4, T, Q>(v.x, static_cast<T>(0), static_cast<T>(0), static_cast<T>(1));
 }

 template <typename T, qualifier Q>
 [[nodiscard]] vec<4, T, Q> make_vec4(vec<2, T, Q> const& v)
 {
  return vec<4, T, Q>(v.x, v.y, static_cast<T>(0), static_cast<T>(1));
 }

 template <typename T, qualifier Q>
 [[nodiscard]] vec<4, T, Q> make_vec4(vec<3, T, Q> const& v)
 {
  return vec<4, T, Q>(v.x, v.y, v.z, static_cast<T>(1));
 }

 template <typename T, qualifier Q>
 [[nodiscard]] vec<4, T, Q> make_vec4(vec<4, T, Q> const& v)
 {
  return v;
 }

 template<typename T>
 inline vec<2, T, defaultp> make_vec2(T const *const ptr)
 {
  vec<2, T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(vec<2, T, defaultp>));
  return Result;
 }

 template<typename T>
 inline vec<3, T, defaultp> make_vec3(T const *const ptr)
 {
  vec<3, T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(vec<3, T, defaultp>));
  return Result;
 }

 template<typename T>
 inline vec<4, T, defaultp> make_vec4(T const *const ptr)
 {
  vec<4, T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(vec<4, T, defaultp>));
  return Result;
 }

 template<typename T>
 inline mat<2, 2, T, defaultp> make_mat2x2(T const *const ptr)
 {
  mat<2, 2, T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(mat<2, 2, T, defaultp>));
  return Result;
 }

 template<typename T>
 inline mat<2, 3, T, defaultp> make_mat2x3(T const *const ptr)
 {
  mat<2, 3, T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(mat<2, 3, T, defaultp>));
  return Result;
 }

 template<typename T>
 inline mat<2, 4, T, defaultp> make_mat2x4(T const *const ptr)
 {
  mat<2, 4, T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(mat<2, 4, T, defaultp>));
  return Result;
 }

 template<typename T>
 inline mat<3, 2, T, defaultp> make_mat3x2(T const *const ptr)
 {
  mat<3, 2, T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(mat<3, 2, T, defaultp>));
  return Result;
 }

 template<typename T>
 inline mat<3, 3, T, defaultp> make_mat3x3(T const *const ptr)
 {
  mat<3, 3, T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(mat<3, 3, T, defaultp>));
  return Result;
 }

 template<typename T>
 inline mat<3, 4, T, defaultp> make_mat3x4(T const *const ptr)
 {
  mat<3, 4, T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(mat<3, 4, T, defaultp>));
  return Result;
 }

 template<typename T>
 inline mat<4, 2, T, defaultp> make_mat4x2(T const *const ptr)
 {
  mat<4, 2, T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(mat<4, 2, T, defaultp>));
  return Result;
 }

 template<typename T>
 inline mat<4, 3, T, defaultp> make_mat4x3(T const *const ptr)
 {
  mat<4, 3, T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(mat<4, 3, T, defaultp>));
  return Result;
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> make_mat4x4(T const *const ptr)
 {
  mat<4, 4, T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(mat<4, 4, T, defaultp>));
  return Result;
 }

 template<typename T>
 inline mat<2, 2, T, defaultp> make_mat2(T const *const ptr)
 {
  return make_mat2x2(ptr);
 }

 template<typename T>
 inline mat<3, 3, T, defaultp> make_mat3(T const *const ptr)
 {
  return make_mat3x3(ptr);
 }

 template<typename T>
 inline mat<4, 4, T, defaultp> make_mat4(T const *const ptr)
 {
  return make_mat4x4(ptr);
 }

 template<typename T>
 inline qua<T, defaultp> make_quat(T const *const ptr)
 {
  qua<T, defaultp> Result;
  memcpy(value_ptr(Result), ptr, sizeof(qua<T, defaultp>));
  return Result;
 }


}
# 231 "/usr/include/glm/gtc/type_ptr.hpp" 2 3 4
# 6 "/home/devkon/CLionProjects/VertexLab/main.cpp" 2


# 1 "/home/devkon/CLionProjects/VertexLab/camera.h" 1







# 7 "/home/devkon/CLionProjects/VertexLab/camera.h"
class Camera {
public:
    glm::vec3 position;
    glm::vec3 target;
    glm::vec3 up;

    float yaw, pitch, distance;

    Camera();
    void updatePosition();
    glm::mat4 getViewMatrix();
    void processMouseMovement(float xOffset, float yOffset);
    void processMouseScroll(float yOffset);
    void processKeyboard(GLFWwindow* window, float deltaTime);
};
# 9 "/home/devkon/CLionProjects/VertexLab/main.cpp" 2
# 1 "/home/devkon/CLionProjects/VertexLab/utils.h" 1
# 9 "/home/devkon/CLionProjects/VertexLab/utils.h"
void InitializeGLFW();
GLFWwindow* CreateWindow(int width = 1280, int height = 960, const char* title = "3D Grid Environment");
void InitializeGLEW();
void SetupOpenGLSettings();
void SetupCallbacks(GLFWwindow* window);
void openglDebugCallback(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* message, const void* userParam);
# 10 "/home/devkon/CLionProjects/VertexLab/main.cpp" 2
# 1 "/home/devkon/CLionProjects/VertexLab/drawing_utils.h" 1
# 10 "/home/devkon/CLionProjects/VertexLab/drawing_utils.h"
# 1 "/usr/include/c++/14.2.1/vector" 1 3
# 58 "/usr/include/c++/14.2.1/vector" 3
       
# 59 "/usr/include/c++/14.2.1/vector" 3




# 1 "/usr/include/c++/14.2.1/bits/allocator.h" 1 3
# 46 "/usr/include/c++/14.2.1/bits/allocator.h" 3
# 1 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/c++allocator.h" 1 3
# 33 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/c++allocator.h" 3
# 1 "/usr/include/c++/14.2.1/bits/new_allocator.h" 1 3
# 41 "/usr/include/c++/14.2.1/bits/new_allocator.h" 3

# 41 "/usr/include/c++/14.2.1/bits/new_allocator.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 62 "/usr/include/c++/14.2.1/bits/new_allocator.h" 3
  template<typename _Tp>
    class __new_allocator
    {
    public:
      typedef _Tp value_type;
      typedef std::size_t size_type;
      typedef std::ptrdiff_t difference_type;
# 83 "/usr/include/c++/14.2.1/bits/new_allocator.h" 3
      typedef std::true_type propagate_on_container_move_assignment;


      __attribute__((__always_inline__))
      constexpr
      __new_allocator() noexcept { }

      __attribute__((__always_inline__))
      constexpr
      __new_allocator(const __new_allocator&) noexcept { }

      template<typename _Tp1>
 __attribute__((__always_inline__))
 constexpr
 __new_allocator(const __new_allocator<_Tp1>&) noexcept { }


      __new_allocator& operator=(const __new_allocator&) = default;
# 125 "/usr/include/c++/14.2.1/bits/new_allocator.h" 3
      [[__nodiscard__]] _Tp*
      allocate(size_type __n, const void* = static_cast<const void*>(0))
      {



 static_assert(sizeof(_Tp) != 0, "cannot allocate incomplete types");


 if (__builtin_expect(__n > this->_M_max_size(), false))
   {


     if (__n > (std::size_t(-1) / sizeof(_Tp)))
       std::__throw_bad_array_new_length();
     std::__throw_bad_alloc();
   }


 if (alignof(_Tp) > 16)
   {
     std::align_val_t __al = std::align_val_t(alignof(_Tp));
     return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp),
          __al));
   }

 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }


      void
      deallocate(_Tp* __p, size_type __n __attribute__ ((__unused__)))
      {







 if (alignof(_Tp) > 16)
   {
     ::operator delete((__p), (__n) * sizeof(_Tp),
         std::align_val_t(alignof(_Tp)));
     return;
   }

 ::operator delete((__p), (__n) * sizeof(_Tp));
      }
# 213 "/usr/include/c++/14.2.1/bits/new_allocator.h" 3
      template<typename _Up>
 friend __attribute__((__always_inline__)) constexpr bool
 operator==(const __new_allocator&, const __new_allocator<_Up>&)
 noexcept
 { return true; }
# 227 "/usr/include/c++/14.2.1/bits/new_allocator.h" 3
    private:
      __attribute__((__always_inline__))
      constexpr size_type
      _M_max_size() const noexcept
      {

 return std::size_t(0x7fffffffffffffffL) / sizeof(_Tp);



      }
    };


}
# 34 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/c++allocator.h" 2 3


namespace std
{
# 46 "/usr/include/c++/14.2.1/x86_64-pc-linux-gnu/bits/c++allocator.h" 3
  template<typename _Tp>
    using __allocator_base = __new_allocator<_Tp>;
}
# 47 "/usr/include/c++/14.2.1/bits/allocator.h" 2 3
# 1 "/usr/include/c++/14.2.1/bits/memoryfwd.h" 1 3
# 46 "/usr/include/c++/14.2.1/bits/memoryfwd.h" 3
       
# 47 "/usr/include/c++/14.2.1/bits/memoryfwd.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{

# 64 "/usr/include/c++/14.2.1/bits/memoryfwd.h" 3
  template<typename>
    class allocator;

  template<>
    class allocator<void>;



  template<typename, typename>
    struct uses_allocator;

  template<typename>
    struct allocator_traits;





}
# 48 "/usr/include/c++/14.2.1/bits/allocator.h" 2 3




namespace std __attribute__ ((__visibility__ ("default")))
{

# 72 "/usr/include/c++/14.2.1/bits/allocator.h" 3
  template<>
    class allocator<void>
    {
    public:
      typedef void value_type;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
# 93 "/usr/include/c++/14.2.1/bits/allocator.h" 3
      using propagate_on_container_move_assignment = true_type;

      using is_always_equal
 __attribute__ ((__deprecated__ ("use '" "std::allocator_traits::is_always_equal" "' instead")))
 = true_type;




      allocator() = default;
      ~allocator() = default;

      template<typename _Up>
 __attribute__((__always_inline__))
 constexpr
 allocator(const allocator<_Up>&) noexcept { }






    };
# 127 "/usr/include/c++/14.2.1/bits/allocator.h" 3
  template<typename _Tp>
    class allocator : public __allocator_base<_Tp>
    {
    public:
      typedef _Tp value_type;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
# 150 "/usr/include/c++/14.2.1/bits/allocator.h" 3
      using propagate_on_container_move_assignment = true_type;

      using is_always_equal
 __attribute__ ((__deprecated__ ("use '" "std::allocator_traits::is_always_equal" "' instead")))
 = true_type;




      __attribute__((__always_inline__))
      constexpr
      allocator() noexcept { }

      __attribute__((__always_inline__))
      constexpr
      allocator(const allocator& __a) noexcept
      : __allocator_base<_Tp>(__a) { }



      allocator& operator=(const allocator&) = default;


      template<typename _Tp1>
 __attribute__((__always_inline__))
 constexpr
 allocator(const allocator<_Tp1>&) noexcept { }

      __attribute__((__always_inline__))

      constexpr

      ~allocator() noexcept { }


      [[nodiscard,__gnu__::__always_inline__]]
      constexpr _Tp*
      allocate(size_t __n)
      {
 if (std::__is_constant_evaluated())
   {
     if (__builtin_mul_overflow(__n, sizeof(_Tp), &__n))
       std::__throw_bad_array_new_length();
     return static_cast<_Tp*>(::operator new(__n));
   }

 return __allocator_base<_Tp>::allocate(__n, 0);
      }

      [[__gnu__::__always_inline__]]
      constexpr void
      deallocate(_Tp* __p, size_t __n)
      {
 if (std::__is_constant_evaluated())
   {
     ::operator delete(__p);
     return;
   }
 __allocator_base<_Tp>::deallocate(__p, __n);
      }


      friend __attribute__((__always_inline__)) constexpr
      bool
      operator==(const allocator&, const allocator&) noexcept
      { return true; }
# 225 "/usr/include/c++/14.2.1/bits/allocator.h" 3
    };






  template<typename _T1, typename _T2>
    __attribute__((__always_inline__))
    inline constexpr bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    noexcept
    { return true; }
# 252 "/usr/include/c++/14.2.1/bits/allocator.h" 3
  template<typename _Tp>
    class allocator<const _Tp>
    {
    public:
      typedef _Tp value_type;
      allocator() { }
      template<typename _Up> allocator(const allocator<_Up>&) { }
    };

  template<typename _Tp>
    class allocator<volatile _Tp>
    {
    public:
      typedef _Tp value_type;
      allocator() { }
      template<typename _Up> allocator(const allocator<_Up>&) { }
    };

  template<typename _Tp>
    class allocator<const volatile _Tp>
    {
    public:
      typedef _Tp value_type;
      allocator() { }
      template<typename _Up> allocator(const allocator<_Up>&) { }
    };







  extern template class allocator<char>;
  extern template class allocator<wchar_t>;






}
# 64 "/usr/include/c++/14.2.1/vector" 2 3

# 1 "/usr/include/c++/14.2.1/bits/stl_uninitialized.h" 1 3
# 64 "/usr/include/c++/14.2.1/bits/stl_uninitialized.h" 3
# 1 "/usr/include/c++/14.2.1/ext/alloc_traits.h" 1 3
# 32 "/usr/include/c++/14.2.1/ext/alloc_traits.h" 3
       
# 33 "/usr/include/c++/14.2.1/ext/alloc_traits.h" 3

# 1 "/usr/include/c++/14.2.1/bits/alloc_traits.h" 1 3
# 46 "/usr/include/c++/14.2.1/bits/alloc_traits.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{




  struct __allocator_traits_base
  {
    template<typename _Tp, typename _Up, typename = void>
      struct __rebind : __replace_first_arg<_Tp, _Up>
      {
 static_assert(is_same<
   typename __replace_first_arg<_Tp, typename _Tp::value_type>::type,
   _Tp>::value,
   "allocator_traits<A>::rebind_alloc<A::value_type> must be A");
      };

    template<typename _Tp, typename _Up>
      struct __rebind<_Tp, _Up,
        __void_t<typename _Tp::template rebind<_Up>::other>>
      {
 using type = typename _Tp::template rebind<_Up>::other;

 static_assert(is_same<
   typename _Tp::template rebind<typename _Tp::value_type>::other,
   _Tp>::value,
   "allocator_traits<A>::rebind_alloc<A::value_type> must be A");
      };

  protected:
    template<typename _Tp>
      using __pointer = typename _Tp::pointer;
    template<typename _Tp>
      using __c_pointer = typename _Tp::const_pointer;
    template<typename _Tp>
      using __v_pointer = typename _Tp::void_pointer;
    template<typename _Tp>
      using __cv_pointer = typename _Tp::const_void_pointer;
    template<typename _Tp>
      using __pocca = typename _Tp::propagate_on_container_copy_assignment;
    template<typename _Tp>
      using __pocma = typename _Tp::propagate_on_container_move_assignment;
    template<typename _Tp>
      using __pocs = typename _Tp::propagate_on_container_swap;
    template<typename _Tp>
      using __equal = __type_identity<typename _Tp::is_always_equal>;
  };

  template<typename _Alloc, typename _Up>
    using __alloc_rebind
      = typename __allocator_traits_base::template __rebind<_Alloc, _Up>::type;
# 105 "/usr/include/c++/14.2.1/bits/alloc_traits.h" 3
  template<typename _Alloc>
    struct allocator_traits : __allocator_traits_base
    {

      typedef _Alloc allocator_type;

      typedef typename _Alloc::value_type value_type;






      using pointer = __detected_or_t<value_type*, __pointer, _Alloc>;

    private:

      template<template<typename> class _Func, typename _Tp, typename = void>
 struct _Ptr
 {
   using type = typename pointer_traits<pointer>::template rebind<_Tp>;
 };

      template<template<typename> class _Func, typename _Tp>
 struct _Ptr<_Func, _Tp, __void_t<_Func<_Alloc>>>
 {
   using type = _Func<_Alloc>;
 };


      template<typename _A2, typename _PtrT, typename = void>
 struct _Diff
 { using type = typename pointer_traits<_PtrT>::difference_type; };

      template<typename _A2, typename _PtrT>
 struct _Diff<_A2, _PtrT, __void_t<typename _A2::difference_type>>
 { using type = typename _A2::difference_type; };


      template<typename _A2, typename _DiffT, typename = void>
 struct _Size : make_unsigned<_DiffT> { };

      template<typename _A2, typename _DiffT>
 struct _Size<_A2, _DiffT, __void_t<typename _A2::size_type>>
 { using type = typename _A2::size_type; };

    public:






      using const_pointer = typename _Ptr<__c_pointer, const value_type>::type;







      using void_pointer = typename _Ptr<__v_pointer, void>::type;







      using const_void_pointer = typename _Ptr<__cv_pointer, const void>::type;







      using difference_type = typename _Diff<_Alloc, pointer>::type;







      using size_type = typename _Size<_Alloc, difference_type>::type;







      using propagate_on_container_copy_assignment
 = __detected_or_t<false_type, __pocca, _Alloc>;







      using propagate_on_container_move_assignment
 = __detected_or_t<false_type, __pocma, _Alloc>;







      using propagate_on_container_swap
 = __detected_or_t<false_type, __pocs, _Alloc>;







      using is_always_equal
 = typename __detected_or_t<is_empty<_Alloc>, __equal, _Alloc>::type;

      template<typename _Tp>
 using rebind_alloc = __alloc_rebind<_Alloc, _Tp>;
      template<typename _Tp>
 using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;

    private:
      template<typename _Alloc2>
 static constexpr auto
 _S_allocate(_Alloc2& __a, size_type __n, const_void_pointer __hint, int)
 -> decltype(__a.allocate(__n, __hint))
 { return __a.allocate(__n, __hint); }

      template<typename _Alloc2>
 static constexpr pointer
 _S_allocate(_Alloc2& __a, size_type __n, const_void_pointer, ...)
 { return __a.allocate(__n); }

      template<typename _Tp, typename... _Args>
 struct __construct_helper
 {
   template<typename _Alloc2,
     typename = decltype(std::declval<_Alloc2*>()->construct(
    std::declval<_Tp*>(), std::declval<_Args>()...))>
     static true_type __test(int);

   template<typename>
     static false_type __test(...);

   using type = decltype(__test<_Alloc>(0));
 };

      template<typename _Tp, typename... _Args>
 using __has_construct
   = typename __construct_helper<_Tp, _Args...>::type;

      template<typename _Tp, typename... _Args>
 static constexpr _Require<__has_construct<_Tp, _Args...>>
 _S_construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
 noexcept(noexcept(__a.construct(__p, std::forward<_Args>(__args)...)))
 { __a.construct(__p, std::forward<_Args>(__args)...); }

      template<typename _Tp, typename... _Args>
 static constexpr
 _Require<__and_<__not_<__has_construct<_Tp, _Args...>>,
          is_constructible<_Tp, _Args...>>>
 _S_construct(_Alloc&, _Tp* __p, _Args&&... __args)
 noexcept(std::is_nothrow_constructible<_Tp, _Args...>::value)
 {



   std::construct_at(__p, std::forward<_Args>(__args)...);

 }

      template<typename _Alloc2, typename _Tp>
 static constexpr auto
 _S_destroy(_Alloc2& __a, _Tp* __p, int)
 noexcept(noexcept(__a.destroy(__p)))
 -> decltype(__a.destroy(__p))
 { __a.destroy(__p); }

      template<typename _Alloc2, typename _Tp>
 static constexpr void
 _S_destroy(_Alloc2&, _Tp* __p, ...)
 noexcept(std::is_nothrow_destructible<_Tp>::value)
 { std::_Destroy(__p); }

      template<typename _Alloc2>
 static constexpr auto
 _S_max_size(_Alloc2& __a, int)
 -> decltype(__a.max_size())
 { return __a.max_size(); }

      template<typename _Alloc2>
 static constexpr size_type
 _S_max_size(_Alloc2&, ...)
 {


   return __gnu_cxx::__numeric_traits<size_type>::__max
     / sizeof(value_type);
 }

      template<typename _Alloc2>
 static constexpr auto
 _S_select(_Alloc2& __a, int)
 -> decltype(__a.select_on_container_copy_construction())
 { return __a.select_on_container_copy_construction(); }

      template<typename _Alloc2>
 static constexpr _Alloc2
 _S_select(_Alloc2& __a, ...)
 { return __a; }

    public:
# 332 "/usr/include/c++/14.2.1/bits/alloc_traits.h" 3
      [[__nodiscard__]] static constexpr pointer
      allocate(_Alloc& __a, size_type __n)
      { return __a.allocate(__n); }
# 347 "/usr/include/c++/14.2.1/bits/alloc_traits.h" 3
      [[__nodiscard__]] static constexpr pointer
      allocate(_Alloc& __a, size_type __n, const_void_pointer __hint)
      { return _S_allocate(__a, __n, __hint, 0); }
# 359 "/usr/include/c++/14.2.1/bits/alloc_traits.h" 3
      static constexpr void
      deallocate(_Alloc& __a, pointer __p, size_type __n)
      { __a.deallocate(__p, __n); }
# 374 "/usr/include/c++/14.2.1/bits/alloc_traits.h" 3
      template<typename _Tp, typename... _Args>
 static constexpr auto
 construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
 noexcept(noexcept(_S_construct(__a, __p,
           std::forward<_Args>(__args)...)))
 -> decltype(_S_construct(__a, __p, std::forward<_Args>(__args)...))
 { _S_construct(__a, __p, std::forward<_Args>(__args)...); }
# 390 "/usr/include/c++/14.2.1/bits/alloc_traits.h" 3
      template<typename _Tp>
 static constexpr void
 destroy(_Alloc& __a, _Tp* __p)
 noexcept(noexcept(_S_destroy(__a, __p, 0)))
 { _S_destroy(__a, __p, 0); }
# 404 "/usr/include/c++/14.2.1/bits/alloc_traits.h" 3
      static constexpr size_type
      max_size(const _Alloc& __a) noexcept
      { return _S_max_size(__a, 0); }
# 416 "/usr/include/c++/14.2.1/bits/alloc_traits.h" 3
      static constexpr _Alloc
      select_on_container_copy_construction(const _Alloc& __rhs)
      { return _S_select(__rhs, 0); }
    };



  template<typename _Tp>
    struct allocator_traits<allocator<_Tp>>
    {

      using allocator_type = allocator<_Tp>;


      using value_type = _Tp;


      using pointer = _Tp*;


      using const_pointer = const _Tp*;


      using void_pointer = void*;


      using const_void_pointer = const void*;


      using difference_type = std::ptrdiff_t;


      using size_type = std::size_t;


      using propagate_on_container_copy_assignment = false_type;


      using propagate_on_container_move_assignment = true_type;


      using propagate_on_container_swap = false_type;


      using is_always_equal = true_type;

      template<typename _Up>
 using rebind_alloc = allocator<_Up>;

      template<typename _Up>
 using rebind_traits = allocator_traits<allocator<_Up>>;
# 475 "/usr/include/c++/14.2.1/bits/alloc_traits.h" 3
      [[__nodiscard__,__gnu__::__always_inline__]]
      static constexpr pointer
      allocate(allocator_type& __a, size_type __n)
      { return __a.allocate(__n); }
# 490 "/usr/include/c++/14.2.1/bits/alloc_traits.h" 3
      [[__nodiscard__,__gnu__::__always_inline__]]
      static constexpr pointer
      allocate(allocator_type& __a, size_type __n,
        [[maybe_unused]] const_void_pointer __hint)
      {



 return __a.allocate(__n);

      }
# 510 "/usr/include/c++/14.2.1/bits/alloc_traits.h" 3
      [[__gnu__::__always_inline__]]
      static constexpr void
      deallocate(allocator_type& __a, pointer __p, size_type __n)
      { __a.deallocate(__p, __n); }
# 526 "/usr/include/c++/14.2.1/bits/alloc_traits.h" 3
      template<typename _Up, typename... _Args>
 [[__gnu__::__always_inline__]]
 static constexpr void
 construct(allocator_type& __a __attribute__((__unused__)), _Up* __p,
    _Args&&... __args)
 noexcept(std::is_nothrow_constructible<_Up, _Args...>::value)
 {



   std::construct_at(__p, std::forward<_Args>(__args)...);

 }
# 547 "/usr/include/c++/14.2.1/bits/alloc_traits.h" 3
      template<typename _Up>
 [[__gnu__::__always_inline__]]
 static constexpr void
 destroy(allocator_type& __a __attribute__((__unused__)), _Up* __p)
 noexcept(is_nothrow_destructible<_Up>::value)
 {



   std::destroy_at(__p);

 }






      [[__gnu__::__always_inline__]]
      static constexpr size_type
      max_size(const allocator_type& __a __attribute__((__unused__))) noexcept
      {



 return size_t(-1) / sizeof(value_type);

      }






      [[__gnu__::__always_inline__]]
      static constexpr allocator_type
      select_on_container_copy_construction(const allocator_type& __rhs)
      { return __rhs; }
    };


  template<>
    struct allocator_traits<allocator<void>>
    {

      using allocator_type = allocator<void>;


      using value_type = void;


      using pointer = void*;


      using const_pointer = const void*;


      using void_pointer = void*;


      using const_void_pointer = const void*;


      using difference_type = std::ptrdiff_t;


      using size_type = std::size_t;


      using propagate_on_container_copy_assignment = false_type;


      using propagate_on_container_move_assignment = true_type;


      using propagate_on_container_swap = false_type;


      using is_always_equal = true_type;

      template<typename _Up>
 using rebind_alloc = allocator<_Up>;

      template<typename _Up>
 using rebind_traits = allocator_traits<allocator<_Up>>;


      static void*
      allocate(allocator_type&, size_type, const void* = nullptr) = delete;


      static void
      deallocate(allocator_type&, void*, size_type) = delete;
# 652 "/usr/include/c++/14.2.1/bits/alloc_traits.h" 3
      template<typename _Up, typename... _Args>
 [[__gnu__::__always_inline__]]
 static constexpr void
 construct(allocator_type&, _Up* __p, _Args&&... __args)
 noexcept(std::is_nothrow_constructible<_Up, _Args...>::value)
 { std::_Construct(__p, std::forward<_Args>(__args)...); }
# 666 "/usr/include/c++/14.2.1/bits/alloc_traits.h" 3
      template<typename _Up>
 [[__gnu__::__always_inline__]]
 static constexpr void
 destroy(allocator_type&, _Up* __p)
 noexcept(is_nothrow_destructible<_Up>::value)
 { std::_Destroy(__p); }


      static size_type
      max_size(const allocator_type&) = delete;






      [[__gnu__::__always_inline__]]
      static constexpr allocator_type
      select_on_container_copy_construction(const allocator_type& __rhs)
      { return __rhs; }
    };
# 704 "/usr/include/c++/14.2.1/bits/alloc_traits.h" 3
  template<typename _Alloc>
    [[__gnu__::__always_inline__]]
    constexpr inline void
    __alloc_on_copy(_Alloc& __one, const _Alloc& __two)
    {
      using __traits = allocator_traits<_Alloc>;
      using __pocca =
 typename __traits::propagate_on_container_copy_assignment::type;

      if constexpr (__pocca::value)
 __one = __two;



    }

  template<typename _Alloc>
    [[__gnu__::__always_inline__]]
    constexpr _Alloc
    __alloc_on_copy(const _Alloc& __a)
    {
      typedef allocator_traits<_Alloc> __traits;
      return __traits::select_on_container_copy_construction(__a);
    }
# 741 "/usr/include/c++/14.2.1/bits/alloc_traits.h" 3
  template<typename _Alloc>
    [[__gnu__::__always_inline__]]
    constexpr inline void
    __alloc_on_move(_Alloc& __one, _Alloc& __two)
    {
      using __traits = allocator_traits<_Alloc>;
      using __pocma
 = typename __traits::propagate_on_container_move_assignment::type;

      if constexpr (__pocma::value)
 __one = std::move(__two);



    }
# 772 "/usr/include/c++/14.2.1/bits/alloc_traits.h" 3
  template<typename _Alloc>
    [[__gnu__::__always_inline__]]
    constexpr inline void
    __alloc_on_swap(_Alloc& __one, _Alloc& __two)
    {
      using __traits = allocator_traits<_Alloc>;
      using __pocs = typename __traits::propagate_on_container_swap::type;

      if constexpr (__pocs::value)
 {
   using std::swap;
   swap(__one, __two);
 }



    }

  template<typename _Alloc, typename _Tp,
    typename _ValueT = __remove_cvref_t<typename _Alloc::value_type>,
    typename = void>
    struct __is_alloc_insertable_impl
    : false_type
    { };

  template<typename _Alloc, typename _Tp, typename _ValueT>
    struct __is_alloc_insertable_impl<_Alloc, _Tp, _ValueT,
      __void_t<decltype(allocator_traits<_Alloc>::construct(
     std::declval<_Alloc&>(), std::declval<_ValueT*>(),
     std::declval<_Tp>()))>>
    : true_type
    { };




  template<typename _Alloc>
    struct __is_copy_insertable
    : __is_alloc_insertable_impl<_Alloc,
     typename _Alloc::value_type const&>::type
    { };



  template<typename _Tp>
    struct __is_copy_insertable<allocator<_Tp>>
    : is_copy_constructible<_Tp>
    { };





  template<typename _Alloc>
    struct __is_move_insertable
    : __is_alloc_insertable_impl<_Alloc, typename _Alloc::value_type>::type
    { };



  template<typename _Tp>
    struct __is_move_insertable<allocator<_Tp>>
    : is_move_constructible<_Tp>
    { };



  template<typename _Alloc, typename = void>
    struct __is_allocator : false_type { };

  template<typename _Alloc>
    struct __is_allocator<_Alloc,
      __void_t<typename _Alloc::value_type,
        decltype(std::declval<_Alloc&>().allocate(size_t{}))>>
    : true_type { };

  template<typename _Alloc>
    using _RequireAllocator
      = typename enable_if<__is_allocator<_Alloc>::value, _Alloc>::type;

  template<typename _Alloc>
    using _RequireNotAllocator
      = typename enable_if<!__is_allocator<_Alloc>::value, _Alloc>::type;


  template<typename _Alloc>
    concept __allocator_like = requires (_Alloc& __a) {
      typename _Alloc::value_type;
      __a.deallocate(__a.allocate(1u), 1u);
    };







  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) noexcept { } };

  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two) noexcept
      {

 if (__one != __two)
   swap(__one, __two);
      }
    };


  template<typename _Tp, bool
    = __or_<is_copy_constructible<typename _Tp::value_type>,
            is_nothrow_move_constructible<typename _Tp::value_type>>::value>
    struct __shrink_to_fit_aux
    { static bool _S_do_it(_Tp&) noexcept { return false; } };

  template<typename _Tp>
    struct __shrink_to_fit_aux<_Tp, true>
    {
      constexpr
      static bool
      _S_do_it(_Tp& __c) noexcept
      {

 try
   {
     _Tp(__make_move_if_noexcept_iterator(__c.begin()),
  __make_move_if_noexcept_iterator(__c.end()),
  __c.get_allocator()).swap(__c);
     return true;
   }
 catch(...)
   { return false; }



      }
    };
# 922 "/usr/include/c++/14.2.1/bits/alloc_traits.h" 3
  template<typename _ForwardIterator, typename _Allocator>
    constexpr
    void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      _Allocator& __alloc)
    {
      for (; __first != __last; ++__first)



 allocator_traits<_Allocator>::destroy(__alloc,
           std::__addressof(*__first));

    }


  template<typename _ForwardIterator, typename _Tp>
    __attribute__((__always_inline__)) constexpr
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      allocator<_Tp>&)
    {
      std::_Destroy(__first, __last);
    }




}
# 35 "/usr/include/c++/14.2.1/ext/alloc_traits.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{






template<typename _Alloc, typename = typename _Alloc::value_type>
  struct __alloc_traits

  : std::allocator_traits<_Alloc>

  {
    typedef _Alloc allocator_type;

    typedef std::allocator_traits<_Alloc> _Base_type;
    typedef typename _Base_type::value_type value_type;
    typedef typename _Base_type::pointer pointer;
    typedef typename _Base_type::const_pointer const_pointer;
    typedef typename _Base_type::size_type size_type;
    typedef typename _Base_type::difference_type difference_type;

    typedef value_type& reference;
    typedef const value_type& const_reference;
    using _Base_type::allocate;
    using _Base_type::deallocate;
    using _Base_type::construct;
    using _Base_type::destroy;
    using _Base_type::max_size;

  private:
    template<typename _Ptr>
      using __is_custom_pointer
 = std::__and_<std::is_same<pointer, _Ptr>,
        std::__not_<std::is_pointer<_Ptr>>>;

  public:

    template<typename _Ptr, typename... _Args>
      [[__gnu__::__always_inline__]]
      static constexpr
      std::__enable_if_t<__is_custom_pointer<_Ptr>::value>
      construct(_Alloc& __a, _Ptr __p, _Args&&... __args)
      noexcept(noexcept(_Base_type::construct(__a, std::__to_address(__p),
           std::forward<_Args>(__args)...)))
      {
 _Base_type::construct(__a, std::__to_address(__p),
         std::forward<_Args>(__args)...);
      }


    template<typename _Ptr>
      [[__gnu__::__always_inline__]]
      static constexpr
      std::__enable_if_t<__is_custom_pointer<_Ptr>::value>
      destroy(_Alloc& __a, _Ptr __p)
      noexcept(noexcept(_Base_type::destroy(__a, std::__to_address(__p))))
      { _Base_type::destroy(__a, std::__to_address(__p)); }

    [[__gnu__::__always_inline__]]
    static constexpr _Alloc _S_select_on_copy(const _Alloc& __a)
    { return _Base_type::select_on_container_copy_construction(__a); }

    [[__gnu__::__always_inline__]]
    static constexpr void _S_on_swap(_Alloc& __a, _Alloc& __b)
    { std::__alloc_on_swap(__a, __b); }

    [[__gnu__::__always_inline__]]
    static constexpr bool _S_propagate_on_copy_assign()
    { return _Base_type::propagate_on_container_copy_assignment::value; }

    [[__gnu__::__always_inline__]]
    static constexpr bool _S_propagate_on_move_assign()
    { return _Base_type::propagate_on_container_move_assignment::value; }

    [[__gnu__::__always_inline__]]
    static constexpr bool _S_propagate_on_swap()
    { return _Base_type::propagate_on_container_swap::value; }

    [[__gnu__::__always_inline__]]
    static constexpr bool _S_always_equal()
    { return _Base_type::is_always_equal::value; }

    __attribute__((__always_inline__))
    static constexpr bool _S_nothrow_move()
    { return _S_propagate_on_move_assign() || _S_always_equal(); }

    template<typename _Tp>
      struct rebind
      { typedef typename _Base_type::template rebind_alloc<_Tp> other; };
# 180 "/usr/include/c++/14.2.1/ext/alloc_traits.h" 3
  };


}
# 65 "/usr/include/c++/14.2.1/bits/stl_uninitialized.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{

# 81 "/usr/include/c++/14.2.1/bits/stl_uninitialized.h" 3
  template<typename _ValueType, typename _Tp>
    constexpr bool
    __check_constructible()
    {





      static_assert(is_constructible<_ValueType, _Tp>::value,
   "result type must be constructible from input type");

      return true;
    }
# 110 "/usr/include/c++/14.2.1/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    constexpr
    _ForwardIterator
    __do_uninit_copy(_InputIterator __first, _InputIterator __last,
       _ForwardIterator __result)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for (; __first != __last; ++__first, (void)++__cur)
     std::_Construct(std::__addressof(*__cur), *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur);
   throw;
 }
    }

  template<bool _TrivialValueTypes>
    struct __uninitialized_copy
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
 { return std::__do_uninit_copy(__first, __last, __result); }
    };

  template<>
    struct __uninitialized_copy<true>
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        { return std::copy(__first, __last, __result); }
    };
# 161 "/usr/include/c++/14.2.1/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy(_InputIterator __first, _InputIterator __last,
         _ForwardIterator __result)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType2;




      const bool __can_memmove = __is_trivial(_ValueType1);




      using _From = decltype(*__first);

      const bool __assignable
 = __is_trivial(_ValueType2) && __is_assignable(_ValueType2&, _From) && std::__check_constructible<_ValueType2, _From>();

      return std::__uninitialized_copy<__can_memmove && __assignable>::
 __uninit_copy(__first, __last, __result);
    }



  template<typename _ForwardIterator, typename _Tp>
    constexpr void
    __do_uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __x)
    {
      _ForwardIterator __cur = __first;
      try
 {
   for (; __cur != __last; ++__cur)
     std::_Construct(std::__addressof(*__cur), __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur);
   throw;
 }
    }

  template<bool _TrivialValueType>
    struct __uninitialized_fill
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
 { std::__do_uninit_fill(__first, __last, __x); }
    };

  template<>
    struct __uninitialized_fill<true>
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        { std::fill(__first, __last, __x); }
    };
# 239 "/usr/include/c++/14.2.1/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
         const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;



      const bool __can_fill
 = __is_trivial(_ValueType) && __is_assignable(_ValueType&, const _Tp&) && std::__check_constructible<_ValueType, const _Tp&>();

      std::__uninitialized_fill<__can_fill>::
 __uninit_fill(__first, __last, __x);
    }



  template<typename _ForwardIterator, typename _Size, typename _Tp>
    constexpr
    _ForwardIterator
    __do_uninit_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
    {
      _ForwardIterator __cur = __first;
      try
 {
   for (; __n > 0; --__n, (void) ++__cur)
     std::_Construct(std::__addressof(*__cur), __x);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__first, __cur);
   throw;
 }
    }

  template<bool _TrivialValueType>
    struct __uninitialized_fill_n
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
 static _ForwardIterator
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
 { return std::__do_uninit_fill_n(__first, __n, __x); }
    };

  template<>
    struct __uninitialized_fill_n<true>
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
 static _ForwardIterator
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        { return std::fill_n(__first, __n, __x); }
    };
# 310 "/usr/include/c++/14.2.1/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline _ForwardIterator
    uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;



      const bool __can_fill
 = __is_trivial(_ValueType) && __is_assignable(_ValueType&, const _Tp&) && std::__check_constructible<_ValueType, const _Tp&>()



 && __is_integer<_Size>::__value;

      return __uninitialized_fill_n<__can_fill>::
 __uninit_fill_n(__first, __n, __x);
    }
# 340 "/usr/include/c++/14.2.1/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    constexpr
    _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __result;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __first != __last; ++__first, (void)++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur, __alloc);
   throw;
 }
    }


  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
    constexpr
    inline _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, allocator<_Tp>&)
    {

      if (std::is_constant_evaluated())
 return std::__do_uninit_copy(__first, __last, __result);

      return std::uninitialized_copy(__first, __last, __result);
    }


  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    constexpr
    inline _ForwardIterator
    __uninitialized_move_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a(std::make_move_iterator(__first),
      std::make_move_iterator(__last),
      __result, __alloc);
    }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    constexpr
    inline _ForwardIterator
    __uninitialized_move_if_noexcept_a(_InputIterator __first,
           _InputIterator __last,
           _ForwardIterator __result,
           _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a
 (std::__make_move_if_noexcept_iterator(__first),
  std::__make_move_if_noexcept_iterator(__last), __result, __alloc);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Allocator>
    constexpr
    void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __cur != __last; ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }


  template<typename _ForwardIterator, typename _Tp, typename _Tp2>
    constexpr
    inline void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, allocator<_Tp2>&)
    {

      if (std::is_constant_evaluated())
 return std::__do_uninit_fill(__first, __last, __x);

      std::uninitialized_fill(__first, __last, __x);
    }


  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Allocator>
     constexpr
    _ForwardIterator
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __n > 0; --__n, (void) ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), __x);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }


  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Tp2>
    constexpr
    inline _ForwardIterator
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, allocator<_Tp2>&)
    {

      if (std::is_constant_evaluated())
 return std::__do_uninit_fill_n(__first, __n, __x);

      return std::uninitialized_fill_n(__first, __n, __x);
    }
# 485 "/usr/include/c++/14.2.1/bits/stl_uninitialized.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_copy_move(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }





  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_copy(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid,
         const _Tp& __x, _InputIterator __first,
         _InputIterator __last, _Allocator& __alloc)
    {
      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
      try
 {
   return std::__uninitialized_move_a(__first, __last, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,
    typename _Allocator>
    inline void
    __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1,
         _ForwardIterator __first2,
         _ForwardIterator __last2, const _Tp& __x,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1,
           __first2,
           __alloc);
      try
 {
   std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__first2, __mid2, __alloc);
   throw;
 }
    }
# 592 "/usr/include/c++/14.2.1/bits/stl_uninitialized.h" 3
  template<bool _TrivialValueType>
    struct __uninitialized_default_1
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(std::__addressof(*__cur));
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_1<true>
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
        {
   if (__first == __last)
     return;

   typename iterator_traits<_ForwardIterator>::value_type* __val
     = std::__addressof(*__first);
   std::_Construct(__val);
   if (++__first != __last)
     std::fill(__first, __last, *__val);
 }
    };

  template<bool _TrivialValueType>
    struct __uninitialized_default_n_1
    {
      template<typename _ForwardIterator, typename _Size>
 constexpr
        static _ForwardIterator
        __uninit_default_n(_ForwardIterator __first, _Size __n)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, (void) ++__cur)
  std::_Construct(std::__addressof(*__cur));
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_n_1<true>
    {
      template<typename _ForwardIterator, typename _Size>
 constexpr
        static _ForwardIterator
        __uninit_default_n(_ForwardIterator __first, _Size __n)
        {
   if (__n > 0)
     {
       typename iterator_traits<_ForwardIterator>::value_type* __val
  = std::__addressof(*__first);
       std::_Construct(__val);
       ++__first;
       __first = std::fill_n(__first, __n - 1, *__val);
     }
   return __first;
 }
    };



  template<typename _ForwardIterator>
    inline void
    __uninitialized_default(_ForwardIterator __first,
       _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      const bool __assignable = is_copy_assignable<_ValueType>::value;

      std::__uninitialized_default_1<__is_trivial(_ValueType)
         && __assignable>::
 __uninit_default(__first, __last);
    }



  template<typename _ForwardIterator, typename _Size>
    constexpr
    inline _ForwardIterator
    __uninitialized_default_n(_ForwardIterator __first, _Size __n)
    {

      if (std::is_constant_evaluated())
 return __uninitialized_default_n_1<false>::
   __uninit_default_n(__first, __n);


      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      constexpr bool __can_fill
 = __and_<is_integral<_Size>, is_copy_assignable<_ValueType>>::value;

      return __uninitialized_default_n_1<__is_trivial(_ValueType)
      && __can_fill>::
 __uninit_default_n(__first, __n);
    }





  template<typename _ForwardIterator, typename _Allocator>
    void
    __uninitialized_default_a(_ForwardIterator __first,
         _ForwardIterator __last,
         _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __cur != __last; ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur));
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }


  template<typename _ForwardIterator, typename _Tp>
    inline void
    __uninitialized_default_a(_ForwardIterator __first,
         _ForwardIterator __last,
         allocator<_Tp>&)
    { std::__uninitialized_default(__first, __last); }





  template<typename _ForwardIterator, typename _Size, typename _Allocator>
    constexpr _ForwardIterator
    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n,
    _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __n > 0; --__n, (void) ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur));
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }




  template<typename _ForwardIterator, typename _Size, typename _Tp>
    constexpr
    inline _ForwardIterator
    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n,
    allocator<_Tp>&)
    { return std::__uninitialized_default_n(__first, __n); }


  template<bool _TrivialValueType>
    struct __uninitialized_default_novalue_1
    {
      template<typename _ForwardIterator>
 static void
 __uninit_default_novalue(_ForwardIterator __first,
     _ForwardIterator __last)
 {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct_novalue(std::__addressof(*__cur));
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_novalue_1<true>
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default_novalue(_ForwardIterator, _ForwardIterator)
 {
 }
    };

  template<bool _TrivialValueType>
    struct __uninitialized_default_novalue_n_1
    {
      template<typename _ForwardIterator, typename _Size>
 static _ForwardIterator
 __uninit_default_novalue_n(_ForwardIterator __first, _Size __n)
 {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, (void) ++__cur)
  std::_Construct_novalue(std::__addressof(*__cur));
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_novalue_n_1<true>
    {
      template<typename _ForwardIterator, typename _Size>
 static _ForwardIterator
 __uninit_default_novalue_n(_ForwardIterator __first, _Size __n)
 { return std::next(__first, __n); }
    };



  template<typename _ForwardIterator>
    inline void
    __uninitialized_default_novalue(_ForwardIterator __first,
        _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_default_novalue_1<
 is_trivially_default_constructible<_ValueType>::value>::
 __uninit_default_novalue(__first, __last);
    }



  template<typename _ForwardIterator, typename _Size>
    inline _ForwardIterator
    __uninitialized_default_novalue_n(_ForwardIterator __first, _Size __n)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      return __uninitialized_default_novalue_n_1<
 is_trivially_default_constructible<_ValueType>::value>::
 __uninit_default_novalue_n(__first, __n);
    }

  template<typename _InputIterator, typename _Size,
    typename _ForwardIterator>
    _ForwardIterator
    __uninitialized_copy_n(_InputIterator __first, _Size __n,
      _ForwardIterator __result, input_iterator_tag)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for (; __n > 0; --__n, (void) ++__first, ++__cur)
     std::_Construct(std::__addressof(*__cur), *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur);
   throw;
 }
    }

  template<typename _RandomAccessIterator, typename _Size,
    typename _ForwardIterator>
    inline _ForwardIterator
    __uninitialized_copy_n(_RandomAccessIterator __first, _Size __n,
      _ForwardIterator __result,
      random_access_iterator_tag)
    { return std::uninitialized_copy(__first, __first + __n, __result); }

  template<typename _InputIterator, typename _Size,
    typename _ForwardIterator>
    pair<_InputIterator, _ForwardIterator>
    __uninitialized_copy_n_pair(_InputIterator __first, _Size __n,
      _ForwardIterator __result, input_iterator_tag)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for (; __n > 0; --__n, (void) ++__first, ++__cur)
     std::_Construct(std::__addressof(*__cur), *__first);
   return {__first, __cur};
 }
      catch(...)
 {
   std::_Destroy(__result, __cur);
   throw;
 }
    }

  template<typename _RandomAccessIterator, typename _Size,
    typename _ForwardIterator>
    inline pair<_RandomAccessIterator, _ForwardIterator>
    __uninitialized_copy_n_pair(_RandomAccessIterator __first, _Size __n,
      _ForwardIterator __result,
      random_access_iterator_tag)
    {
      auto __second_res = uninitialized_copy(__first, __first + __n, __result);
      auto __first_res = std::next(__first, __n);
      return {__first_res, __second_res};
    }
# 946 "/usr/include/c++/14.2.1/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _Size, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy_n(_InputIterator __first, _Size __n,
    _ForwardIterator __result)
    { return std::__uninitialized_copy_n(__first, __n, __result,
      std::__iterator_category(__first)); }


  template<typename _InputIterator, typename _Size, typename _ForwardIterator>
    inline pair<_InputIterator, _ForwardIterator>
    __uninitialized_copy_n_pair(_InputIterator __first, _Size __n,
         _ForwardIterator __result)
    {
      return
 std::__uninitialized_copy_n_pair(__first, __n, __result,
      std::__iterator_category(__first));
    }
# 973 "/usr/include/c++/14.2.1/bits/stl_uninitialized.h" 3
  template <typename _ForwardIterator>
    inline void
    uninitialized_default_construct(_ForwardIterator __first,
        _ForwardIterator __last)
    {
      __uninitialized_default_novalue(__first, __last);
    }
# 988 "/usr/include/c++/14.2.1/bits/stl_uninitialized.h" 3
  template <typename _ForwardIterator, typename _Size>
    inline _ForwardIterator
    uninitialized_default_construct_n(_ForwardIterator __first, _Size __count)
    {
      return __uninitialized_default_novalue_n(__first, __count);
    }







  template <typename _ForwardIterator>
    inline void
    uninitialized_value_construct(_ForwardIterator __first,
      _ForwardIterator __last)
    {
      return __uninitialized_default(__first, __last);
    }
# 1016 "/usr/include/c++/14.2.1/bits/stl_uninitialized.h" 3
  template <typename _ForwardIterator, typename _Size>
    inline _ForwardIterator
    uninitialized_value_construct_n(_ForwardIterator __first, _Size __count)
    {
      return __uninitialized_default_n(__first, __count);
    }
# 1031 "/usr/include/c++/14.2.1/bits/stl_uninitialized.h" 3
  template <typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_move(_InputIterator __first, _InputIterator __last,
         _ForwardIterator __result)
    {
      return std::uninitialized_copy
 (std::make_move_iterator(__first),
  std::make_move_iterator(__last), __result);
    }
# 1049 "/usr/include/c++/14.2.1/bits/stl_uninitialized.h" 3
  template <typename _InputIterator, typename _Size, typename _ForwardIterator>
    inline pair<_InputIterator, _ForwardIterator>
    uninitialized_move_n(_InputIterator __first, _Size __count,
    _ForwardIterator __result)
    {
      auto __res = std::__uninitialized_copy_n_pair
 (std::make_move_iterator(__first),
  __count, __result);
      return {__res.first.base(), __res.second};
    }





  template<typename _Tp, typename _Up, typename _Allocator>
    constexpr
    inline void
    __relocate_object_a(_Tp* __restrict __dest, _Up* __restrict __orig,
   _Allocator& __alloc)
    noexcept(noexcept(std::allocator_traits<_Allocator>::construct(__alloc,
    __dest, std::move(*__orig)))
      && noexcept(std::allocator_traits<_Allocator>::destroy(
       __alloc, std::__addressof(*__orig))))
    {
      typedef std::allocator_traits<_Allocator> __traits;
      __traits::construct(__alloc, __dest, std::move(*__orig));
      __traits::destroy(__alloc, std::__addressof(*__orig));
    }



  template<typename _Tp, typename = void>
    struct __is_bitwise_relocatable
    : is_trivial<_Tp> { };

  template <typename _InputIterator, typename _ForwardIterator,
     typename _Allocator>
    constexpr
    inline _ForwardIterator
    __relocate_a_1(_InputIterator __first, _InputIterator __last,
     _ForwardIterator __result, _Allocator& __alloc)
    noexcept(noexcept(std::__relocate_object_a(std::addressof(*__result),
            std::addressof(*__first),
            __alloc)))
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType2;
      static_assert(std::is_same<_ValueType, _ValueType2>::value,
   "relocation is only possible for values of the same type");
      _ForwardIterator __cur = __result;
      for (; __first != __last; ++__first, (void)++__cur)
 std::__relocate_object_a(std::__addressof(*__cur),
     std::__addressof(*__first), __alloc);
      return __cur;
    }


  template <typename _Tp, typename _Up>
    constexpr
    inline __enable_if_t<std::__is_bitwise_relocatable<_Tp>::value, _Tp*>
    __relocate_a_1(_Tp* __first, _Tp* __last,
     _Tp* __result,
     [[__maybe_unused__]] allocator<_Up>& __alloc) noexcept
    {
      ptrdiff_t __count = __last - __first;
      if (__count > 0)
 {

   if (std::is_constant_evaluated())
     {


       __gnu_cxx::__normal_iterator<_Tp*, void> __out(__result);
       __out = std::__relocate_a_1(__first, __last, __out, __alloc);
       return __out.base();
     }

   __builtin_memcpy(__result, __first, __count * sizeof(_Tp));
 }
      return __result + __count;
    }


  template <typename _InputIterator, typename _ForwardIterator,
     typename _Allocator>
    constexpr
    inline _ForwardIterator
    __relocate_a(_InputIterator __first, _InputIterator __last,
   _ForwardIterator __result, _Allocator& __alloc)
    noexcept(noexcept(__relocate_a_1(std::__niter_base(__first),
         std::__niter_base(__last),
         std::__niter_base(__result), __alloc)))
    {
      return std::__relocate_a_1(std::__niter_base(__first),
     std::__niter_base(__last),
     std::__niter_base(__result), __alloc);
    }







}
# 66 "/usr/include/c++/14.2.1/vector" 2 3
# 1 "/usr/include/c++/14.2.1/bits/stl_vector.h" 1 3
# 63 "/usr/include/c++/14.2.1/bits/stl_vector.h" 3
# 1 "/usr/include/c++/14.2.1/initializer_list" 1 3
# 33 "/usr/include/c++/14.2.1/initializer_list" 3
       
# 34 "/usr/include/c++/14.2.1/initializer_list" 3







namespace std __attribute__ ((__visibility__ ("default")))
{

  template<class _E>
    class initializer_list
    {
    public:
      typedef _E value_type;
      typedef const _E& reference;
      typedef const _E& const_reference;
      typedef size_t size_type;
      typedef const _E* iterator;
      typedef const _E* const_iterator;

    private:
      iterator _M_array;
      size_type _M_len;


      constexpr initializer_list(const_iterator __a, size_type __l)
      : _M_array(__a), _M_len(__l) { }

    public:
      constexpr initializer_list() noexcept
      : _M_array(0), _M_len(0) { }


      constexpr size_type
      size() const noexcept { return _M_len; }


      constexpr const_iterator
      begin() const noexcept { return _M_array; }


      constexpr const_iterator
      end() const noexcept { return begin() + size(); }
    };







  template<class _Tp>
    constexpr const _Tp*
    begin(initializer_list<_Tp> __ils) noexcept
    { return __ils.begin(); }







  template<class _Tp>
    constexpr const _Tp*
    end(initializer_list<_Tp> __ils) noexcept
    { return __ils.end(); }
}
# 64 "/usr/include/c++/14.2.1/bits/stl_vector.h" 2 3
# 77 "/usr/include/c++/14.2.1/bits/stl_vector.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _Tp, typename _Alloc>
    struct _Vector_base
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_Tp>::other _Tp_alloc_type;
      typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>::pointer
        pointer;

      struct _Vector_impl_data
      {
 pointer _M_start;
 pointer _M_finish;
 pointer _M_end_of_storage;

 constexpr
 _Vector_impl_data() noexcept
 : _M_start(), _M_finish(), _M_end_of_storage()
 { }


 constexpr
 _Vector_impl_data(_Vector_impl_data&& __x) noexcept
 : _M_start(__x._M_start), _M_finish(__x._M_finish),
   _M_end_of_storage(__x._M_end_of_storage)
 { __x._M_start = __x._M_finish = __x._M_end_of_storage = pointer(); }


 constexpr
 void
 _M_copy_data(_Vector_impl_data const& __x) noexcept
 {
   _M_start = __x._M_start;
   _M_finish = __x._M_finish;
   _M_end_of_storage = __x._M_end_of_storage;
 }

 constexpr
 void
 _M_swap_data(_Vector_impl_data& __x) noexcept
 {


   _Vector_impl_data __tmp;
   __tmp._M_copy_data(*this);
   _M_copy_data(__x);
   __x._M_copy_data(__tmp);
 }
      };

      struct _Vector_impl
 : public _Tp_alloc_type, public _Vector_impl_data
      {
 constexpr
 _Vector_impl() noexcept(is_nothrow_default_constructible<_Tp_alloc_type>::value)


 requires is_default_constructible_v<_Tp_alloc_type>

 : _Tp_alloc_type()
 { }

 constexpr
 _Vector_impl(_Tp_alloc_type const& __a) noexcept
 : _Tp_alloc_type(__a)
 { }




 constexpr
 _Vector_impl(_Vector_impl&& __x) noexcept
 : _Tp_alloc_type(std::move(__x)), _Vector_impl_data(std::move(__x))
 { }

 constexpr
 _Vector_impl(_Tp_alloc_type&& __a) noexcept
 : _Tp_alloc_type(std::move(__a))
 { }

 constexpr
 _Vector_impl(_Tp_alloc_type&& __a, _Vector_impl&& __rv) noexcept
 : _Tp_alloc_type(std::move(__a)), _Vector_impl_data(std::move(__rv))
 { }
# 293 "/usr/include/c++/14.2.1/bits/stl_vector.h" 3
      };

    public:
      typedef _Alloc allocator_type;

      constexpr
      _Tp_alloc_type&
      _M_get_Tp_allocator() noexcept
      { return this->_M_impl; }

      constexpr
      const _Tp_alloc_type&
      _M_get_Tp_allocator() const noexcept
      { return this->_M_impl; }

      constexpr
      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Tp_allocator()); }


      _Vector_base() = default;




      constexpr
      _Vector_base(const allocator_type& __a) noexcept
      : _M_impl(__a) { }



      constexpr
      _Vector_base(size_t __n)
      : _M_impl()
      { _M_create_storage(__n); }


      constexpr
      _Vector_base(size_t __n, const allocator_type& __a)
      : _M_impl(__a)
      { _M_create_storage(__n); }


      _Vector_base(_Vector_base&&) = default;



      constexpr
      _Vector_base(_Tp_alloc_type&& __a) noexcept
      : _M_impl(std::move(__a)) { }

      constexpr
      _Vector_base(_Vector_base&& __x, const allocator_type& __a)
      : _M_impl(__a)
      {
 if (__x.get_allocator() == __a)
   this->_M_impl._M_swap_data(__x._M_impl);
 else
   {
     size_t __n = __x._M_impl._M_finish - __x._M_impl._M_start;
     _M_create_storage(__n);
   }
      }


      constexpr
      _Vector_base(const allocator_type& __a, _Vector_base&& __x)
      : _M_impl(_Tp_alloc_type(__a), std::move(__x._M_impl))
      { }


      constexpr
      ~_Vector_base() noexcept
      {
 _M_deallocate(_M_impl._M_start,
        _M_impl._M_end_of_storage - _M_impl._M_start);
      }

    public:
      _Vector_impl _M_impl;

      constexpr
      pointer
      _M_allocate(size_t __n)
      {
 typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
 return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
      }

      constexpr
      void
      _M_deallocate(pointer __p, size_t __n)
      {
 typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
 if (__p)
   _Tr::deallocate(_M_impl, __p, __n);
      }

    protected:

      constexpr
      void
      _M_create_storage(size_t __n)
      {
 this->_M_impl._M_start = this->_M_allocate(__n);
 this->_M_impl._M_finish = this->_M_impl._M_start;
 this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
      }
    };
# 427 "/usr/include/c++/14.2.1/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class vector : protected _Vector_base<_Tp, _Alloc>
    {
# 440 "/usr/include/c++/14.2.1/bits/stl_vector.h" 3
      static_assert(is_same<typename remove_cv<_Tp>::type, _Tp>::value,
   "std::vector must have a non-const, non-volatile value_type");

      static_assert(is_same<typename _Alloc::value_type, _Tp>::value,
   "std::vector must have the same value_type as its allocator");



      typedef _Vector_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Alloc_traits;

    public:
      typedef _Tp value_type;
      typedef typename _Base::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, vector>
      const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    private:

      static constexpr bool
      _S_nothrow_relocate(true_type)
      {
 return noexcept(std::__relocate_a(std::declval<pointer>(),
       std::declval<pointer>(),
       std::declval<pointer>(),
       std::declval<_Tp_alloc_type&>()));
      }

      static constexpr bool
      _S_nothrow_relocate(false_type)
      { return false; }

      static constexpr bool
      _S_use_relocate()
      {



 return _S_nothrow_relocate(__is_move_insertable<_Tp_alloc_type>{});
      }

      static pointer
      _S_do_relocate(pointer __first, pointer __last, pointer __result,
       _Tp_alloc_type& __alloc, true_type) noexcept
      {
 return std::__relocate_a(__first, __last, __result, __alloc);
      }

      static pointer
      _S_do_relocate(pointer, pointer, pointer __result,
       _Tp_alloc_type&, false_type) noexcept
      { return __result; }

      static constexpr pointer
      _S_relocate(pointer __first, pointer __last, pointer __result,
    _Tp_alloc_type& __alloc) noexcept
      {


 return std::__relocate_a(__first, __last, __result, __alloc);




      }


    protected:
      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_M_impl;
      using _Base::_M_get_Tp_allocator;

    public:







      vector() = default;
# 540 "/usr/include/c++/14.2.1/bits/stl_vector.h" 3
      explicit
      constexpr
      vector(const allocator_type& __a) noexcept
      : _Base(__a) { }
# 554 "/usr/include/c++/14.2.1/bits/stl_vector.h" 3
      explicit
      constexpr
      vector(size_type __n, const allocator_type& __a = allocator_type())
      : _Base(_S_check_init_len(__n, __a), __a)
      { _M_default_initialize(__n); }
# 568 "/usr/include/c++/14.2.1/bits/stl_vector.h" 3
      constexpr
      vector(size_type __n, const value_type& __value,
      const allocator_type& __a = allocator_type())
      : _Base(_S_check_init_len(__n, __a), __a)
      { _M_fill_initialize(__n, __value); }
# 600 "/usr/include/c++/14.2.1/bits/stl_vector.h" 3
      constexpr
      vector(const vector& __x)
      : _Base(__x.size(),
 _Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))
      {
 this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }
# 620 "/usr/include/c++/14.2.1/bits/stl_vector.h" 3
      vector(vector&&) noexcept = default;


      constexpr
      vector(const vector& __x, const __type_identity_t<allocator_type>& __a)
      : _Base(__x.size(), __a)
      {
 this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }

    private:
      constexpr
      vector(vector&& __rv, const allocator_type& __m, true_type) noexcept
      : _Base(__m, std::move(__rv))
      { }

      constexpr
      vector(vector&& __rv, const allocator_type& __m, false_type)
      : _Base(__m)
      {
 if (__rv.get_allocator() == __m)
   this->_M_impl._M_swap_data(__rv._M_impl);
 else if (!__rv.empty())
   {
     this->_M_create_storage(__rv.size());
     this->_M_impl._M_finish =
       std::__uninitialized_move_a(__rv.begin(), __rv.end(),
       this->_M_impl._M_start,
       _M_get_Tp_allocator());
     __rv.clear();
   }
      }

    public:

      constexpr
      vector(vector&& __rv, const __type_identity_t<allocator_type>& __m)
      noexcept( noexcept(
 vector(std::declval<vector&&>(), std::declval<const allocator_type&>(),
        std::declval<typename _Alloc_traits::is_always_equal>())) )
      : vector(std::move(__rv), __m, typename _Alloc_traits::is_always_equal{})
      { }
# 677 "/usr/include/c++/14.2.1/bits/stl_vector.h" 3
      constexpr
      vector(initializer_list<value_type> __l,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 _M_range_initialize(__l.begin(), __l.end(),
       random_access_iterator_tag());
      }
# 704 "/usr/include/c++/14.2.1/bits/stl_vector.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 constexpr
 vector(_InputIterator __first, _InputIterator __last,
        const allocator_type& __a = allocator_type())
 : _Base(__a)
 {
   _M_range_initialize(__first, __last,
         std::__iterator_category(__first));
 }
# 732 "/usr/include/c++/14.2.1/bits/stl_vector.h" 3
      constexpr
      ~vector() noexcept
      {
 std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
        _M_get_Tp_allocator());
 ;
      }
# 749 "/usr/include/c++/14.2.1/bits/stl_vector.h" 3
      constexpr
      vector&
      operator=(const vector& __x);
# 764 "/usr/include/c++/14.2.1/bits/stl_vector.h" 3
      constexpr
      vector&
      operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())
      {
 constexpr bool __move_storage =
   _Alloc_traits::_S_propagate_on_move_assign()
   || _Alloc_traits::_S_always_equal();
 _M_move_assign(std::move(__x), __bool_constant<__move_storage>());
 return *this;
      }
# 786 "/usr/include/c++/14.2.1/bits/stl_vector.h" 3
      constexpr
      vector&
      operator=(initializer_list<value_type> __l)
      {
 this->_M_assign_aux(__l.begin(), __l.end(),
       random_access_iterator_tag());
 return *this;
      }
# 806 "/usr/include/c++/14.2.1/bits/stl_vector.h" 3
      constexpr
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 824 "/usr/include/c++/14.2.1/bits/stl_vector.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 constexpr
 void
 assign(_InputIterator __first, _InputIterator __last)
 { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }
# 853 "/usr/include/c++/14.2.1/bits/stl_vector.h" 3
      constexpr
      void
      assign(initializer_list<value_type> __l)
      {
 this->_M_assign_aux(__l.begin(), __l.end(),
       random_access_iterator_tag());
      }



      using _Base::get_allocator;







      [[__nodiscard__]] constexpr
      iterator
      begin() noexcept
      { return iterator(this->_M_impl._M_start); }






      [[__nodiscard__]] constexpr
      const_iterator
      begin() const noexcept
      { return const_iterator(this->_M_impl._M_start); }






      [[__nodiscard__]] constexpr
      iterator
      end() noexcept
      { return iterator(this->_M_impl._M_finish); }






      [[__nodiscard__]] constexpr
      const_iterator
      end() const noexcept
      { return const_iterator(this->_M_impl._M_finish); }






      [[__nodiscard__]] constexpr
      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }






      [[__nodiscard__]] constexpr
      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }






      [[__nodiscard__]] constexpr
      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }






      [[__nodiscard__]] constexpr
      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }







      [[__nodiscard__]] constexpr
      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_impl._M_start); }






      [[__nodiscard__]] constexpr
      const_iterator
      cend() const noexcept
      { return const_iterator(this->_M_impl._M_finish); }






      [[__nodiscard__]] constexpr
      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }






      [[__nodiscard__]] constexpr
      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }




      [[__nodiscard__]] constexpr
      size_type
      size() const noexcept
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }


      [[__nodiscard__]] constexpr
      size_type
      max_size() const noexcept
      { return _S_max_size(_M_get_Tp_allocator()); }
# 1011 "/usr/include/c++/14.2.1/bits/stl_vector.h" 3
      constexpr
      void
      resize(size_type __new_size)
      {
 if (__new_size > size())
   _M_default_append(__new_size - size());
 else if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
      }
# 1032 "/usr/include/c++/14.2.1/bits/stl_vector.h" 3
      constexpr
      void
      resize(size_type __new_size, const value_type& __x)
      {
 if (__new_size > size())
   _M_fill_insert(end(), __new_size - size(), __x);
 else if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
      }
# 1066 "/usr/include/c++/14.2.1/bits/stl_vector.h" 3
      constexpr
      void
      shrink_to_fit()
      { _M_shrink_to_fit(); }






      [[__nodiscard__]] constexpr
      size_type
      capacity() const noexcept
      {
 return size_type(this->_M_impl._M_end_of_storage
      - this->_M_impl._M_start);
      }





      [[__nodiscard__]] constexpr
      bool
      empty() const noexcept
      { return begin() == end(); }
# 1110 "/usr/include/c++/14.2.1/bits/stl_vector.h" 3
      constexpr
      void
      reserve(size_type __n);
# 1126 "/usr/include/c++/14.2.1/bits/stl_vector.h" 3
      [[__nodiscard__]] constexpr
      reference
      operator[](size_type __n) noexcept
      {
 ;
 return *(this->_M_impl._M_start + __n);
      }
# 1145 "/usr/include/c++/14.2.1/bits/stl_vector.h" 3
      [[__nodiscard__]] constexpr
      const_reference
      operator[](size_type __n) const noexcept
      {
 ;
 return *(this->_M_impl._M_start + __n);
      }

    protected:

      constexpr
      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range_fmt(("vector::_M_range_check: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
      }

    public:
# 1178 "/usr/include/c++/14.2.1/bits/stl_vector.h" 3
      [[__nodiscard__]] constexpr
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
# 1197 "/usr/include/c++/14.2.1/bits/stl_vector.h" 3
      [[__nodiscard__]] constexpr
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }





      [[__nodiscard__]] constexpr
      reference
      front() noexcept
      {
 ;
 return *begin();
      }





      [[__nodiscard__]] constexpr
      const_reference
      front() const noexcept
      {
 ;
 return *begin();
      }





      [[__nodiscard__]] constexpr
      reference
      back() noexcept
      {
 ;
 return *(end() - 1);
      }





      [[__nodiscard__]] constexpr
      const_reference
      back() const noexcept
      {
 ;
 return *(end() - 1);
      }
# 1260 "/usr/include/c++/14.2.1/bits/stl_vector.h" 3
      [[__nodiscard__]] constexpr
      _Tp*
      data() noexcept
      { return _M_data_ptr(this->_M_impl._M_start); }

      [[__nodiscard__]] constexpr
      const _Tp*
      data() const noexcept
      { return _M_data_ptr(this->_M_impl._M_start); }
# 1281 "/usr/include/c++/14.2.1/bits/stl_vector.h" 3
      constexpr
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     ;
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         __x);
     ++this->_M_impl._M_finish;
     ;
   }
 else
   _M_realloc_append(__x);
      }


      constexpr
      void
      push_back(value_type&& __x)
      { emplace_back(std::move(__x)); }

      template<typename... _Args>

 constexpr
 reference



 emplace_back(_Args&&... __args);
# 1322 "/usr/include/c++/14.2.1/bits/stl_vector.h" 3
      constexpr
      void
      pop_back() noexcept
      {
 ;
 --this->_M_impl._M_finish;
 _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
 ;
      }
# 1345 "/usr/include/c++/14.2.1/bits/stl_vector.h" 3
      template<typename... _Args>
 constexpr
 iterator
 emplace(const_iterator __position, _Args&&... __args)
 { return _M_emplace_aux(__position, std::forward<_Args>(__args)...); }
# 1362 "/usr/include/c++/14.2.1/bits/stl_vector.h" 3
      constexpr
      iterator
      insert(const_iterator __position, const value_type& __x);
# 1393 "/usr/include/c++/14.2.1/bits/stl_vector.h" 3
      constexpr
      iterator
      insert(const_iterator __position, value_type&& __x)
      { return _M_insert_rval(__position, std::move(__x)); }
# 1411 "/usr/include/c++/14.2.1/bits/stl_vector.h" 3
      constexpr
      iterator
      insert(const_iterator __position, initializer_list<value_type> __l)
      {
 auto __offset = __position - cbegin();
 _M_range_insert(begin() + __offset, __l.begin(), __l.end(),
   std::random_access_iterator_tag());
 return begin() + __offset;
      }
# 1437 "/usr/include/c++/14.2.1/bits/stl_vector.h" 3
      constexpr
      iterator
      insert(const_iterator __position, size_type __n, const value_type& __x)
      {
 difference_type __offset = __position - cbegin();
 _M_fill_insert(begin() + __offset, __n, __x);
 return begin() + __offset;
      }
# 1480 "/usr/include/c++/14.2.1/bits/stl_vector.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 constexpr
 iterator
 insert(const_iterator __position, _InputIterator __first,
        _InputIterator __last)
 {
   difference_type __offset = __position - cbegin();
   _M_range_insert(begin() + __offset, __first, __last,
     std::__iterator_category(__first));
   return begin() + __offset;
 }
# 1533 "/usr/include/c++/14.2.1/bits/stl_vector.h" 3
      constexpr
      iterator

      erase(const_iterator __position)
      { return _M_erase(begin() + (__position - cbegin())); }
# 1561 "/usr/include/c++/14.2.1/bits/stl_vector.h" 3
      constexpr
      iterator

      erase(const_iterator __first, const_iterator __last)
      {
 const auto __beg = begin();
 const auto __cbeg = cbegin();
 return _M_erase(__beg + (__first - __cbeg), __beg + (__last - __cbeg));
      }
# 1586 "/usr/include/c++/14.2.1/bits/stl_vector.h" 3
      constexpr
      void
      swap(vector& __x) noexcept
      {

 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(_Alloc_traits::propagate_on_container_swap::value || _M_get_Tp_allocator() == __x._M_get_Tp_allocator()), false)) std::__glibcxx_assert_fail(); } while (false)
                                                          ;

 this->_M_impl._M_swap_data(__x._M_impl);
 _Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),
      __x._M_get_Tp_allocator());
      }







      constexpr
      void
      clear() noexcept
      { _M_erase_at_end(this->_M_impl._M_start); }

    protected:




      template<typename _ForwardIterator>
 constexpr
 pointer
 _M_allocate_and_copy(size_type __n,
        _ForwardIterator __first, _ForwardIterator __last)
 {
   pointer __result = this->_M_allocate(__n);
   try
     {
       std::__uninitialized_copy_a(__first, __last, __result,
       _M_get_Tp_allocator());
       return __result;
     }
   catch(...)
     {
       _M_deallocate(__result, __n);
       throw;
     }
 }
# 1666 "/usr/include/c++/14.2.1/bits/stl_vector.h" 3
      template<typename _InputIterator>
 constexpr
 void
 _M_range_initialize(_InputIterator __first, _InputIterator __last,
       std::input_iterator_tag)
 {
   try {
     for (; __first != __last; ++__first)

       emplace_back(*__first);



   } catch(...) {
     clear();
     throw;
   }
 }


      template<typename _ForwardIterator>
 constexpr
 void
 _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
       std::forward_iterator_tag)
 {
   const size_type __n = std::distance(__first, __last);
   this->_M_impl._M_start
     = this->_M_allocate(_S_check_init_len(__n, _M_get_Tp_allocator()));
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
   this->_M_impl._M_finish =
     std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_start,
     _M_get_Tp_allocator());
 }



      constexpr
      void
      _M_fill_initialize(size_type __n, const value_type& __value)
      {
 this->_M_impl._M_finish =
   std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
     _M_get_Tp_allocator());
      }



      constexpr
      void
      _M_default_initialize(size_type __n)
      {
 this->_M_impl._M_finish =
   std::__uninitialized_default_n_a(this->_M_impl._M_start, __n,
        _M_get_Tp_allocator());
      }
# 1732 "/usr/include/c++/14.2.1/bits/stl_vector.h" 3
      template<typename _Integer>
 constexpr
 void
 _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
 { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
 constexpr
 void
 _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
 { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }


      template<typename _InputIterator>
 constexpr
 void
 _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);


      template<typename _ForwardIterator>
 constexpr
 void
 _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag);



      constexpr
      void
      _M_fill_assign(size_type __n, const value_type& __val);







      template<typename _Integer>
 constexpr
 void
 _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
      __true_type)
 { _M_fill_insert(__pos, __n, __val); }


      template<typename _InputIterator>
 constexpr
 void
 _M_insert_dispatch(iterator __pos, _InputIterator __first,
      _InputIterator __last, __false_type)
 {
   _M_range_insert(__pos, __first, __last,
     std::__iterator_category(__first));
 }


      template<typename _InputIterator>
 constexpr
 void
 _M_range_insert(iterator __pos, _InputIterator __first,
   _InputIterator __last, std::input_iterator_tag);


      template<typename _ForwardIterator>
 constexpr
 void
 _M_range_insert(iterator __pos, _ForwardIterator __first,
   _ForwardIterator __last, std::forward_iterator_tag);



      constexpr
      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);



      constexpr
      void
      _M_default_append(size_type __n);

      constexpr
      bool
      _M_shrink_to_fit();
# 1834 "/usr/include/c++/14.2.1/bits/stl_vector.h" 3
      struct _Temporary_value
      {
 template<typename... _Args>
   constexpr explicit
   _Temporary_value(vector* __vec, _Args&&... __args) : _M_this(__vec)
   {
     _Alloc_traits::construct(_M_this->_M_impl, _M_ptr(),
         std::forward<_Args>(__args)...);
   }

 constexpr
 ~_Temporary_value()
 { _Alloc_traits::destroy(_M_this->_M_impl, _M_ptr()); }

 constexpr value_type&
 _M_val() noexcept { return _M_storage._M_val; }

      private:
 constexpr _Tp*
 _M_ptr() noexcept { return std::__addressof(_M_storage._M_val); }

 union _Storage
 {
   constexpr _Storage() : _M_byte() { }
   constexpr ~_Storage() { }
   _Storage& operator=(const _Storage&) = delete;
   unsigned char _M_byte;
   _Tp _M_val;
 };

 vector* _M_this;
 _Storage _M_storage;
      };



      template<typename _Arg>
 constexpr
 void
 _M_insert_aux(iterator __position, _Arg&& __arg);

      template<typename... _Args>
 constexpr
 void
 _M_realloc_insert(iterator __position, _Args&&... __args);

      template<typename... _Args>
 constexpr
 void
 _M_realloc_append(_Args&&... __args);


      constexpr
      iterator
      _M_insert_rval(const_iterator __position, value_type&& __v);


      template<typename... _Args>
 constexpr
 iterator
 _M_emplace_aux(const_iterator __position, _Args&&... __args);


      constexpr
      iterator
      _M_emplace_aux(const_iterator __position, value_type&& __v)
      { return _M_insert_rval(__position, std::move(__v)); }



      constexpr
      size_type
      _M_check_len(size_type __n, const char* __s) const
      {
 if (max_size() - size() < __n)
   __throw_length_error((__s));

 const size_type __len = size() + (std::max)(size(), __n);
 return (__len < size() || __len > max_size()) ? max_size() : __len;
      }


      static constexpr size_type
      _S_check_init_len(size_type __n, const allocator_type& __a)
      {
 if (__n > _S_max_size(_Tp_alloc_type(__a)))
   __throw_length_error(
       ("cannot create std::vector larger than max_size()"));
 return __n;
      }

      static constexpr size_type
      _S_max_size(const _Tp_alloc_type& __a) noexcept
      {



 const size_t __diffmax
   = __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
 const size_t __allocmax = _Alloc_traits::max_size(__a);
 return (std::min)(__diffmax, __allocmax);
      }





      constexpr
      void
      _M_erase_at_end(pointer __pos) noexcept
      {
 if (size_type __n = this->_M_impl._M_finish - __pos)
   {
     std::_Destroy(__pos, this->_M_impl._M_finish,
     _M_get_Tp_allocator());
     this->_M_impl._M_finish = __pos;
     ;
   }
      }

      constexpr
      iterator
      _M_erase(iterator __position);

      constexpr
      iterator
      _M_erase(iterator __first, iterator __last);


    private:



      constexpr
      void
      _M_move_assign(vector&& __x, true_type) noexcept
      {
 vector __tmp(get_allocator());
 this->_M_impl._M_swap_data(__x._M_impl);
 __tmp._M_impl._M_swap_data(__x._M_impl);
 std::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
      }



      constexpr
      void
      _M_move_assign(vector&& __x, false_type)
      {
 if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())
   _M_move_assign(std::move(__x), true_type());
 else
   {


     this->_M_assign_aux(std::make_move_iterator(__x.begin()),
           std::make_move_iterator(__x.end()),
    std::random_access_iterator_tag());
     __x.clear();
   }
      }


      template<typename _Up>
 constexpr
 _Up*
 _M_data_ptr(_Up* __ptr) const noexcept
 { return __ptr; }


      template<typename _Ptr>
 constexpr
 typename std::pointer_traits<_Ptr>::element_type*
 _M_data_ptr(_Ptr __ptr) const
 { return empty() ? nullptr : std::__to_address(__ptr); }
# 2025 "/usr/include/c++/14.2.1/bits/stl_vector.h" 3
    };


  template<typename _InputIterator, typename _ValT
      = typename iterator_traits<_InputIterator>::value_type,
    typename _Allocator = allocator<_ValT>,
    typename = _RequireInputIter<_InputIterator>,
    typename = _RequireAllocator<_Allocator>>
    vector(_InputIterator, _InputIterator, _Allocator = _Allocator())
      -> vector<_ValT, _Allocator>;
# 2047 "/usr/include/c++/14.2.1/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    [[__nodiscard__]] constexpr
    inline bool
    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return (__x.size() == __y.size()
       && std::equal(__x.begin(), __x.end(), __y.begin())); }
# 2066 "/usr/include/c++/14.2.1/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    [[nodiscard]] constexpr
    inline __detail::__synth3way_t<_Tp>
    operator<=>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    {
      return std::lexicographical_compare_three_way(__x.begin(), __x.end(),
          __y.begin(), __y.end(),
          __detail::__synth3way);
    }
# 2119 "/usr/include/c++/14.2.1/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    constexpr
    inline void
    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }




  namespace __detail::__variant
  {
    template<typename> struct _Never_valueless_alt;



    template<typename _Tp, typename _Alloc>
      struct _Never_valueless_alt<std::vector<_Tp, _Alloc>>
      : std::is_nothrow_move_assignable<std::vector<_Tp, _Alloc>>
      { };
  }



}
# 67 "/usr/include/c++/14.2.1/vector" 2 3
# 1 "/usr/include/c++/14.2.1/bits/stl_bvector.h" 1 3
# 65 "/usr/include/c++/14.2.1/bits/stl_bvector.h" 3
# 1 "/usr/include/c++/14.2.1/bits/functional_hash.h" 1 3
# 33 "/usr/include/c++/14.2.1/bits/functional_hash.h" 3
       
# 34 "/usr/include/c++/14.2.1/bits/functional_hash.h" 3


# 1 "/usr/include/c++/14.2.1/bits/hash_bytes.h" 1 3
# 33 "/usr/include/c++/14.2.1/bits/hash_bytes.h" 3
       
# 34 "/usr/include/c++/14.2.1/bits/hash_bytes.h" 3



namespace std
{







  size_t
  _Hash_bytes(const void* __ptr, size_t __len, size_t __seed);





  size_t
  _Fnv_hash_bytes(const void* __ptr, size_t __len, size_t __seed);


}
# 37 "/usr/include/c++/14.2.1/bits/functional_hash.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 50 "/usr/include/c++/14.2.1/bits/functional_hash.h" 3
  template<typename _Result, typename _Arg>
    struct __hash_base
    {
      typedef _Result result_type [[__deprecated__]];
      typedef _Arg argument_type [[__deprecated__]];
    };


  template<typename _Tp>
    struct hash;

  template<typename _Tp, typename = void>
    struct __poison_hash
    {
      static constexpr bool __enable_hash_call = false;
    private:

      __poison_hash(__poison_hash&&);
      ~__poison_hash();
    };

  template<typename _Tp>
    struct __poison_hash<_Tp, __void_t<decltype(hash<_Tp>()(declval<_Tp>()))>>
    {
      static constexpr bool __enable_hash_call = true;
    };


  template<typename _Tp, bool = is_enum<_Tp>::value>
    struct __hash_enum
    {
    private:

      __hash_enum(__hash_enum&&);
      ~__hash_enum();
    };


  template<typename _Tp>
    struct __hash_enum<_Tp, true> : public __hash_base<size_t, _Tp>
    {
      size_t
      operator()(_Tp __val) const noexcept
      {
       using __type = typename underlying_type<_Tp>::type;
       return hash<__type>{}(static_cast<__type>(__val));
      }
    };



  template<typename _Tp>
    struct hash : __hash_enum<_Tp>
    { };


  template<typename _Tp>
    struct hash<_Tp*> : public __hash_base<size_t, _Tp*>
    {
      size_t
      operator()(_Tp* __p) const noexcept
      { return reinterpret_cast<size_t>(__p); }
    };
# 125 "/usr/include/c++/14.2.1/bits/functional_hash.h" 3
  template<> struct hash<bool> : public __hash_base<size_t, bool> { size_t operator()(bool __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char> : public __hash_base<size_t, char> { size_t operator()(char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<signed char> : public __hash_base<size_t, signed char> { size_t operator()(signed char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned char> : public __hash_base<size_t, unsigned char> { size_t operator()(unsigned char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<wchar_t> : public __hash_base<size_t, wchar_t> { size_t operator()(wchar_t __val) const noexcept { return static_cast<size_t>(__val); } };



  template<> struct hash<char8_t> : public __hash_base<size_t, char8_t> { size_t operator()(char8_t __val) const noexcept { return static_cast<size_t>(__val); } };



  template<> struct hash<char16_t> : public __hash_base<size_t, char16_t> { size_t operator()(char16_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char32_t> : public __hash_base<size_t, char32_t> { size_t operator()(char32_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<short> : public __hash_base<size_t, short> { size_t operator()(short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<int> : public __hash_base<size_t, int> { size_t operator()(int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long> : public __hash_base<size_t, long> { size_t operator()(long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long long> : public __hash_base<size_t, long long> { size_t operator()(long long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned short> : public __hash_base<size_t, unsigned short> { size_t operator()(unsigned short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned int> : public __hash_base<size_t, unsigned int> { size_t operator()(unsigned int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long> : public __hash_base<size_t, unsigned long> { size_t operator()(unsigned long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long long> : public __hash_base<size_t, unsigned long long> { size_t operator()(unsigned long long __val) const noexcept { return static_cast<size_t>(__val); } };


  __extension__
  template<> struct hash<__int128> : public __hash_base<size_t, __int128> { size_t operator()(__int128 __val) const noexcept { return static_cast<size_t>(__val); } };
  __extension__
  template<> struct hash<__int128 unsigned> : public __hash_base<size_t, __int128 unsigned> { size_t operator()(__int128 unsigned __val) const noexcept { return static_cast<size_t>(__val); } };
# 201 "/usr/include/c++/14.2.1/bits/functional_hash.h" 3
  struct _Hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(0xc70f6907UL))
    { return _Hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };


  struct _Fnv_hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(2166136261UL))
    { return _Fnv_hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };


  template<>
    struct hash<float> : public __hash_base<size_t, float>
    {
      size_t
      operator()(float __val) const noexcept
      {

 return __val != 0.0f ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<double> : public __hash_base<size_t, double>
    {
      size_t
      operator()(double __val) const noexcept
      {

 return __val != 0.0 ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<long double>
    : public __hash_base<size_t, long double>
    {
      __attribute__ ((__pure__)) size_t
      operator()(long double __val) const noexcept;
    };


  template<>
    struct hash<nullptr_t> : public __hash_base<size_t, nullptr_t>
    {
      size_t
      operator()(nullptr_t) const noexcept
      { return 0; }
    };
# 294 "/usr/include/c++/14.2.1/bits/functional_hash.h" 3
  template<typename _Hash>
    struct __is_fast_hash : public std::true_type
    { };

  template<>
    struct __is_fast_hash<hash<long double>> : public std::false_type
    { };


}
# 66 "/usr/include/c++/14.2.1/bits/stl_bvector.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{


  typedef unsigned long _Bit_type;
  enum { _S_word_bit = int(8 * sizeof(_Bit_type)) };

  __attribute__((__nonnull__))
  constexpr
  void
  __fill_bvector_n(_Bit_type*, size_t, bool) noexcept;



  struct _Bit_reference
  {
    _Bit_type * _M_p;
    _Bit_type _M_mask;

    constexpr
    _Bit_reference(_Bit_type * __x, _Bit_type __y)
    : _M_p(__x), _M_mask(__y) { }

    constexpr
    _Bit_reference() noexcept : _M_p(0), _M_mask(0) { }


    _Bit_reference(const _Bit_reference&) = default;


    [[__nodiscard__]] constexpr
    operator bool() const noexcept
    { return !!(*_M_p & _M_mask); }

    constexpr
    _Bit_reference&
    operator=(bool __x) noexcept
    {
      if (__x)
 *_M_p |= _M_mask;
      else
 *_M_p &= ~_M_mask;
      return *this;
    }
# 125 "/usr/include/c++/14.2.1/bits/stl_bvector.h" 3
    constexpr
    _Bit_reference&
    operator=(const _Bit_reference& __x) noexcept
    { return *this = bool(__x); }

    [[__nodiscard__]] constexpr
    bool
    operator==(const _Bit_reference& __x) const
    { return bool(*this) == bool(__x); }

    [[__nodiscard__]] constexpr
    bool
    operator<(const _Bit_reference& __x) const
    { return !bool(*this) && bool(__x); }

    constexpr
    void
    flip() noexcept
    { *_M_p ^= _M_mask; }


    constexpr
    friend void
    swap(_Bit_reference __x, _Bit_reference __y) noexcept
    {
      bool __tmp = __x;
      __x = __y;
      __y = __tmp;
    }

    constexpr
    friend void
    swap(_Bit_reference __x, bool& __y) noexcept
    {
      bool __tmp = __x;
      __x = __y;
      __y = __tmp;
    }

    constexpr
    friend void
    swap(bool& __x, _Bit_reference __y) noexcept
    {
      bool __tmp = __x;
      __x = __y;
      __y = __tmp;
    }

  };


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
  struct _Bit_iterator_base
  : public std::iterator<std::random_access_iterator_tag, bool>
  {
    _Bit_type * _M_p;
    unsigned int _M_offset;

    constexpr inline __attribute__((__always_inline__))
    void
    _M_assume_normalized() const
    {

      unsigned int __ofst = _M_offset;
      __attribute__ ((__assume__ (__ofst < unsigned(_S_word_bit))));

    }

    constexpr
    _Bit_iterator_base(_Bit_type * __x, unsigned int __y)
    : _M_p(__x), _M_offset(__y) { }

    constexpr
    void
    _M_bump_up()
    {
      _M_assume_normalized();
      if (_M_offset++ == int(_S_word_bit) - 1)
 {
   _M_offset = 0;
   ++_M_p;
 }
    }

    constexpr
    void
    _M_bump_down()
    {
      _M_assume_normalized();
      if (_M_offset-- == 0)
 {
   _M_offset = int(_S_word_bit) - 1;
   --_M_p;
 }
    }

    constexpr
    void
    _M_incr(ptrdiff_t __i)
    {
      _M_assume_normalized();
      difference_type __n = __i + _M_offset;
      _M_p += __n / int(_S_word_bit);
      __n = __n % int(_S_word_bit);
      if (__n < 0)
 {
   __n += int(_S_word_bit);
   --_M_p;
 }
      _M_offset = static_cast<unsigned int>(__n);
    }

    [[__nodiscard__]]
    friend constexpr bool
    operator==(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
    {
      __x._M_assume_normalized();
      __y._M_assume_normalized();
      return __x._M_p == __y._M_p && __x._M_offset == __y._M_offset;
    }


    [[nodiscard]]
    friend constexpr strong_ordering
    operator<=>(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
    noexcept
    {
      __x._M_assume_normalized();
      __y._M_assume_normalized();
      if (const auto __cmp = __x._M_p <=> __y._M_p; __cmp != 0)
 return __cmp;
      return __x._M_offset <=> __y._M_offset;
    }
# 291 "/usr/include/c++/14.2.1/bits/stl_bvector.h" 3
    friend constexpr ptrdiff_t
    operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
    {
      __x._M_assume_normalized();
      __y._M_assume_normalized();
      return (int(_S_word_bit) * (__x._M_p - __y._M_p)
       + __x._M_offset - __y._M_offset);
    }
  };
#pragma GCC diagnostic pop

  struct _Bit_iterator : public _Bit_iterator_base
  {
    typedef _Bit_reference reference;

    typedef void pointer;



    typedef _Bit_iterator iterator;

    constexpr
    _Bit_iterator() : _Bit_iterator_base(0, 0) { }

    constexpr
    _Bit_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    constexpr
    iterator
    _M_const_cast() const
    { return *this; }

    [[__nodiscard__]] constexpr
    reference
    operator*() const
    {
      _M_assume_normalized();
      return reference(_M_p, 1UL << _M_offset);
    }

    constexpr
    iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    constexpr
    iterator
    operator++(int)
    {
      iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    constexpr
    iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    constexpr
    iterator
    operator--(int)
    {
      iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    constexpr
    iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    constexpr
    iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    [[__nodiscard__]] constexpr
    reference
    operator[](difference_type __i) const
    { return *(*this + __i); }

    [[__nodiscard__]]
    friend constexpr iterator
    operator+(const iterator& __x, difference_type __n)
    {
      iterator __tmp = __x;
      __tmp += __n;
      return __tmp;
    }

    [[__nodiscard__]]
    friend constexpr iterator
    operator+(difference_type __n, const iterator& __x)
    { return __x + __n; }

    [[__nodiscard__]]
    friend constexpr iterator
    operator-(const iterator& __x, difference_type __n)
    {
      iterator __tmp = __x;
      __tmp -= __n;
      return __tmp;
    }
  };

  struct _Bit_const_iterator : public _Bit_iterator_base
  {
    typedef bool reference;
    typedef bool const_reference;

    typedef void pointer;



    typedef _Bit_const_iterator const_iterator;

    constexpr
    _Bit_const_iterator() : _Bit_iterator_base(0, 0) { }

    constexpr
    _Bit_const_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    constexpr
    _Bit_const_iterator(const _Bit_iterator& __x)
    : _Bit_iterator_base(__x._M_p, __x._M_offset) { }

    constexpr
    _Bit_iterator
    _M_const_cast() const
    { return _Bit_iterator(_M_p, _M_offset); }

    [[__nodiscard__]] constexpr
    const_reference
    operator*() const
    {
      _M_assume_normalized();
      return _Bit_reference(_M_p, 1UL << _M_offset);
    }

    constexpr
    const_iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    constexpr
    const_iterator
    operator++(int)
    {
      const_iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    constexpr
    const_iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    constexpr
    const_iterator
    operator--(int)
    {
      const_iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    constexpr
    const_iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    constexpr
    const_iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    [[__nodiscard__]] constexpr
    const_reference
    operator[](difference_type __i) const
    { return *(*this + __i); }

    [[__nodiscard__]]
    friend constexpr const_iterator
    operator+(const const_iterator& __x, difference_type __n)
    {
      const_iterator __tmp = __x;
      __tmp += __n;
      return __tmp;
    }

    [[__nodiscard__]]
    friend constexpr const_iterator
    operator-(const const_iterator& __x, difference_type __n)
    {
      const_iterator __tmp = __x;
      __tmp -= __n;
      return __tmp;
    }

    [[__nodiscard__]]
    friend constexpr const_iterator
    operator+(difference_type __n, const const_iterator& __x)
    { return __x + __n; }
  };

  template<typename _Alloc>
    struct _Bvector_base
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
        rebind<_Bit_type>::other _Bit_alloc_type;
      typedef typename __gnu_cxx::__alloc_traits<_Bit_alloc_type>
 _Bit_alloc_traits;
      typedef typename _Bit_alloc_traits::pointer _Bit_pointer;

      struct _Bvector_impl_data
      {

 _Bit_iterator _M_start;
# 547 "/usr/include/c++/14.2.1/bits/stl_bvector.h" 3
 _Bit_iterator _M_finish;
 _Bit_pointer _M_end_of_storage;

 constexpr
 _Bvector_impl_data() noexcept
 : _M_start(), _M_finish(), _M_end_of_storage()
 { }


 _Bvector_impl_data(const _Bvector_impl_data&) = default;

 _Bvector_impl_data&
 operator=(const _Bvector_impl_data&) = default;

 constexpr
 _Bvector_impl_data(_Bvector_impl_data&& __x) noexcept
 : _Bvector_impl_data(__x)
 { __x._M_reset(); }

 constexpr
 void
 _M_move_data(_Bvector_impl_data&& __x) noexcept
 {
   *this = __x;
   __x._M_reset();
 }


 constexpr
 void
 _M_reset() noexcept
 { *this = _Bvector_impl_data(); }

 constexpr
 void
 _M_swap_data(_Bvector_impl_data& __x) noexcept
 {


   std::swap(*this, __x);
 }
      };

      struct _Bvector_impl
 : public _Bit_alloc_type, public _Bvector_impl_data
      {
 constexpr
 _Bvector_impl() noexcept(is_nothrow_default_constructible<_Bit_alloc_type>::value)


 requires is_default_constructible_v<_Bit_alloc_type>

 : _Bit_alloc_type()
 { }

 constexpr
 _Bvector_impl(const _Bit_alloc_type& __a) noexcept
 : _Bit_alloc_type(__a)
 { }




 constexpr
 _Bvector_impl(_Bvector_impl&& __x) noexcept
 : _Bit_alloc_type(std::move(__x)), _Bvector_impl_data(std::move(__x))
 { }

 constexpr
 _Bvector_impl(_Bit_alloc_type&& __a, _Bvector_impl&& __x) noexcept
 : _Bit_alloc_type(std::move(__a)), _Bvector_impl_data(std::move(__x))
 { }


 constexpr
 _Bit_type*
 _M_end_addr() const noexcept
 {
   if (this->_M_end_of_storage)
     return std::__addressof(this->_M_end_of_storage[-1]) + 1;
   return 0;
 }
      };

    public:
      typedef _Alloc allocator_type;

      constexpr
      _Bit_alloc_type&
      _M_get_Bit_allocator() noexcept
      { return this->_M_impl; }

      constexpr
      const _Bit_alloc_type&
      _M_get_Bit_allocator() const noexcept
      { return this->_M_impl; }

      constexpr
      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Bit_allocator()); }


      _Bvector_base() = default;




      constexpr
      _Bvector_base(const allocator_type& __a)
      : _M_impl(_Bit_alloc_type(__a)) { }


      _Bvector_base(_Bvector_base&&) = default;

      constexpr
      _Bvector_base(_Bvector_base&& __x, const allocator_type& __a) noexcept
      : _M_impl(_Bit_alloc_type(__a), std::move(__x._M_impl))
      { }


      constexpr
      ~_Bvector_base()
      { this->_M_deallocate(); }

    protected:
      _Bvector_impl _M_impl;

      constexpr
      _Bit_pointer
      _M_allocate(size_t __n)
      {
 _Bit_pointer __p = _Bit_alloc_traits::allocate(_M_impl, _S_nword(__n));

 if (std::is_constant_evaluated())
   {
     __n = _S_nword(__n);
     for (size_t __i = 0; __i < __n; ++__i)
       std::construct_at(std::to_address(__p) + __i);
   }

 return __p;
      }

      constexpr
      void
      _M_deallocate()
      {
 if (_M_impl._M_start._M_p)
   {
     const size_t __n = _M_impl._M_end_addr() - _M_impl._M_start._M_p;
     _Bit_alloc_traits::deallocate(_M_impl,
       _M_impl._M_end_of_storage - __n,
       __n);
     _M_impl._M_reset();
   }
      }


      constexpr
      void
      _M_move_data(_Bvector_base&& __x) noexcept
      { _M_impl._M_move_data(std::move(__x._M_impl)); }


      constexpr
      static size_t
      _S_nword(size_t __n)
      { return (__n + int(_S_word_bit) - 1) / int(_S_word_bit); }
    };
# 739 "/usr/include/c++/14.2.1/bits/stl_bvector.h" 3
  template<typename _Alloc>
    class vector<bool, _Alloc> : protected _Bvector_base<_Alloc>
    {
      typedef _Bvector_base<_Alloc> _Base;
      typedef typename _Base::_Bit_pointer _Bit_pointer;
      typedef typename _Base::_Bit_alloc_traits _Bit_alloc_traits;


      friend struct std::hash<vector>;


    public:
      typedef bool value_type;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Bit_reference reference;
      typedef bool const_reference;
      typedef _Bit_reference* pointer;
      typedef const bool* const_pointer;
      typedef _Bit_iterator iterator;
      typedef _Bit_const_iterator const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef _Alloc allocator_type;

      constexpr
      allocator_type
      get_allocator() const
      { return _Base::get_allocator(); }

    protected:
      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_S_nword;
      using _Base::_M_get_Bit_allocator;

    public:

      vector() = default;




      constexpr
      explicit
      vector(const allocator_type& __a)
      : _Base(__a) { }


      constexpr
      explicit
      vector(size_type __n, const allocator_type& __a = allocator_type())
      : vector(__n, false, __a)
      { }

      constexpr
      vector(size_type __n, const bool& __value,
      const allocator_type& __a = allocator_type())





      : _Base(__a)
      {
 _M_initialize(__n);
 _M_initialize_value(__value);
      }

      constexpr
      vector(const vector& __x)
      : _Base(_Bit_alloc_traits::_S_select_on_copy(__x._M_get_Bit_allocator()))
      {
 const_iterator __xbegin = __x.begin(), __xend = __x.end();
 _M_initialize(__x.size());
 _M_copy_aligned(__xbegin, __xend, begin());
      }


      vector(vector&&) = default;

    private:
      constexpr
      vector(vector&& __x, const allocator_type& __a, true_type) noexcept
      : _Base(std::move(__x), __a)
      { }

      constexpr
      vector(vector&& __x, const allocator_type& __a, false_type)
      : _Base(__a)
      {
 if (__x.get_allocator() == __a)
   this->_M_move_data(std::move(__x));
 else
   {
     _M_initialize(__x.size());
     _M_copy_aligned(__x.begin(), __x.end(), begin());
     __x.clear();
   }
      }

    public:
      constexpr
      vector(vector&& __x, const __type_identity_t<allocator_type>& __a)
      noexcept(_Bit_alloc_traits::_S_always_equal())
      : vector(std::move(__x), __a,
        typename _Bit_alloc_traits::is_always_equal{})
      { }

      constexpr
      vector(const vector& __x, const __type_identity_t<allocator_type>& __a)
      : _Base(__a)
      {
 _M_initialize(__x.size());
 _M_copy_aligned(__x.begin(), __x.end(), begin());
      }

      constexpr
      vector(initializer_list<bool> __l,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 _M_initialize_range(__l.begin(), __l.end(),
       random_access_iterator_tag());
      }



      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 constexpr
 vector(_InputIterator __first, _InputIterator __last,
        const allocator_type& __a = allocator_type())
 : _Base(__a)
 {
   _M_initialize_range(__first, __last,
         std::__iterator_category(__first));
 }
# 889 "/usr/include/c++/14.2.1/bits/stl_bvector.h" 3
      constexpr
      ~vector() noexcept { }

      constexpr
      vector&
      operator=(const vector& __x)
      {
 if (&__x == this)
   return *this;

 if (_Bit_alloc_traits::_S_propagate_on_copy_assign())
   {
     if (this->_M_get_Bit_allocator() != __x._M_get_Bit_allocator())
       {
  this->_M_deallocate();
  std::__alloc_on_copy(_M_get_Bit_allocator(),
         __x._M_get_Bit_allocator());
  _M_initialize(__x.size());
       }
     else
       std::__alloc_on_copy(_M_get_Bit_allocator(),
       __x._M_get_Bit_allocator());
   }

 if (__x.size() > capacity())
   {
     this->_M_deallocate();
     _M_initialize(__x.size());
   }
 this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
        begin());
 return *this;
      }


      constexpr
      vector&
      operator=(vector&& __x) noexcept(_Bit_alloc_traits::_S_nothrow_move())
      {
 if (_Bit_alloc_traits::_S_propagate_on_move_assign()
     || this->_M_get_Bit_allocator() == __x._M_get_Bit_allocator())
   {
     this->_M_deallocate();
     this->_M_move_data(std::move(__x));
     std::__alloc_on_move(_M_get_Bit_allocator(),
     __x._M_get_Bit_allocator());
   }
 else
   {
     if (__x.size() > capacity())
       {
  this->_M_deallocate();
  _M_initialize(__x.size());
       }
     this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
            begin());
     __x.clear();
   }
 return *this;
      }

      constexpr
      vector&
      operator=(initializer_list<bool> __l)
      {
 this->assign(__l.begin(), __l.end());
 return *this;
      }






      constexpr
      void
      assign(size_type __n, const bool& __x)
      { _M_fill_assign(__n, __x); }


      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 constexpr
 void
 assign(_InputIterator __first, _InputIterator __last)
 { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }
# 987 "/usr/include/c++/14.2.1/bits/stl_bvector.h" 3
      constexpr
      void
      assign(initializer_list<bool> __l)
      { _M_assign_aux(__l.begin(), __l.end(), random_access_iterator_tag()); }


      [[__nodiscard__]] constexpr
      iterator
      begin() noexcept
      { return iterator(this->_M_impl._M_start._M_p, 0); }

      [[__nodiscard__]] constexpr
      const_iterator
      begin() const noexcept
      { return const_iterator(this->_M_impl._M_start._M_p, 0); }

      [[__nodiscard__]] constexpr
      iterator
      end() noexcept
      { return this->_M_impl._M_finish; }

      [[__nodiscard__]] constexpr
      const_iterator
      end() const noexcept
      { return this->_M_impl._M_finish; }

      [[__nodiscard__]] constexpr
      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }

      [[__nodiscard__]] constexpr
      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }

      [[__nodiscard__]] constexpr
      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }

      [[__nodiscard__]] constexpr
      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }


      [[__nodiscard__]] constexpr
      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_impl._M_start._M_p, 0); }

      [[__nodiscard__]] constexpr
      const_iterator
      cend() const noexcept
      { return this->_M_impl._M_finish; }

      [[__nodiscard__]] constexpr
      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }

      [[__nodiscard__]] constexpr
      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }


      [[__nodiscard__]] constexpr
      size_type
      size() const noexcept
      { return size_type(end() - begin()); }

      [[__nodiscard__]] constexpr
      size_type
      max_size() const noexcept
      {
 const size_type __isize =
   __gnu_cxx::__numeric_traits<difference_type>::__max
   - int(_S_word_bit) + 1;
 const size_type __asize
   = _Bit_alloc_traits::max_size(_M_get_Bit_allocator());
 return (__asize <= __isize / int(_S_word_bit)
  ? __asize * int(_S_word_bit) : __isize);
      }

      [[__nodiscard__]] constexpr
      size_type
      capacity() const noexcept
      { return size_type(const_iterator(this->_M_impl._M_end_addr(), 0)
    - begin()); }

      [[__nodiscard__]] constexpr
      bool
      empty() const noexcept
      { return begin() == end(); }

      [[__nodiscard__]] constexpr
      reference
      operator[](size_type __n)
      { return begin()[__n]; }

      [[__nodiscard__]] constexpr
      const_reference
      operator[](size_type __n) const
      { return begin()[__n]; }

    protected:
      constexpr
      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range_fmt(("vector<bool>::_M_range_check: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
      }

    public:
      [[__nodiscard__]] constexpr
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }

      [[__nodiscard__]] constexpr
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }

      constexpr
      void
      reserve(size_type __n)
      {
 if (__n > max_size())
   __throw_length_error(("vector::reserve"));
 if (capacity() < __n)
   _M_reallocate(__n);
      }

      [[__nodiscard__]] constexpr
      reference
      front()
      { return *begin(); }

      [[__nodiscard__]] constexpr
      const_reference
      front() const
      { return *begin(); }

      [[__nodiscard__]] constexpr
      reference
      back()
      { return *(end() - 1); }

      [[__nodiscard__]] constexpr
      const_reference
      back() const
      { return *(end() - 1); }

      constexpr
      void
      push_back(bool __x)
      {
 if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())
   *this->_M_impl._M_finish++ = __x;
 else
   _M_insert_aux(end(), __x);
      }

      constexpr
      void
      swap(vector& __x) noexcept
      {

 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(_Bit_alloc_traits::propagate_on_container_swap::value || _M_get_Bit_allocator() == __x._M_get_Bit_allocator()), false)) std::__glibcxx_assert_fail(); } while (false)
                                                            ;

 this->_M_impl._M_swap_data(__x._M_impl);
 _Bit_alloc_traits::_S_on_swap(_M_get_Bit_allocator(),
          __x._M_get_Bit_allocator());
      }


      constexpr
      static void
      swap(reference __x, reference __y) noexcept
      {
 bool __tmp = __x;
 __x = __y;
 __y = __tmp;
      }

      constexpr
      iterator

      insert(const_iterator __position, const bool& __x)



      {
 const difference_type __n = __position - begin();
 if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr()
     && __position == end())
   *this->_M_impl._M_finish++ = __x;
 else
   _M_insert_aux(__position._M_const_cast(), __x);
 return begin() + __n;
      }


      __attribute__ ((__deprecated__ ("use '" "insert(position, false)" "' instead")))
      iterator
      insert(const_iterator __position)
      { return this->insert(__position._M_const_cast(), false); }



      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 constexpr
 iterator
 insert(const_iterator __position,
        _InputIterator __first, _InputIterator __last)
 {
   difference_type __offset = __position - cbegin();
   _M_insert_range(__position._M_const_cast(),
     __first, __last,
     std::__iterator_category(__first));
   return begin() + __offset;
 }
# 1237 "/usr/include/c++/14.2.1/bits/stl_bvector.h" 3
      constexpr
      iterator
      insert(const_iterator __position, size_type __n, const bool& __x)
      {
 difference_type __offset = __position - cbegin();
 _M_fill_insert(__position._M_const_cast(), __n, __x);
 return begin() + __offset;
      }







      constexpr
      iterator
      insert(const_iterator __p, initializer_list<bool> __l)
      { return this->insert(__p, __l.begin(), __l.end()); }


      constexpr
      void
      pop_back()
      { --this->_M_impl._M_finish; }

      constexpr
      iterator

      erase(const_iterator __position)



      { return _M_erase(__position._M_const_cast()); }

      constexpr
      iterator

      erase(const_iterator __first, const_iterator __last)



      { return _M_erase(__first._M_const_cast(), __last._M_const_cast()); }

      constexpr
      void
      resize(size_type __new_size, bool __x = bool())
      {
 if (__new_size < size())
   _M_erase_at_end(begin() + difference_type(__new_size));
 else
   insert(end(), __new_size - size(), __x);
      }


      constexpr
      void
      shrink_to_fit()
      { _M_shrink_to_fit(); }


      constexpr
      void
      flip() noexcept
      {
 _Bit_type * const __end = this->_M_impl._M_end_addr();
 for (_Bit_type * __p = this->_M_impl._M_start._M_p; __p != __end; ++__p)
   *__p = ~*__p;
      }

      constexpr
      void
      clear() noexcept
      { _M_erase_at_end(begin()); }


      template<typename... _Args>

 constexpr
 reference



 emplace_back(_Args&&... __args)
 {
   push_back(bool(__args...));

   return back();

 }

      template<typename... _Args>
 constexpr
 iterator
 emplace(const_iterator __pos, _Args&&... __args)
 { return insert(__pos, bool(__args...)); }


    protected:

      constexpr
      iterator
      _M_copy_aligned(const_iterator __first, const_iterator __last,
        iterator __result)
      {
 _Bit_type* __q = std::copy(__first._M_p, __last._M_p, __result._M_p);
 return std::copy(const_iterator(__last._M_p, 0), __last,
    iterator(__q, 0));
      }

      constexpr
      void
      _M_initialize(size_type __n)
      {
 if (__n)
   {
     _Bit_pointer __q = this->_M_allocate(__n);
     this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
     iterator __start = iterator(std::__addressof(*__q), 0);
     this->_M_impl._M_start = __start;
     this->_M_impl._M_finish = __start + difference_type(__n);
   }
      }

      constexpr
      void
      _M_initialize_value(bool __x) noexcept
      {
 if (_Bit_type* __p = this->_M_impl._M_start._M_p)
   __fill_bvector_n(__p, this->_M_impl._M_end_addr() - __p, __x);
      }

      constexpr
      void
      _M_reallocate(size_type __n);


      constexpr
      bool
      _M_shrink_to_fit();
# 1398 "/usr/include/c++/14.2.1/bits/stl_bvector.h" 3
      template<typename _InputIterator>
 constexpr
 void
 _M_initialize_range(_InputIterator __first, _InputIterator __last,
       std::input_iterator_tag)
 {
   for (; __first != __last; ++__first)
     push_back(*__first);
 }

      template<typename _ForwardIterator>
 constexpr
 void
 _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,
       std::forward_iterator_tag)
 {
   const size_type __n = std::distance(__first, __last);
   _M_initialize(__n);
   std::copy(__first, __last, begin());
 }
# 1434 "/usr/include/c++/14.2.1/bits/stl_bvector.h" 3
      constexpr
      void
      _M_fill_assign(size_t __n, bool __x)
      {
 if (__n > size())
   {
     _M_initialize_value(__x);
     insert(end(), __n - size(), __x);
   }
 else
   {
     _M_erase_at_end(begin() + __n);
     _M_initialize_value(__x);
   }
      }

      template<typename _InputIterator>
 constexpr
 void
 _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag)
 {
   iterator __cur = begin();
   for (; __first != __last && __cur != end(); ++__cur, (void)++__first)
     *__cur = *__first;
   if (__first == __last)
     _M_erase_at_end(__cur);
   else
     insert(end(), __first, __last);
 }

      template<typename _ForwardIterator>
 constexpr
 void
 _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag)
 {
   const size_type __len = std::distance(__first, __last);
   if (__len < size())
     _M_erase_at_end(std::copy(__first, __last, begin()));
   else
     {
       _ForwardIterator __mid = __first;
       std::advance(__mid, size());
       std::copy(__first, __mid, begin());
       insert(end(), __mid, __last);
     }
 }
# 1501 "/usr/include/c++/14.2.1/bits/stl_bvector.h" 3
      constexpr
      void
      _M_fill_insert(iterator __position, size_type __n, bool __x);

      template<typename _InputIterator>
 constexpr
 void
 _M_insert_range(iterator __pos, _InputIterator __first,
   _InputIterator __last, std::input_iterator_tag)
 {
   for (; __first != __last; ++__first)
     {
       __pos = insert(__pos, *__first);
       ++__pos;
     }
 }

      template<typename _ForwardIterator>
 constexpr
 void
 _M_insert_range(iterator __position, _ForwardIterator __first,
   _ForwardIterator __last, std::forward_iterator_tag);

      constexpr
      void
      _M_insert_aux(iterator __position, bool __x);

      constexpr
      size_type
      _M_check_len(size_type __n, const char* __s) const
      {
 if (max_size() - size() < __n)
   __throw_length_error((__s));

 const size_type __len = size() + std::max(size(), __n);
 return (__len < size() || __len > max_size()) ? max_size() : __len;
      }

      constexpr
      void
      _M_erase_at_end(iterator __pos)
      { this->_M_impl._M_finish = __pos; }

      constexpr
      iterator
      _M_erase(iterator __pos);

      constexpr
      iterator
      _M_erase(iterator __first, iterator __last);

    protected:






      void data() = delete;



    };




  constexpr
  inline void
  __fill_bvector(_Bit_type* __v, unsigned int __first, unsigned int __last,
   bool __x) noexcept
  {
    const _Bit_type __fmask = ~0ul << __first;
    const _Bit_type __lmask = ~0ul >> (_S_word_bit - __last);
    const _Bit_type __mask = __fmask & __lmask;

    if (__x)
      *__v |= __mask;
    else
      *__v &= ~__mask;
  }


  __attribute__((__nonnull__))
  constexpr
  inline void
  __fill_bvector_n(_Bit_type* __p, size_t __n, bool __x) noexcept
  {

    if (std::is_constant_evaluated())
    {
      for (size_t __i = 0; __i < __n; ++__i)
 __p[__i] = __x ? ~0ul : 0ul;
      return;
    }

    __builtin_memset(__p, __x ? ~0 : 0, __n * sizeof(_Bit_type));
  }


  constexpr
  inline void
  __fill_a1(std::_Bit_iterator __first,
     std::_Bit_iterator __last, const bool& __x)
  {
    if (__first._M_p != __last._M_p)
      {
 _Bit_type* __first_p = __first._M_p;
 if (__first._M_offset != 0)
   __fill_bvector(__first_p++, __first._M_offset, _S_word_bit, __x);

 __fill_bvector_n(__first_p, __last._M_p - __first_p, __x);

 if (__last._M_offset != 0)
   __fill_bvector(__last._M_p, 0, __last._M_offset, __x);
      }
    else if (__first._M_offset != __last._M_offset)
      __fill_bvector(__first._M_p, __first._M_offset, __last._M_offset, __x);
  }




  template<typename _Alloc>
    struct hash<std::vector<bool, _Alloc>>
    : public __hash_base<size_t, std::vector<bool, _Alloc>>
    {
      size_t
      operator()(const std::vector<bool, _Alloc>&) const noexcept;
    };



}
# 68 "/usr/include/c++/14.2.1/vector" 2 3
# 1 "/usr/include/c++/14.2.1/bits/refwrap.h" 1 3
# 33 "/usr/include/c++/14.2.1/bits/refwrap.h" 3
       
# 34 "/usr/include/c++/14.2.1/bits/refwrap.h" 3




# 1 "/usr/include/c++/14.2.1/bits/invoke.h" 1 3
# 33 "/usr/include/c++/14.2.1/bits/invoke.h" 3
       
# 34 "/usr/include/c++/14.2.1/bits/invoke.h" 3
# 42 "/usr/include/c++/14.2.1/bits/invoke.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 53 "/usr/include/c++/14.2.1/bits/invoke.h" 3
  template<typename _Tp, typename _Up = typename __inv_unwrap<_Tp>::type>
    constexpr _Up&&
    __invfwd(typename remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Up&&>(__t); }

  template<typename _Res, typename _Fn, typename... _Args>
    constexpr _Res
    __invoke_impl(__invoke_other, _Fn&& __f, _Args&&... __args)
    { return std::forward<_Fn>(__f)(std::forward<_Args>(__args)...); }

  template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>
    constexpr _Res
    __invoke_impl(__invoke_memfun_ref, _MemFun&& __f, _Tp&& __t,
    _Args&&... __args)
    { return (__invfwd<_Tp>(__t).*__f)(std::forward<_Args>(__args)...); }

  template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>
    constexpr _Res
    __invoke_impl(__invoke_memfun_deref, _MemFun&& __f, _Tp&& __t,
    _Args&&... __args)
    {
      return ((*std::forward<_Tp>(__t)).*__f)(std::forward<_Args>(__args)...);
    }

  template<typename _Res, typename _MemPtr, typename _Tp>
    constexpr _Res
    __invoke_impl(__invoke_memobj_ref, _MemPtr&& __f, _Tp&& __t)
    { return __invfwd<_Tp>(__t).*__f; }

  template<typename _Res, typename _MemPtr, typename _Tp>
    constexpr _Res
    __invoke_impl(__invoke_memobj_deref, _MemPtr&& __f, _Tp&& __t)
    { return (*std::forward<_Tp>(__t)).*__f; }


  template<typename _Callable, typename... _Args>
    constexpr typename __invoke_result<_Callable, _Args...>::type
    __invoke(_Callable&& __fn, _Args&&... __args)
    noexcept(__is_nothrow_invocable<_Callable, _Args...>::value)
    {
      using __result = __invoke_result<_Callable, _Args...>;
      using __type = typename __result::type;
      using __tag = typename __result::__invoke_type;
      return std::__invoke_impl<__type>(__tag{}, std::forward<_Callable>(__fn),
     std::forward<_Args>(__args)...);
    }



  template<typename _Res, typename _Callable, typename... _Args>
    constexpr enable_if_t<is_invocable_r_v<_Res, _Callable, _Args...>, _Res>
    __invoke_r(_Callable&& __fn, _Args&&... __args)
    noexcept(is_nothrow_invocable_r_v<_Res, _Callable, _Args...>)
    {
      using __result = __invoke_result<_Callable, _Args...>;
      using __type = typename __result::type;
      using __tag = typename __result::__invoke_type;
      if constexpr (is_void_v<_Res>)
 std::__invoke_impl<__type>(__tag{}, std::forward<_Callable>(__fn),
     std::forward<_Args>(__args)...);
      else
 return std::__invoke_impl<__type>(__tag{},
       std::forward<_Callable>(__fn),
       std::forward<_Args>(__args)...);
    }
# 155 "/usr/include/c++/14.2.1/bits/invoke.h" 3

}
# 39 "/usr/include/c++/14.2.1/bits/refwrap.h" 2 3
# 1 "/usr/include/c++/14.2.1/bits/stl_function.h" 1 3
# 63 "/usr/include/c++/14.2.1/bits/stl_function.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 116 "/usr/include/c++/14.2.1/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    struct unary_function
    {

      typedef _Arg argument_type;


      typedef _Result result_type;
    } __attribute__ ((__deprecated__));





  template<typename _Arg1, typename _Arg2, typename _Result>
    struct binary_function
    {

      typedef _Arg1 first_argument_type;


      typedef _Arg2 second_argument_type;


      typedef _Result result_type;
    } __attribute__ ((__deprecated__));
# 157 "/usr/include/c++/14.2.1/bits/stl_function.h" 3
  struct __is_transparent;

  template<typename _Tp = void>
    struct plus;

  template<typename _Tp = void>
    struct minus;

  template<typename _Tp = void>
    struct multiplies;

  template<typename _Tp = void>
    struct divides;

  template<typename _Tp = void>
    struct modulus;

  template<typename _Tp = void>
    struct negate;



#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"


  template<typename _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {

      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };


  template<typename _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };


  template<typename _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };


  template<typename _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };


  template<typename _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };


  template<typename _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };
#pragma GCC diagnostic pop


  template<>
    struct plus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) + std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) + std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) + std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct minus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) - std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) - std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) - std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct multiplies<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) * std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) * std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) * std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct divides<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) / std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) / std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) / std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct modulus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) % std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) % std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) % std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct negate<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(-std::forward<_Tp>(__t)))
 -> decltype(-std::forward<_Tp>(__t))
 { return -std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };
# 346 "/usr/include/c++/14.2.1/bits/stl_function.h" 3
  template<typename _Tp = void>
    struct equal_to;

  template<typename _Tp = void>
    struct not_equal_to;

  template<typename _Tp = void>
    struct greater;

  template<typename _Tp = void>
    struct less;

  template<typename _Tp = void>
    struct greater_equal;

  template<typename _Tp = void>
    struct less_equal;


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"


  template<typename _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };


  template<typename _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };


  template<typename _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };


  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };


  template<typename _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };


  template<typename _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };


  template<typename _Tp>
    struct greater<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
    {
      constexpr bool
      operator()(_Tp* __x, _Tp* __y) const noexcept
      {

 if (std::__is_constant_evaluated())
   return __x > __y;

 return (long unsigned int)__x > (long unsigned int)__y;
      }
    };


  template<typename _Tp>
    struct less<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
    {
      constexpr bool
      operator()(_Tp* __x, _Tp* __y) const noexcept
      {

 if (std::__is_constant_evaluated())
   return __x < __y;

 return (long unsigned int)__x < (long unsigned int)__y;
      }
    };


  template<typename _Tp>
    struct greater_equal<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
    {
      constexpr bool
      operator()(_Tp* __x, _Tp* __y) const noexcept
      {

 if (std::__is_constant_evaluated())
   return __x >= __y;

 return (long unsigned int)__x >= (long unsigned int)__y;
      }
    };


  template<typename _Tp>
    struct less_equal<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
    {
      constexpr bool
      operator()(_Tp* __x, _Tp* __y) const noexcept
      {

 if (std::__is_constant_evaluated())
   return __x <= __y;

 return (long unsigned int)__x <= (long unsigned int)__y;
      }
    };
#pragma GCC diagnostic pop



  template<>
    struct equal_to<void>
    {
      template <typename _Tp, typename _Up>
 constexpr auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) == std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) == std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) == std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct not_equal_to<void>
    {
      template <typename _Tp, typename _Up>
 constexpr auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) != std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) != std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) != std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct greater<void>
    {
      template <typename _Tp, typename _Up>
 constexpr auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) > std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) > std::forward<_Up>(__u))
 {
   return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),
   __ptr_cmp<_Tp, _Up>{});
 }

      template<typename _Tp, typename _Up>
 constexpr bool
 operator()(_Tp* __t, _Up* __u) const noexcept
 { return greater<common_type_t<_Tp*, _Up*>>{}(__t, __u); }

      typedef __is_transparent is_transparent;

    private:
      template <typename _Tp, typename _Up>
 static constexpr decltype(auto)
 _S_cmp(_Tp&& __t, _Up&& __u, false_type)
 { return std::forward<_Tp>(__t) > std::forward<_Up>(__u); }

      template <typename _Tp, typename _Up>
 static constexpr bool
 _S_cmp(_Tp&& __t, _Up&& __u, true_type) noexcept
 {
   return greater<const volatile void*>{}(
       static_cast<const volatile void*>(std::forward<_Tp>(__t)),
       static_cast<const volatile void*>(std::forward<_Up>(__u)));
 }


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded2 : true_type { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded2<_Tp, _Up, __void_t<
   decltype(std::declval<_Tp>().operator>(std::declval<_Up>()))>>
 : false_type { };


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded : __not_overloaded2<_Tp, _Up> { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded<_Tp, _Up, __void_t<
   decltype(operator>(std::declval<_Tp>(), std::declval<_Up>()))>>
 : false_type { };

      template<typename _Tp, typename _Up>
 using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,
       is_convertible<_Tp, const volatile void*>,
       is_convertible<_Up, const volatile void*>>;
    };


  template<>
    struct less<void>
    {
      template <typename _Tp, typename _Up>
 constexpr auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) < std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) < std::forward<_Up>(__u))
 {
   return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),
   __ptr_cmp<_Tp, _Up>{});
 }

      template<typename _Tp, typename _Up>
 constexpr bool
 operator()(_Tp* __t, _Up* __u) const noexcept
 { return less<common_type_t<_Tp*, _Up*>>{}(__t, __u); }

      typedef __is_transparent is_transparent;

    private:
      template <typename _Tp, typename _Up>
 static constexpr decltype(auto)
 _S_cmp(_Tp&& __t, _Up&& __u, false_type)
 { return std::forward<_Tp>(__t) < std::forward<_Up>(__u); }

      template <typename _Tp, typename _Up>
 static constexpr bool
 _S_cmp(_Tp&& __t, _Up&& __u, true_type) noexcept
 {
   return less<const volatile void*>{}(
       static_cast<const volatile void*>(std::forward<_Tp>(__t)),
       static_cast<const volatile void*>(std::forward<_Up>(__u)));
 }


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded2 : true_type { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded2<_Tp, _Up, __void_t<
   decltype(std::declval<_Tp>().operator<(std::declval<_Up>()))>>
 : false_type { };


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded : __not_overloaded2<_Tp, _Up> { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded<_Tp, _Up, __void_t<
   decltype(operator<(std::declval<_Tp>(), std::declval<_Up>()))>>
 : false_type { };

      template<typename _Tp, typename _Up>
 using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,
       is_convertible<_Tp, const volatile void*>,
       is_convertible<_Up, const volatile void*>>;
    };


  template<>
    struct greater_equal<void>
    {
      template <typename _Tp, typename _Up>
 constexpr auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) >= std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) >= std::forward<_Up>(__u))
 {
   return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),
   __ptr_cmp<_Tp, _Up>{});
 }

      template<typename _Tp, typename _Up>
 constexpr bool
 operator()(_Tp* __t, _Up* __u) const noexcept
 { return greater_equal<common_type_t<_Tp*, _Up*>>{}(__t, __u); }

      typedef __is_transparent is_transparent;

    private:
      template <typename _Tp, typename _Up>
 static constexpr decltype(auto)
 _S_cmp(_Tp&& __t, _Up&& __u, false_type)
 { return std::forward<_Tp>(__t) >= std::forward<_Up>(__u); }

      template <typename _Tp, typename _Up>
 static constexpr bool
 _S_cmp(_Tp&& __t, _Up&& __u, true_type) noexcept
 {
   return greater_equal<const volatile void*>{}(
       static_cast<const volatile void*>(std::forward<_Tp>(__t)),
       static_cast<const volatile void*>(std::forward<_Up>(__u)));
 }


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded2 : true_type { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded2<_Tp, _Up, __void_t<
   decltype(std::declval<_Tp>().operator>=(std::declval<_Up>()))>>
 : false_type { };


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded : __not_overloaded2<_Tp, _Up> { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded<_Tp, _Up, __void_t<
   decltype(operator>=(std::declval<_Tp>(), std::declval<_Up>()))>>
 : false_type { };

      template<typename _Tp, typename _Up>
 using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,
       is_convertible<_Tp, const volatile void*>,
       is_convertible<_Up, const volatile void*>>;
    };


  template<>
    struct less_equal<void>
    {
      template <typename _Tp, typename _Up>
 constexpr auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) <= std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) <= std::forward<_Up>(__u))
 {
   return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),
   __ptr_cmp<_Tp, _Up>{});
 }

      template<typename _Tp, typename _Up>
 constexpr bool
 operator()(_Tp* __t, _Up* __u) const noexcept
 { return less_equal<common_type_t<_Tp*, _Up*>>{}(__t, __u); }

      typedef __is_transparent is_transparent;

    private:
      template <typename _Tp, typename _Up>
 static constexpr decltype(auto)
 _S_cmp(_Tp&& __t, _Up&& __u, false_type)
 { return std::forward<_Tp>(__t) <= std::forward<_Up>(__u); }

      template <typename _Tp, typename _Up>
 static constexpr bool
 _S_cmp(_Tp&& __t, _Up&& __u, true_type) noexcept
 {
   return less_equal<const volatile void*>{}(
       static_cast<const volatile void*>(std::forward<_Tp>(__t)),
       static_cast<const volatile void*>(std::forward<_Up>(__u)));
 }


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded2 : true_type { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded2<_Tp, _Up, __void_t<
   decltype(std::declval<_Tp>().operator<=(std::declval<_Up>()))>>
 : false_type { };


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded : __not_overloaded2<_Tp, _Up> { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded<_Tp, _Up, __void_t<
   decltype(operator<=(std::declval<_Tp>(), std::declval<_Up>()))>>
 : false_type { };

      template<typename _Tp, typename _Up>
 using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,
       is_convertible<_Tp, const volatile void*>,
       is_convertible<_Up, const volatile void*>>;
    };
# 778 "/usr/include/c++/14.2.1/bits/stl_function.h" 3
  template<typename _Tp = void>
    struct logical_and;

  template<typename _Tp = void>
    struct logical_or;

  template<typename _Tp = void>
    struct logical_not;


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"


  template<typename _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };


  template<typename _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };


  template<typename _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };
#pragma GCC diagnostic pop



  template<>
    struct logical_and<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) && std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) && std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) && std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct logical_or<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) || std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) || std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) || std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct logical_not<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(!std::forward<_Tp>(__t)))
 -> decltype(!std::forward<_Tp>(__t))
 { return !std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };




  template<typename _Tp = void>
    struct bit_and;

  template<typename _Tp = void>
    struct bit_or;

  template<typename _Tp = void>
    struct bit_xor;

  template<typename _Tp = void>
    struct bit_not;


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"



  template<typename _Tp>
    struct bit_and : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x & __y; }
    };

  template<typename _Tp>
    struct bit_or : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x | __y; }
    };

  template<typename _Tp>
    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x ^ __y; }
    };

  template<typename _Tp>
    struct bit_not : public unary_function<_Tp, _Tp>
    {
    constexpr
      _Tp
      operator()(const _Tp& __x) const
      { return ~__x; }
    };
#pragma GCC diagnostic pop


  template <>
    struct bit_and<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) & std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) & std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) & std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_or<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) | std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) | std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) | std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_xor<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) ^ std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_not<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(~std::forward<_Tp>(__t)))
 -> decltype(~std::forward<_Tp>(__t))
 { return ~std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
# 1020 "/usr/include/c++/14.2.1/bits/stl_function.h" 3
  template<typename _Predicate>
    class [[__deprecated__]] unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      constexpr
      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) { }

      constexpr
      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };


  template<typename _Predicate>
    __attribute__ ((__deprecated__ ("use '" "std::not_fn" "' instead")))
    constexpr
    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }


  template<typename _Predicate>
    class [[__deprecated__]] binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      constexpr
      explicit
      binary_negate(const _Predicate& __x) : _M_pred(__x) { }

      constexpr
      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };


  template<typename _Predicate>
    __attribute__ ((__deprecated__ ("use '" "std::not_fn" "' instead")))
    constexpr
    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
# 1101 "/usr/include/c++/14.2.1/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);

    public:
      pointer_to_unary_function() { }

      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    } __attribute__ ((__deprecated__));


  template<typename _Arg, typename _Result>
    __attribute__ ((__deprecated__ ("use '" "std::function" "' instead")))
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }


  template<typename _Arg1, typename _Arg2, typename _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);

    public:
      pointer_to_binary_function() { }

      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    } __attribute__ ((__deprecated__));


  template<typename _Arg1, typename _Arg2, typename _Result>
    __attribute__ ((__deprecated__ ("use '" "std::function" "' instead")))
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }


  template<typename _Tp>
    struct _Identity
    : public unary_function<_Tp, _Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }

      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };


  template<typename _Tp> struct _Identity<const _Tp> : _Identity<_Tp> { };

  template<typename _Pair>
    struct _Select1st
    : public unary_function<_Pair, typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }

      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }


      template<typename _Pair2>
        typename _Pair2::first_type&
        operator()(_Pair2& __x) const
        { return __x.first; }

      template<typename _Pair2>
        const typename _Pair2::first_type&
        operator()(const _Pair2& __x) const
        { return __x.first; }

    };

  template<typename _Pair>
    struct _Select2nd
    : public unary_function<_Pair, typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }

      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };
# 1228 "/usr/include/c++/14.2.1/bits/stl_function.h" 3
  template<typename _Ret, typename _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
    } __attribute__ ((__deprecated__));


  template<typename _Ret, typename _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    } __attribute__ ((__deprecated__));


  template<typename _Ret, typename _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
    } __attribute__ ((__deprecated__));


  template<typename _Ret, typename _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    } __attribute__ ((__deprecated__));


  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    } __attribute__ ((__deprecated__));


  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    } __attribute__ ((__deprecated__));


  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    } __attribute__ ((__deprecated__));


  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    } __attribute__ ((__deprecated__));



  template<typename _Ret, typename _Tp>
    __attribute__ ((__deprecated__ ("use '" "std::mem_fn" "' instead")))
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    __attribute__ ((__deprecated__ ("use '" "std::mem_fn" "' instead")))
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    __attribute__ ((__deprecated__ ("use '" "std::mem_fn" "' instead")))
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    __attribute__ ((__deprecated__ ("use '" "std::mem_fn" "' instead")))
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    __attribute__ ((__deprecated__ ("use '" "std::mem_fn" "' instead")))
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    __attribute__ ((__deprecated__ ("use '" "std::mem_fn" "' instead")))
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    __attribute__ ((__deprecated__ ("use '" "std::mem_fn" "' instead")))
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    __attribute__ ((__deprecated__ ("use '" "std::mem_fn" "' instead")))
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }
#pragma GCC diagnostic pop




  template<typename _Func, typename _SfinaeType, typename = __void_t<>>
    struct __has_is_transparent
    { };

  template<typename _Func, typename _SfinaeType>
    struct __has_is_transparent<_Func, _SfinaeType,
    __void_t<typename _Func::is_transparent>>
    { typedef void type; };

  template<typename _Func, typename _SfinaeType>
    using __has_is_transparent_t
      = typename __has_is_transparent<_Func, _SfinaeType>::type;



}


# 1 "/usr/include/c++/14.2.1/backward/binders.h" 1 3
# 60 "/usr/include/c++/14.2.1/backward/binders.h" 3
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

namespace std __attribute__ ((__visibility__ ("default")))
{

# 107 "/usr/include/c++/14.2.1/backward/binders.h" 3
  template<typename _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;

    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }



      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    } __attribute__ ((__deprecated__ ("use '" "std::bind" "' instead")));


  template<typename _Operation, typename _Tp>
    __attribute__ ((__deprecated__ ("use '" "std::bind" "' instead")))
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }


  template<typename _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;

    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }



      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    } __attribute__ ((__deprecated__ ("use '" "std::bind" "' instead")));


  template<typename _Operation, typename _Tp>
    __attribute__ ((__deprecated__ ("use '" "std::bind" "' instead")))
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }



}

#pragma GCC diagnostic pop
# 1436 "/usr/include/c++/14.2.1/bits/stl_function.h" 2 3
# 40 "/usr/include/c++/14.2.1/bits/refwrap.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{

# 56 "/usr/include/c++/14.2.1/bits/refwrap.h" 3
  template<typename _Res, typename... _ArgTypes>
    struct _Maybe_unary_or_binary_function { };


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"


  template<typename _Res, typename _T1>
    struct _Maybe_unary_or_binary_function<_Res, _T1>
    : std::unary_function<_T1, _Res> { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Maybe_unary_or_binary_function<_Res, _T1, _T2>
    : std::binary_function<_T1, _T2, _Res> { };

#pragma GCC diagnostic pop

  template<typename _Signature>
    struct _Mem_fn_traits;

  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Mem_fn_traits_base
    {
      using __result_type = _Res;
      using __maybe_type
 = _Maybe_unary_or_binary_function<_Res, _Class*, _ArgTypes...>;
      using __arity = integral_constant<size_t, sizeof...(_ArgTypes)>;
    };
# 107 "/usr/include/c++/14.2.1/bits/refwrap.h" 3
template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) > : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) > : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const > : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const > : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile > : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile > : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile > : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile > : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };
template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) &> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) &> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const &> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const &> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile &> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile &> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile &> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile &> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };
template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) &&> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) &&> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const &&> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const &&> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile &&> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile &&> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile &&> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile &&> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };


template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) noexcept> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) noexcept> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const noexcept> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const noexcept> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile noexcept> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile noexcept> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile noexcept> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile noexcept> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };
template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) & noexcept> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) & noexcept> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const & noexcept> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const & noexcept> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile & noexcept> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile & noexcept> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile & noexcept> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile & noexcept> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };
template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) && noexcept> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) && noexcept> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const && noexcept> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const && noexcept> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile && noexcept> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile && noexcept> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile && noexcept> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile && noexcept> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };






  template<typename _Functor, typename = __void_t<>>
    struct _Maybe_get_result_type
    { };

  template<typename _Functor>
    struct _Maybe_get_result_type<_Functor,
      __void_t<typename _Functor::result_type>>
    { typedef typename _Functor::result_type result_type; };





  template<typename _Functor>
    struct _Weak_result_type_impl
    : _Maybe_get_result_type<_Functor>
    { };


  template<typename _Res, typename... _ArgTypes , bool _NE>
    struct _Weak_result_type_impl<_Res(_ArgTypes...) noexcept (_NE)>
    { typedef _Res result_type; };


  template<typename _Res, typename... _ArgTypes , bool _NE>
    struct _Weak_result_type_impl<_Res(_ArgTypes......) noexcept (_NE)>
    { typedef _Res result_type; };


  template<typename _Res, typename... _ArgTypes , bool _NE>
    struct _Weak_result_type_impl<_Res(*)(_ArgTypes...) noexcept (_NE)>
    { typedef _Res result_type; };


  template<typename _Res, typename... _ArgTypes , bool _NE>
    struct
    _Weak_result_type_impl<_Res(*)(_ArgTypes......) noexcept (_NE)>
    { typedef _Res result_type; };


  template<typename _Functor,
    bool = is_member_function_pointer<_Functor>::value>
    struct _Weak_result_type_memfun
    : _Weak_result_type_impl<_Functor>
    { };


  template<typename _MemFunPtr>
    struct _Weak_result_type_memfun<_MemFunPtr, true>
    {
      using result_type = typename _Mem_fn_traits<_MemFunPtr>::__result_type;
    };


  template<typename _Func, typename _Class>
    struct _Weak_result_type_memfun<_Func _Class::*, false>
    { };





  template<typename _Functor>
    struct _Weak_result_type
    : _Weak_result_type_memfun<typename remove_cv<_Functor>::type>
    { };
# 306 "/usr/include/c++/14.2.1/bits/refwrap.h" 3
  template<typename _Tp>
    class reference_wrapper





    {
      _Tp* _M_data;

      constexpr
      static _Tp* _S_fun(_Tp& __r) noexcept { return std::__addressof(__r); }

      static void _S_fun(_Tp&&) = delete;

      template<typename _Up, typename _Up2 = __remove_cvref_t<_Up>>
 using __not_same
   = typename enable_if<!is_same<reference_wrapper, _Up2>::value>::type;

    public:
      typedef _Tp type;




      template<typename _Up, typename = __not_same<_Up>, typename
  = decltype(reference_wrapper::_S_fun(std::declval<_Up>()))>
 constexpr
 reference_wrapper(_Up&& __uref)
 noexcept(noexcept(reference_wrapper::_S_fun(std::declval<_Up>())))
 : _M_data(reference_wrapper::_S_fun(std::forward<_Up>(__uref)))
 { }

      reference_wrapper(const reference_wrapper&) = default;

      reference_wrapper&
      operator=(const reference_wrapper&) = default;

      constexpr
      operator _Tp&() const noexcept
      { return this->get(); }

      constexpr
      _Tp&
      get() const noexcept
      { return *_M_data; }

      template<typename... _Args>
 constexpr
 typename __invoke_result<_Tp&, _Args...>::type
 operator()(_Args&&... __args) const
 noexcept(__is_nothrow_invocable<_Tp&, _Args...>::value)
 {

   if constexpr (is_object_v<type>)
     static_assert(sizeof(type), "type must be complete");

   return std::__invoke(get(), std::forward<_Args>(__args)...);
 }
# 412 "/usr/include/c++/14.2.1/bits/refwrap.h" 3
    };


  template<typename _Tp>
    reference_wrapper(_Tp&) -> reference_wrapper<_Tp>;





  template<typename _Tp>
    constexpr
    inline reference_wrapper<_Tp>
    ref(_Tp& __t) noexcept
    { return reference_wrapper<_Tp>(__t); }


  template<typename _Tp>
    constexpr
    inline reference_wrapper<const _Tp>
    cref(const _Tp& __t) noexcept
    { return reference_wrapper<const _Tp>(__t); }

  template<typename _Tp>
    void ref(const _Tp&&) = delete;

  template<typename _Tp>
    void cref(const _Tp&&) = delete;


  template<typename _Tp>
    constexpr
    inline reference_wrapper<_Tp>
    ref(reference_wrapper<_Tp> __t) noexcept
    { return __t; }


  template<typename _Tp>
    constexpr
    inline reference_wrapper<const _Tp>
    cref(reference_wrapper<_Tp> __t) noexcept
    { return { __t.get() }; }




}
# 69 "/usr/include/c++/14.2.1/vector" 2 3
# 1 "/usr/include/c++/14.2.1/bits/range_access.h" 1 3
# 33 "/usr/include/c++/14.2.1/bits/range_access.h" 3
       
# 34 "/usr/include/c++/14.2.1/bits/range_access.h" 3






namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _Container>
    [[__nodiscard__, __gnu__::__always_inline__]]
    inline constexpr auto
    begin(_Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<typename _Container>
    [[__nodiscard__, __gnu__::__always_inline__]]
    inline constexpr auto
    begin(const _Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<typename _Container>
    [[__nodiscard__, __gnu__::__always_inline__]]
    inline constexpr auto
    end(_Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }






  template<typename _Container>
    [[__nodiscard__, __gnu__::__always_inline__]]
    inline constexpr auto
    end(const _Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }





  template<typename _Tp, size_t _Nm>
    [[__nodiscard__, __gnu__::__always_inline__]]
    inline constexpr _Tp*
    begin(_Tp (&__arr)[_Nm]) noexcept
    { return __arr; }






  template<typename _Tp, size_t _Nm>
    [[__nodiscard__, __gnu__::__always_inline__]]
    inline constexpr _Tp*
    end(_Tp (&__arr)[_Nm]) noexcept
    { return __arr + _Nm; }



  template<typename _Tp> class valarray;

  template<typename _Tp> _Tp* begin(valarray<_Tp>&) noexcept;
  template<typename _Tp> const _Tp* begin(const valarray<_Tp>&) noexcept;
  template<typename _Tp> _Tp* end(valarray<_Tp>&) noexcept;
  template<typename _Tp> const _Tp* end(const valarray<_Tp>&) noexcept;






  template<typename _Container>
    [[__nodiscard__, __gnu__::__always_inline__]]
    constexpr auto
    cbegin(const _Container& __cont) noexcept(noexcept(std::begin(__cont)))
      -> decltype(std::begin(__cont))
    { return std::begin(__cont); }






  template<typename _Container>
    [[__nodiscard__, __gnu__::__always_inline__]]
    constexpr auto
    cend(const _Container& __cont) noexcept(noexcept(std::end(__cont)))
      -> decltype(std::end(__cont))
    { return std::end(__cont); }






  template<typename _Container>
    [[__nodiscard__, __gnu__::__always_inline__]]
    inline constexpr auto
    rbegin(_Container& __cont) -> decltype(__cont.rbegin())
    { return __cont.rbegin(); }






  template<typename _Container>
    [[__nodiscard__, __gnu__::__always_inline__]]
    inline constexpr auto
    rbegin(const _Container& __cont) -> decltype(__cont.rbegin())
    { return __cont.rbegin(); }






  template<typename _Container>
    [[__nodiscard__, __gnu__::__always_inline__]]
    inline constexpr auto
    rend(_Container& __cont) -> decltype(__cont.rend())
    { return __cont.rend(); }






  template<typename _Container>
    [[__nodiscard__, __gnu__::__always_inline__]]
    inline constexpr auto
    rend(const _Container& __cont) -> decltype(__cont.rend())
    { return __cont.rend(); }






  template<typename _Tp, size_t _Nm>
    [[__nodiscard__]]
    inline constexpr reverse_iterator<_Tp*>
    rbegin(_Tp (&__arr)[_Nm]) noexcept
    { return reverse_iterator<_Tp*>(__arr + _Nm); }






  template<typename _Tp, size_t _Nm>
    [[__nodiscard__]]
    inline constexpr reverse_iterator<_Tp*>
    rend(_Tp (&__arr)[_Nm]) noexcept
    { return reverse_iterator<_Tp*>(__arr); }






  template<typename _Tp>
    [[__nodiscard__]]
    inline constexpr reverse_iterator<const _Tp*>
    rbegin(initializer_list<_Tp> __il) noexcept
    { return reverse_iterator<const _Tp*>(__il.end()); }






  template<typename _Tp>
    [[__nodiscard__]]
    inline constexpr reverse_iterator<const _Tp*>
    rend(initializer_list<_Tp> __il) noexcept
    { return reverse_iterator<const _Tp*>(__il.begin()); }






  template<typename _Container>
    [[__nodiscard__, __gnu__::__always_inline__]]
    inline constexpr auto
    crbegin(const _Container& __cont) -> decltype(std::rbegin(__cont))
    { return std::rbegin(__cont); }






  template<typename _Container>
    [[__nodiscard__, __gnu__::__always_inline__]]
    inline constexpr auto
    crend(const _Container& __cont) -> decltype(std::rend(__cont))
    { return std::rend(__cont); }
# 259 "/usr/include/c++/14.2.1/bits/range_access.h" 3
  template <typename _Container>
    [[nodiscard, __gnu__::__always_inline__]]
    constexpr auto
    size(const _Container& __cont) noexcept(noexcept(__cont.size()))
    -> decltype(__cont.size())
    { return __cont.size(); }




  template <typename _Tp, size_t _Nm>
    [[nodiscard, __gnu__::__always_inline__]]
    constexpr size_t
    size(const _Tp (&)[_Nm]) noexcept
    { return _Nm; }





  template <typename _Container>
    [[nodiscard, __gnu__::__always_inline__]]
    constexpr auto
    empty(const _Container& __cont) noexcept(noexcept(__cont.empty()))
    -> decltype(__cont.empty())
    { return __cont.empty(); }




  template <typename _Tp, size_t _Nm>
    [[nodiscard, __gnu__::__always_inline__]]
    constexpr bool
    empty(const _Tp (&)[_Nm]) noexcept
    { return false; }





  template <typename _Tp>
    [[nodiscard, __gnu__::__always_inline__]]
    constexpr bool
    empty(initializer_list<_Tp> __il) noexcept
    { return __il.size() == 0;}





  template <typename _Container>
    [[nodiscard, __gnu__::__always_inline__]]
    constexpr auto
    data(_Container& __cont) noexcept(noexcept(__cont.data()))
    -> decltype(__cont.data())
    { return __cont.data(); }





  template <typename _Container>
    [[nodiscard, __gnu__::__always_inline__]]
    constexpr auto
    data(const _Container& __cont) noexcept(noexcept(__cont.data()))
    -> decltype(__cont.data())
    { return __cont.data(); }





  template <typename _Tp, size_t _Nm>
    [[nodiscard, __gnu__::__always_inline__]]
    constexpr _Tp*
    data(_Tp (&__array)[_Nm]) noexcept
    { return __array; }





  template <typename _Tp>
    [[nodiscard, __gnu__::__always_inline__]]
    constexpr const _Tp*
    data(initializer_list<_Tp> __il) noexcept
    { return __il.begin(); }



  template<typename _Container>
    [[nodiscard, __gnu__::__always_inline__]]
    constexpr auto
    ssize(const _Container& __cont)
    noexcept(noexcept(__cont.size()))
    -> common_type_t<ptrdiff_t, make_signed_t<decltype(__cont.size())>>
    {
      using type = make_signed_t<decltype(__cont.size())>;
      return static_cast<common_type_t<ptrdiff_t, type>>(__cont.size());
    }

  template<typename _Tp, ptrdiff_t _Num>
    [[nodiscard, __gnu__::__always_inline__]]
    constexpr ptrdiff_t
    ssize(const _Tp (&)[_Num]) noexcept
    { return _Num; }


}
# 70 "/usr/include/c++/14.2.1/vector" 2 3


# 1 "/usr/include/c++/14.2.1/bits/vector.tcc" 1 3
# 59 "/usr/include/c++/14.2.1/bits/vector.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp, typename _Alloc>
    constexpr
    void
    vector<_Tp, _Alloc>::
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   const size_type __old_size = size();
   pointer __tmp;

   if constexpr (_S_use_relocate())
     {
       __tmp = this->_M_allocate(__n);
       _S_relocate(this->_M_impl._M_start, this->_M_impl._M_finish,
     __tmp, _M_get_Tp_allocator());
     }
   else

     {
       __tmp = _M_allocate_and_copy(__n,
  std::__make_move_if_noexcept_iterator(this->_M_impl._M_start),
  std::__make_move_if_noexcept_iterator(this->_M_impl._M_finish));
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
     }
   ;
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __tmp;
   this->_M_impl._M_finish = __tmp + __old_size;
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
 }
    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>

      constexpr
      typename vector<_Tp, _Alloc>::reference



      vector<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     ;
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         std::forward<_Args>(__args)...);
     ++this->_M_impl._M_finish;
     ;
   }
 else
   _M_realloc_append(std::forward<_Args>(__args)...);

 return back();

      }


  template<typename _Tp, typename _Alloc>
    constexpr
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::

    insert(const_iterator __position, const value_type& __x)



    {
      const size_type __n = __position - begin();
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
 {
   do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__position != const_iterator()), false)) std::__glibcxx_assert_fail(); } while (false);
   if (!(__position != const_iterator()))
     __builtin_unreachable();

   if (__position == end())
     {
       ;
       _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
           __x);
       ++this->_M_impl._M_finish;
       ;
     }
   else
     {

       const auto __pos = begin() + (__position - cbegin());


       _Temporary_value __x_copy(this, __x);
       _M_insert_aux(__pos, std::move(__x_copy._M_val()));



     }
 }
      else

 _M_realloc_insert(begin() + (__position - cbegin()), __x);




      return iterator(this->_M_impl._M_start + __n);
    }

  template<typename _Tp, typename _Alloc>
    constexpr
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    _M_erase(iterator __position)
    {
      if (__position + 1 != end())
 std::move(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
      ;
      return __position;
    }

  template<typename _Tp, typename _Alloc>
    constexpr
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    _M_erase(iterator __first, iterator __last)
    {
      if (__first != __last)
 {
   if (__last != end())
     std::move(__last, end(), __first);
   _M_erase_at_end(__first.base() + (end() - __last));
 }
      return __first;
    }

  template<typename _Tp, typename _Alloc>
    constexpr
    vector<_Tp, _Alloc>&
    vector<_Tp, _Alloc>::
    operator=(const vector<_Tp, _Alloc>& __x)
    {
      if (std::__addressof(__x) != this)
 {
   ;

   if (_Alloc_traits::_S_propagate_on_copy_assign())
     {
       if (!_Alloc_traits::_S_always_equal()
           && _M_get_Tp_allocator() != __x._M_get_Tp_allocator())
         {

    this->clear();
    _M_deallocate(this->_M_impl._M_start,
    this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start);
    this->_M_impl._M_start = nullptr;
    this->_M_impl._M_finish = nullptr;
    this->_M_impl._M_end_of_storage = nullptr;
  }
       std::__alloc_on_copy(_M_get_Tp_allocator(),
       __x._M_get_Tp_allocator());
     }

   const size_type __xlen = __x.size();
   if (__xlen > capacity())
     {
       pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),
         __x.end());
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __tmp;
       this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
     }
   else if (size() >= __xlen)
     {
       std::_Destroy(std::copy(__x.begin(), __x.end(), begin()),
       end(), _M_get_Tp_allocator());
     }
   else
     {
       std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(),
   this->_M_impl._M_start);
       std::__uninitialized_copy_a(__x._M_impl._M_start + size(),
       __x._M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
     }
   this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    constexpr
    void
    vector<_Tp, _Alloc>::
    _M_fill_assign(size_t __n, const value_type& __val)
    {
      const size_type __sz = size();
      if (__n > capacity())
 {
   if (__n <= __sz)
     __builtin_unreachable();
   vector __tmp(__n, __val, _M_get_Tp_allocator());
   __tmp._M_impl._M_swap_data(this->_M_impl);
 }
      else if (__n > __sz)
 {
   std::fill(begin(), end(), __val);
   const size_type __add = __n - __sz;
   ;
   this->_M_impl._M_finish =
     std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
       __add, __val, _M_get_Tp_allocator());
   ;
 }
      else
        _M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
    }

  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      constexpr
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 pointer __cur(this->_M_impl._M_start);
 for (; __first != __last && __cur != this->_M_impl._M_finish;
      ++__cur, (void)++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   _M_range_insert(end(), __first, __last,
     std::__iterator_category(__first));
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      constexpr
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __sz = size();
 const size_type __len = std::distance(__first, __last);

 if (__len > capacity())
   {
     if (__len <= __sz)
       __builtin_unreachable();

     _S_check_init_len(__len, _M_get_Tp_allocator());
     pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
     std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
     _M_get_Tp_allocator());
     ;
     _M_deallocate(this->_M_impl._M_start,
     this->_M_impl._M_end_of_storage
     - this->_M_impl._M_start);
     this->_M_impl._M_start = __tmp;
     this->_M_impl._M_finish = this->_M_impl._M_start + __len;
     this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
   }
 else if (__sz >= __len)
   _M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, __sz);
     std::copy(__first, __mid, this->_M_impl._M_start);
     const size_type __attribute__((__unused__)) __n = __len - __sz;
     ;
     this->_M_impl._M_finish =
       std::__uninitialized_copy_a(__mid, __last,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
     ;
   }
      }


  template<typename _Tp, typename _Alloc>
    constexpr
    auto
    vector<_Tp, _Alloc>::
    _M_insert_rval(const_iterator __position, value_type&& __v) -> iterator
    {
      const auto __n = __position - cbegin();
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
 if (__position == cend())
   {
     ;
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         std::move(__v));
     ++this->_M_impl._M_finish;
     ;
   }
 else
   _M_insert_aux(begin() + __n, std::move(__v));
      else
 _M_realloc_insert(begin() + __n, std::move(__v));

      return iterator(this->_M_impl._M_start + __n);
    }

  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      constexpr
      auto
      vector<_Tp, _Alloc>::
      _M_emplace_aux(const_iterator __position, _Args&&... __args)
      -> iterator
      {
 const auto __n = __position - cbegin();
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   if (__position == cend())
     {
       ;
       _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
           std::forward<_Args>(__args)...);
       ++this->_M_impl._M_finish;
       ;
     }
   else
     {



       _Temporary_value __tmp(this, std::forward<_Args>(__args)...);
       _M_insert_aux(begin() + __n, std::move(__tmp._M_val()));
     }
 else
   _M_realloc_insert(begin() + __n, std::forward<_Args>(__args)...);

 return iterator(this->_M_impl._M_start + __n);
      }

  template<typename _Tp, typename _Alloc>
    template<typename _Arg>
      constexpr
      void
      vector<_Tp, _Alloc>::
      _M_insert_aux(iterator __position, _Arg&& __arg)






    {
      ;
      _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
          std::move(*(this->_M_impl._M_finish - 1)));
      ++this->_M_impl._M_finish;
      ;



      std::move_backward(__position.base(), this->_M_impl._M_finish - 2, this->_M_impl._M_finish - 1)

                                     ;



      *__position = std::forward<_Arg>(__arg);

    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      constexpr
      void
      vector<_Tp, _Alloc>::
      _M_realloc_insert(iterator __position, _Args&&... __args)






    {
      const size_type __len = _M_check_len(1u, "vector::_M_realloc_insert");
      if (__len <= 0)
 __builtin_unreachable ();
      pointer __old_start = this->_M_impl._M_start;
      pointer __old_finish = this->_M_impl._M_finish;
      const size_type __elems_before = __position - begin();
      pointer __new_start(this->_M_allocate(__len));
      pointer __new_finish(__new_start);


      struct _Guard
      {
 pointer _M_storage;
 size_type _M_len;
 _Tp_alloc_type& _M_alloc;

 constexpr
 _Guard(pointer __s, size_type __l, _Tp_alloc_type& __a)
 : _M_storage(__s), _M_len(__l), _M_alloc(__a)
 { }

 constexpr
 ~_Guard()
 {
   if (_M_storage)
     __gnu_cxx::__alloc_traits<_Tp_alloc_type>::
       deallocate(_M_alloc, _M_storage, _M_len);
 }

      private:
 _Guard(const _Guard&);
      };

      {
 _Guard __guard(__new_start, __len, _M_impl);
# 505 "/usr/include/c++/14.2.1/bits/vector.tcc" 3
 _Alloc_traits::construct(this->_M_impl,
     std::__to_address(__new_start + __elems_before),
     std::forward<_Args>(__args)...);







 if constexpr (_S_use_relocate())
   {

     __new_finish = _S_relocate(__old_start, __position.base(),
           __new_start, _M_get_Tp_allocator());
     ++__new_finish;
     __new_finish = _S_relocate(__position.base(), __old_finish,
           __new_finish, _M_get_Tp_allocator());
   }
 else

   {

     struct _Guard_elts
     {
       pointer _M_first, _M_last;
       _Tp_alloc_type& _M_alloc;

       constexpr
       _Guard_elts(pointer __elt, _Tp_alloc_type& __a)
       : _M_first(__elt), _M_last(__elt + 1), _M_alloc(__a)
       { }

       constexpr
       ~_Guard_elts()
       { std::_Destroy(_M_first, _M_last, _M_alloc); }

     private:
       _Guard_elts(const _Guard_elts&);
     };


     _Guard_elts __guard_elts(__new_start + __elems_before, _M_impl);

     __new_finish = std::__uninitialized_move_if_noexcept_a(
        __old_start, __position.base(),
        __new_start, _M_get_Tp_allocator());

     ++__new_finish;

     __guard_elts._M_first = __new_start;

     __new_finish = std::__uninitialized_move_if_noexcept_a(
         __position.base(), __old_finish,
         __new_finish, _M_get_Tp_allocator());


     __guard_elts._M_first = __old_start;
     __guard_elts._M_last = __old_finish;
   }
 __guard._M_storage = __old_start;
 __guard._M_len = this->_M_impl._M_end_of_storage - __old_start;
      }



      this->_M_impl._M_start = __new_start;
      this->_M_impl._M_finish = __new_finish;
      this->_M_impl._M_end_of_storage = __new_start + __len;
    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      constexpr
      void
      vector<_Tp, _Alloc>::
      _M_realloc_append(_Args&&... __args)






    {
      const size_type __len = _M_check_len(1u, "vector::_M_realloc_append");
      if (__len <= 0)
 __builtin_unreachable ();
      pointer __old_start = this->_M_impl._M_start;
      pointer __old_finish = this->_M_impl._M_finish;
      const size_type __elems = end() - begin();
      pointer __new_start(this->_M_allocate(__len));
      pointer __new_finish(__new_start);


      struct _Guard
      {
 pointer _M_storage;
 size_type _M_len;
 _Tp_alloc_type& _M_alloc;

 constexpr
 _Guard(pointer __s, size_type __l, _Tp_alloc_type& __a)
 : _M_storage(__s), _M_len(__l), _M_alloc(__a)
 { }

 constexpr
 ~_Guard()
 {
   if (_M_storage)
     __gnu_cxx::__alloc_traits<_Tp_alloc_type>::
       deallocate(_M_alloc, _M_storage, _M_len);
 }

      private:
 _Guard(const _Guard&);
      };

      {
 _Guard __guard(__new_start, __len, _M_impl);
# 634 "/usr/include/c++/14.2.1/bits/vector.tcc" 3
 _Alloc_traits::construct(this->_M_impl,
     std::__to_address(__new_start + __elems),
     std::forward<_Args>(__args)...);







 if constexpr (_S_use_relocate())
   {

     __new_finish = _S_relocate(__old_start, __old_finish,
           __new_start, _M_get_Tp_allocator());
     ++__new_finish;
   }
 else

   {

     struct _Guard_elts
     {
       pointer _M_first, _M_last;
       _Tp_alloc_type& _M_alloc;

       constexpr
       _Guard_elts(pointer __elt, _Tp_alloc_type& __a)
       : _M_first(__elt), _M_last(__elt + 1), _M_alloc(__a)
       { }

       constexpr
       ~_Guard_elts()
       { std::_Destroy(_M_first, _M_last, _M_alloc); }

     private:
       _Guard_elts(const _Guard_elts&);
     };


     _Guard_elts __guard_elts(__new_start + __elems, _M_impl);

     __new_finish = std::__uninitialized_move_if_noexcept_a(
        __old_start, __old_finish,
        __new_start, _M_get_Tp_allocator());

     ++__new_finish;


     __guard_elts._M_first = __old_start;
     __guard_elts._M_last = __old_finish;
   }
 __guard._M_storage = __old_start;
 __guard._M_len = this->_M_impl._M_end_of_storage - __old_start;
      }



      this->_M_impl._M_start = __new_start;
      this->_M_impl._M_finish = __new_finish;
      this->_M_impl._M_end_of_storage = __new_start + __len;
    }

  template<typename _Tp, typename _Alloc>
    constexpr
    void
    vector<_Tp, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
    {
      if (__n != 0)
 {
   if (size_type(this->_M_impl._M_end_of_storage
   - this->_M_impl._M_finish) >= __n)
     {



       _Temporary_value __tmp(this, __x);
       value_type& __x_copy = __tmp._M_val();

       const size_type __elems_after = end() - __position;
       pointer __old_finish(this->_M_impl._M_finish);
       if (__elems_after > __n)
  {
    ;
    std::__uninitialized_move_a(__old_finish - __n,
           __old_finish,
           __old_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n;
    ;
    std::move_backward(__position.base(), __old_finish - __n, __old_finish)
                                        ;
    std::fill(__position.base(), __position.base() + __n,
       __x_copy);
  }
       else
  {
    ;
    this->_M_impl._M_finish =
      std::__uninitialized_fill_n_a(__old_finish,
        __n - __elems_after,
        __x_copy,
        _M_get_Tp_allocator());
    ;
    std::__uninitialized_move_a(__position.base(), __old_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __elems_after;
    ;
    std::fill(__position.base(), __old_finish, __x_copy);
  }
     }
   else
     {


       pointer __old_start = this->_M_impl._M_start;
       pointer __old_finish = this->_M_impl._M_finish;
       const pointer __pos = __position.base();

       const size_type __len =
  _M_check_len(__n, "vector::_M_fill_insert");
       const size_type __elems_before = __pos - __old_start;
       pointer __new_start(this->_M_allocate(__len));
       pointer __new_finish(__new_start);
       try
  {

    std::__uninitialized_fill_n_a(__new_start + __elems_before,
      __n, __x,
      _M_get_Tp_allocator());
    __new_finish = pointer();

    __new_finish
      = std::__uninitialized_move_if_noexcept_a
      (__old_start, __pos, __new_start, _M_get_Tp_allocator());

    __new_finish += __n;

    __new_finish
      = std::__uninitialized_move_if_noexcept_a
      (__pos, __old_finish, __new_finish, _M_get_Tp_allocator());
  }
       catch(...)
  {
    if (!__new_finish)
      std::_Destroy(__new_start + __elems_before,
      __new_start + __elems_before + __n,
      _M_get_Tp_allocator());
    else
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
    _M_deallocate(__new_start, __len);
    throw;
  }
       std::_Destroy(__old_start, __old_finish, _M_get_Tp_allocator());
       ;
       _M_deallocate(__old_start,
       this->_M_impl._M_end_of_storage - __old_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_finish;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }


  template<typename _Tp, typename _Alloc>
    constexpr
    void
    vector<_Tp, _Alloc>::
    _M_default_append(size_type __n)
    {
      if (__n != 0)
 {
   const size_type __size = size();
   size_type __navail = size_type(this->_M_impl._M_end_of_storage
      - this->_M_impl._M_finish);

   if (__size > max_size() || __navail > max_size() - __size)
     __builtin_unreachable();

   if (__navail >= __n)
     {
       ;
       this->_M_impl._M_finish =
  std::__uninitialized_default_n_a(this->_M_impl._M_finish,
       __n, _M_get_Tp_allocator());
       ;
     }
   else
     {


       pointer __old_start = this->_M_impl._M_start;
       pointer __old_finish = this->_M_impl._M_finish;

       const size_type __len =
  _M_check_len(__n, "vector::_M_default_append");
       pointer __new_start(this->_M_allocate(__len));


       struct _Guard
       {
  pointer _M_storage;
  size_type _M_len;
  _Tp_alloc_type& _M_alloc;

  constexpr
  _Guard(pointer __s, size_type __l, _Tp_alloc_type& __a)
  : _M_storage(__s), _M_len(__l), _M_alloc(__a)
  { }

  constexpr
  ~_Guard()
  {
    if (_M_storage)
      __gnu_cxx::__alloc_traits<_Tp_alloc_type>::
        deallocate(_M_alloc, _M_storage, _M_len);
  }

       private:
  _Guard(const _Guard&);
       };

       {
  _Guard __guard(__new_start, __len, _M_impl);

  std::__uninitialized_default_n_a(__new_start + __size, __n,
       _M_get_Tp_allocator());

  if constexpr (_S_use_relocate())
    {
      _S_relocate(__old_start, __old_finish,
    __new_start, _M_get_Tp_allocator());
    }
  else
    {

      struct _Guard_elts
      {
        pointer _M_first, _M_last;
        _Tp_alloc_type& _M_alloc;

        constexpr
        _Guard_elts(pointer __first, size_type __n,
      _Tp_alloc_type& __a)
        : _M_first(__first), _M_last(__first + __n), _M_alloc(__a)
        { }

        constexpr
        ~_Guard_elts()
        { std::_Destroy(_M_first, _M_last, _M_alloc); }

      private:
        _Guard_elts(const _Guard_elts&);
      };
      _Guard_elts __guard_elts(__new_start + __size, __n, _M_impl);

      std::__uninitialized_move_if_noexcept_a(
        __old_start, __old_finish, __new_start,
        _M_get_Tp_allocator());

      __guard_elts._M_first = __old_start;
      __guard_elts._M_last = __old_finish;
    }
  ;
  __guard._M_storage = __old_start;
  __guard._M_len = this->_M_impl._M_end_of_storage - __old_start;
       }



       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_start + __size + __n;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }

  template<typename _Tp, typename _Alloc>
    constexpr
    bool
    vector<_Tp, _Alloc>::
    _M_shrink_to_fit()
    {
      if (capacity() == size())
 return false;
      ;
      return std::__shrink_to_fit_aux<vector>::_S_do_it(*this);
    }


  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      constexpr
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 if (__pos == end())
   {
     for (; __first != __last; ++__first)
       insert(end(), *__first);
   }
 else if (__first != __last)
   {
     vector __tmp(__first, __last, _M_get_Tp_allocator());
     insert(__pos,
     std::make_move_iterator(__tmp.begin()),
     std::make_move_iterator(__tmp.end()));
   }
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      constexpr
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     const size_type __n = std::distance(__first, __last);
     if (size_type(this->_M_impl._M_end_of_storage
     - this->_M_impl._M_finish) >= __n)
       {
  const size_type __elems_after = end() - __position;
  pointer __old_finish(this->_M_impl._M_finish);
  if (__elems_after > __n)
    {
      ;
      std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
      this->_M_impl._M_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n;
      ;
      std::move_backward(__position.base(), __old_finish - __n, __old_finish)
                                          ;
      std::copy(__first, __last, __position);
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, __elems_after);
      ;
      std::__uninitialized_copy_a(__mid, __last,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n - __elems_after;
      ;
      std::__uninitialized_move_a(__position.base(),
      __old_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __elems_after;
      ;
      std::copy(__first, __mid, __position);
    }
       }
     else
       {



  pointer __old_start = this->_M_impl._M_start;
  pointer __old_finish = this->_M_impl._M_finish;

  const size_type __len =
    _M_check_len(__n, "vector::_M_range_insert");





  pointer __new_start(this->_M_allocate(__len));
  pointer __new_finish(__new_start);
  try
    {
      __new_finish
        = std::__uninitialized_move_if_noexcept_a
        (__old_start, __position.base(),
         __new_start, _M_get_Tp_allocator());
      __new_finish
        = std::__uninitialized_copy_a(__first, __last,
          __new_finish,
          _M_get_Tp_allocator());
      __new_finish
        = std::__uninitialized_move_if_noexcept_a
        (__position.base(), __old_finish,
         __new_finish, _M_get_Tp_allocator());
    }
  catch(...)
    {
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
      _M_deallocate(__new_start, __len);
      throw;
    }
  std::_Destroy(__old_start, __old_finish,
         _M_get_Tp_allocator());
  ;
  _M_deallocate(__old_start,
         this->_M_impl._M_end_of_storage - __old_start);
  this->_M_impl._M_start = __new_start;
  this->_M_impl._M_finish = __new_finish;
  this->_M_impl._M_end_of_storage = __new_start + __len;
       }
   }
      }



  template<typename _Alloc>
    constexpr
    void
    vector<bool, _Alloc>::
    _M_reallocate(size_type __n)
    {
      _Bit_pointer __q = this->_M_allocate(__n);
      iterator __start(std::__addressof(*__q), 0);
      iterator __finish(_M_copy_aligned(begin(), end(), __start));
      this->_M_deallocate();
      this->_M_impl._M_start = __start;
      this->_M_impl._M_finish = __finish;
      this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
    }

  template<typename _Alloc>
    constexpr
    void
    vector<bool, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, bool __x)
    {
      if (__n == 0)
 return;
      if (capacity() - size() >= __n)
 {
   std::copy_backward(__position, end(),
        this->_M_impl._M_finish + difference_type(__n));
   std::fill(__position, __position + difference_type(__n), __x);
   this->_M_impl._M_finish += difference_type(__n);
 }
      else
 {
   const size_type __len =
     _M_check_len(__n, "vector<bool>::_M_fill_insert");
   _Bit_pointer __q = this->_M_allocate(__len);
   iterator __start(std::__addressof(*__q), 0);
   iterator __i = _M_copy_aligned(begin(), __position, __start);
   std::fill(__i, __i + difference_type(__n), __x);
   iterator __finish = std::copy(__position, end(),
     __i + difference_type(__n));
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
   this->_M_impl._M_start = __start;
   this->_M_impl._M_finish = __finish;
 }
    }

  template<typename _Alloc>
    template<typename _ForwardIterator>
      constexpr
      void
      vector<bool, _Alloc>::
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     size_type __n = std::distance(__first, __last);
     if (capacity() - size() >= __n)
       {
  std::copy_backward(__position, end(),
       this->_M_impl._M_finish
       + difference_type(__n));
  std::copy(__first, __last, __position);
  this->_M_impl._M_finish += difference_type(__n);
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector<bool>::_M_insert_range");
  const iterator __begin = begin(), __end = end();
  _Bit_pointer __q = this->_M_allocate(__len);
  iterator __start(std::__addressof(*__q), 0);
  iterator __i = _M_copy_aligned(__begin, __position, __start);
  __i = std::copy(__first, __last, __i);
  iterator __finish = std::copy(__position, __end, __i);
  this->_M_deallocate();
  this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
  this->_M_impl._M_start = __start;
  this->_M_impl._M_finish = __finish;
       }
   }
      }

  template<typename _Alloc>
    constexpr
    void
    vector<bool, _Alloc>::
    _M_insert_aux(iterator __position, bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())
 {
   std::copy_backward(__position, this->_M_impl._M_finish,
        this->_M_impl._M_finish + 1);
   *__position = __x;
   ++this->_M_impl._M_finish;
 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector<bool>::_M_insert_aux");
   _Bit_pointer __q = this->_M_allocate(__len);
   iterator __start(std::__addressof(*__q), 0);
   iterator __i = _M_copy_aligned(begin(), __position, __start);
   *__i++ = __x;
   iterator __finish = std::copy(__position, end(), __i);
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
   this->_M_impl._M_start = __start;
   this->_M_impl._M_finish = __finish;
 }
    }

  template<typename _Alloc>
    constexpr
    typename vector<bool, _Alloc>::iterator
    vector<bool, _Alloc>::
    _M_erase(iterator __position)
    {
      if (__position + 1 != end())
        std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      return __position;
    }

  template<typename _Alloc>
    constexpr
    typename vector<bool, _Alloc>::iterator
    vector<bool, _Alloc>::
    _M_erase(iterator __first, iterator __last)
    {
      if (__first != __last)
 _M_erase_at_end(std::copy(__last, end(), __first));
      return __first;
    }


  template<typename _Alloc>
    constexpr
    bool
    vector<bool, _Alloc>::
    _M_shrink_to_fit()
    {
      if (capacity() - size() < int(_S_word_bit))
 return false;
      try
 {
   if (size_type __n = size())
     _M_reallocate(__n);
   else
     {
       this->_M_deallocate();
       this->_M_impl._M_reset();
     }
   return true;
 }
      catch(...)
 { return false; }
    }




}



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Alloc>
    size_t
    hash<std::vector<bool, _Alloc>>::
    operator()(const std::vector<bool, _Alloc>& __b) const noexcept
    {
      size_t __hash = 0;
      const size_t __words = __b.size() / _S_word_bit;
      if (__words)
 {
   const size_t __clength = __words * sizeof(_Bit_type);
   __hash = std::_Hash_impl::hash(__b._M_impl._M_start._M_p, __clength);
 }

      const size_t __extrabits = __b.size() % _S_word_bit;
      if (__extrabits)
 {
   _Bit_type __hiword = *__b._M_impl._M_finish._M_p;
   __hiword &= ~((~static_cast<_Bit_type>(0)) << __extrabits);

   const size_t __clength
     = (__extrabits + 8 - 1) / 8;
   if (__words)
     __hash = std::_Hash_impl::hash(&__hiword, __clength, __hash);
   else
     __hash = std::_Hash_impl::hash(&__hiword, __clength);
 }

      return __hash;
    }


}
# 73 "/usr/include/c++/14.2.1/vector" 2 3
# 84 "/usr/include/c++/14.2.1/vector" 3
# 1 "/usr/include/c++/14.2.1/bits/version.h" 1 3
# 47 "/usr/include/c++/14.2.1/bits/version.h" 3
       
# 48 "/usr/include/c++/14.2.1/bits/version.h" 3
# 85 "/usr/include/c++/14.2.1/vector" 2 3


# 1 "/usr/include/c++/14.2.1/bits/memory_resource.h" 1 3
# 33 "/usr/include/c++/14.2.1/bits/memory_resource.h" 3
       
# 34 "/usr/include/c++/14.2.1/bits/memory_resource.h" 3






# 1 "/usr/include/c++/14.2.1/bits/uses_allocator.h" 1 3
# 40 "/usr/include/c++/14.2.1/bits/uses_allocator.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{




  struct __erased_type { };




  template<typename _Alloc, typename _Tp>
    using __is_erased_or_convertible
      = __or_<is_convertible<_Alloc, _Tp>, is_same<_Tp, __erased_type>>;


  struct allocator_arg_t { explicit allocator_arg_t() = default; };

  inline constexpr allocator_arg_t allocator_arg =
    allocator_arg_t();

  template<typename _Tp, typename _Alloc, typename = __void_t<>>
    struct __uses_allocator_helper
    : false_type { };

  template<typename _Tp, typename _Alloc>
    struct __uses_allocator_helper<_Tp, _Alloc,
       __void_t<typename _Tp::allocator_type>>
    : __is_erased_or_convertible<_Alloc, typename _Tp::allocator_type>::type
    { };


  template<typename _Tp, typename _Alloc>
    struct uses_allocator
    : __uses_allocator_helper<_Tp, _Alloc>::type
    { };

  struct __uses_alloc_base { };

  struct __uses_alloc0 : __uses_alloc_base
  {
    struct _Sink { void constexpr operator=(const void*) { } } _M_a;
  };

  template<typename _Alloc>
    struct __uses_alloc1 : __uses_alloc_base { const _Alloc* _M_a; };

  template<typename _Alloc>
    struct __uses_alloc2 : __uses_alloc_base { const _Alloc* _M_a; };

  template<bool, typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc;

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc<true, _Tp, _Alloc, _Args...>
    : __conditional_t<
        is_constructible<_Tp, allocator_arg_t, const _Alloc&, _Args...>::value,
        __uses_alloc1<_Alloc>,
        __uses_alloc2<_Alloc>>
    {


      static_assert(__or_<
   is_constructible<_Tp, allocator_arg_t, const _Alloc&, _Args...>,
   is_constructible<_Tp, _Args..., const _Alloc&>>::value,
   "construction with an allocator must be possible"
   " if uses_allocator is true");
    };

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc<false, _Tp, _Alloc, _Args...>
    : __uses_alloc0 { };

  template<typename _Tp, typename _Alloc, typename... _Args>
    using __uses_alloc_t =
      __uses_alloc<uses_allocator<_Tp, _Alloc>::value, _Tp, _Alloc, _Args...>;

  template<typename _Tp, typename _Alloc, typename... _Args>
    constexpr
    inline __uses_alloc_t<_Tp, _Alloc, _Args...>
    __use_alloc(const _Alloc& __a)
    {
      __uses_alloc_t<_Tp, _Alloc, _Args...> __ret;
      __ret._M_a = std::__addressof(__a);
      return __ret;
    }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void
    __use_alloc(const _Alloc&&) = delete;


  template <typename _Tp, typename _Alloc>
    inline constexpr bool uses_allocator_v =
      uses_allocator<_Tp, _Alloc>::value;


  template<template<typename...> class _Predicate,
    typename _Tp, typename _Alloc, typename... _Args>
    struct __is_uses_allocator_predicate
    : __conditional_t<uses_allocator<_Tp, _Alloc>::value,
      __or_<_Predicate<_Tp, allocator_arg_t, _Alloc, _Args...>,
     _Predicate<_Tp, _Args..., _Alloc>>,
      _Predicate<_Tp, _Args...>> { };

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __is_uses_allocator_constructible
    : __is_uses_allocator_predicate<is_constructible, _Tp, _Alloc, _Args...>
    { };


  template<typename _Tp, typename _Alloc, typename... _Args>
    inline constexpr bool __is_uses_allocator_constructible_v =
      __is_uses_allocator_constructible<_Tp, _Alloc, _Args...>::value;


  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __is_nothrow_uses_allocator_constructible
    : __is_uses_allocator_predicate<is_nothrow_constructible,
        _Tp, _Alloc, _Args...>
    { };



  template<typename _Tp, typename _Alloc, typename... _Args>
    inline constexpr bool
    __is_nothrow_uses_allocator_constructible_v =
      __is_nothrow_uses_allocator_constructible<_Tp, _Alloc, _Args...>::value;


  template<typename _Tp, typename... _Args>
    void __uses_allocator_construct_impl(__uses_alloc0, _Tp* __ptr,
      _Args&&... __args)
    { ::new ((void*)__ptr) _Tp(std::forward<_Args>(__args)...); }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void __uses_allocator_construct_impl(__uses_alloc1<_Alloc> __a, _Tp* __ptr,
      _Args&&... __args)
    {
      ::new ((void*)__ptr) _Tp(allocator_arg, *__a._M_a,
          std::forward<_Args>(__args)...);
    }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void __uses_allocator_construct_impl(__uses_alloc2<_Alloc> __a, _Tp* __ptr,
      _Args&&... __args)
    { ::new ((void*)__ptr) _Tp(std::forward<_Args>(__args)..., *__a._M_a); }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void __uses_allocator_construct(const _Alloc& __a, _Tp* __ptr,
        _Args&&... __args)
    {
      std::__uses_allocator_construct_impl(
   std::__use_alloc<_Tp, _Alloc, _Args...>(__a), __ptr,
   std::forward<_Args>(__args)...);
    }



}
# 41 "/usr/include/c++/14.2.1/bits/memory_resource.h" 2 3
# 1 "/usr/include/c++/14.2.1/bits/uses_allocator_args.h" 1 3
# 33 "/usr/include/c++/14.2.1/bits/uses_allocator_args.h" 3
       
# 34 "/usr/include/c++/14.2.1/bits/uses_allocator_args.h" 3

# 1 "/usr/include/c++/14.2.1/bits/version.h" 1 3
# 47 "/usr/include/c++/14.2.1/bits/version.h" 3
       
# 48 "/usr/include/c++/14.2.1/bits/version.h" 3
# 36 "/usr/include/c++/14.2.1/bits/uses_allocator_args.h" 2 3



# 1 "/usr/include/c++/14.2.1/tuple" 1 3
# 32 "/usr/include/c++/14.2.1/tuple" 3
       
# 33 "/usr/include/c++/14.2.1/tuple" 3
# 44 "/usr/include/c++/14.2.1/tuple" 3
# 1 "/usr/include/c++/14.2.1/bits/ranges_util.h" 1 3
# 34 "/usr/include/c++/14.2.1/bits/ranges_util.h" 3
# 1 "/usr/include/c++/14.2.1/bits/ranges_base.h" 1 3
# 33 "/usr/include/c++/14.2.1/bits/ranges_base.h" 3
       
# 34 "/usr/include/c++/14.2.1/bits/ranges_base.h" 3





# 1 "/usr/include/c++/14.2.1/bits/max_size_type.h" 1 3
# 33 "/usr/include/c++/14.2.1/bits/max_size_type.h" 3
       
# 34 "/usr/include/c++/14.2.1/bits/max_size_type.h" 3



# 1 "/usr/include/c++/14.2.1/numbers" 1 3
# 32 "/usr/include/c++/14.2.1/numbers" 3
       
# 33 "/usr/include/c++/14.2.1/numbers" 3


# 1 "/usr/include/c++/14.2.1/bits/version.h" 1 3
# 47 "/usr/include/c++/14.2.1/bits/version.h" 3
       
# 48 "/usr/include/c++/14.2.1/bits/version.h" 3
# 36 "/usr/include/c++/14.2.1/numbers" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{








namespace numbers
{


  template<typename _Tp>
    using _Enable_if_floating = enable_if_t<is_floating_point_v<_Tp>, _Tp>;



  template<typename _Tp>
    inline constexpr _Tp e_v
      = _Enable_if_floating<_Tp>(2.718281828459045235360287471352662498L);


  template<typename _Tp>
    inline constexpr _Tp log2e_v
      = _Enable_if_floating<_Tp>(1.442695040888963407359924681001892137L);


  template<typename _Tp>
    inline constexpr _Tp log10e_v
      = _Enable_if_floating<_Tp>(0.434294481903251827651128918916605082L);


  template<typename _Tp>
    inline constexpr _Tp pi_v
      = _Enable_if_floating<_Tp>(3.141592653589793238462643383279502884L);


  template<typename _Tp>
    inline constexpr _Tp inv_pi_v
      = _Enable_if_floating<_Tp>(0.318309886183790671537767526745028724L);


  template<typename _Tp>
    inline constexpr _Tp inv_sqrtpi_v
      = _Enable_if_floating<_Tp>(0.564189583547756286948079451560772586L);


  template<typename _Tp>
    inline constexpr _Tp ln2_v
      = _Enable_if_floating<_Tp>(0.693147180559945309417232121458176568L);


  template<typename _Tp>
    inline constexpr _Tp ln10_v
      = _Enable_if_floating<_Tp>(2.302585092994045684017991454684364208L);


  template<typename _Tp>
    inline constexpr _Tp sqrt2_v
      = _Enable_if_floating<_Tp>(1.414213562373095048801688724209698079L);


  template<typename _Tp>
    inline constexpr _Tp sqrt3_v
      = _Enable_if_floating<_Tp>(1.732050807568877293527446341505872367L);


  template<typename _Tp>
    inline constexpr _Tp inv_sqrt3_v
      = _Enable_if_floating<_Tp>(0.577350269189625764509148780501957456L);


  template<typename _Tp>
    inline constexpr _Tp egamma_v
      = _Enable_if_floating<_Tp>(0.577215664901532860606512090082402431L);


  template<typename _Tp>
    inline constexpr _Tp phi_v
      = _Enable_if_floating<_Tp>(1.618033988749894848204586834365638118L);

  inline constexpr double e = e_v<double>;
  inline constexpr double log2e = log2e_v<double>;
  inline constexpr double log10e = log10e_v<double>;
  inline constexpr double pi = pi_v<double>;
  inline constexpr double inv_pi = inv_pi_v<double>;
  inline constexpr double inv_sqrtpi = inv_sqrtpi_v<double>;
  inline constexpr double ln2 = ln2_v<double>;
  inline constexpr double ln10 = ln10_v<double>;
  inline constexpr double sqrt2 = sqrt2_v<double>;
  inline constexpr double sqrt3 = sqrt3_v<double>;
  inline constexpr double inv_sqrt3 = inv_sqrt3_v<double>;
  inline constexpr double egamma = egamma_v<double>;
  inline constexpr double phi = phi_v<double>;
# 225 "/usr/include/c++/14.2.1/numbers" 3
template<> inline constexpr __float128 e_v<__float128> = 2.718281828459045235360287471352662498Q; template<> inline constexpr __float128 log2e_v<__float128> = 1.442695040888963407359924681001892137Q; template<> inline constexpr __float128 log10e_v<__float128> = 0.434294481903251827651128918916605082Q; template<> inline constexpr __float128 pi_v<__float128> = 3.141592653589793238462643383279502884Q; template<> inline constexpr __float128 inv_pi_v<__float128> = 0.318309886183790671537767526745028724Q; template<> inline constexpr __float128 inv_sqrtpi_v<__float128> = 0.564189583547756286948079451560772586Q; template<> inline constexpr __float128 ln2_v<__float128> = 0.693147180559945309417232121458176568Q; template<> inline constexpr __float128 ln10_v<__float128> = 2.302585092994045684017991454684364208Q; template<> inline constexpr __float128 sqrt2_v<__float128> = 1.414213562373095048801688724209698079Q; template<> inline constexpr __float128 sqrt3_v<__float128> = 1.732050807568877293527446341505872367Q; template<> inline constexpr __float128 inv_sqrt3_v<__float128> = 0.577350269189625764509148780501957456Q; template<> inline constexpr __float128 egamma_v<__float128> = 0.577215664901532860606512090082402431Q; template<> inline constexpr __float128 phi_v<__float128> = 1.618033988749894848204586834365638118Q;




}


}
# 38 "/usr/include/c++/14.2.1/bits/max_size_type.h" 2 3
# 48 "/usr/include/c++/14.2.1/bits/max_size_type.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


template<typename _Tp>
  struct numeric_limits;

namespace ranges
{
  namespace __detail
  {
    class __max_size_type
    {
    public:
      __max_size_type() = default;

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 constexpr
 __max_size_type(_Tp __i) noexcept
   : _M_val(__i), _M_msb(__i < 0)
 { }

      constexpr explicit
      __max_size_type(const __max_diff_type& __d) noexcept;

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 constexpr explicit
 operator _Tp() const noexcept
 { return _M_val; }

      constexpr explicit
      operator bool() const noexcept
      { return _M_val != 0 || _M_msb != 0; }

      constexpr __max_size_type
      operator+() const noexcept
      { return *this; }

      constexpr __max_size_type
      operator~() const noexcept
      { return __max_size_type{~_M_val, !_M_msb}; }

      constexpr __max_size_type
      operator-() const noexcept
      { return operator~() + 1; }

      constexpr __max_size_type&
      operator++() noexcept
      { return *this += 1; }

      constexpr __max_size_type
      operator++(int) noexcept
      {
 auto __tmp = *this;
 ++*this;
 return __tmp;
      }

      constexpr __max_size_type&
      operator--() noexcept
      { return *this -= 1; }

      constexpr __max_size_type
      operator--(int) noexcept
      {
 auto __tmp = *this;
 --*this;
 return __tmp;
      }

      constexpr __max_size_type&
      operator+=(const __max_size_type& __r) noexcept
      {
 const auto __sum = _M_val + __r._M_val;
 const bool __overflow = (__sum < _M_val);
 _M_msb = _M_msb ^ __r._M_msb ^ __overflow;
 _M_val = __sum;
 return *this;
      }

      constexpr __max_size_type&
      operator-=(const __max_size_type& __r) noexcept
      { return *this += -__r; }

      constexpr __max_size_type&
      operator*=(__max_size_type __r) noexcept
      {
 constexpr __max_size_type __threshold
   = __rep(1) << (_S_rep_bits / 2 - 1);
 if (_M_val < __threshold && __r < __threshold)


   _M_val = _M_val * __r._M_val;
 else
   {



     const bool __lsb = _M_val & 1;
     const bool __rlsb = __r._M_val & 1;
     *this >>= 1;
     __r >>= 1;
     _M_val = (2 * _M_val * __r._M_val
        + _M_val * __rlsb + __r._M_val * __lsb);
     *this <<= 1;
     *this += __rlsb * __lsb;
   }

 return *this;
      }

      constexpr __max_size_type&
      operator/=(const __max_size_type& __r) noexcept
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__r != 0), false)) std::__glibcxx_assert_fail(); } while (false);

 if (!_M_msb && !__r._M_msb) [[likely]]
   _M_val /= __r._M_val;
 else if (_M_msb && __r._M_msb)
   {
     _M_val = (_M_val >= __r._M_val);
     _M_msb = 0;
   }
 else if (!_M_msb && __r._M_msb)
   _M_val = 0;
 else if (_M_msb && !__r._M_msb)
   {




     const auto __orig = *this;
     *this >>= 1;
     _M_val /= __r._M_val;
     *this <<= 1;
     if (__orig - *this * __r >= __r)
       ++_M_val;
   }
 return *this;
      }

      constexpr __max_size_type&
      operator%=(const __max_size_type& __r) noexcept
      {
 if (!_M_msb && !__r._M_msb) [[likely]]
   _M_val %= __r._M_val;
 else
   *this -= (*this / __r) * __r;
 return *this;
      }

      constexpr __max_size_type&
      operator<<=(const __max_size_type& __r) noexcept
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__r <= _S_rep_bits), false)) std::__glibcxx_assert_fail(); } while (false);
 if (__r != 0)
   {
     _M_msb = (_M_val >> (_S_rep_bits - __r._M_val)) & 1;

     if (__r._M_val == _S_rep_bits) [[unlikely]]
       _M_val = 0;
     else
       _M_val <<= __r._M_val;
   }
 return *this;
      }

      constexpr __max_size_type&
      operator>>=(const __max_size_type& __r) noexcept
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__r <= _S_rep_bits), false)) std::__glibcxx_assert_fail(); } while (false);
 if (__r != 0)
   {
     if (__r._M_val == _S_rep_bits) [[unlikely]]
       _M_val = 0;
     else
       _M_val >>= __r._M_val;

     if (_M_msb) [[unlikely]]
       {
  _M_val |= __rep(1) << (_S_rep_bits - __r._M_val);
  _M_msb = 0;
       }
   }
 return *this;
      }

      constexpr __max_size_type&
      operator&=(const __max_size_type& __r) noexcept
      {
 _M_val &= __r._M_val;
 _M_msb &= __r._M_msb;
 return *this;
      }

      constexpr __max_size_type&
      operator|=(const __max_size_type& __r) noexcept
      {
 _M_val |= __r._M_val;
 _M_msb |= __r._M_msb;
 return *this;
      }

      constexpr __max_size_type&
      operator^=(const __max_size_type& __r) noexcept
      {
 _M_val ^= __r._M_val;
 _M_msb ^= __r._M_msb;
 return *this;
      }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator+=(_Tp& __a, const __max_size_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a + __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator-=(_Tp& __a, const __max_size_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a - __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator*=(_Tp& __a, const __max_size_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a * __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator/=(_Tp& __a, const __max_size_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a / __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator%=(_Tp& __a, const __max_size_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a % __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator&=(_Tp& __a, const __max_size_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a & __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator|=(_Tp& __a, const __max_size_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a | __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator^=(_Tp& __a, const __max_size_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a ^ __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator<<=(_Tp& __a, const __max_size_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a << __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator>>=(_Tp& __a, const __max_size_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a >> __b)); }

      friend constexpr __max_size_type
      operator+(__max_size_type __l, const __max_size_type& __r) noexcept
      {
 __l += __r;
 return __l;
      }

      friend constexpr __max_size_type
      operator-(__max_size_type __l, const __max_size_type& __r) noexcept
      {
 __l -= __r;
 return __l;
      }

      friend constexpr __max_size_type
      operator*(__max_size_type __l, const __max_size_type& __r) noexcept
      {
 __l *= __r;
 return __l;
      }

      friend constexpr __max_size_type
      operator/(__max_size_type __l, const __max_size_type& __r) noexcept
      {
 __l /= __r;
 return __l;
      }

      friend constexpr __max_size_type
      operator%(__max_size_type __l, const __max_size_type& __r) noexcept
      {
 __l %= __r;
 return __l;
      }

      friend constexpr __max_size_type
      operator<<(__max_size_type __l, const __max_size_type& __r) noexcept
      {
 __l <<= __r;
 return __l;
      }

      friend constexpr __max_size_type
      operator>>(__max_size_type __l, const __max_size_type& __r) noexcept
      {
 __l >>= __r;
 return __l;
      }

      friend constexpr __max_size_type
      operator&(__max_size_type __l, const __max_size_type& __r) noexcept
      {
 __l &= __r;
 return __l;
      }

      friend constexpr __max_size_type
      operator|(__max_size_type __l, const __max_size_type& __r) noexcept
      {
 __l |= __r;
 return __l;
      }

      friend constexpr __max_size_type
      operator^(__max_size_type __l, const __max_size_type& __r) noexcept
      {
 __l ^= __r;
 return __l;
      }

      friend constexpr bool
      operator==(const __max_size_type& __l, const __max_size_type& __r) noexcept
      { return __l._M_val == __r._M_val && __l._M_msb == __r._M_msb; }


      friend constexpr strong_ordering
      operator<=>(const __max_size_type& __l, const __max_size_type& __r) noexcept
      {
 if (__l._M_msb ^ __r._M_msb)
   return __l._M_msb ? strong_ordering::greater : strong_ordering::less;
 else
   return __l._M_val <=> __r._M_val;
      }
# 420 "/usr/include/c++/14.2.1/bits/max_size_type.h" 3
      __extension__
      using __rep = unsigned __int128;



      static constexpr size_t _S_rep_bits = sizeof(__rep) * 8;
    private:
      __rep _M_val = 0;
      unsigned _M_msb:1 = 0;

      constexpr explicit
      __max_size_type(__rep __val, int __msb) noexcept
 : _M_val(__val), _M_msb(__msb)
      { }

      friend __max_diff_type;
      friend std::numeric_limits<__max_size_type>;
      friend std::numeric_limits<__max_diff_type>;
    };

    class __max_diff_type
    {
    public:
      __max_diff_type() = default;

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 constexpr
 __max_diff_type(_Tp __i) noexcept
   : _M_rep(__i)
 { }

      constexpr explicit
      __max_diff_type(const __max_size_type& __d) noexcept
 : _M_rep(__d)
      { }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 constexpr explicit
 operator _Tp() const noexcept
 { return static_cast<_Tp>(_M_rep); }

      constexpr explicit
      operator bool() const noexcept
      { return _M_rep != 0; }

      constexpr __max_diff_type
      operator+() const noexcept
      { return *this; }

      constexpr __max_diff_type
      operator-() const noexcept
      { return __max_diff_type(-_M_rep); }

      constexpr __max_diff_type
      operator~() const noexcept
      { return __max_diff_type(~_M_rep); }

      constexpr __max_diff_type&
      operator++() noexcept
      { return *this += 1; }

      constexpr __max_diff_type
      operator++(int) noexcept
      {
 auto __tmp = *this;
 ++*this;
 return __tmp;
      }

      constexpr __max_diff_type&
      operator--() noexcept
      { return *this -= 1; }

      constexpr __max_diff_type
      operator--(int) noexcept
      {
 auto __tmp = *this;
 --*this;
 return __tmp;
      }

      constexpr __max_diff_type&
      operator+=(const __max_diff_type& __r) noexcept
      {
 _M_rep += __r._M_rep;
 return *this;
      }

      constexpr __max_diff_type&
      operator-=(const __max_diff_type& __r) noexcept
      {
 _M_rep -= __r._M_rep;
 return *this;
      }

      constexpr __max_diff_type&
      operator*=(const __max_diff_type& __r) noexcept
      {
 _M_rep *= __r._M_rep;
 return *this;
      }

      constexpr __max_diff_type&
      operator/=(const __max_diff_type& __r) noexcept
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__r != 0), false)) std::__glibcxx_assert_fail(); } while (false);
 const bool __neg = *this < 0;
 const bool __rneg = __r < 0;
 if (!__neg && !__rneg)
   _M_rep = _M_rep / __r._M_rep;
 else if (__neg && __rneg)
   _M_rep = -_M_rep / -__r._M_rep;
 else if (__neg && !__rneg)
   _M_rep = -(-_M_rep / __r._M_rep);
 else
   _M_rep = -(_M_rep / -__r._M_rep);
 return *this ;
      }

      constexpr __max_diff_type&
      operator%=(const __max_diff_type& __r) noexcept
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__r != 0), false)) std::__glibcxx_assert_fail(); } while (false);
 if (*this >= 0 && __r > 0)
   _M_rep %= __r._M_rep;
 else
   *this -= (*this / __r) * __r;
 return *this;
      }

      constexpr __max_diff_type&
      operator<<=(const __max_diff_type& __r) noexcept
      {
 _M_rep.operator<<=(__r._M_rep);
 return *this;
      }

      constexpr __max_diff_type&
      operator>>=(const __max_diff_type& __r) noexcept
      {

 const auto __msb = _M_rep._M_msb;
 _M_rep >>= __r._M_rep;
 if (__msb)
   _M_rep |= ~(__max_size_type(-1) >> __r._M_rep);
 return *this;
      }

      constexpr __max_diff_type&
      operator&=(const __max_diff_type& __r) noexcept
      {
 _M_rep &= __r._M_rep;
 return *this;
      }

      constexpr __max_diff_type&
      operator|=(const __max_diff_type& __r) noexcept
      {
 _M_rep |= __r._M_rep;
 return *this;
      }

      constexpr __max_diff_type&
      operator^=(const __max_diff_type& __r) noexcept
      {
 _M_rep ^= __r._M_rep;
 return *this;
      }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator+=(_Tp& __a, const __max_diff_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a + __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator-=(_Tp& __a, const __max_diff_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a - __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator*=(_Tp& __a, const __max_diff_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a * __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator/=(_Tp& __a, const __max_diff_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a / __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator%=(_Tp& __a, const __max_diff_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a % __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator&=(_Tp& __a, const __max_diff_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a & __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator|=(_Tp& __a, const __max_diff_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a | __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator^=(_Tp& __a, const __max_diff_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a ^ __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator<<=(_Tp& __a, const __max_diff_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a << __b)); }

      template<typename _Tp> requires integral<_Tp> || __is_int128<_Tp>
 friend constexpr _Tp&
 operator>>=(_Tp& __a, const __max_diff_type& __b) noexcept
 { return (__a = static_cast<_Tp>(__a >> __b)); }

      friend constexpr __max_diff_type
      operator+(__max_diff_type __l, const __max_diff_type& __r) noexcept
      {
 __l += __r;
 return __l;
      }

      friend constexpr __max_diff_type
      operator-(__max_diff_type __l, const __max_diff_type& __r) noexcept
      {
 __l -= __r;
 return __l;
      }

      friend constexpr __max_diff_type
      operator*(__max_diff_type __l, const __max_diff_type& __r) noexcept
      {
 __l *= __r;
 return __l;
      }

      friend constexpr __max_diff_type
      operator/(__max_diff_type __l, const __max_diff_type& __r) noexcept
      {
 __l /= __r;
 return __l;
      }

      friend constexpr __max_diff_type
      operator%(__max_diff_type __l, const __max_diff_type& __r) noexcept
      {
 __l %= __r;
 return __l;
      }

      friend constexpr __max_diff_type
      operator<<(__max_diff_type __l, const __max_diff_type& __r) noexcept
      {
 __l <<= __r;
 return __l;
      }

      friend constexpr __max_diff_type
      operator>>(__max_diff_type __l, const __max_diff_type& __r) noexcept
      {
 __l >>= __r;
 return __l;
      }

      friend constexpr __max_diff_type
      operator&(__max_diff_type __l, const __max_diff_type& __r) noexcept
      {
 __l &= __r;
 return __l;
      }

      friend constexpr __max_diff_type
      operator|(__max_diff_type __l, const __max_diff_type& __r) noexcept
      {
 __l |= __r;
 return __l;
      }

      friend constexpr __max_diff_type
      operator^(__max_diff_type __l, const __max_diff_type& __r) noexcept
      {
 __l ^= __r;
 return __l;
      }

      friend constexpr bool
      operator==(const __max_diff_type& __l, const __max_diff_type& __r) noexcept
      { return __l._M_rep == __r._M_rep; }


      constexpr strong_ordering
      operator<=>(const __max_diff_type& __r) const noexcept
      {
 const auto __lsign = _M_rep._M_msb;
 const auto __rsign = __r._M_rep._M_msb;
 if (__lsign ^ __rsign)
   return __lsign ? strong_ordering::less : strong_ordering::greater;
 else
   return _M_rep <=> __r._M_rep;
      }
# 753 "/usr/include/c++/14.2.1/bits/max_size_type.h" 3
    private:
      __max_size_type _M_rep = 0;

      friend class __max_size_type;
    };

    constexpr
    __max_size_type::__max_size_type(const __max_diff_type& __d) noexcept
      : __max_size_type(__d._M_rep)
    { }

  }
}

  template<>
    struct numeric_limits<ranges::__detail::__max_size_type>
    {
      using _Sp = ranges::__detail::__max_size_type;
      static constexpr bool is_specialized = true;
      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int digits
 = __gnu_cxx::__int_traits<_Sp::__rep>::__digits + 1;
      static constexpr int digits10
 = static_cast<int>(digits * numbers::ln2 / numbers::ln10);

      static constexpr _Sp
      min() noexcept
      { return 0; }

      static constexpr _Sp
      max() noexcept
      { return _Sp(static_cast<_Sp::__rep>(-1), 1); }

      static constexpr _Sp
      lowest() noexcept
      { return min(); }
    };

  template<>
    struct numeric_limits<ranges::__detail::__max_diff_type>
    {
      using _Dp = ranges::__detail::__max_diff_type;
      using _Sp = ranges::__detail::__max_size_type;
      static constexpr bool is_specialized = true;
      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int digits = numeric_limits<_Sp>::digits - 1;
      static constexpr int digits10
 = static_cast<int>(digits * numbers::ln2 / numbers::ln10);

      static constexpr _Dp
      min() noexcept
      { return _Dp(_Sp(0, 1)); }

      static constexpr _Dp
      max() noexcept
      { return _Dp(_Sp(static_cast<_Sp::__rep>(-1), 0)); }

      static constexpr _Dp
      lowest() noexcept
      { return min(); }
    };


}
# 40 "/usr/include/c++/14.2.1/bits/ranges_base.h" 2 3
# 1 "/usr/include/c++/14.2.1/bits/version.h" 1 3
# 47 "/usr/include/c++/14.2.1/bits/version.h" 3
       
# 48 "/usr/include/c++/14.2.1/bits/version.h" 3
# 41 "/usr/include/c++/14.2.1/bits/ranges_base.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{

namespace ranges
{
  template<typename>
    inline constexpr bool disable_sized_range = false;

  template<typename _Tp>
    inline constexpr bool enable_borrowed_range = false;

  namespace __detail
  {
    constexpr __max_size_type
    __to_unsigned_like(__max_size_type __t) noexcept
    { return __t; }

    constexpr __max_size_type
    __to_unsigned_like(__max_diff_type __t) noexcept
    { return __max_size_type(__t); }

    template<integral _Tp>
      constexpr auto
      __to_unsigned_like(_Tp __t) noexcept
      { return static_cast<make_unsigned_t<_Tp>>(__t); }
# 79 "/usr/include/c++/14.2.1/bits/ranges_base.h" 3
    template<typename _Tp>
      using __make_unsigned_like_t
 = decltype(__detail::__to_unsigned_like(std::declval<_Tp>()));


    template<typename _Tp>
      concept __maybe_borrowed_range
 = is_lvalue_reference_v<_Tp>
   || enable_borrowed_range<remove_cvref_t<_Tp>>;

  }


  namespace __access
  {
    using std::ranges::__detail::__maybe_borrowed_range;
    using std::__detail::__range_iter_t;

    struct _Begin
    {
    private:
      template<typename _Tp>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (is_array_v<remove_reference_t<_Tp>>)
     return true;
   else if constexpr (__member_begin<_Tp>)
     return noexcept(__decay_copy(std::declval<_Tp&>().begin()));
   else
     return noexcept(__decay_copy(begin(std::declval<_Tp&>())));
 }

    public:
      template<__maybe_borrowed_range _Tp>
 requires is_array_v<remove_reference_t<_Tp>> || __member_begin<_Tp>
   || __adl_begin<_Tp>
 constexpr auto
 operator()[[nodiscard]](_Tp&& __t) const noexcept(_S_noexcept<_Tp&>())
 {
   if constexpr (is_array_v<remove_reference_t<_Tp>>)
     {
       static_assert(is_lvalue_reference_v<_Tp>);
       return __t + 0;
     }
   else if constexpr (__member_begin<_Tp>)
     return __t.begin();
   else
     return begin(__t);
 }
    };

    template<typename _Tp>
      concept __member_end = requires(_Tp& __t)
 {
   { __decay_copy(__t.end()) } -> sentinel_for<__range_iter_t<_Tp>>;
 };


    void end() = delete;

    template<typename _Tp>
      concept __adl_end = __class_or_enum<remove_reference_t<_Tp>>
 && requires(_Tp& __t)
 {
   { __decay_copy(end(__t)) } -> sentinel_for<__range_iter_t<_Tp>>;
 };

    struct _End
    {
    private:
      template<typename _Tp>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (is_bounded_array_v<remove_reference_t<_Tp>>)
     return true;
   else if constexpr (__member_end<_Tp>)
     return noexcept(__decay_copy(std::declval<_Tp&>().end()));
   else
     return noexcept(__decay_copy(end(std::declval<_Tp&>())));
 }

    public:
      template<__maybe_borrowed_range _Tp>
 requires is_bounded_array_v<remove_reference_t<_Tp>>
   || __member_end<_Tp> || __adl_end<_Tp>
 constexpr auto
 operator()[[nodiscard]](_Tp&& __t) const noexcept(_S_noexcept<_Tp&>())
 {
   if constexpr (is_bounded_array_v<remove_reference_t<_Tp>>)
     {
       static_assert(is_lvalue_reference_v<_Tp>);
       return __t + extent_v<remove_reference_t<_Tp>>;
     }
   else if constexpr (__member_end<_Tp>)
     return __t.end();
   else
     return end(__t);
 }
    };

    template<typename _Tp>
      concept __member_rbegin = requires(_Tp& __t)
 {
   { __decay_copy(__t.rbegin()) } -> input_or_output_iterator;
 };

    void rbegin() = delete;

    template<typename _Tp>
      concept __adl_rbegin = __class_or_enum<remove_reference_t<_Tp>>
 && requires(_Tp& __t)
 {
   { __decay_copy(rbegin(__t)) } -> input_or_output_iterator;
 };

    template<typename _Tp>
      concept __reversable = requires(_Tp& __t)
 {
   { _Begin{}(__t) } -> bidirectional_iterator;
   { _End{}(__t) } -> same_as<decltype(_Begin{}(__t))>;
 };

    struct _RBegin
    {
    private:
      template<typename _Tp>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (__member_rbegin<_Tp>)
     return noexcept(__decay_copy(std::declval<_Tp&>().rbegin()));
   else if constexpr (__adl_rbegin<_Tp>)
     return noexcept(__decay_copy(rbegin(std::declval<_Tp&>())));
   else
     {
       if constexpr (noexcept(_End{}(std::declval<_Tp&>())))
  {
    using _It = decltype(_End{}(std::declval<_Tp&>()));

    return is_nothrow_copy_constructible_v<_It>;
  }
       else
  return false;
     }
 }

    public:
      template<__maybe_borrowed_range _Tp>
 requires __member_rbegin<_Tp> || __adl_rbegin<_Tp> || __reversable<_Tp>
 constexpr auto
 operator()[[nodiscard]](_Tp&& __t) const
 noexcept(_S_noexcept<_Tp&>())
 {
   if constexpr (__member_rbegin<_Tp>)
     return __t.rbegin();
   else if constexpr (__adl_rbegin<_Tp>)
     return rbegin(__t);
   else
     return std::make_reverse_iterator(_End{}(__t));
 }
    };

    template<typename _Tp>
      concept __member_rend = requires(_Tp& __t)
 {
   { __decay_copy(__t.rend()) }
     -> sentinel_for<decltype(_RBegin{}(std::forward<_Tp>(__t)))>;
 };

    void rend() = delete;

    template<typename _Tp>
      concept __adl_rend = __class_or_enum<remove_reference_t<_Tp>>
 && requires(_Tp& __t)
 {
   { __decay_copy(rend(__t)) }
     -> sentinel_for<decltype(_RBegin{}(std::forward<_Tp>(__t)))>;
 };

    struct _REnd
    {
    private:
      template<typename _Tp>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (__member_rend<_Tp>)
     return noexcept(__decay_copy(std::declval<_Tp&>().rend()));
   else if constexpr (__adl_rend<_Tp>)
     return noexcept(__decay_copy(rend(std::declval<_Tp&>())));
   else
     {
       if constexpr (noexcept(_Begin{}(std::declval<_Tp&>())))
  {
    using _It = decltype(_Begin{}(std::declval<_Tp&>()));

    return is_nothrow_copy_constructible_v<_It>;
  }
       else
  return false;
     }
 }

    public:
      template<__maybe_borrowed_range _Tp>
 requires __member_rend<_Tp> || __adl_rend<_Tp> || __reversable<_Tp>
 constexpr auto
 operator()[[nodiscard]](_Tp&& __t) const
 noexcept(_S_noexcept<_Tp&>())
 {
   if constexpr (__member_rend<_Tp>)
     return __t.rend();
   else if constexpr (__adl_rend<_Tp>)
     return rend(__t);
   else
     return std::make_reverse_iterator(_Begin{}(__t));
 }
    };

    template<typename _Tp>
      concept __member_size = !disable_sized_range<remove_cvref_t<_Tp>>
 && requires(_Tp& __t)
 {
   { __decay_copy(__t.size()) } -> __detail::__is_integer_like;
 };

    void size() = delete;

    template<typename _Tp>
      concept __adl_size = __class_or_enum<remove_reference_t<_Tp>>
 && !disable_sized_range<remove_cvref_t<_Tp>>
 && requires(_Tp& __t)
 {
   { __decay_copy(size(__t)) } -> __detail::__is_integer_like;
 };

    template<typename _Tp>
      concept __sentinel_size = requires(_Tp& __t)
 {
   requires (!is_unbounded_array_v<remove_reference_t<_Tp>>);

   { _Begin{}(__t) } -> forward_iterator;

   { _End{}(__t) } -> sized_sentinel_for<decltype(_Begin{}(__t))>;

   __detail::__to_unsigned_like(_End{}(__t) - _Begin{}(__t));
 };

    struct _Size
    {
    private:
      template<typename _Tp>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (is_bounded_array_v<remove_reference_t<_Tp>>)
     return true;
   else if constexpr (__member_size<_Tp>)
     return noexcept(__decay_copy(std::declval<_Tp&>().size()));
   else if constexpr (__adl_size<_Tp>)
     return noexcept(__decay_copy(size(std::declval<_Tp&>())));
   else if constexpr (__sentinel_size<_Tp>)
     return noexcept(_End{}(std::declval<_Tp&>())
       - _Begin{}(std::declval<_Tp&>()));
 }

    public:
      template<typename _Tp>
 requires is_bounded_array_v<remove_reference_t<_Tp>>
   || __member_size<_Tp> || __adl_size<_Tp> || __sentinel_size<_Tp>
 constexpr auto
 operator()[[nodiscard]](_Tp&& __t) const noexcept(_S_noexcept<_Tp&>())
 {
   if constexpr (is_bounded_array_v<remove_reference_t<_Tp>>)
     return extent_v<remove_reference_t<_Tp>>;
   else if constexpr (__member_size<_Tp>)
     return __t.size();
   else if constexpr (__adl_size<_Tp>)
     return size(__t);
   else if constexpr (__sentinel_size<_Tp>)
     return __detail::__to_unsigned_like(_End{}(__t) - _Begin{}(__t));
 }
    };

    struct _SSize
    {


      template<typename _Tp>
 requires requires (_Tp& __t) { _Size{}(__t); }
 constexpr auto
 operator()[[nodiscard]](_Tp&& __t) const noexcept(noexcept(_Size{}(__t)))
 {
   auto __size = _Size{}(__t);
   using __size_type = decltype(__size);

   if constexpr (integral<__size_type>)
     {
       using __gnu_cxx::__int_traits;
       if constexpr (__int_traits<__size_type>::__digits
       < __int_traits<ptrdiff_t>::__digits)
  return static_cast<ptrdiff_t>(__size);
       else
  return static_cast<make_signed_t<__size_type>>(__size);
     }





   else
     return __detail::__max_diff_type(__size);
 }
    };

    template<typename _Tp>
      concept __member_empty = requires(_Tp& __t) { bool(__t.empty()); };

    template<typename _Tp>
      concept __size0_empty = requires(_Tp& __t) { _Size{}(__t) == 0; };

    template<typename _Tp>
      concept __eq_iter_empty = requires(_Tp& __t)
 {
   requires (!is_unbounded_array_v<remove_reference_t<_Tp>>);

   { _Begin{}(__t) } -> forward_iterator;

   bool(_Begin{}(__t) == _End{}(__t));
 };

    struct _Empty
    {
    private:
      template<typename _Tp>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (__member_empty<_Tp>)
     return noexcept(bool(std::declval<_Tp&>().empty()));
   else if constexpr (__size0_empty<_Tp>)
     return noexcept(_Size{}(std::declval<_Tp&>()) == 0);
   else
     return noexcept(bool(_Begin{}(std::declval<_Tp&>())
  == _End{}(std::declval<_Tp&>())));
 }

    public:
      template<typename _Tp>
 requires __member_empty<_Tp> || __size0_empty<_Tp>
   || __eq_iter_empty<_Tp>
 constexpr bool
 operator()[[nodiscard]](_Tp&& __t) const noexcept(_S_noexcept<_Tp&>())
 {
   if constexpr (__member_empty<_Tp>)
     return bool(__t.empty());
   else if constexpr (__size0_empty<_Tp>)
     return _Size{}(__t) == 0;
   else
     return bool(_Begin{}(__t) == _End{}(__t));
 }
    };

    template<typename _Tp>
      concept __pointer_to_object = is_pointer_v<_Tp>
        && is_object_v<remove_pointer_t<_Tp>>;

    template<typename _Tp>
      concept __member_data = requires(_Tp& __t)
 {
   { __decay_copy(__t.data()) } -> __pointer_to_object;
 };

    template<typename _Tp>
      concept __begin_data = contiguous_iterator<__range_iter_t<_Tp>>;

    struct _Data
    {
    private:
      template<typename _Tp>
 static constexpr bool
 _S_noexcept()
 {
   if constexpr (__member_data<_Tp>)
     return noexcept(__decay_copy(std::declval<_Tp&>().data()));
   else
     return noexcept(_Begin{}(std::declval<_Tp&>()));
 }

    public:
      template<__maybe_borrowed_range _Tp>
 requires __member_data<_Tp> || __begin_data<_Tp>
 constexpr auto
 operator()[[nodiscard]](_Tp&& __t) const noexcept(_S_noexcept<_Tp>())
 {
   if constexpr (__member_data<_Tp>)
     return __t.data();
   else
     return std::to_address(_Begin{}(__t));
 }
    };

  }

  inline namespace _Cpo
  {
    inline constexpr ranges::__access::_Begin begin{};
    inline constexpr ranges::__access::_End end{};
    inline constexpr ranges::__access::_RBegin rbegin{};
    inline constexpr ranges::__access::_REnd rend{};
    inline constexpr ranges::__access::_Size size{};
    inline constexpr ranges::__access::_SSize ssize{};
    inline constexpr ranges::__access::_Empty empty{};
    inline constexpr ranges::__access::_Data data{};
  }


  template<typename _Tp>
    concept range = requires(_Tp& __t)
      {
 ranges::begin(__t);
 ranges::end(__t);
      };


  template<typename _Tp>
    concept borrowed_range
      = range<_Tp> && __detail::__maybe_borrowed_range<_Tp>;

  template<typename _Tp>
    using iterator_t = std::__detail::__range_iter_t<_Tp>;

  template<range _Range>
    using sentinel_t = decltype(ranges::end(std::declval<_Range&>()));
# 527 "/usr/include/c++/14.2.1/bits/ranges_base.h" 3
  template<range _Range>
    using range_difference_t = iter_difference_t<iterator_t<_Range>>;

  template<range _Range>
    using range_value_t = iter_value_t<iterator_t<_Range>>;

  template<range _Range>
    using range_reference_t = iter_reference_t<iterator_t<_Range>>;

  template<range _Range>
    using range_rvalue_reference_t
      = iter_rvalue_reference_t<iterator_t<_Range>>;


  template<typename _Tp>
    concept sized_range = range<_Tp>
      && requires(_Tp& __t) { ranges::size(__t); };

  template<sized_range _Range>
    using range_size_t = decltype(ranges::size(std::declval<_Range&>()));

  template<typename _Derived>
    requires is_class_v<_Derived> && same_as<_Derived, remove_cv_t<_Derived>>
    class view_interface;

  namespace __detail
  {
    template<typename _Tp, typename _Up>
      requires (!same_as<_Tp, view_interface<_Up>>)
      void __is_derived_from_view_interface_fn(const _Tp&,
            const view_interface<_Up>&);



    template<typename _Tp>
      concept __is_derived_from_view_interface
 = requires (_Tp __t) { __is_derived_from_view_interface_fn(__t, __t); };
  }


  struct view_base { };


  template<typename _Tp>
    inline constexpr bool enable_view = derived_from<_Tp, view_base>
      || __detail::__is_derived_from_view_interface<_Tp>;


  template<typename _Tp>
    concept view
      = range<_Tp> && movable<_Tp> && enable_view<_Tp>;




  template<typename _Range, typename _Tp>
    concept output_range
      = range<_Range> && output_iterator<iterator_t<_Range>, _Tp>;


  template<typename _Tp>
    concept input_range = range<_Tp> && input_iterator<iterator_t<_Tp>>;


  template<typename _Tp>
    concept forward_range
      = input_range<_Tp> && forward_iterator<iterator_t<_Tp>>;


  template<typename _Tp>
    concept bidirectional_range
      = forward_range<_Tp> && bidirectional_iterator<iterator_t<_Tp>>;


  template<typename _Tp>
    concept random_access_range
      = bidirectional_range<_Tp> && random_access_iterator<iterator_t<_Tp>>;


  template<typename _Tp>
    concept contiguous_range
      = random_access_range<_Tp> && contiguous_iterator<iterator_t<_Tp>>
      && requires(_Tp& __t)
      {
 { ranges::data(__t) } -> same_as<add_pointer_t<range_reference_t<_Tp>>>;
      };


  template<typename _Tp>
    concept common_range
      = range<_Tp> && same_as<iterator_t<_Tp>, sentinel_t<_Tp>>;







  namespace __access
  {
# 639 "/usr/include/c++/14.2.1/bits/ranges_base.h" 3
    template<typename _To, typename _Tp>
      constexpr decltype(auto)
      __as_const(_Tp& __t) noexcept
      {
 static_assert(std::is_same_v<_To&, _Tp&>);

 if constexpr (is_lvalue_reference_v<_To>)
   return const_cast<const _Tp&>(__t);
 else
   return static_cast<const _Tp&&>(__t);
      }


    struct _CBegin
    {
# 668 "/usr/include/c++/14.2.1/bits/ranges_base.h" 3
      template<typename _Tp>
 [[nodiscard]]
 constexpr auto
 operator()(_Tp&& __e) const
 noexcept(noexcept(_Begin{}(__access::__as_const<_Tp>(__e))))
 requires requires { _Begin{}(__access::__as_const<_Tp>(__e)); }
 {
   return _Begin{}(__access::__as_const<_Tp>(__e));
 }

    };

    struct _CEnd final
    {
# 696 "/usr/include/c++/14.2.1/bits/ranges_base.h" 3
      template<typename _Tp>
 [[nodiscard]]
 constexpr auto
 operator()(_Tp&& __e) const
 noexcept(noexcept(_End{}(__access::__as_const<_Tp>(__e))))
 requires requires { _End{}(__access::__as_const<_Tp>(__e)); }
 {
   return _End{}(__access::__as_const<_Tp>(__e));
 }

    };

    struct _CRBegin
    {
# 724 "/usr/include/c++/14.2.1/bits/ranges_base.h" 3
      template<typename _Tp>
 [[nodiscard]]
 constexpr auto
 operator()(_Tp&& __e) const
 noexcept(noexcept(_RBegin{}(__access::__as_const<_Tp>(__e))))
 requires requires { _RBegin{}(__access::__as_const<_Tp>(__e)); }
 {
   return _RBegin{}(__access::__as_const<_Tp>(__e));
 }

    };

    struct _CREnd
    {
# 752 "/usr/include/c++/14.2.1/bits/ranges_base.h" 3
      template<typename _Tp>
 [[nodiscard]]
 constexpr auto
 operator()(_Tp&& __e) const
 noexcept(noexcept(_REnd{}(__access::__as_const<_Tp>(__e))))
 requires requires { _REnd{}(__access::__as_const<_Tp>(__e)); }
 {
   return _REnd{}(__access::__as_const<_Tp>(__e));
 }

    };

    struct _CData
    {
# 775 "/usr/include/c++/14.2.1/bits/ranges_base.h" 3
      template<typename _Tp>
 [[nodiscard]]
 constexpr auto
 operator()(_Tp&& __e) const
 noexcept(noexcept(_Data{}(__access::__as_const<_Tp>(__e))))
 requires requires { _Data{}(__access::__as_const<_Tp>(__e)); }
 {
   return _Data{}(__access::__as_const<_Tp>(__e));
 }

    };
  }

  inline namespace _Cpo
  {
    inline constexpr ranges::__access::_CBegin cbegin{};
    inline constexpr ranges::__access::_CEnd cend{};
    inline constexpr ranges::__access::_CRBegin crbegin{};
    inline constexpr ranges::__access::_CREnd crend{};
    inline constexpr ranges::__access::_CData cdata{};
  }

  namespace __detail
  {
    template<typename _Tp>
      inline constexpr bool __is_initializer_list = false;

    template<typename _Tp>
      inline constexpr bool __is_initializer_list<initializer_list<_Tp>> = true;
  }


  template<typename _Tp>
    concept viewable_range = range<_Tp>
      && ((view<remove_cvref_t<_Tp>> && constructible_from<remove_cvref_t<_Tp>, _Tp>)
   || (!view<remove_cvref_t<_Tp>>
       && (is_lvalue_reference_v<_Tp>
    || (movable<remove_reference_t<_Tp>>
        && !__detail::__is_initializer_list<remove_cvref_t<_Tp>>))));



  struct __advance_fn final
  {
    template<input_or_output_iterator _It>
      constexpr void
      operator()(_It& __it, iter_difference_t<_It> __n) const
      {
 if constexpr (random_access_iterator<_It>)
   __it += __n;
 else if constexpr (bidirectional_iterator<_It>)
   {
     if (__n > 0)
       {
  do
    {
      ++__it;
    }
  while (--__n);
       }
     else if (__n < 0)
       {
  do
    {
      --__it;
    }
  while (++__n);
       }
   }
 else
   {

     do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__n >= 0), false)) std::__glibcxx_assert_fail(); } while (false);
     while (__n-- > 0)
       ++__it;
   }
      }

    template<input_or_output_iterator _It, sentinel_for<_It> _Sent>
      constexpr void
      operator()(_It& __it, _Sent __bound) const
      {
 if constexpr (assignable_from<_It&, _Sent>)
   __it = std::move(__bound);
 else if constexpr (sized_sentinel_for<_Sent, _It>)
   (*this)(__it, __bound - __it);
 else
   {
     while (__it != __bound)
       ++__it;
   }
      }

    template<input_or_output_iterator _It, sentinel_for<_It> _Sent>
      constexpr iter_difference_t<_It>
      operator()(_It& __it, iter_difference_t<_It> __n, _Sent __bound) const
      {
 if constexpr (sized_sentinel_for<_Sent, _It>)
   {
     const auto __diff = __bound - __it;

     if (__diff == 0)
       return __n;
     else if (__diff > 0 ? __n >= __diff : __n <= __diff)
       {
  (*this)(__it, __bound);
  return __n - __diff;
       }
     else if (__n != 0) [[likely]]
       {

  do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool((__n < 0) == (__diff < 0)), false)) std::__glibcxx_assert_fail(); } while (false);

  (*this)(__it, __n);
  return 0;
       }
     else
       return 0;
   }
 else if (__it == __bound || __n == 0)
   return __n;
 else if (__n > 0)
   {
     iter_difference_t<_It> __m = 0;
     do
       {
  ++__it;
  ++__m;
       }
     while (__m != __n && __it != __bound);
     return __n - __m;
   }
 else if constexpr (bidirectional_iterator<_It> && same_as<_It, _Sent>)
   {
     iter_difference_t<_It> __m = 0;
     do
       {
  --__it;
  --__m;
       }
     while (__m != __n && __it != __bound);
     return __n - __m;
   }
 else
   {

     do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__n >= 0), false)) std::__glibcxx_assert_fail(); } while (false);
     return __n;
   }
      }

    void operator&() const = delete;
  };

  inline constexpr __advance_fn advance{};

  struct __distance_fn final
  {
    template<input_or_output_iterator _It, sentinel_for<_It> _Sent>
      requires (!sized_sentinel_for<_Sent, _It>)
      constexpr iter_difference_t<_It>
      operator()[[nodiscard]](_It __first, _Sent __last) const
      {
 iter_difference_t<_It> __n = 0;
 while (__first != __last)
   {
     ++__first;
     ++__n;
   }
 return __n;
      }

    template<input_or_output_iterator _It, sized_sentinel_for<_It> _Sent>
      [[nodiscard]]
      constexpr iter_difference_t<_It>
      operator()(const _It& __first, const _Sent& __last) const
      {
 return __last - __first;
      }

    template<range _Range>
      [[nodiscard]]
      constexpr range_difference_t<_Range>
      operator()(_Range&& __r) const
      {
 if constexpr (sized_range<_Range>)
   return static_cast<range_difference_t<_Range>>(ranges::size(__r));
 else
   return (*this)(ranges::begin(__r), ranges::end(__r));
      }

    void operator&() const = delete;
  };

  inline constexpr __distance_fn distance{};

  struct __next_fn final
  {
    template<input_or_output_iterator _It>
      [[nodiscard]]
      constexpr _It
      operator()(_It __x) const
      {
 ++__x;
 return __x;
      }

    template<input_or_output_iterator _It>
      [[nodiscard]]
      constexpr _It
      operator()(_It __x, iter_difference_t<_It> __n) const
      {
 ranges::advance(__x, __n);
 return __x;
      }

    template<input_or_output_iterator _It, sentinel_for<_It> _Sent>
      [[nodiscard]]
      constexpr _It
      operator()(_It __x, _Sent __bound) const
      {
 ranges::advance(__x, __bound);
 return __x;
      }

    template<input_or_output_iterator _It, sentinel_for<_It> _Sent>
      [[nodiscard]]
      constexpr _It
      operator()(_It __x, iter_difference_t<_It> __n, _Sent __bound) const
      {
 ranges::advance(__x, __n, __bound);
 return __x;
      }

    void operator&() const = delete;
  };

  inline constexpr __next_fn next{};

  struct __prev_fn final
  {
    template<bidirectional_iterator _It>
      [[nodiscard]]
      constexpr _It
      operator()(_It __x) const
      {
 --__x;
 return __x;
      }

    template<bidirectional_iterator _It>
      [[nodiscard]]
      constexpr _It
      operator()(_It __x, iter_difference_t<_It> __n) const
      {
 ranges::advance(__x, -__n);
 return __x;
      }

    template<bidirectional_iterator _It>
      [[nodiscard]]
      constexpr _It
      operator()(_It __x, iter_difference_t<_It> __n, _It __bound) const
      {
 ranges::advance(__x, -__n, __bound);
 return __x;
      }

    void operator&() const = delete;
  };

  inline constexpr __prev_fn prev{};


  struct dangling
  {
    constexpr dangling() noexcept = default;
    template<typename... _Args>
      constexpr dangling(_Args&&...) noexcept { }
  };

  template<range _Range>
    using borrowed_iterator_t = __conditional_t<borrowed_range<_Range>,
      iterator_t<_Range>,
      dangling>;
}







}
# 35 "/usr/include/c++/14.2.1/bits/ranges_util.h" 2 3




namespace std __attribute__ ((__visibility__ ("default")))
{

namespace ranges
{


  namespace __detail
  {
    template<typename _Range>
      concept __simple_view = view<_Range> && range<const _Range>
 && same_as<iterator_t<_Range>, iterator_t<const _Range>>
 && same_as<sentinel_t<_Range>, sentinel_t<const _Range>>;

    template<typename _It>
      concept __has_arrow = input_iterator<_It>
 && (is_pointer_v<_It> || requires(_It __it) { __it.operator->(); });

    using std::__detail::__different_from;
  }


  template<typename _Derived>
    requires is_class_v<_Derived> && same_as<_Derived, remove_cv_t<_Derived>>
    class view_interface
    {
    private:
      constexpr _Derived& _M_derived() noexcept
      {
 static_assert(derived_from<_Derived, view_interface<_Derived>>);
 static_assert(view<_Derived>);
 return static_cast<_Derived&>(*this);
      }

      constexpr const _Derived& _M_derived() const noexcept
      {
 static_assert(derived_from<_Derived, view_interface<_Derived>>);
 static_assert(view<_Derived>);
 return static_cast<const _Derived&>(*this);
      }

      static constexpr bool
      _S_bool(bool) noexcept;

      template<typename _Tp>
 static constexpr bool
 _S_empty(_Tp& __t)
 noexcept(noexcept(_S_bool(ranges::begin(__t) == ranges::end(__t))))
 { return ranges::begin(__t) == ranges::end(__t); }

      template<typename _Tp>
 static constexpr auto
 _S_size(_Tp& __t)
 noexcept(noexcept(ranges::end(__t) - ranges::begin(__t)))
 { return ranges::end(__t) - ranges::begin(__t); }

    public:
      constexpr bool
      empty()
      noexcept(noexcept(_S_empty(_M_derived())))
      requires forward_range<_Derived> && (!sized_range<_Derived>)
      { return _S_empty(_M_derived()); }

      constexpr bool
      empty()
      noexcept(noexcept(ranges::size(_M_derived()) == 0))
      requires sized_range<_Derived>
      { return ranges::size(_M_derived()) == 0; }

      constexpr bool
      empty() const
      noexcept(noexcept(_S_empty(_M_derived())))
      requires forward_range<const _Derived> && (!sized_range<const _Derived>)
      { return _S_empty(_M_derived()); }

      constexpr bool
      empty() const
      noexcept(noexcept(ranges::size(_M_derived()) == 0))
      requires sized_range<const _Derived>
      { return ranges::size(_M_derived()) == 0; }

      constexpr explicit
      operator bool() noexcept(noexcept(ranges::empty(_M_derived())))
      requires requires { ranges::empty(_M_derived()); }
      { return !ranges::empty(_M_derived()); }

      constexpr explicit
      operator bool() const noexcept(noexcept(ranges::empty(_M_derived())))
      requires requires { ranges::empty(_M_derived()); }
      { return !ranges::empty(_M_derived()); }

      constexpr auto
      data() noexcept(noexcept(ranges::begin(_M_derived())))
      requires contiguous_iterator<iterator_t<_Derived>>
      { return std::to_address(ranges::begin(_M_derived())); }

      constexpr auto
      data() const noexcept(noexcept(ranges::begin(_M_derived())))
      requires range<const _Derived>
 && contiguous_iterator<iterator_t<const _Derived>>
      { return std::to_address(ranges::begin(_M_derived())); }

      constexpr auto
      size() noexcept(noexcept(_S_size(_M_derived())))
      requires forward_range<_Derived>
 && sized_sentinel_for<sentinel_t<_Derived>, iterator_t<_Derived>>
      { return _S_size(_M_derived()); }

      constexpr auto
      size() const noexcept(noexcept(_S_size(_M_derived())))
      requires forward_range<const _Derived>
 && sized_sentinel_for<sentinel_t<const _Derived>,
         iterator_t<const _Derived>>
      { return _S_size(_M_derived()); }

      constexpr decltype(auto)
      front() requires forward_range<_Derived>
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(!empty()), false)) std::__glibcxx_assert_fail(); } while (false);
 return *ranges::begin(_M_derived());
      }

      constexpr decltype(auto)
      front() const requires forward_range<const _Derived>
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(!empty()), false)) std::__glibcxx_assert_fail(); } while (false);
 return *ranges::begin(_M_derived());
      }

      constexpr decltype(auto)
      back()
      requires bidirectional_range<_Derived> && common_range<_Derived>
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(!empty()), false)) std::__glibcxx_assert_fail(); } while (false);
 return *ranges::prev(ranges::end(_M_derived()));
      }

      constexpr decltype(auto)
      back() const
      requires bidirectional_range<const _Derived>
 && common_range<const _Derived>
      {
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(!empty()), false)) std::__glibcxx_assert_fail(); } while (false);
 return *ranges::prev(ranges::end(_M_derived()));
      }

      template<random_access_range _Range = _Derived>
 constexpr decltype(auto)
 operator[](range_difference_t<_Range> __n)
 { return ranges::begin(_M_derived())[__n]; }

      template<random_access_range _Range = const _Derived>
 constexpr decltype(auto)
 operator[](range_difference_t<_Range> __n) const
 { return ranges::begin(_M_derived())[__n]; }
# 212 "/usr/include/c++/14.2.1/bits/ranges_util.h" 3
    };

  namespace __detail
  {
    template<typename _From, typename _To>
      concept __uses_nonqualification_pointer_conversion
 = is_pointer_v<_From> && is_pointer_v<_To>
   && !convertible_to<remove_pointer_t<_From>(*)[],
        remove_pointer_t<_To>(*)[]>;

    template<typename _From, typename _To>
      concept __convertible_to_non_slicing = convertible_to<_From, _To>
 && !__uses_nonqualification_pointer_conversion<decay_t<_From>,
             decay_t<_To>>;





    template<typename _Tp>
      concept __pair_like
 = !is_reference_v<_Tp> && requires(_Tp __t)
 {
   typename tuple_size<_Tp>::type;
   requires derived_from<tuple_size<_Tp>, integral_constant<size_t, 2>>;
   typename tuple_element_t<0, remove_const_t<_Tp>>;
   typename tuple_element_t<1, remove_const_t<_Tp>>;
   { get<0>(__t) } -> convertible_to<const tuple_element_t<0, _Tp>&>;
   { get<1>(__t) } -> convertible_to<const tuple_element_t<1, _Tp>&>;
 };


    template<typename _Tp, typename _Up, typename _Vp>
      concept __pair_like_convertible_from
 = !range<_Tp> && !is_reference_v<_Vp> && __pair_like<_Tp>
 && constructible_from<_Tp, _Up, _Vp>
 && __convertible_to_non_slicing<_Up, tuple_element_t<0, _Tp>>
 && convertible_to<_Vp, tuple_element_t<1, _Tp>>;

  }

  namespace views { struct _Drop; }

  enum class subrange_kind : bool { unsized, sized };


  template<input_or_output_iterator _It, sentinel_for<_It> _Sent = _It,
    subrange_kind _Kind = sized_sentinel_for<_Sent, _It>
      ? subrange_kind::sized : subrange_kind::unsized>
    requires (_Kind == subrange_kind::sized || !sized_sentinel_for<_Sent, _It>)
    class subrange : public view_interface<subrange<_It, _Sent, _Kind>>
    {
    private:
      static constexpr bool _S_store_size
 = _Kind == subrange_kind::sized && !sized_sentinel_for<_Sent, _It>;

      friend struct views::_Drop;

      _It _M_begin = _It();
      [[no_unique_address]] _Sent _M_end = _Sent();

      using __size_type
 = __detail::__make_unsigned_like_t<iter_difference_t<_It>>;

      template<typename _Tp, bool = _S_store_size>
 struct _Size
 {
   [[__gnu__::__always_inline__]]
   constexpr _Size(_Tp = {}) { }
 };

      template<typename _Tp>
 struct _Size<_Tp, true>
 {
   [[__gnu__::__always_inline__]]
   constexpr _Size(_Tp __s = {}) : _M_size(__s) { }

   _Tp _M_size;
 };

      [[no_unique_address]] _Size<__size_type> _M_size = {};

    public:
      subrange() requires default_initializable<_It> = default;

      constexpr
      subrange(__detail::__convertible_to_non_slicing<_It> auto __i, _Sent __s)
      noexcept(is_nothrow_constructible_v<_It, decltype(__i)>
        && is_nothrow_constructible_v<_Sent, _Sent&>)
 requires (!_S_store_size)
      : _M_begin(std::move(__i)), _M_end(__s)
      { }

      constexpr
      subrange(__detail::__convertible_to_non_slicing<_It> auto __i, _Sent __s,
        __size_type __n)
      noexcept(is_nothrow_constructible_v<_It, decltype(__i)>
        && is_nothrow_constructible_v<_Sent, _Sent&>)
 requires (_Kind == subrange_kind::sized)
      : _M_begin(std::move(__i)), _M_end(__s), _M_size(__n)
      { }

      template<__detail::__different_from<subrange> _Rng>
 requires borrowed_range<_Rng>
   && __detail::__convertible_to_non_slicing<iterator_t<_Rng>, _It>
   && convertible_to<sentinel_t<_Rng>, _Sent>
 constexpr
 subrange(_Rng&& __r)
 noexcept(noexcept(subrange(__r, ranges::size(__r))))
 requires _S_store_size && sized_range<_Rng>
 : subrange(__r, ranges::size(__r))
 { }

      template<__detail::__different_from<subrange> _Rng>
 requires borrowed_range<_Rng>
   && __detail::__convertible_to_non_slicing<iterator_t<_Rng>, _It>
   && convertible_to<sentinel_t<_Rng>, _Sent>
 constexpr
 subrange(_Rng&& __r)
 noexcept(noexcept(subrange(ranges::begin(__r), ranges::end(__r))))
 requires (!_S_store_size)
 : subrange(ranges::begin(__r), ranges::end(__r))
 { }

      template<borrowed_range _Rng>
 requires __detail::__convertible_to_non_slicing<iterator_t<_Rng>, _It>
   && convertible_to<sentinel_t<_Rng>, _Sent>
 constexpr
 subrange(_Rng&& __r, __size_type __n)
 noexcept(noexcept(subrange(ranges::begin(__r), ranges::end(__r), __n)))
 requires (_Kind == subrange_kind::sized)
 : subrange{ranges::begin(__r), ranges::end(__r), __n}
 { }

      template<__detail::__different_from<subrange> _PairLike>
 requires __detail::__pair_like_convertible_from<_PairLike, const _It&,
       const _Sent&>
 constexpr
 operator _PairLike() const
 { return _PairLike(_M_begin, _M_end); }

      constexpr _It
      begin() const requires copyable<_It>
      { return _M_begin; }

      [[nodiscard]] constexpr _It
      begin() requires (!copyable<_It>)
      { return std::move(_M_begin); }

      constexpr _Sent end() const { return _M_end; }

      constexpr bool empty() const { return _M_begin == _M_end; }

      constexpr __size_type
      size() const requires (_Kind == subrange_kind::sized)
      {
 if constexpr (_S_store_size)
   return _M_size._M_size;
 else
   return __detail::__to_unsigned_like(_M_end - _M_begin);
      }

      [[nodiscard]] constexpr subrange
      next(iter_difference_t<_It> __n = 1) const &
 requires forward_iterator<_It>
      {
 auto __tmp = *this;
 __tmp.advance(__n);
 return __tmp;
      }

      [[nodiscard]] constexpr subrange
      next(iter_difference_t<_It> __n = 1) &&
      {
 advance(__n);
 return std::move(*this);
      }

      [[nodiscard]] constexpr subrange
      prev(iter_difference_t<_It> __n = 1) const
 requires bidirectional_iterator<_It>
      {
 auto __tmp = *this;
 __tmp.advance(-__n);
 return __tmp;
      }

      constexpr subrange&
      advance(iter_difference_t<_It> __n)
      {


 if constexpr (bidirectional_iterator<_It>)
   if (__n < 0)
     {
       ranges::advance(_M_begin, __n);
       if constexpr (_S_store_size)
  _M_size._M_size += __detail::__to_unsigned_like(-__n);
       return *this;
     }

 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__n >= 0), false)) std::__glibcxx_assert_fail(); } while (false);
 auto __d = __n - ranges::advance(_M_begin, __n, _M_end);
 if constexpr (_S_store_size)
   _M_size._M_size -= __detail::__to_unsigned_like(__d);
 return *this;
      }
    };

  template<input_or_output_iterator _It, sentinel_for<_It> _Sent>
    subrange(_It, _Sent) -> subrange<_It, _Sent>;

  template<input_or_output_iterator _It, sentinel_for<_It> _Sent>
    subrange(_It, _Sent,
      __detail::__make_unsigned_like_t<iter_difference_t<_It>>)
      -> subrange<_It, _Sent, subrange_kind::sized>;

  template<borrowed_range _Rng>
    subrange(_Rng&&)
      -> subrange<iterator_t<_Rng>, sentinel_t<_Rng>,
   (sized_range<_Rng>
    || sized_sentinel_for<sentinel_t<_Rng>, iterator_t<_Rng>>)
   ? subrange_kind::sized : subrange_kind::unsized>;

  template<borrowed_range _Rng>
    subrange(_Rng&&,
      __detail::__make_unsigned_like_t<range_difference_t<_Rng>>)
      -> subrange<iterator_t<_Rng>, sentinel_t<_Rng>, subrange_kind::sized>;

  template<size_t _Num, class _It, class _Sent, subrange_kind _Kind>
    requires (_Num < 2)
    constexpr auto
    get(const subrange<_It, _Sent, _Kind>& __r)
    {
      if constexpr (_Num == 0)
 return __r.begin();
      else
 return __r.end();
    }

  template<size_t _Num, class _It, class _Sent, subrange_kind _Kind>
    requires (_Num < 2)
    constexpr auto
    get(subrange<_It, _Sent, _Kind>&& __r)
    {
      if constexpr (_Num == 0)
 return __r.begin();
      else
 return __r.end();
    }

  template<typename _It, typename _Sent, subrange_kind _Kind>
    inline constexpr bool
      enable_borrowed_range<subrange<_It, _Sent, _Kind>> = true;

  template<range _Range>
    using borrowed_subrange_t = __conditional_t<borrowed_range<_Range>,
      subrange<iterator_t<_Range>>,
      dangling>;


  template<typename _Iter, typename _Sent, subrange_kind _Kind>
    inline constexpr bool __detail::__is_subrange<subrange<_Iter, _Sent, _Kind>> = true;
}
# 485 "/usr/include/c++/14.2.1/bits/ranges_util.h" 3
namespace ranges
{
  struct __find_fn
  {
    template<input_iterator _Iter, sentinel_for<_Iter> _Sent, typename _Tp,
      typename _Proj = identity>
      requires indirect_binary_predicate<ranges::equal_to,
      projected<_Iter, _Proj>, const _Tp*>
      constexpr _Iter
      operator()(_Iter __first, _Sent __last,
   const _Tp& __value, _Proj __proj = {}) const
      {
 while (__first != __last
     && !(std::__invoke(__proj, *__first) == __value))
   ++__first;
 return __first;
      }

    template<input_range _Range, typename _Tp, typename _Proj = identity>
      requires indirect_binary_predicate<ranges::equal_to,
      projected<iterator_t<_Range>, _Proj>,
      const _Tp*>
      constexpr borrowed_iterator_t<_Range>
      operator()(_Range&& __r, const _Tp& __value, _Proj __proj = {}) const
      {
 return (*this)(ranges::begin(__r), ranges::end(__r),
         __value, std::move(__proj));
      }
  };

  inline constexpr __find_fn find{};

  struct __find_if_fn
  {
    template<input_iterator _Iter, sentinel_for<_Iter> _Sent,
      typename _Proj = identity,
      indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
      constexpr _Iter
      operator()(_Iter __first, _Sent __last,
   _Pred __pred, _Proj __proj = {}) const
      {
 while (__first != __last
     && !(bool)std::__invoke(__pred, std::__invoke(__proj, *__first)))
   ++__first;
 return __first;
      }

    template<input_range _Range, typename _Proj = identity,
      indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>>
        _Pred>
      constexpr borrowed_iterator_t<_Range>
      operator()(_Range&& __r, _Pred __pred, _Proj __proj = {}) const
      {
 return (*this)(ranges::begin(__r), ranges::end(__r),
         std::move(__pred), std::move(__proj));
      }
  };

  inline constexpr __find_if_fn find_if{};

  struct __find_if_not_fn
  {
    template<input_iterator _Iter, sentinel_for<_Iter> _Sent,
      typename _Proj = identity,
      indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
      constexpr _Iter
      operator()(_Iter __first, _Sent __last,
   _Pred __pred, _Proj __proj = {}) const
      {
 while (__first != __last
     && (bool)std::__invoke(__pred, std::__invoke(__proj, *__first)))
   ++__first;
 return __first;
      }

    template<input_range _Range, typename _Proj = identity,
      indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>>
        _Pred>
      constexpr borrowed_iterator_t<_Range>
      operator()(_Range&& __r, _Pred __pred, _Proj __proj = {}) const
      {
 return (*this)(ranges::begin(__r), ranges::end(__r),
         std::move(__pred), std::move(__proj));
      }
  };

  inline constexpr __find_if_not_fn find_if_not{};

  template<typename _Iter1, typename _Iter2>
    struct in_in_result
    {
      [[no_unique_address]] _Iter1 in1;
      [[no_unique_address]] _Iter2 in2;

      template<typename _IIter1, typename _IIter2>
 requires convertible_to<const _Iter1&, _IIter1>
   && convertible_to<const _Iter2&, _IIter2>
 constexpr
 operator in_in_result<_IIter1, _IIter2>() const &
 { return {in1, in2}; }

      template<typename _IIter1, typename _IIter2>
 requires convertible_to<_Iter1, _IIter1>
   && convertible_to<_Iter2, _IIter2>
 constexpr
 operator in_in_result<_IIter1, _IIter2>() &&
 { return {std::move(in1), std::move(in2)}; }
    };

  template<typename _Iter1, typename _Iter2>
    using mismatch_result = in_in_result<_Iter1, _Iter2>;

  struct __mismatch_fn
  {
    template<input_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
      input_iterator _Iter2, sentinel_for<_Iter2> _Sent2,
      typename _Pred = ranges::equal_to,
      typename _Proj1 = identity, typename _Proj2 = identity>
      requires indirectly_comparable<_Iter1, _Iter2, _Pred, _Proj1, _Proj2>
      constexpr mismatch_result<_Iter1, _Iter2>
      operator()(_Iter1 __first1, _Sent1 __last1,
   _Iter2 __first2, _Sent2 __last2, _Pred __pred = {},
   _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
      {
 while (__first1 != __last1 && __first2 != __last2
        && (bool)std::__invoke(__pred,
          std::__invoke(__proj1, *__first1),
          std::__invoke(__proj2, *__first2)))
 {
   ++__first1;
   ++__first2;
 }
 return { std::move(__first1), std::move(__first2) };
      }

    template<input_range _Range1, input_range _Range2,
      typename _Pred = ranges::equal_to,
      typename _Proj1 = identity, typename _Proj2 = identity>
      requires indirectly_comparable<iterator_t<_Range1>, iterator_t<_Range2>,
         _Pred, _Proj1, _Proj2>
      constexpr mismatch_result<iterator_t<_Range1>, iterator_t<_Range2>>
      operator()(_Range1&& __r1, _Range2&& __r2, _Pred __pred = {},
   _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
      {
 return (*this)(ranges::begin(__r1), ranges::end(__r1),
         ranges::begin(__r2), ranges::end(__r2),
         std::move(__pred),
         std::move(__proj1), std::move(__proj2));
      }
  };

  inline constexpr __mismatch_fn mismatch{};

  struct __search_fn
  {
    template<forward_iterator _Iter1, sentinel_for<_Iter1> _Sent1,
      forward_iterator _Iter2, sentinel_for<_Iter2> _Sent2,
      typename _Pred = ranges::equal_to,
      typename _Proj1 = identity, typename _Proj2 = identity>
      requires indirectly_comparable<_Iter1, _Iter2, _Pred, _Proj1, _Proj2>
      constexpr subrange<_Iter1>
      operator()(_Iter1 __first1, _Sent1 __last1,
   _Iter2 __first2, _Sent2 __last2, _Pred __pred = {},
   _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
      {
 if (__first1 == __last1 || __first2 == __last2)
   return {__first1, __first1};

 for (;;)
   {
     for (;;)
       {
  if (__first1 == __last1)
    return {__first1, __first1};
  if (std::__invoke(__pred,
      std::__invoke(__proj1, *__first1),
      std::__invoke(__proj2, *__first2)))
    break;
  ++__first1;
       }
     auto __cur1 = __first1;
     auto __cur2 = __first2;
     for (;;)
       {
  if (++__cur2 == __last2)
    return {__first1, ++__cur1};
  if (++__cur1 == __last1)
    return {__cur1, __cur1};
  if (!(bool)std::__invoke(__pred,
      std::__invoke(__proj1, *__cur1),
      std::__invoke(__proj2, *__cur2)))
    {
      ++__first1;
      break;
    }
       }
   }
      }

    template<forward_range _Range1, forward_range _Range2,
      typename _Pred = ranges::equal_to,
      typename _Proj1 = identity, typename _Proj2 = identity>
      requires indirectly_comparable<iterator_t<_Range1>, iterator_t<_Range2>,
         _Pred, _Proj1, _Proj2>
      constexpr borrowed_subrange_t<_Range1>
      operator()(_Range1&& __r1, _Range2&& __r2, _Pred __pred = {},
   _Proj1 __proj1 = {}, _Proj2 __proj2 = {}) const
      {
 return (*this)(ranges::begin(__r1), ranges::end(__r1),
         ranges::begin(__r2), ranges::end(__r2),
         std::move(__pred),
         std::move(__proj1), std::move(__proj2));
      }
  };

  inline constexpr __search_fn search{};

  struct __min_fn
  {
    template<typename _Tp, typename _Proj = identity,
      indirect_strict_weak_order<projected<const _Tp*, _Proj>>
        _Comp = ranges::less>
      constexpr const _Tp&
      operator()(const _Tp& __a, const _Tp& __b,
   _Comp __comp = {}, _Proj __proj = {}) const
      {
 if (std::__invoke(__comp,
     std::__invoke(__proj, __b),
     std::__invoke(__proj, __a)))
   return __b;
 else
   return __a;
      }

    template<input_range _Range, typename _Proj = identity,
      indirect_strict_weak_order<projected<iterator_t<_Range>, _Proj>>
        _Comp = ranges::less>
      requires indirectly_copyable_storable<iterator_t<_Range>,
         range_value_t<_Range>*>
      constexpr range_value_t<_Range>
      operator()(_Range&& __r, _Comp __comp = {}, _Proj __proj = {}) const
      {
 auto __first = ranges::begin(__r);
 auto __last = ranges::end(__r);
 do { if (std::__is_constant_evaluated()) if (__builtin_expect(!bool(__first != __last), false)) std::__glibcxx_assert_fail(); } while (false);
 auto __result = *__first;
 while (++__first != __last)
   {
     auto __tmp = *__first;
     if (std::__invoke(__comp,
         std::__invoke(__proj, __tmp),
         std::__invoke(__proj, __result)))
       __result = std::move(__tmp);
   }
 return __result;
      }

    template<copyable _Tp, typename _Proj = identity,
      indirect_strict_weak_order<projected<const _Tp*, _Proj>>
        _Comp = ranges::less>
      constexpr _Tp
      operator()(initializer_list<_Tp> __r,
   _Comp __comp = {}, _Proj __proj = {}) const
      {
 return (*this)(ranges::subrange(__r),
         std::move(__comp), std::move(__proj));
      }
  };

  inline constexpr __min_fn min{};

  struct __adjacent_find_fn
  {
    template<forward_iterator _Iter, sentinel_for<_Iter> _Sent,
      typename _Proj = identity,
      indirect_binary_predicate<projected<_Iter, _Proj>,
           projected<_Iter, _Proj>> _Pred
        = ranges::equal_to>
      constexpr _Iter
      operator()(_Iter __first, _Sent __last,
   _Pred __pred = {}, _Proj __proj = {}) const
      {
 if (__first == __last)
   return __first;
 auto __next = __first;
 for (; ++__next != __last; __first = __next)
   {
     if (std::__invoke(__pred,
         std::__invoke(__proj, *__first),
         std::__invoke(__proj, *__next)))
       return __first;
   }
 return __next;
      }

    template<forward_range _Range, typename _Proj = identity,
      indirect_binary_predicate<
        projected<iterator_t<_Range>, _Proj>,
        projected<iterator_t<_Range>, _Proj>> _Pred = ranges::equal_to>
      constexpr borrowed_iterator_t<_Range>
      operator()(_Range&& __r, _Pred __pred = {}, _Proj __proj = {}) const
      {
 return (*this)(ranges::begin(__r), ranges::end(__r),
         std::move(__pred), std::move(__proj));
      }
  };

  inline constexpr __adjacent_find_fn adjacent_find{};

}

  using ranges::get;

  template<typename _Iter, typename _Sent, ranges::subrange_kind _Kind>
    struct tuple_size<ranges::subrange<_Iter, _Sent, _Kind>>
    : integral_constant<size_t, 2>
    { };

  template<typename _Iter, typename _Sent, ranges::subrange_kind _Kind>
    struct tuple_element<0, ranges::subrange<_Iter, _Sent, _Kind>>
    { using type = _Iter; };

  template<typename _Iter, typename _Sent, ranges::subrange_kind _Kind>
    struct tuple_element<1, ranges::subrange<_Iter, _Sent, _Kind>>
    { using type = _Sent; };

  template<typename _Iter, typename _Sent, ranges::subrange_kind _Kind>
    struct tuple_element<0, const ranges::subrange<_Iter, _Sent, _Kind>>
    { using type = _Iter; };

  template<typename _Iter, typename _Sent, ranges::subrange_kind _Kind>
    struct tuple_element<1, const ranges::subrange<_Iter, _Sent, _Kind>>
    { using type = _Sent; };


}
# 45 "/usr/include/c++/14.2.1/tuple" 2 3
# 54 "/usr/include/c++/14.2.1/tuple" 3
# 1 "/usr/include/c++/14.2.1/bits/version.h" 1 3
# 47 "/usr/include/c++/14.2.1/bits/version.h" 3
       
# 48 "/usr/include/c++/14.2.1/bits/version.h" 3
# 55 "/usr/include/c++/14.2.1/tuple" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename... _Elements>
    class tuple;

  template<typename _Tp>
    struct __is_empty_non_tuple : is_empty<_Tp> { };


  template<typename _El0, typename... _El>
    struct __is_empty_non_tuple<tuple<_El0, _El...>> : false_type { };


  template<typename _Tp>
    using __empty_not_final
    = __conditional_t<__is_final(_Tp), false_type,
        __is_empty_non_tuple<_Tp>>;

  template<size_t _Idx, typename _Head,
    bool = __empty_not_final<_Head>::value>
    struct _Head_base;


  template<size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, true>
    {
      constexpr _Head_base()
      : _M_head_impl() { }

      constexpr _Head_base(const _Head& __h)
      : _M_head_impl(__h) { }

      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
 constexpr _Head_base(_UHead&& __h)
 : _M_head_impl(std::forward<_UHead>(__h)) { }

      constexpr
      _Head_base(allocator_arg_t, __uses_alloc0)
      : _M_head_impl() { }

      template<typename _Alloc>
 constexpr
 _Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
 : _M_head_impl(allocator_arg, *__a._M_a) { }

      template<typename _Alloc>
 constexpr
 _Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
 : _M_head_impl(*__a._M_a) { }

      template<typename _UHead>
 constexpr
 _Head_base(__uses_alloc0, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 constexpr
 _Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead))
 { }

      template<typename _Alloc, typename _UHead>
 constexpr
 _Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead), *__a._M_a) { }

      static constexpr _Head&
      _M_head(_Head_base& __b) noexcept { return __b._M_head_impl; }

      static constexpr const _Head&
      _M_head(const _Head_base& __b) noexcept { return __b._M_head_impl; }

      [[__no_unique_address__]] _Head _M_head_impl;
    };
# 195 "/usr/include/c++/14.2.1/tuple" 3
  template<size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, false>
    {
      constexpr _Head_base()
      : _M_head_impl() { }

      constexpr _Head_base(const _Head& __h)
      : _M_head_impl(__h) { }

      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
 : _M_head_impl(std::forward<_UHead>(__h)) { }

      constexpr
      _Head_base(allocator_arg_t, __uses_alloc0)
      : _M_head_impl() { }

      template<typename _Alloc>
 constexpr
 _Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
 : _M_head_impl(allocator_arg, *__a._M_a) { }

      template<typename _Alloc>
 constexpr
 _Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
 : _M_head_impl(*__a._M_a) { }

      template<typename _UHead>
 constexpr
 _Head_base(__uses_alloc0, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 constexpr
 _Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead))
 { }

      template<typename _Alloc, typename _UHead>
 constexpr
 _Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead), *__a._M_a) { }

      static constexpr _Head&
      _M_head(_Head_base& __b) noexcept { return __b._M_head_impl; }

      static constexpr const _Head&
      _M_head(const _Head_base& __b) noexcept { return __b._M_head_impl; }

      _Head _M_head_impl;
    };
# 274 "/usr/include/c++/14.2.1/tuple" 3
  template<size_t _Idx, typename... _Elements>
    struct _Tuple_impl;






  template<size_t _Idx, typename _Head, typename... _Tail>
    struct _Tuple_impl<_Idx, _Head, _Tail...>
    : public _Tuple_impl<_Idx + 1, _Tail...>,
      private _Head_base<_Idx, _Head>
    {
      template<size_t, typename...> friend struct _Tuple_impl;

      typedef _Tuple_impl<_Idx + 1, _Tail...> _Inherited;
      typedef _Head_base<_Idx, _Head> _Base;

      static constexpr _Head&
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr const _Head&
      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr _Inherited&
      _M_tail(_Tuple_impl& __t) noexcept { return __t; }

      static constexpr const _Inherited&
      _M_tail(const _Tuple_impl& __t) noexcept { return __t; }

      constexpr _Tuple_impl()
      : _Inherited(), _Base() { }

      explicit constexpr
      _Tuple_impl(const _Head& __head, const _Tail&... __tail)
      : _Inherited(__tail...), _Base(__head)
      { }

      template<typename _UHead, typename... _UTail,
        typename = __enable_if_t<sizeof...(_Tail) == sizeof...(_UTail)>>
 explicit constexpr
 _Tuple_impl(_UHead&& __head, _UTail&&... __tail)
 : _Inherited(std::forward<_UTail>(__tail)...),
   _Base(std::forward<_UHead>(__head))
 { }

      constexpr _Tuple_impl(const _Tuple_impl&) = default;



      _Tuple_impl& operator=(const _Tuple_impl&) = delete;

      _Tuple_impl(_Tuple_impl&&) = default;

      template<typename... _UElements>
 constexpr
 _Tuple_impl(const _Tuple_impl<_Idx, _UElements...>& __in)
 : _Inherited(_Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
   _Base(_Tuple_impl<_Idx, _UElements...>::_M_head(__in))
 { }

      template<typename _UHead, typename... _UTails>
 constexpr
 _Tuple_impl(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 : _Inherited(std::move
       (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
   _Base(std::forward<_UHead>
  (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in)))
 { }
# 370 "/usr/include/c++/14.2.1/tuple" 3
      template<typename _Alloc>
 constexpr
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a),
   _Base(__tag, __use_alloc<_Head>(__a))
 { }

      template<typename _Alloc>
 constexpr
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Head& __head, const _Tail&... __tail)
 : _Inherited(__tag, __a, __tail...),
   _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head)
 { }

      template<typename _Alloc, typename _UHead, typename... _UTail,
        typename = __enable_if_t<sizeof...(_Tail) == sizeof...(_UTail)>>
 constexpr
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      _UHead&& __head, _UTail&&... __tail)
 : _Inherited(__tag, __a, std::forward<_UTail>(__tail)...),
   _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
  std::forward<_UHead>(__head))
 { }

      template<typename _Alloc>
 constexpr
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Tuple_impl& __in)
 : _Inherited(__tag, __a, _M_tail(__in)),
   _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in))
 { }

      template<typename _Alloc>
 constexpr
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      _Tuple_impl&& __in)
 : _Inherited(__tag, __a, std::move(_M_tail(__in))),
   _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
  std::forward<_Head>(_M_head(__in)))
 { }

      template<typename _Alloc, typename _UHead, typename... _UTails>
 constexpr
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Tuple_impl<_Idx, _UHead, _UTails...>& __in)
 : _Inherited(__tag, __a,
       _Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in)),
   _Base(__use_alloc<_Head, _Alloc, const _UHead&>(__a),
  _Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))
 { }

      template<typename _Alloc, typename _UHead, typename... _UTails>
 constexpr
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      _Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 : _Inherited(__tag, __a, std::move
       (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
   _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
  std::forward<_UHead>
  (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in)))
 { }
# 465 "/usr/include/c++/14.2.1/tuple" 3
      template<typename... _UElements>
 constexpr
 void
 _M_assign(const _Tuple_impl<_Idx, _UElements...>& __in)
 {
   _M_head(*this) = _Tuple_impl<_Idx, _UElements...>::_M_head(__in);
   _M_tail(*this)._M_assign(
       _Tuple_impl<_Idx, _UElements...>::_M_tail(__in));
 }

      template<typename _UHead, typename... _UTails>
 constexpr
 void
 _M_assign(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 {
   _M_head(*this) = std::forward<_UHead>
     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in));
   _M_tail(*this)._M_assign(
       std::move(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in)));
 }
# 525 "/usr/include/c++/14.2.1/tuple" 3
    protected:
      constexpr
      void
      _M_swap(_Tuple_impl& __in)
      {
 using std::swap;
 swap(_M_head(*this), _M_head(__in));
 _Inherited::_M_swap(_M_tail(__in));
      }
# 544 "/usr/include/c++/14.2.1/tuple" 3
    };


  template<size_t _Idx, typename _Head>
    struct _Tuple_impl<_Idx, _Head>
    : private _Head_base<_Idx, _Head>
    {
      template<size_t, typename...> friend struct _Tuple_impl;

      typedef _Head_base<_Idx, _Head> _Base;

      static constexpr _Head&
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr const _Head&
      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      constexpr
      _Tuple_impl()
      : _Base() { }

      explicit constexpr
      _Tuple_impl(const _Head& __head)
      : _Base(__head)
      { }

      template<typename _UHead>
 explicit constexpr
 _Tuple_impl(_UHead&& __head)
 : _Base(std::forward<_UHead>(__head))
 { }

      constexpr _Tuple_impl(const _Tuple_impl&) = default;



      _Tuple_impl& operator=(const _Tuple_impl&) = delete;




      constexpr
      _Tuple_impl(_Tuple_impl&& __in)
      noexcept(is_nothrow_move_constructible<_Head>::value)
      : _Base(static_cast<_Base&&>(__in))
      { }


      template<typename _UHead>
 constexpr
 _Tuple_impl(const _Tuple_impl<_Idx, _UHead>& __in)
 : _Base(_Tuple_impl<_Idx, _UHead>::_M_head(__in))
 { }

      template<typename _UHead>
 constexpr
 _Tuple_impl(_Tuple_impl<_Idx, _UHead>&& __in)
 : _Base(std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
 { }
# 626 "/usr/include/c++/14.2.1/tuple" 3
      template<typename _Alloc>
 constexpr
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)
 : _Base(__tag, __use_alloc<_Head>(__a))
 { }

      template<typename _Alloc>
 constexpr
 _Tuple_impl(allocator_arg_t, const _Alloc& __a,
      const _Head& __head)
 : _Base(__use_alloc<_Head, _Alloc, const _Head&>(__a), __head)
 { }

      template<typename _Alloc, typename _UHead>
 constexpr
 _Tuple_impl(allocator_arg_t, const _Alloc& __a,
      _UHead&& __head)
 : _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
  std::forward<_UHead>(__head))
 { }

      template<typename _Alloc>
 constexpr
 _Tuple_impl(allocator_arg_t, const _Alloc& __a,
      const _Tuple_impl& __in)
 : _Base(__use_alloc<_Head, _Alloc, const _Head&>(__a), _M_head(__in))
 { }

      template<typename _Alloc>
 constexpr
 _Tuple_impl(allocator_arg_t, const _Alloc& __a,
      _Tuple_impl&& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
  std::forward<_Head>(_M_head(__in)))
 { }

      template<typename _Alloc, typename _UHead>
 constexpr
 _Tuple_impl(allocator_arg_t, const _Alloc& __a,
      const _Tuple_impl<_Idx, _UHead>& __in)
 : _Base(__use_alloc<_Head, _Alloc, const _UHead&>(__a),
  _Tuple_impl<_Idx, _UHead>::_M_head(__in))
 { }

      template<typename _Alloc, typename _UHead>
 constexpr
 _Tuple_impl(allocator_arg_t, const _Alloc& __a,
      _Tuple_impl<_Idx, _UHead>&& __in)
 : _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
  std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
 { }
# 705 "/usr/include/c++/14.2.1/tuple" 3
      template<typename _UHead>
 constexpr
 void
 _M_assign(const _Tuple_impl<_Idx, _UHead>& __in)
 {
   _M_head(*this) = _Tuple_impl<_Idx, _UHead>::_M_head(__in);
 }

      template<typename _UHead>
 constexpr
 void
 _M_assign(_Tuple_impl<_Idx, _UHead>&& __in)
 {
   _M_head(*this)
     = std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in));
 }
# 751 "/usr/include/c++/14.2.1/tuple" 3
    protected:
      constexpr
      void
      _M_swap(_Tuple_impl& __in)
      {
 using std::swap;
 swap(_M_head(*this), _M_head(__in));
      }
# 768 "/usr/include/c++/14.2.1/tuple" 3
    };



  template<bool, typename... _Types>
    struct _TupleConstraints
    {
      template<typename... _UTypes>
 using __constructible = __and_<is_constructible<_Types, _UTypes>...>;

      template<typename... _UTypes>
 using __convertible = __and_<is_convertible<_UTypes, _Types>...>;




      template<typename... _UTypes>
 static constexpr bool __is_implicitly_constructible()
 {
   return __and_<__constructible<_UTypes...>,
   __convertible<_UTypes...>
   >::value;
 }




      template<typename... _UTypes>
 static constexpr bool __is_explicitly_constructible()
 {
   return __and_<__constructible<_UTypes...>,
   __not_<__convertible<_UTypes...>>
   >::value;
 }

      static constexpr bool __is_implicitly_default_constructible()
      {
 return __and_<std::__is_implicitly_default_constructible<_Types>...
        >::value;
      }

      static constexpr bool __is_explicitly_default_constructible()
      {
 return __and_<is_default_constructible<_Types>...,
        __not_<__and_<
   std::__is_implicitly_default_constructible<_Types>...>
        >>::value;
      }
    };



  template<typename... _Types>
    struct _TupleConstraints<false, _Types...>
    {
      template<typename... _UTypes>
 static constexpr bool __is_implicitly_constructible()
 { return false; }

      template<typename... _UTypes>
 static constexpr bool __is_explicitly_constructible()
 { return false; }
    };


  template<typename... _Elements>
    class tuple : public _Tuple_impl<0, _Elements...>
    {
      using _Inherited = _Tuple_impl<0, _Elements...>;


      template<typename... _UTypes>
 static consteval bool
 __constructible()
 {
   if constexpr (sizeof...(_UTypes) == sizeof...(_Elements))
     return __and_v<is_constructible<_Elements, _UTypes>...>;
   else
     return false;
 }

      template<typename... _UTypes>
 static consteval bool
 __nothrow_constructible()
 {
   if constexpr (sizeof...(_UTypes) == sizeof...(_Elements))
     return __and_v<is_nothrow_constructible<_Elements, _UTypes>...>;
   else
     return false;
 }

      template<typename... _UTypes>
 static consteval bool
 __convertible()
 {
   if constexpr (sizeof...(_UTypes) == sizeof...(_Elements))
     return __and_v<is_convertible<_UTypes, _Elements>...>;
   else
     return false;
 }



      template<typename... _UTypes>
 static consteval bool
 __disambiguating_constraint()
 {
   if constexpr (sizeof...(_Elements) != sizeof...(_UTypes))
     return false;
   else if constexpr (sizeof...(_Elements) == 1)
     {
       using _U0 = typename _Nth_type<0, _UTypes...>::type;
       return !is_same_v<remove_cvref_t<_U0>, tuple>;
     }
   else if constexpr (sizeof...(_Elements) < 4)
     {
       using _U0 = typename _Nth_type<0, _UTypes...>::type;
       if constexpr (!is_same_v<remove_cvref_t<_U0>, allocator_arg_t>)
  return true;
       else
  {
    using _T0 = typename _Nth_type<0, _Elements...>::type;
    return is_same_v<remove_cvref_t<_T0>, allocator_arg_t>;
  }
     }
   return true;
 }




      template<typename _Tuple>
 static consteval bool
 __use_other_ctor()
 {
   if constexpr (sizeof...(_Elements) != 1)
     return false;
   else if constexpr (is_same_v<remove_cvref_t<_Tuple>, tuple>)
     return true;
   else
     {
       using _Tp = typename _Nth_type<0, _Elements...>::type;
       if constexpr (is_convertible_v<_Tuple, _Tp>)
  return true;
       else if constexpr (is_constructible_v<_Tp, _Tuple>)
  return true;
     }
   return false;
 }

      template<typename... _Up>
 static consteval bool
 __dangles()
 {

   return (__reference_constructs_from_temporary(_Elements, _Up&&)
      || ...);



 }
# 961 "/usr/include/c++/14.2.1/tuple" 3
    public:
      constexpr
      explicit(!(__is_implicitly_default_constructible_v<_Elements> && ...))
      tuple()
      noexcept((is_nothrow_default_constructible_v<_Elements> && ...))
      requires (is_default_constructible_v<_Elements> && ...)
      : _Inherited()
      { }

      constexpr explicit(!__convertible<const _Elements&...>())
      tuple(const _Elements&... __elements)
      noexcept(__nothrow_constructible<const _Elements&...>())
      requires (__constructible<const _Elements&...>())
      : _Inherited(__elements...)
      { }

      template<typename... _UTypes>
 requires (__disambiguating_constraint<_UTypes...>())
   && (__constructible<_UTypes...>())
   && (!__dangles<_UTypes...>())
 constexpr explicit(!__convertible<_UTypes...>())
 tuple(_UTypes&&... __u)
 noexcept(__nothrow_constructible<_UTypes...>())
 : _Inherited(std::forward<_UTypes>(__u)...)
 { }

      template<typename... _UTypes>
 requires (__disambiguating_constraint<_UTypes...>())
   && (__constructible<_UTypes...>())
   && (__dangles<_UTypes...>())
 tuple(_UTypes&&...) = delete;

      constexpr tuple(const tuple&) = default;

      constexpr tuple(tuple&&) = default;

      template<typename... _UTypes>
 requires (__constructible<const _UTypes&...>())
   && (!__use_other_ctor<const tuple<_UTypes...>&>())
   && (!__dangles<const _UTypes&...>())
 constexpr explicit(!__convertible<const _UTypes&...>())
 tuple(const tuple<_UTypes...>& __u)
 noexcept(__nothrow_constructible<const _UTypes&...>())
 : _Inherited(static_cast<const _Tuple_impl<0, _UTypes...>&>(__u))
 { }

      template<typename... _UTypes>
 requires (__constructible<const _UTypes&...>())
   && (!__use_other_ctor<const tuple<_UTypes...>&>())
   && (__dangles<const _UTypes&...>())
 tuple(const tuple<_UTypes...>&) = delete;

      template<typename... _UTypes>
 requires (__constructible<_UTypes...>())
   && (!__use_other_ctor<tuple<_UTypes...>>())
   && (!__dangles<_UTypes...>())
 constexpr explicit(!__convertible<_UTypes...>())
 tuple(tuple<_UTypes...>&& __u)
 noexcept(__nothrow_constructible<_UTypes...>())
 : _Inherited(static_cast<_Tuple_impl<0, _UTypes...>&&>(__u))
 { }

      template<typename... _UTypes>
 requires (__constructible<_UTypes...>())
   && (!__use_other_ctor<tuple<_UTypes...>>())
   && (__dangles<_UTypes...>())
 tuple(tuple<_UTypes...>&&) = delete;
# 1063 "/usr/include/c++/14.2.1/tuple" 3
      template<typename _U1, typename _U2>
 requires (sizeof...(_Elements) == 2)
   && (__constructible<const _U1&, const _U2&>())
   && (!__dangles<const _U1&, const _U2&>())
 constexpr explicit(!__convertible<const _U1&, const _U2&>())
 tuple(const pair<_U1, _U2>& __u)
 noexcept(__nothrow_constructible<const _U1&, const _U2&>())
 : _Inherited(__u.first, __u.second)
 { }

      template<typename _U1, typename _U2>
 requires (sizeof...(_Elements) == 2)
   && (__constructible<const _U1&, const _U2&>())
   && (__dangles<const _U1&, const _U2&>())
 tuple(const pair<_U1, _U2>&) = delete;

      template<typename _U1, typename _U2>
 requires (sizeof...(_Elements) == 2)
   && (__constructible<_U1, _U2>())
   && (!__dangles<_U1, _U2>())
 constexpr explicit(!__convertible<_U1, _U2>())
 tuple(pair<_U1, _U2>&& __u)
 noexcept(__nothrow_constructible<_U1, _U2>())
 : _Inherited(std::forward<_U1>(__u.first),
       std::forward<_U2>(__u.second))
 { }

      template<typename _U1, typename _U2>
 requires (sizeof...(_Elements) == 2)
   && (__constructible<_U1, _U2>())
   && (__dangles<_U1, _U2>())
 tuple(pair<_U1, _U2>&&) = delete;
# 1152 "/usr/include/c++/14.2.1/tuple" 3
      template<typename _Alloc>
 constexpr
 explicit(!(__is_implicitly_default_constructible_v<_Elements> && ...))
 tuple(allocator_arg_t __tag, const _Alloc& __a)
 requires (is_default_constructible_v<_Elements> && ...)
 : _Inherited(__tag, __a)
 { }

      template<typename _Alloc>
 constexpr explicit(!__convertible<const _Elements&...>())
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _Elements&... __elements)
 requires (__constructible<const _Elements&...>())
 : _Inherited(__tag, __a, __elements...)
 { }

      template<typename _Alloc, typename... _UTypes>
 requires (__disambiguating_constraint<_UTypes...>())
   && (__constructible<_UTypes...>())
   && (!__dangles<_UTypes...>())
 constexpr explicit(!__convertible<_UTypes...>())
 tuple(allocator_arg_t __tag, const _Alloc& __a, _UTypes&&... __u)
 : _Inherited(__tag, __a, std::forward<_UTypes>(__u)...)
 { }

      template<typename _Alloc, typename... _UTypes>
 requires (__disambiguating_constraint<_UTypes...>())
   && (__constructible<_UTypes...>())
   && (__dangles<_UTypes...>())
 tuple(allocator_arg_t, const _Alloc&, _UTypes&&...) = delete;

      template<typename _Alloc>
 constexpr
 tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __u)
 : _Inherited(__tag, __a, static_cast<const _Inherited&>(__u))
 { }

      template<typename _Alloc>
 requires (__constructible<_Elements...>())
 constexpr
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __u)
 : _Inherited(__tag, __a, static_cast<_Inherited&&>(__u))
 { }

      template<typename _Alloc, typename... _UTypes>
 requires (__constructible<const _UTypes&...>())
   && (!__use_other_ctor<const tuple<_UTypes...>&>())
   && (!__dangles<const _UTypes&...>())
 constexpr explicit(!__convertible<const _UTypes&...>())
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_UTypes...>& __u)
 : _Inherited(__tag, __a,
       static_cast<const _Tuple_impl<0, _UTypes...>&>(__u))
 { }

      template<typename _Alloc, typename... _UTypes>
 requires (__constructible<const _UTypes&...>())
   && (!__use_other_ctor<const tuple<_UTypes...>&>())
   && (__dangles<const _UTypes&...>())
 tuple(allocator_arg_t, const _Alloc&, const tuple<_UTypes...>&) = delete;

      template<typename _Alloc, typename... _UTypes>
 requires (__constructible<_UTypes...>())
   && (!__use_other_ctor<tuple<_UTypes...>>())
   && (!__dangles<_UTypes...>())
 constexpr explicit(!__use_other_ctor<tuple<_UTypes...>>())
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple<_UTypes...>&& __u)
 : _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _UTypes...>&&>(__u))
 { }

      template<typename _Alloc, typename... _UTypes>
 requires (__constructible<_UTypes...>())
   && (!__use_other_ctor<tuple<_UTypes...>>())
   && (__dangles<_UTypes...>())
 tuple(allocator_arg_t, const _Alloc&, tuple<_UTypes...>&&) = delete;
# 1262 "/usr/include/c++/14.2.1/tuple" 3
      template<typename _Alloc, typename _U1, typename _U2>
 requires (sizeof...(_Elements) == 2)
   && (__constructible<const _U1&, const _U2&>())
   && (!__dangles<const _U1&, const _U2&>())
 constexpr explicit(!__convertible<const _U1&, const _U2&>())
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const pair<_U1, _U2>& __u)
 noexcept(__nothrow_constructible<const _U1&, const _U2&>())
 : _Inherited(__tag, __a, __u.first, __u.second)
 { }

      template<typename _Alloc, typename _U1, typename _U2>
 requires (sizeof...(_Elements) == 2)
   && (__constructible<const _U1&, const _U2&>())
   && (__dangles<const _U1&, const _U2&>())
 tuple(allocator_arg_t, const _Alloc&, const pair<_U1, _U2>&) = delete;

      template<typename _Alloc, typename _U1, typename _U2>
 requires (sizeof...(_Elements) == 2)
   && (__constructible<_U1, _U2>())
   && (!__dangles<_U1, _U2>())
 constexpr explicit(!__convertible<_U1, _U2>())
 tuple(allocator_arg_t __tag, const _Alloc& __a, pair<_U1, _U2>&& __u)
 noexcept(__nothrow_constructible<_U1, _U2>())
 : _Inherited(__tag, __a, std::move(__u.first), std::move(__u.second))
 { }

      template<typename _Alloc, typename _U1, typename _U2>
 requires (sizeof...(_Elements) == 2)
   && (__constructible<_U1, _U2>())
   && (__dangles<_U1, _U2>())
 tuple(allocator_arg_t, const _Alloc&, pair<_U1, _U2>&&) = delete;
# 1654 "/usr/include/c++/14.2.1/tuple" 3
    private:
      template<typename... _UTypes>
 static consteval bool
 __assignable()
 {
   if constexpr (sizeof...(_UTypes) == sizeof...(_Elements))
     return __and_v<is_assignable<_Elements&, _UTypes>...>;
   else
     return false;
 }

      template<typename... _UTypes>
 static consteval bool
 __nothrow_assignable()
 {
   if constexpr (sizeof...(_UTypes) == sizeof...(_Elements))
     return __and_v<is_nothrow_assignable<_Elements&, _UTypes>...>;
   else
     return false;
 }
# 1707 "/usr/include/c++/14.2.1/tuple" 3
    public:

      tuple& operator=(const tuple& __u) = delete;

      constexpr tuple&
      operator=(const tuple& __u)
      noexcept(__nothrow_assignable<const _Elements&...>())
      requires (__assignable<const _Elements&...>())
      {
 this->_M_assign(__u);
 return *this;
      }

      constexpr tuple&
      operator=(tuple&& __u)
      noexcept(__nothrow_assignable<_Elements...>())
      requires (__assignable<_Elements...>())
      {
 this->_M_assign(std::move(__u));
 return *this;
      }

      template<typename... _UTypes>
 requires (__assignable<const _UTypes&...>())
 constexpr tuple&
 operator=(const tuple<_UTypes...>& __u)
 noexcept(__nothrow_assignable<const _UTypes&...>())
 {
   this->_M_assign(__u);
   return *this;
 }

      template<typename... _UTypes>
 requires (__assignable<_UTypes...>())
 constexpr tuple&
 operator=(tuple<_UTypes...>&& __u)
 noexcept(__nothrow_assignable<_UTypes...>())
 {
   this->_M_assign(std::move(__u));
   return *this;
 }
# 1785 "/usr/include/c++/14.2.1/tuple" 3
      template<typename _U1, typename _U2>
 requires (__assignable<const _U1&, const _U2&>())
 constexpr tuple&
 operator=(const pair<_U1, _U2>& __u)
 noexcept(__nothrow_assignable<const _U1&, const _U2&>())
 {
   this->_M_head(*this) = __u.first;
   this->_M_tail(*this)._M_head(*this) = __u.second;
   return *this;
 }

      template<typename _U1, typename _U2>
 requires (__assignable<_U1, _U2>())
 constexpr tuple&
 operator=(pair<_U1, _U2>&& __u)
 noexcept(__nothrow_assignable<_U1, _U2>())
 {
   this->_M_head(*this) = std::forward<_U1>(__u.first);
   this->_M_tail(*this)._M_head(*this) = std::forward<_U2>(__u.second);
   return *this;
 }
# 1947 "/usr/include/c++/14.2.1/tuple" 3
      constexpr
      void
      swap(tuple& __in)
      noexcept(__and_<__is_nothrow_swappable<_Elements>...>::value)
      { _Inherited::_M_swap(__in); }
# 1966 "/usr/include/c++/14.2.1/tuple" 3
    };


  template<typename... _UTypes>
    tuple(_UTypes...) -> tuple<_UTypes...>;
  template<typename _T1, typename _T2>
    tuple(pair<_T1, _T2>) -> tuple<_T1, _T2>;
  template<typename _Alloc, typename... _UTypes>
    tuple(allocator_arg_t, _Alloc, _UTypes...) -> tuple<_UTypes...>;
  template<typename _Alloc, typename _T1, typename _T2>
    tuple(allocator_arg_t, _Alloc, pair<_T1, _T2>) -> tuple<_T1, _T2>;
  template<typename _Alloc, typename... _UTypes>
    tuple(allocator_arg_t, _Alloc, tuple<_UTypes...>) -> tuple<_UTypes...>;



  template<>
    class tuple<>
    {
    public:
      constexpr
      void swap(tuple&) noexcept { }





      tuple() = default;

      template<typename _Alloc>
 constexpr
 tuple(allocator_arg_t, const _Alloc&) noexcept { }
      template<typename _Alloc>
 constexpr
 tuple(allocator_arg_t, const _Alloc&, const tuple&) noexcept { }
    };
# 2402 "/usr/include/c++/14.2.1/tuple" 3
  template<typename... _Elements>
    struct tuple_size<tuple<_Elements...>>
    : public integral_constant<size_t, sizeof...(_Elements)> { };


  template<typename... _Types>
    inline constexpr size_t tuple_size_v<tuple<_Types...>>
      = sizeof...(_Types);

  template<typename... _Types>
    inline constexpr size_t tuple_size_v<const tuple<_Types...>>
      = sizeof...(_Types);



  template<size_t __i, typename... _Types>
    struct tuple_element<__i, tuple<_Types...>>
    {
      static_assert(__i < sizeof...(_Types), "tuple index must be in range");

      using type = typename _Nth_type<__i, _Types...>::type;
    };

  template<size_t __i, typename _Head, typename... _Tail>
    constexpr _Head&
    __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }

  template<size_t __i, typename _Head, typename... _Tail>
    constexpr const _Head&
    __get_helper(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }


  template<size_t __i, typename... _Types>
    __enable_if_t<(__i >= sizeof...(_Types))>
    __get_helper(const tuple<_Types...>&) = delete;


  template<size_t __i, typename... _Elements>
    constexpr __tuple_element_t<__i, tuple<_Elements...>>&
    get(tuple<_Elements...>& __t) noexcept
    { return std::__get_helper<__i>(__t); }


  template<size_t __i, typename... _Elements>
    constexpr const __tuple_element_t<__i, tuple<_Elements...>>&
    get(const tuple<_Elements...>& __t) noexcept
    { return std::__get_helper<__i>(__t); }


  template<size_t __i, typename... _Elements>
    constexpr __tuple_element_t<__i, tuple<_Elements...>>&&
    get(tuple<_Elements...>&& __t) noexcept
    {
      typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;
      return std::forward<__element_type>(std::__get_helper<__i>(__t));
    }


  template<size_t __i, typename... _Elements>
    constexpr const __tuple_element_t<__i, tuple<_Elements...>>&&
    get(const tuple<_Elements...>&& __t) noexcept
    {
      typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;
      return std::forward<const __element_type>(std::__get_helper<__i>(__t));
    }



  template<size_t __i, typename... _Elements>
    constexpr __enable_if_t<(__i >= sizeof...(_Elements))>
    get(const tuple<_Elements...>&) = delete;




  template <typename _Tp, typename... _Types>
    constexpr _Tp&
    get(tuple<_Types...>& __t) noexcept
    {
      constexpr size_t __idx = __find_uniq_type_in_pack<_Tp, _Types...>();
      static_assert(__idx < sizeof...(_Types),
   "the type T in std::get<T> must occur exactly once in the tuple");
      return std::__get_helper<__idx>(__t);
    }


  template <typename _Tp, typename... _Types>
    constexpr _Tp&&
    get(tuple<_Types...>&& __t) noexcept
    {
      constexpr size_t __idx = __find_uniq_type_in_pack<_Tp, _Types...>();
      static_assert(__idx < sizeof...(_Types),
   "the type T in std::get<T> must occur exactly once in the tuple");
      return std::forward<_Tp>(std::__get_helper<__idx>(__t));
    }


  template <typename _Tp, typename... _Types>
    constexpr const _Tp&
    get(const tuple<_Types...>& __t) noexcept
    {
      constexpr size_t __idx = __find_uniq_type_in_pack<_Tp, _Types...>();
      static_assert(__idx < sizeof...(_Types),
   "the type T in std::get<T> must occur exactly once in the tuple");
      return std::__get_helper<__idx>(__t);
    }



  template <typename _Tp, typename... _Types>
    constexpr const _Tp&&
    get(const tuple<_Types...>&& __t) noexcept
    {
      constexpr size_t __idx = __find_uniq_type_in_pack<_Tp, _Types...>();
      static_assert(__idx < sizeof...(_Types),
   "the type T in std::get<T> must occur exactly once in the tuple");
      return std::forward<const _Tp>(std::__get_helper<__idx>(__t));
    }



  template<typename _Tp, typename _Up, size_t __i, size_t __size>
    struct __tuple_compare
    {
      static constexpr bool
      __eq(const _Tp& __t, const _Up& __u)
      {
 return bool(std::get<__i>(__t) == std::get<__i>(__u))
   && __tuple_compare<_Tp, _Up, __i + 1, __size>::__eq(__t, __u);
      }

      static constexpr bool
      __less(const _Tp& __t, const _Up& __u)
      {
 return bool(std::get<__i>(__t) < std::get<__i>(__u))
   || (!bool(std::get<__i>(__u) < std::get<__i>(__t))
       && __tuple_compare<_Tp, _Up, __i + 1, __size>::__less(__t, __u));
      }
    };

  template<typename _Tp, typename _Up, size_t __size>
    struct __tuple_compare<_Tp, _Up, __size, __size>
    {
      static constexpr bool
      __eq(const _Tp&, const _Up&) { return true; }

      static constexpr bool
      __less(const _Tp&, const _Up&) { return false; }
    };

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator==(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    {
      static_assert(sizeof...(_TElements) == sizeof...(_UElements),
   "tuple objects can only be compared if they have equal sizes.");
      using __compare = __tuple_compare<tuple<_TElements...>,
     tuple<_UElements...>,
     0, sizeof...(_TElements)>;
      return __compare::__eq(__t, __u);
    }


  template<typename _Cat, typename _Tp, typename _Up>
    constexpr _Cat
    __tuple_cmp(const _Tp&, const _Up&, index_sequence<>)
    { return _Cat::equivalent; }

  template<typename _Cat, typename _Tp, typename _Up,
    size_t _Idx0, size_t... _Idxs>
    constexpr _Cat
    __tuple_cmp(const _Tp& __t, const _Up& __u,
  index_sequence<_Idx0, _Idxs...>)
    {
      auto __c
 = __detail::__synth3way(std::get<_Idx0>(__t), std::get<_Idx0>(__u));
      if (__c != 0)
 return __c;
      return std::__tuple_cmp<_Cat>(__t, __u, index_sequence<_Idxs...>());
    }

  template<typename... _Tps, typename... _Ups>
    constexpr
    common_comparison_category_t<__detail::__synth3way_t<_Tps, _Ups>...>
    operator<=>(const tuple<_Tps...>& __t, const tuple<_Ups...>& __u)
    {
      using _Cat
 = common_comparison_category_t<__detail::__synth3way_t<_Tps, _Ups>...>;
      return std::__tuple_cmp<_Cat>(__t, __u, index_sequence_for<_Tps...>());
    }
# 2636 "/usr/include/c++/14.2.1/tuple" 3
  template<typename... _Elements>
    constexpr tuple<typename __decay_and_strip<_Elements>::__type...>
    make_tuple(_Elements&&... __args)
    {
      typedef tuple<typename __decay_and_strip<_Elements>::__type...>
 __result_type;
      return __result_type(std::forward<_Elements>(__args)...);
    }




  template<typename... _Elements>
    constexpr tuple<_Elements&&...>
    forward_as_tuple(_Elements&&... __args) noexcept
    { return tuple<_Elements&&...>(std::forward<_Elements>(__args)...); }


  template<size_t, typename, typename, size_t>
    struct __make_tuple_impl;

  template<size_t _Idx, typename _Tuple, typename... _Tp, size_t _Nm>
    struct __make_tuple_impl<_Idx, tuple<_Tp...>, _Tuple, _Nm>
    : __make_tuple_impl<_Idx + 1,
   tuple<_Tp..., __tuple_element_t<_Idx, _Tuple>>,
   _Tuple, _Nm>
    { };

  template<size_t _Nm, typename _Tuple, typename... _Tp>
    struct __make_tuple_impl<_Nm, tuple<_Tp...>, _Tuple, _Nm>
    {
      typedef tuple<_Tp...> __type;
    };

  template<typename _Tuple>
    struct __do_make_tuple
    : __make_tuple_impl<0, tuple<>, _Tuple, tuple_size<_Tuple>::value>
    { };


  template<typename _Tuple>
    struct __make_tuple
    : public __do_make_tuple<__remove_cvref_t<_Tuple>>
    { };


  template<typename...>
    struct __combine_tuples;

  template<>
    struct __combine_tuples<>
    {
      typedef tuple<> __type;
    };

  template<typename... _Ts>
    struct __combine_tuples<tuple<_Ts...>>
    {
      typedef tuple<_Ts...> __type;
    };

  template<typename... _T1s, typename... _T2s, typename... _Rem>
    struct __combine_tuples<tuple<_T1s...>, tuple<_T2s...>, _Rem...>
    {
      typedef typename __combine_tuples<tuple<_T1s..., _T2s...>,
     _Rem...>::__type __type;
    };


  template<typename... _Tpls>
    struct __tuple_cat_result
    {
      typedef typename __combine_tuples
        <typename __make_tuple<_Tpls>::__type...>::__type __type;
    };



  template<typename...>
    struct __make_1st_indices;

  template<>
    struct __make_1st_indices<>
    {
      typedef _Index_tuple<> __type;
    };

  template<typename _Tp, typename... _Tpls>
    struct __make_1st_indices<_Tp, _Tpls...>
    {
      typedef typename _Build_index_tuple<tuple_size<
 typename remove_reference<_Tp>::type>::value>::__type __type;
    };




  template<typename _Ret, typename _Indices, typename... _Tpls>
    struct __tuple_concater;

  template<typename _Ret, size_t... _Is, typename _Tp, typename... _Tpls>
    struct __tuple_concater<_Ret, _Index_tuple<_Is...>, _Tp, _Tpls...>
    {
      template<typename... _Us>
        static constexpr _Ret
        _S_do(_Tp&& __tp, _Tpls&&... __tps, _Us&&... __us)
        {
   typedef typename __make_1st_indices<_Tpls...>::__type __idx;
   typedef __tuple_concater<_Ret, __idx, _Tpls...> __next;
   return __next::_S_do(std::forward<_Tpls>(__tps)...,
          std::forward<_Us>(__us)...,
          std::get<_Is>(std::forward<_Tp>(__tp))...);
 }
    };

  template<typename _Ret>
    struct __tuple_concater<_Ret, _Index_tuple<>>
    {
      template<typename... _Us>
 static constexpr _Ret
 _S_do(_Us&&... __us)
        {
   return _Ret(std::forward<_Us>(__us)...);
 }
    };

  template<typename... _Tps>
    struct __is_tuple_like_impl<tuple<_Tps...>> : true_type
    { };






  template<typename... _Tpls, typename = typename
           enable_if<__and_<__is_tuple_like<_Tpls>...>::value>::type>

    constexpr auto
    tuple_cat(_Tpls&&... __tpls)
    -> typename __tuple_cat_result<_Tpls...>::__type
    {
      typedef typename __tuple_cat_result<_Tpls...>::__type __ret;
      typedef typename __make_1st_indices<_Tpls...>::__type __idx;
      typedef __tuple_concater<__ret, __idx, _Tpls...> __concater;
      return __concater::_S_do(std::forward<_Tpls>(__tpls)...);
    }




  template<typename... _Elements>
    constexpr tuple<_Elements&...>
    tie(_Elements&... __args) noexcept
    { return tuple<_Elements&...>(__args...); }


  template<typename... _Elements>
    constexpr
    inline


    typename enable_if<__and_<__is_swappable<_Elements>...>::value
      >::type



    swap(tuple<_Elements...>& __x, tuple<_Elements...>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }
# 2818 "/usr/include/c++/14.2.1/tuple" 3
  template<typename... _Elements>
    constexpr
    typename enable_if<!__and_<__is_swappable<_Elements>...>::value>::type
    swap(tuple<_Elements...>&, tuple<_Elements...>&) = delete;






  struct _Swallow_assign
  {
    template<class _Tp>
      constexpr const _Swallow_assign&
      operator=(const _Tp&) const
      { return *this; }
  };
# 2853 "/usr/include/c++/14.2.1/tuple" 3
  inline constexpr _Swallow_assign ignore{};


  template<typename... _Types, typename _Alloc>
    struct uses_allocator<tuple<_Types...>, _Alloc> : true_type { };
# 2868 "/usr/include/c++/14.2.1/tuple" 3
  template<class _T1, class _T2>
    template<typename... _Args1, typename... _Args2>
      constexpr
      inline
      pair<_T1, _T2>::
      pair(piecewise_construct_t,
    tuple<_Args1...> __first, tuple<_Args2...> __second)
      : pair(__first, __second,
      typename _Build_index_tuple<sizeof...(_Args1)>::__type(),
      typename _Build_index_tuple<sizeof...(_Args2)>::__type())
      { }

  template<class _T1, class _T2>
    template<typename... _Args1, size_t... _Indexes1,
      typename... _Args2, size_t... _Indexes2>
      constexpr inline
      pair<_T1, _T2>::
      pair(tuple<_Args1...>& __tuple1, tuple<_Args2...>& __tuple2,
    _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>)
      : first(std::forward<_Args1>(std::get<_Indexes1>(__tuple1))...),
 second(std::forward<_Args2>(std::get<_Indexes2>(__tuple2))...)
      { }






  template<template<typename...> class _Trait, typename _Tp, typename _Tuple>
    inline constexpr bool __unpack_std_tuple = false;

  template<template<typename...> class _Trait, typename _Tp, typename... _Up>
    inline constexpr bool __unpack_std_tuple<_Trait, _Tp, tuple<_Up...>>
      = _Trait<_Tp, _Up...>::value;

  template<template<typename...> class _Trait, typename _Tp, typename... _Up>
    inline constexpr bool __unpack_std_tuple<_Trait, _Tp, tuple<_Up...>&>
      = _Trait<_Tp, _Up&...>::value;

  template<template<typename...> class _Trait, typename _Tp, typename... _Up>
    inline constexpr bool __unpack_std_tuple<_Trait, _Tp, const tuple<_Up...>>
      = _Trait<_Tp, const _Up...>::value;

  template<template<typename...> class _Trait, typename _Tp, typename... _Up>
    inline constexpr bool __unpack_std_tuple<_Trait, _Tp, const tuple<_Up...>&>
      = _Trait<_Tp, const _Up&...>::value;



  template <typename _Fn, typename _Tuple, size_t... _Idx>
    constexpr decltype(auto)
    __apply_impl(_Fn&& __f, _Tuple&& __t, index_sequence<_Idx...>)
    {
      return std::__invoke(std::forward<_Fn>(__f),
      std::get<_Idx>(std::forward<_Tuple>(__t))...);
    }




  template <typename _Fn, typename _Tuple>

    constexpr decltype(auto)
    apply(_Fn&& __f, _Tuple&& __t)
    noexcept(__unpack_std_tuple<is_nothrow_invocable, _Fn, _Tuple>)
    {
      using _Indices
 = make_index_sequence<tuple_size_v<remove_reference_t<_Tuple>>>;
      return std::__apply_impl(std::forward<_Fn>(__f),
          std::forward<_Tuple>(__t),
          _Indices{});
    }



  template <typename _Tp, typename _Tuple, size_t... _Idx>
    constexpr _Tp
    __make_from_tuple_impl(_Tuple&& __t, index_sequence<_Idx...>)
    { return _Tp(std::get<_Idx>(std::forward<_Tuple>(__t))...); }




  template <typename _Tp, typename _Tuple>

    constexpr _Tp
    make_from_tuple(_Tuple&& __t)
    noexcept(__unpack_std_tuple<is_nothrow_constructible, _Tp, _Tuple>)
    {
      constexpr size_t __n = tuple_size_v<remove_reference_t<_Tuple>>;

      if constexpr (__n == 1)
 {
   using _Elt = decltype(std::get<0>(std::declval<_Tuple>()));
   static_assert(!__reference_constructs_from_temporary(_Tp, _Elt));
 }

      return __make_from_tuple_impl<_Tp>(std::forward<_Tuple>(__t),
      make_index_sequence<__n>{});
    }
# 3030 "/usr/include/c++/14.2.1/tuple" 3

}
# 40 "/usr/include/c++/14.2.1/bits/uses_allocator_args.h" 2 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp>
    concept _Std_pair = __is_pair<remove_cv_t<_Tp>>;




  template<typename _Tp, typename _Alloc, typename... _Args>
    constexpr auto
    uses_allocator_construction_args(const _Alloc& __a,
         _Args&&... __args) noexcept
    requires (! _Std_pair<_Tp>)
    {
      if constexpr (uses_allocator_v<remove_cv_t<_Tp>, _Alloc>)
 {
   if constexpr (is_constructible_v<_Tp, allocator_arg_t,
        const _Alloc&, _Args...>)
     {
       return tuple<allocator_arg_t, const _Alloc&, _Args&&...>(
    allocator_arg, __a, std::forward<_Args>(__args)...);
     }
   else
     {
       static_assert(is_constructible_v<_Tp, _Args..., const _Alloc&>,
    "construction with an allocator must be possible"
    " if uses_allocator is true");

       return tuple<_Args&&..., const _Alloc&>(
    std::forward<_Args>(__args)..., __a);
     }
 }
      else
 {
   static_assert(is_constructible_v<_Tp, _Args...>);

   return tuple<_Args&&...>(std::forward<_Args>(__args)...);
 }
    }

  template<_Std_pair _Tp, typename _Alloc, typename _Tuple1, typename _Tuple2>
    constexpr auto
    uses_allocator_construction_args(const _Alloc& __a, piecewise_construct_t,
         _Tuple1&& __x, _Tuple2&& __y) noexcept;

  template<_Std_pair _Tp, typename _Alloc>
    constexpr auto
    uses_allocator_construction_args(const _Alloc&) noexcept;

  template<_Std_pair _Tp, typename _Alloc, typename _Up, typename _Vp>
    constexpr auto
    uses_allocator_construction_args(const _Alloc&, _Up&&, _Vp&&) noexcept;

  template<_Std_pair _Tp, typename _Alloc, typename _Up, typename _Vp>
    constexpr auto
    uses_allocator_construction_args(const _Alloc&,
         const pair<_Up, _Vp>&) noexcept;

  template<_Std_pair _Tp, typename _Alloc, typename _Up, typename _Vp>
    constexpr auto
    uses_allocator_construction_args(const _Alloc&, pair<_Up, _Vp>&&) noexcept;
# 118 "/usr/include/c++/14.2.1/bits/uses_allocator_args.h" 3
  template<_Std_pair _Tp, typename _Alloc, typename _Tuple1, typename _Tuple2>
    constexpr auto
    uses_allocator_construction_args(const _Alloc& __a, piecewise_construct_t,
         _Tuple1&& __x, _Tuple2&& __y) noexcept
    {
      using _Tp1 = typename _Tp::first_type;
      using _Tp2 = typename _Tp::second_type;

      return std::make_tuple(piecewise_construct,
   std::apply([&__a](auto&&... __args1) {
       return std::uses_allocator_construction_args<_Tp1>(
    __a, std::forward<decltype(__args1)>(__args1)...);
   }, std::forward<_Tuple1>(__x)),
   std::apply([&__a](auto&&... __args2) {
       return std::uses_allocator_construction_args<_Tp2>(
    __a, std::forward<decltype(__args2)>(__args2)...);
   }, std::forward<_Tuple2>(__y)));
    }

  template<_Std_pair _Tp, typename _Alloc>
    constexpr auto
    uses_allocator_construction_args(const _Alloc& __a) noexcept
    {
      using _Tp1 = typename _Tp::first_type;
      using _Tp2 = typename _Tp::second_type;

      return std::make_tuple(piecewise_construct,
   std::uses_allocator_construction_args<_Tp1>(__a),
   std::uses_allocator_construction_args<_Tp2>(__a));
    }

  template<_Std_pair _Tp, typename _Alloc, typename _Up, typename _Vp>
    constexpr auto
    uses_allocator_construction_args(const _Alloc& __a, _Up&& __u, _Vp&& __v)
      noexcept
    {
      using _Tp1 = typename _Tp::first_type;
      using _Tp2 = typename _Tp::second_type;

      return std::make_tuple(piecewise_construct,
   std::uses_allocator_construction_args<_Tp1>(__a,
     std::forward<_Up>(__u)),
   std::uses_allocator_construction_args<_Tp2>(__a,
     std::forward<_Vp>(__v)));
    }

  template<_Std_pair _Tp, typename _Alloc, typename _Up, typename _Vp>
    constexpr auto
    uses_allocator_construction_args(const _Alloc& __a,
         const pair<_Up, _Vp>& __pr) noexcept
    {
      using _Tp1 = typename _Tp::first_type;
      using _Tp2 = typename _Tp::second_type;

      return std::make_tuple(piecewise_construct,
   std::uses_allocator_construction_args<_Tp1>(__a, __pr.first),
   std::uses_allocator_construction_args<_Tp2>(__a, __pr.second));
    }

  template<_Std_pair _Tp, typename _Alloc, typename _Up, typename _Vp>
    constexpr auto
    uses_allocator_construction_args(const _Alloc& __a,
         pair<_Up, _Vp>&& __pr) noexcept
    {
      using _Tp1 = typename _Tp::first_type;
      using _Tp2 = typename _Tp::second_type;




      return std::make_tuple(piecewise_construct,
   std::uses_allocator_construction_args<_Tp1>(__a,
     std::get<0>(std::move(__pr))),
   std::uses_allocator_construction_args<_Tp2>(__a,
     std::get<1>(std::move(__pr))));
    }
# 225 "/usr/include/c++/14.2.1/bits/uses_allocator_args.h" 3
  template<typename _Tp, typename _Alloc, typename... _Args>
    constexpr _Tp
    make_obj_using_allocator(const _Alloc& __a, _Args&&... __args)
    {
      return std::make_from_tuple<_Tp>(
   std::uses_allocator_construction_args<_Tp>(__a,
     std::forward<_Args>(__args)...));
    }

  template<typename _Tp, typename _Alloc, typename... _Args>
    constexpr _Tp*
    uninitialized_construct_using_allocator(_Tp* __p, const _Alloc& __a,
         _Args&&... __args)
    {
      return std::apply([&](auto&&... __xs) {
 return std::construct_at(__p, std::forward<decltype(__xs)>(__xs)...);
      }, std::uses_allocator_construction_args<_Tp>(__a,
 std::forward<_Args>(__args)...));
    }


}
# 42 "/usr/include/c++/14.2.1/bits/memory_resource.h" 2 3
# 50 "/usr/include/c++/14.2.1/bits/memory_resource.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

namespace pmr
{






  class memory_resource
  {
    static constexpr size_t _S_max_align = alignof(max_align_t);

  public:
    memory_resource() = default;
    memory_resource(const memory_resource&) = default;
    virtual ~memory_resource();

    memory_resource& operator=(const memory_resource&) = default;

    [[nodiscard]]
    void*
    allocate(size_t __bytes, size_t __alignment = _S_max_align)
    __attribute__((__returns_nonnull__,__alloc_size__(2),__alloc_align__(3)))
    { return ::operator new(__bytes, do_allocate(__bytes, __alignment)); }

    void
    deallocate(void* __p, size_t __bytes, size_t __alignment = _S_max_align)
    __attribute__((__nonnull__))
    { return do_deallocate(__p, __bytes, __alignment); }

    [[nodiscard]]
    bool
    is_equal(const memory_resource& __other) const noexcept
    { return do_is_equal(__other); }

  private:
    virtual void*
    do_allocate(size_t __bytes, size_t __alignment) = 0;

    virtual void
    do_deallocate(void* __p, size_t __bytes, size_t __alignment) = 0;

    virtual bool
    do_is_equal(const memory_resource& __other) const noexcept = 0;
  };

  [[nodiscard]]
  inline bool
  operator==(const memory_resource& __a, const memory_resource& __b) noexcept
  { return &__a == &__b || __a.is_equal(__b); }
# 119 "/usr/include/c++/14.2.1/bits/memory_resource.h" 3
  template<typename _Tp>
    class polymorphic_allocator
    {


      template<typename _Up>
 struct __not_pair { using type = void; };

      template<typename _Up1, typename _Up2>
 struct __not_pair<pair<_Up1, _Up2>> { };

    public:
      using value_type = _Tp;

      polymorphic_allocator() noexcept
      {
 extern memory_resource* get_default_resource() noexcept
   __attribute__((__returns_nonnull__));
 _M_resource = get_default_resource();
      }

      polymorphic_allocator(memory_resource* __r) noexcept
      __attribute__((__nonnull__))
      : _M_resource(__r)
      { ; }

      polymorphic_allocator(const polymorphic_allocator& __other) = default;

      template<typename _Up>
 polymorphic_allocator(const polymorphic_allocator<_Up>& __x) noexcept
 : _M_resource(__x.resource())
 { }

      polymorphic_allocator&
      operator=(const polymorphic_allocator&) = delete;

      [[nodiscard]]
      _Tp*
      allocate(size_t __n)
      __attribute__((__returns_nonnull__))
      {
 if ((__gnu_cxx::__int_traits<size_t>::__max / sizeof(_Tp)) < __n)
   std::__throw_bad_array_new_length();
 return static_cast<_Tp*>(_M_resource->allocate(__n * sizeof(_Tp),
             alignof(_Tp)));
      }

      void
      deallocate(_Tp* __p, size_t __n) noexcept
      __attribute__((__nonnull__))
      { _M_resource->deallocate(__p, __n * sizeof(_Tp), alignof(_Tp)); }


      [[nodiscard]] void*
      allocate_bytes(size_t __nbytes,
       size_t __alignment = alignof(max_align_t))
      { return _M_resource->allocate(__nbytes, __alignment); }

      void
      deallocate_bytes(void* __p, size_t __nbytes,
         size_t __alignment = alignof(max_align_t))
      { _M_resource->deallocate(__p, __nbytes, __alignment); }

      template<typename _Up>
 [[nodiscard]] _Up*
 allocate_object(size_t __n = 1)
 {
   if ((__gnu_cxx::__int_traits<size_t>::__max / sizeof(_Up)) < __n)
     std::__throw_bad_array_new_length();
   return static_cast<_Up*>(allocate_bytes(__n * sizeof(_Up),
        alignof(_Up)));
 }

      template<typename _Up>
 void
 deallocate_object(_Up* __p, size_t __n = 1)
 { deallocate_bytes(__p, __n * sizeof(_Up), alignof(_Up)); }

      template<typename _Up, typename... _CtorArgs>
 [[nodiscard]] _Up*
 new_object(_CtorArgs&&... __ctor_args)
 {
   _Up* __p = allocate_object<_Up>();
   try
     {
       construct(__p, std::forward<_CtorArgs>(__ctor_args)...);
     }
   catch(...)
     {
       deallocate_object(__p);
       throw;
     }
   return __p;
 }

      template<typename _Up>
 void
 delete_object(_Up* __p)
 {
   __p->~_Up();
   deallocate_object(__p);
 }
# 297 "/usr/include/c++/14.2.1/bits/memory_resource.h" 3
      template<typename _Tp1, typename... _Args>
 __attribute__((__nonnull__))
 void
 construct(_Tp1* __p, _Args&&... __args)
 {
   std::uninitialized_construct_using_allocator(__p, *this,
       std::forward<_Args>(__args)...);
 }


      template<typename _Up>
 __attribute__ ((__deprecated__ ("use '" "allocator_traits::destroy" "' instead")))
 __attribute__((__nonnull__))
 void
 destroy(_Up* __p)
 { __p->~_Up(); }

      polymorphic_allocator
      select_on_container_copy_construction() const noexcept
      { return polymorphic_allocator(); }

      memory_resource*
      resource() const noexcept
      __attribute__((__returns_nonnull__))
      { return _M_resource; }



      [[nodiscard]]
      friend bool
      operator==(const polymorphic_allocator& __a,
   const polymorphic_allocator& __b) noexcept
      { return *__a.resource() == *__b.resource(); }
# 339 "/usr/include/c++/14.2.1/bits/memory_resource.h" 3
    private:
# 366 "/usr/include/c++/14.2.1/bits/memory_resource.h" 3
      memory_resource* _M_resource;
    };

  template<typename _Tp1, typename _Tp2>
    [[nodiscard]]
    inline bool
    operator==(const polymorphic_allocator<_Tp1>& __a,
        const polymorphic_allocator<_Tp2>& __b) noexcept
    { return *__a.resource() == *__b.resource(); }
# 385 "/usr/include/c++/14.2.1/bits/memory_resource.h" 3
}

  template<typename _Alloc> struct allocator_traits;


  template<typename _Tp>
    struct allocator_traits<pmr::polymorphic_allocator<_Tp>>
    {

      using allocator_type = pmr::polymorphic_allocator<_Tp>;


      using value_type = _Tp;


      using pointer = _Tp*;


      using const_pointer = const _Tp*;


      using void_pointer = void*;


      using const_void_pointer = const void*;


      using difference_type = std::ptrdiff_t;


      using size_type = std::size_t;





      using propagate_on_container_copy_assignment = false_type;
      using propagate_on_container_move_assignment = false_type;
      using propagate_on_container_swap = false_type;

      static allocator_type
      select_on_container_copy_construction(const allocator_type&) noexcept
      { return allocator_type(); }



      using is_always_equal = false_type;

      template<typename _Up>
 using rebind_alloc = pmr::polymorphic_allocator<_Up>;

      template<typename _Up>
 using rebind_traits = allocator_traits<pmr::polymorphic_allocator<_Up>>;
# 446 "/usr/include/c++/14.2.1/bits/memory_resource.h" 3
      [[nodiscard]] static pointer
      allocate(allocator_type& __a, size_type __n)
      { return __a.allocate(__n); }
# 461 "/usr/include/c++/14.2.1/bits/memory_resource.h" 3
      [[nodiscard]] static pointer
      allocate(allocator_type& __a, size_type __n, const_void_pointer)
      { return __a.allocate(__n); }
# 473 "/usr/include/c++/14.2.1/bits/memory_resource.h" 3
      static void
      deallocate(allocator_type& __a, pointer __p, size_type __n)
      { __a.deallocate(__p, __n); }
# 488 "/usr/include/c++/14.2.1/bits/memory_resource.h" 3
      template<typename _Up, typename... _Args>
 static void
 construct(allocator_type& __a, _Up* __p, _Args&&... __args)
 { __a.construct(__p, std::forward<_Args>(__args)...); }
# 500 "/usr/include/c++/14.2.1/bits/memory_resource.h" 3
      template<typename _Up>
 static constexpr void
 destroy(allocator_type&, _Up* __p)
 noexcept(is_nothrow_destructible<_Up>::value)
 { __p->~_Up(); }





      static constexpr size_type
      max_size(const allocator_type&) noexcept
      { return size_t(-1) / sizeof(value_type); }
    };


}
# 88 "/usr/include/c++/14.2.1/vector" 2 3
namespace std __attribute__ ((__visibility__ ("default")))
{

  namespace pmr {
    template<typename _Tp>
      using vector = std::vector<_Tp, polymorphic_allocator<_Tp>>;
  }








}



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp, typename _Alloc, typename _Predicate>
    constexpr
    inline typename vector<_Tp, _Alloc>::size_type
    erase_if(vector<_Tp, _Alloc>& __cont, _Predicate __pred)
    {
      using namespace __gnu_cxx;
      std::vector<_Tp, _Alloc>& __ucont = __cont;
      const auto __osz = __cont.size();
      const auto __end = __ucont.end();
      auto __removed = std::__remove_if(__ucont.begin(), __end,
     __ops::__pred_iter(std::ref(__pred)));
      if (__removed != __end)
 {
   __cont.erase(__niter_wrap(__cont.begin(), __removed),
         __cont.end());
   return __osz - __cont.size();
 }

      return 0;
    }

  template<typename _Tp, typename _Alloc, typename _Up>
    constexpr
    inline typename vector<_Tp, _Alloc>::size_type
    erase(vector<_Tp, _Alloc>& __cont, const _Up& __value)
    {
      using namespace __gnu_cxx;
      std::vector<_Tp, _Alloc>& __ucont = __cont;
      const auto __osz = __cont.size();
      const auto __end = __ucont.end();
      auto __removed = std::__remove_if(__ucont.begin(), __end,
     __ops::__iter_equals_val(__value));
      if (__removed != __end)
 {
   __cont.erase(__niter_wrap(__cont.begin(), __removed),
         __cont.end());
   return __osz - __cont.size();
 }

      return 0;
    }

}
# 11 "/home/devkon/CLionProjects/VertexLab/drawing_utils.h" 2



# 13 "/home/devkon/CLionProjects/VertexLab/drawing_utils.h"
struct GridData {
    GLuint vao;
    GLuint vbo;
    GLuint shaderProgram;
    std::vector<float> vertices;
};


void GenerateGrid(std::vector<float>& gridVertices, float size = 10.0f, float spacing = 1.0f);
GridData CreateGrid();
void DrawGrid(const GridData& grid, const glm::mat4& view, const glm::mat4& projection);
# 11 "/home/devkon/CLionProjects/VertexLab/main.cpp" 2
# 1 "/usr/include/imgui.h" 1 3 4
# 57 "/usr/include/imgui.h" 3 4
       






# 1 "/usr/include/imconfig.h" 1 3 4
# 15 "/usr/include/imconfig.h" 3 4
       
# 65 "/usr/include/imgui.h" 2 3 4
# 74 "/usr/include/imgui.h" 3 4
# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/stdarg.h" 3 4

# 40 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 103 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/stdarg.h" 3 4
typedef __gnuc_va_list va_list;
# 75 "/usr/include/imgui.h" 2 3 4
# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/include/stddef.h" 1 3 4
# 76 "/usr/include/imgui.h" 2 3 4
# 90 "/usr/include/imgui.h" 3 4
# 1 "/usr/include/assert.h" 1 3 4
# 64 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     noexcept (true) __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     noexcept (true) __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     noexcept (true) __attribute__ ((__noreturn__));


}
# 91 "/usr/include/imgui.h" 2 3 4
# 139 "/usr/include/imgui.h" 3 4
 
# 139 "/usr/include/imgui.h" 3 4
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpragmas"
#pragma GCC diagnostic ignored "-Wclass-memaccess"







typedef unsigned int ImGuiID;
typedef signed char ImS8;
typedef unsigned char ImU8;
typedef signed short ImS16;
typedef unsigned short ImU16;
typedef signed int ImS32;
typedef unsigned int ImU32;
typedef signed long long ImS64;
typedef unsigned long long ImU64;


struct ImDrawChannel;
struct ImDrawCmd;
struct ImDrawData;
struct ImDrawList;
struct ImDrawListSharedData;
struct ImDrawListSplitter;
struct ImDrawVert;
struct ImFont;
struct ImFontAtlas;
struct ImFontBuilderIO;
struct ImFontConfig;
struct ImFontGlyph;
struct ImFontGlyphRangesBuilder;
struct ImColor;
struct ImGuiContext;
struct ImGuiIO;
struct ImGuiInputTextCallbackData;
struct ImGuiKeyData;
struct ImGuiListClipper;
struct ImGuiMultiSelectIO;
struct ImGuiOnceUponAFrame;
struct ImGuiPayload;
struct ImGuiPlatformIO;
struct ImGuiPlatformImeData;
struct ImGuiSelectionBasicStorage;
struct ImGuiSelectionExternalStorage;
struct ImGuiSelectionRequest;
struct ImGuiSizeCallbackData;
struct ImGuiStorage;
struct ImGuiStoragePair;
struct ImGuiStyle;
struct ImGuiTableSortSpecs;
struct ImGuiTableColumnSortSpecs;
struct ImGuiTextBuffer;
struct ImGuiTextFilter;
struct ImGuiViewport;







enum ImGuiDir : int;
enum ImGuiKey : int;
enum ImGuiMouseSource : int;
enum ImGuiSortDirection : ImU8;
typedef int ImGuiCol;
typedef int ImGuiCond;
typedef int ImGuiDataType;
typedef int ImGuiMouseButton;
typedef int ImGuiMouseCursor;
typedef int ImGuiStyleVar;
typedef int ImGuiTableBgTarget;






typedef int ImDrawFlags;
typedef int ImDrawListFlags;
typedef int ImFontAtlasFlags;
typedef int ImGuiBackendFlags;
typedef int ImGuiButtonFlags;
typedef int ImGuiChildFlags;
typedef int ImGuiColorEditFlags;
typedef int ImGuiConfigFlags;
typedef int ImGuiComboFlags;
typedef int ImGuiDragDropFlags;
typedef int ImGuiFocusedFlags;
typedef int ImGuiHoveredFlags;
typedef int ImGuiInputFlags;
typedef int ImGuiInputTextFlags;
typedef int ImGuiItemFlags;
typedef int ImGuiKeyChord;
typedef int ImGuiPopupFlags;
typedef int ImGuiMultiSelectFlags;
typedef int ImGuiSelectableFlags;
typedef int ImGuiSliderFlags;
typedef int ImGuiTabBarFlags;
typedef int ImGuiTabItemFlags;
typedef int ImGuiTableFlags;
typedef int ImGuiTableColumnFlags;
typedef int ImGuiTableRowFlags;
typedef int ImGuiTreeNodeFlags;
typedef int ImGuiViewportFlags;
typedef int ImGuiWindowFlags;







typedef ImU64 ImTextureID;






typedef unsigned short ImDrawIdx;




typedef unsigned int ImWchar32;
typedef unsigned short ImWchar16;



typedef ImWchar16 ImWchar;





typedef ImS64 ImGuiSelectionUserData;


typedef int (*ImGuiInputTextCallback)(ImGuiInputTextCallbackData* data);
typedef void (*ImGuiSizeCallback)(ImGuiSizeCallbackData* data);
typedef void* (*ImGuiMemAllocFunc)(size_t sz, void* user_data);
typedef void (*ImGuiMemFreeFunc)(void* ptr, void* user_data);





struct ImVec2
{
    float x, y;
    constexpr ImVec2() : x(0.0f), y(0.0f) { }
    constexpr ImVec2(float _x, float _y) : x(_x), y(_y) { }
    float& operator[] (size_t idx) { (static_cast <bool> (idx == 0 || idx == 1) ? void (0) : __assert_fail ("idx == 0 || idx == 1", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)); return ((float*)(void*)(char*)this)[idx]; }
    float operator[] (size_t idx) const { (static_cast <bool> (idx == 0 || idx == 1) ? void (0) : __assert_fail ("idx == 0 || idx == 1", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)); return ((const float*)(const void*)(const char*)this)[idx]; }



};


struct ImVec4
{
    float x, y, z, w;
    constexpr ImVec4() : x(0.0f), y(0.0f), z(0.0f), w(0.0f) { }
    constexpr ImVec4(float _x, float _y, float _z, float _w) : x(_x), y(_y), z(_z), w(_w) { }



};







namespace ImGui
{




    ImGuiContext* CreateContext(ImFontAtlas* shared_font_atlas = __null);
    void DestroyContext(ImGuiContext* ctx = __null);
    ImGuiContext* GetCurrentContext();
    void SetCurrentContext(ImGuiContext* ctx);


    ImGuiIO& GetIO();
    ImGuiPlatformIO& GetPlatformIO();
    ImGuiStyle& GetStyle();
    void NewFrame();
    void EndFrame();
    void Render();
    ImDrawData* GetDrawData();


    void ShowDemoWindow(bool* p_open = __null);
    void ShowMetricsWindow(bool* p_open = __null);
    void ShowDebugLogWindow(bool* p_open = __null);
    void ShowIDStackToolWindow(bool* p_open = __null);
    void ShowAboutWindow(bool* p_open = __null);
    void ShowStyleEditor(ImGuiStyle* ref = __null);
    bool ShowStyleSelector(const char* label);
    void ShowFontSelector(const char* label);
    void ShowUserGuide();
    const char* GetVersion();


    void StyleColorsDark(ImGuiStyle* dst = __null);
    void StyleColorsLight(ImGuiStyle* dst = __null);
    void StyleColorsClassic(ImGuiStyle* dst = __null);
# 368 "/usr/include/imgui.h" 3 4
    bool Begin(const char* name, bool* p_open = __null, ImGuiWindowFlags flags = 0);
    void End();
# 389 "/usr/include/imgui.h" 3 4
    bool BeginChild(const char* str_id, const ImVec2& size = ImVec2(0, 0), ImGuiChildFlags child_flags = 0, ImGuiWindowFlags window_flags = 0);
    bool BeginChild(ImGuiID id, const ImVec2& size = ImVec2(0, 0), ImGuiChildFlags child_flags = 0, ImGuiWindowFlags window_flags = 0);
    void EndChild();



    bool IsWindowAppearing();
    bool IsWindowCollapsed();
    bool IsWindowFocused(ImGuiFocusedFlags flags=0);
    bool IsWindowHovered(ImGuiHoveredFlags flags=0);
    ImDrawList* GetWindowDrawList();
    ImVec2 GetWindowPos();
    ImVec2 GetWindowSize();
    float GetWindowWidth();
    float GetWindowHeight();



    void SetNextWindowPos(const ImVec2& pos, ImGuiCond cond = 0, const ImVec2& pivot = ImVec2(0, 0));
    void SetNextWindowSize(const ImVec2& size, ImGuiCond cond = 0);
    void SetNextWindowSizeConstraints(const ImVec2& size_min, const ImVec2& size_max, ImGuiSizeCallback custom_callback = __null, void* custom_callback_data = __null);
    void SetNextWindowContentSize(const ImVec2& size);
    void SetNextWindowCollapsed(bool collapsed, ImGuiCond cond = 0);
    void SetNextWindowFocus();
    void SetNextWindowScroll(const ImVec2& scroll);
    void SetNextWindowBgAlpha(float alpha);
    void SetWindowPos(const ImVec2& pos, ImGuiCond cond = 0);
    void SetWindowSize(const ImVec2& size, ImGuiCond cond = 0);
    void SetWindowCollapsed(bool collapsed, ImGuiCond cond = 0);
    void SetWindowFocus();
    void SetWindowFontScale(float scale);
    void SetWindowPos(const char* name, const ImVec2& pos, ImGuiCond cond = 0);
    void SetWindowSize(const char* name, const ImVec2& size, ImGuiCond cond = 0);
    void SetWindowCollapsed(const char* name, bool collapsed, ImGuiCond cond = 0);
    void SetWindowFocus(const char* name);




    float GetScrollX();
    float GetScrollY();
    void SetScrollX(float scroll_x);
    void SetScrollY(float scroll_y);
    float GetScrollMaxX();
    float GetScrollMaxY();
    void SetScrollHereX(float center_x_ratio = 0.5f);
    void SetScrollHereY(float center_y_ratio = 0.5f);
    void SetScrollFromPosX(float local_x, float center_x_ratio = 0.5f);
    void SetScrollFromPosY(float local_y, float center_y_ratio = 0.5f);


    void PushFont(ImFont* font);
    void PopFont();
    void PushStyleColor(ImGuiCol idx, ImU32 col);
    void PushStyleColor(ImGuiCol idx, const ImVec4& col);
    void PopStyleColor(int count = 1);
    void PushStyleVar(ImGuiStyleVar idx, float val);
    void PushStyleVar(ImGuiStyleVar idx, const ImVec2& val);
    void PushStyleVarX(ImGuiStyleVar idx, float val_x);
    void PushStyleVarY(ImGuiStyleVar idx, float val_y);
    void PopStyleVar(int count = 1);
    void PushItemFlag(ImGuiItemFlags option, bool enabled);
    void PopItemFlag();


    void PushItemWidth(float item_width);
    void PopItemWidth();
    void SetNextItemWidth(float item_width);
    float CalcItemWidth();
    void PushTextWrapPos(float wrap_local_pos_x = 0.0f);
    void PopTextWrapPos();



    ImFont* GetFont();
    float GetFontSize();
    ImVec2 GetFontTexUvWhitePixel();
    ImU32 GetColorU32(ImGuiCol idx, float alpha_mul = 1.0f);
    ImU32 GetColorU32(const ImVec4& col);
    ImU32 GetColorU32(ImU32 col, float alpha_mul = 1.0f);
    const ImVec4& GetStyleColorVec4(ImGuiCol idx);
# 481 "/usr/include/imgui.h" 3 4
    ImVec2 GetCursorScreenPos();
    void SetCursorScreenPos(const ImVec2& pos);
    ImVec2 GetContentRegionAvail();
    ImVec2 GetCursorPos();
    float GetCursorPosX();
    float GetCursorPosY();
    void SetCursorPos(const ImVec2& local_pos);
    void SetCursorPosX(float local_x);
    void SetCursorPosY(float local_y);
    ImVec2 GetCursorStartPos();


    void Separator();
    void SameLine(float offset_from_start_x=0.0f, float spacing=-1.0f);
    void NewLine();
    void Spacing();
    void Dummy(const ImVec2& size);
    void Indent(float indent_w = 0.0f);
    void Unindent(float indent_w = 0.0f);
    void BeginGroup();
    void EndGroup();
    void AlignTextToFramePadding();
    float GetTextLineHeight();
    float GetTextLineHeightWithSpacing();
    float GetFrameHeight();
    float GetFrameHeightWithSpacing();
# 519 "/usr/include/imgui.h" 3 4
    void PushID(const char* str_id);
    void PushID(const char* str_id_begin, const char* str_id_end);
    void PushID(const void* ptr_id);
    void PushID(int int_id);
    void PopID();
    ImGuiID GetID(const char* str_id);
    ImGuiID GetID(const char* str_id_begin, const char* str_id_end);
    ImGuiID GetID(const void* ptr_id);
    ImGuiID GetID(int int_id);


    void TextUnformatted(const char* text, const char* text_end = __null);
    void Text(const char* fmt, ...) __attribute__((format(printf, 1, 1 +1)));
    void TextV(const char* fmt, va_list args) __attribute__((format(printf, 1, 0)));
    void TextColored(const ImVec4& col, const char* fmt, ...) __attribute__((format(printf, 2, 2 +1)));
    void TextColoredV(const ImVec4& col, const char* fmt, va_list args) __attribute__((format(printf, 2, 0)));
    void TextDisabled(const char* fmt, ...) __attribute__((format(printf, 1, 1 +1)));
    void TextDisabledV(const char* fmt, va_list args) __attribute__((format(printf, 1, 0)));
    void TextWrapped(const char* fmt, ...) __attribute__((format(printf, 1, 1 +1)));
    void TextWrappedV(const char* fmt, va_list args) __attribute__((format(printf, 1, 0)));
    void LabelText(const char* label, const char* fmt, ...) __attribute__((format(printf, 2, 2 +1)));
    void LabelTextV(const char* label, const char* fmt, va_list args) __attribute__((format(printf, 2, 0)));
    void BulletText(const char* fmt, ...) __attribute__((format(printf, 1, 1 +1)));
    void BulletTextV(const char* fmt, va_list args) __attribute__((format(printf, 1, 0)));
    void SeparatorText(const char* label);




    bool Button(const char* label, const ImVec2& size = ImVec2(0, 0));
    bool SmallButton(const char* label);
    bool InvisibleButton(const char* str_id, const ImVec2& size, ImGuiButtonFlags flags = 0);
    bool ArrowButton(const char* str_id, ImGuiDir dir);
    bool Checkbox(const char* label, bool* v);
    bool CheckboxFlags(const char* label, int* flags, int flags_value);
    bool CheckboxFlags(const char* label, unsigned int* flags, unsigned int flags_value);
    bool RadioButton(const char* label, bool active);
    bool RadioButton(const char* label, int* v, int v_button);
    void ProgressBar(float fraction, const ImVec2& size_arg = ImVec2(-1.17549435082228750796873653722224568e-38F, 0), const char* overlay = __null);
    void Bullet();
    bool TextLink(const char* label);
    void TextLinkOpenURL(const char* label, const char* url = __null);





    void Image(ImTextureID user_texture_id, const ImVec2& image_size, const ImVec2& uv0 = ImVec2(0, 0), const ImVec2& uv1 = ImVec2(1, 1), const ImVec4& tint_col = ImVec4(1, 1, 1, 1), const ImVec4& border_col = ImVec4(0, 0, 0, 0));
    bool ImageButton(const char* str_id, ImTextureID user_texture_id, const ImVec2& image_size, const ImVec2& uv0 = ImVec2(0, 0), const ImVec2& uv1 = ImVec2(1, 1), const ImVec4& bg_col = ImVec4(0, 0, 0, 0), const ImVec4& tint_col = ImVec4(1, 1, 1, 1));




    bool BeginCombo(const char* label, const char* preview_value, ImGuiComboFlags flags = 0);
    void EndCombo();
    bool Combo(const char* label, int* current_item, const char* const items[], int items_count, int popup_max_height_in_items = -1);
    bool Combo(const char* label, int* current_item, const char* items_separated_by_zeros, int popup_max_height_in_items = -1);
    bool Combo(const char* label, int* current_item, const char* (*getter)(void* user_data, int idx), void* user_data, int items_count, int popup_max_height_in_items = -1);
# 590 "/usr/include/imgui.h" 3 4
    bool DragFloat(const char* label, float* v, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = "%.3f", ImGuiSliderFlags flags = 0);
    bool DragFloat2(const char* label, float v[2], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = "%.3f", ImGuiSliderFlags flags = 0);
    bool DragFloat3(const char* label, float v[3], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = "%.3f", ImGuiSliderFlags flags = 0);
    bool DragFloat4(const char* label, float v[4], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = "%.3f", ImGuiSliderFlags flags = 0);
    bool DragFloatRange2(const char* label, float* v_current_min, float* v_current_max, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* format = "%.3f", const char* format_max = __null, ImGuiSliderFlags flags = 0);
    bool DragInt(const char* label, int* v, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = "%d", ImGuiSliderFlags flags = 0);
    bool DragInt2(const char* label, int v[2], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = "%d", ImGuiSliderFlags flags = 0);
    bool DragInt3(const char* label, int v[3], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = "%d", ImGuiSliderFlags flags = 0);
    bool DragInt4(const char* label, int v[4], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = "%d", ImGuiSliderFlags flags = 0);
    bool DragIntRange2(const char* label, int* v_current_min, int* v_current_max, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* format = "%d", const char* format_max = __null, ImGuiSliderFlags flags = 0);
    bool DragScalar(const char* label, ImGuiDataType data_type, void* p_data, float v_speed = 1.0f, const void* p_min = __null, const void* p_max = __null, const char* format = __null, ImGuiSliderFlags flags = 0);
    bool DragScalarN(const char* label, ImGuiDataType data_type, void* p_data, int components, float v_speed = 1.0f, const void* p_min = __null, const void* p_max = __null, const char* format = __null, ImGuiSliderFlags flags = 0);







    bool SliderFloat(const char* label, float* v, float v_min, float v_max, const char* format = "%.3f", ImGuiSliderFlags flags = 0);
    bool SliderFloat2(const char* label, float v[2], float v_min, float v_max, const char* format = "%.3f", ImGuiSliderFlags flags = 0);
    bool SliderFloat3(const char* label, float v[3], float v_min, float v_max, const char* format = "%.3f", ImGuiSliderFlags flags = 0);
    bool SliderFloat4(const char* label, float v[4], float v_min, float v_max, const char* format = "%.3f", ImGuiSliderFlags flags = 0);
    bool SliderAngle(const char* label, float* v_rad, float v_degrees_min = -360.0f, float v_degrees_max = +360.0f, const char* format = "%.0f deg", ImGuiSliderFlags flags = 0);
    bool SliderInt(const char* label, int* v, int v_min, int v_max, const char* format = "%d", ImGuiSliderFlags flags = 0);
    bool SliderInt2(const char* label, int v[2], int v_min, int v_max, const char* format = "%d", ImGuiSliderFlags flags = 0);
    bool SliderInt3(const char* label, int v[3], int v_min, int v_max, const char* format = "%d", ImGuiSliderFlags flags = 0);
    bool SliderInt4(const char* label, int v[4], int v_min, int v_max, const char* format = "%d", ImGuiSliderFlags flags = 0);
    bool SliderScalar(const char* label, ImGuiDataType data_type, void* p_data, const void* p_min, const void* p_max, const char* format = __null, ImGuiSliderFlags flags = 0);
    bool SliderScalarN(const char* label, ImGuiDataType data_type, void* p_data, int components, const void* p_min, const void* p_max, const char* format = __null, ImGuiSliderFlags flags = 0);
    bool VSliderFloat(const char* label, const ImVec2& size, float* v, float v_min, float v_max, const char* format = "%.3f", ImGuiSliderFlags flags = 0);
    bool VSliderInt(const char* label, const ImVec2& size, int* v, int v_min, int v_max, const char* format = "%d", ImGuiSliderFlags flags = 0);
    bool VSliderScalar(const char* label, const ImVec2& size, ImGuiDataType data_type, void* p_data, const void* p_min, const void* p_max, const char* format = __null, ImGuiSliderFlags flags = 0);




    bool InputText(const char* label, char* buf, size_t buf_size, ImGuiInputTextFlags flags = 0, ImGuiInputTextCallback callback = __null, void* user_data = __null);
    bool InputTextMultiline(const char* label, char* buf, size_t buf_size, const ImVec2& size = ImVec2(0, 0), ImGuiInputTextFlags flags = 0, ImGuiInputTextCallback callback = __null, void* user_data = __null);
    bool InputTextWithHint(const char* label, const char* hint, char* buf, size_t buf_size, ImGuiInputTextFlags flags = 0, ImGuiInputTextCallback callback = __null, void* user_data = __null);
    bool InputFloat(const char* label, float* v, float step = 0.0f, float step_fast = 0.0f, const char* format = "%.3f", ImGuiInputTextFlags flags = 0);
    bool InputFloat2(const char* label, float v[2], const char* format = "%.3f", ImGuiInputTextFlags flags = 0);
    bool InputFloat3(const char* label, float v[3], const char* format = "%.3f", ImGuiInputTextFlags flags = 0);
    bool InputFloat4(const char* label, float v[4], const char* format = "%.3f", ImGuiInputTextFlags flags = 0);
    bool InputInt(const char* label, int* v, int step = 1, int step_fast = 100, ImGuiInputTextFlags flags = 0);
    bool InputInt2(const char* label, int v[2], ImGuiInputTextFlags flags = 0);
    bool InputInt3(const char* label, int v[3], ImGuiInputTextFlags flags = 0);
    bool InputInt4(const char* label, int v[4], ImGuiInputTextFlags flags = 0);
    bool InputDouble(const char* label, double* v, double step = 0.0, double step_fast = 0.0, const char* format = "%.6f", ImGuiInputTextFlags flags = 0);
    bool InputScalar(const char* label, ImGuiDataType data_type, void* p_data, const void* p_step = __null, const void* p_step_fast = __null, const char* format = __null, ImGuiInputTextFlags flags = 0);
    bool InputScalarN(const char* label, ImGuiDataType data_type, void* p_data, int components, const void* p_step = __null, const void* p_step_fast = __null, const char* format = __null, ImGuiInputTextFlags flags = 0);




    bool ColorEdit3(const char* label, float col[3], ImGuiColorEditFlags flags = 0);
    bool ColorEdit4(const char* label, float col[4], ImGuiColorEditFlags flags = 0);
    bool ColorPicker3(const char* label, float col[3], ImGuiColorEditFlags flags = 0);
    bool ColorPicker4(const char* label, float col[4], ImGuiColorEditFlags flags = 0, const float* ref_col = __null);
    bool ColorButton(const char* desc_id, const ImVec4& col, ImGuiColorEditFlags flags = 0, const ImVec2& size = ImVec2(0, 0));
    void SetColorEditOptions(ImGuiColorEditFlags flags);



    bool TreeNode(const char* label);
    bool TreeNode(const char* str_id, const char* fmt, ...) __attribute__((format(printf, 2, 2 +1)));
    bool TreeNode(const void* ptr_id, const char* fmt, ...) __attribute__((format(printf, 2, 2 +1)));
    bool TreeNodeV(const char* str_id, const char* fmt, va_list args) __attribute__((format(printf, 2, 0)));
    bool TreeNodeV(const void* ptr_id, const char* fmt, va_list args) __attribute__((format(printf, 2, 0)));
    bool TreeNodeEx(const char* label, ImGuiTreeNodeFlags flags = 0);
    bool TreeNodeEx(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, ...) __attribute__((format(printf, 3, 3 +1)));
    bool TreeNodeEx(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, ...) __attribute__((format(printf, 3, 3 +1)));
    bool TreeNodeExV(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args) __attribute__((format(printf, 3, 0)));
    bool TreeNodeExV(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args) __attribute__((format(printf, 3, 0)));
    void TreePush(const char* str_id);
    void TreePush(const void* ptr_id);
    void TreePop();
    float GetTreeNodeToLabelSpacing();
    bool CollapsingHeader(const char* label, ImGuiTreeNodeFlags flags = 0);
    bool CollapsingHeader(const char* label, bool* p_visible, ImGuiTreeNodeFlags flags = 0);
    void SetNextItemOpen(bool is_open, ImGuiCond cond = 0);
    void SetNextItemStorageID(ImGuiID storage_id);




    bool Selectable(const char* label, bool selected = false, ImGuiSelectableFlags flags = 0, const ImVec2& size = ImVec2(0, 0));
    bool Selectable(const char* label, bool* p_selected, ImGuiSelectableFlags flags = 0, const ImVec2& size = ImVec2(0, 0));
# 686 "/usr/include/imgui.h" 3 4
    ImGuiMultiSelectIO* BeginMultiSelect(ImGuiMultiSelectFlags flags, int selection_size = -1, int items_count = -1);
    ImGuiMultiSelectIO* EndMultiSelect();
    void SetNextItemSelectionUserData(ImGuiSelectionUserData selection_user_data);
    bool IsItemToggledSelection();







    bool BeginListBox(const char* label, const ImVec2& size = ImVec2(0, 0));
    void EndListBox();
    bool ListBox(const char* label, int* current_item, const char* const items[], int items_count, int height_in_items = -1);
    bool ListBox(const char* label, int* current_item, const char* (*getter)(void* user_data, int idx), void* user_data, int items_count, int height_in_items = -1);



    void PlotLines(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = __null, float scale_min = 3.40282346638528859811704183484516925e+38F, float scale_max = 3.40282346638528859811704183484516925e+38F, ImVec2 graph_size = ImVec2(0, 0), int stride = sizeof(float));
    void PlotLines(const char* label, float(*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = __null, float scale_min = 3.40282346638528859811704183484516925e+38F, float scale_max = 3.40282346638528859811704183484516925e+38F, ImVec2 graph_size = ImVec2(0, 0));
    void PlotHistogram(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = __null, float scale_min = 3.40282346638528859811704183484516925e+38F, float scale_max = 3.40282346638528859811704183484516925e+38F, ImVec2 graph_size = ImVec2(0, 0), int stride = sizeof(float));
    void PlotHistogram(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = __null, float scale_min = 3.40282346638528859811704183484516925e+38F, float scale_max = 3.40282346638528859811704183484516925e+38F, ImVec2 graph_size = ImVec2(0, 0));



    void Value(const char* prefix, bool b);
    void Value(const char* prefix, int v);
    void Value(const char* prefix, unsigned int v);
    void Value(const char* prefix, float v, const char* float_format = __null);






    bool BeginMenuBar();
    void EndMenuBar();
    bool BeginMainMenuBar();
    void EndMainMenuBar();
    bool BeginMenu(const char* label, bool enabled = true);
    void EndMenu();
    bool MenuItem(const char* label, const char* shortcut = __null, bool selected = false, bool enabled = true);
    bool MenuItem(const char* label, const char* shortcut, bool* p_selected, bool enabled = true);





    bool BeginTooltip();
    void EndTooltip();
    void SetTooltip(const char* fmt, ...) __attribute__((format(printf, 1, 1 +1)));
    void SetTooltipV(const char* fmt, va_list args) __attribute__((format(printf, 1, 0)));





    bool BeginItemTooltip();
    void SetItemTooltip(const char* fmt, ...) __attribute__((format(printf, 1, 1 +1)));
    void SetItemTooltipV(const char* fmt, va_list args) __attribute__((format(printf, 1, 0)));
# 757 "/usr/include/imgui.h" 3 4
    bool BeginPopup(const char* str_id, ImGuiWindowFlags flags = 0);
    bool BeginPopupModal(const char* name, bool* p_open = __null, ImGuiWindowFlags flags = 0);
    void EndPopup();
# 769 "/usr/include/imgui.h" 3 4
    void OpenPopup(const char* str_id, ImGuiPopupFlags popup_flags = 0);
    void OpenPopup(ImGuiID id, ImGuiPopupFlags popup_flags = 0);
    void OpenPopupOnItemClick(const char* str_id = __null, ImGuiPopupFlags popup_flags = 1);
    void CloseCurrentPopup();






    bool BeginPopupContextItem(const char* str_id = __null, ImGuiPopupFlags popup_flags = 1);
    bool BeginPopupContextWindow(const char* str_id = __null, ImGuiPopupFlags popup_flags = 1);
    bool BeginPopupContextVoid(const char* str_id = __null, ImGuiPopupFlags popup_flags = 1);





    bool IsPopupOpen(const char* str_id, ImGuiPopupFlags flags = 0);
# 810 "/usr/include/imgui.h" 3 4
    bool BeginTable(const char* str_id, int columns, ImGuiTableFlags flags = 0, const ImVec2& outer_size = ImVec2(0.0f, 0.0f), float inner_width = 0.0f);
    void EndTable();
    void TableNextRow(ImGuiTableRowFlags row_flags = 0, float min_row_height = 0.0f);
    bool TableNextColumn();
    bool TableSetColumnIndex(int column_n);
# 824 "/usr/include/imgui.h" 3 4
    void TableSetupColumn(const char* label, ImGuiTableColumnFlags flags = 0, float init_width_or_weight = 0.0f, ImGuiID user_id = 0);
    void TableSetupScrollFreeze(int cols, int rows);
    void TableHeader(const char* label);
    void TableHeadersRow();
    void TableAngledHeadersRow();







    ImGuiTableSortSpecs* TableGetSortSpecs();
    int TableGetColumnCount();
    int TableGetColumnIndex();
    int TableGetRowIndex();
    const char* TableGetColumnName(int column_n = -1);
    ImGuiTableColumnFlags TableGetColumnFlags(int column_n = -1);
    void TableSetColumnEnabled(int column_n, bool v);
    int TableGetHoveredColumn();
    void TableSetBgColor(ImGuiTableBgTarget target, ImU32 color, int column_n = -1);



    void Columns(int count = 1, const char* id = __null, bool borders = true);
    void NextColumn();
    int GetColumnIndex();
    float GetColumnWidth(int column_index = -1);
    void SetColumnWidth(int column_index, float width);
    float GetColumnOffset(int column_index = -1);
    void SetColumnOffset(int column_index, float offset_x);
    int GetColumnsCount();



    bool BeginTabBar(const char* str_id, ImGuiTabBarFlags flags = 0);
    void EndTabBar();
    bool BeginTabItem(const char* label, bool* p_open = __null, ImGuiTabItemFlags flags = 0);
    void EndTabItem();
    bool TabItemButton(const char* label, ImGuiTabItemFlags flags = 0);
    void SetTabItemClosed(const char* tab_or_docked_window_label);



    void LogToTTY(int auto_open_depth = -1);
    void LogToFile(int auto_open_depth = -1, const char* filename = __null);
    void LogToClipboard(int auto_open_depth = -1);
    void LogFinish();
    void LogButtons();
    void LogText(const char* fmt, ...) __attribute__((format(printf, 1, 1 +1)));
    void LogTextV(const char* fmt, va_list args) __attribute__((format(printf, 1, 0)));






    bool BeginDragDropSource(ImGuiDragDropFlags flags = 0);
    bool SetDragDropPayload(const char* type, const void* data, size_t sz, ImGuiCond cond = 0);
    void EndDragDropSource();
    bool BeginDragDropTarget();
    const ImGuiPayload* AcceptDragDropPayload(const char* type, ImGuiDragDropFlags flags = 0);
    void EndDragDropTarget();
    const ImGuiPayload* GetDragDropPayload();






    void BeginDisabled(bool disabled = true);
    void EndDisabled();



    void PushClipRect(const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_current_clip_rect);
    void PopClipRect();


    void SetItemDefaultFocus();
    void SetKeyboardFocusHere(int offset = 0);


    void SetNavCursorVisible(bool visible);


    void SetNextItemAllowOverlap();




    bool IsItemHovered(ImGuiHoveredFlags flags = 0);
    bool IsItemActive();
    bool IsItemFocused();
    bool IsItemClicked(ImGuiMouseButton mouse_button = 0);
    bool IsItemVisible();
    bool IsItemEdited();
    bool IsItemActivated();
    bool IsItemDeactivated();
    bool IsItemDeactivatedAfterEdit();
    bool IsItemToggledOpen();
    bool IsAnyItemHovered();
    bool IsAnyItemActive();
    bool IsAnyItemFocused();
    ImGuiID GetItemID();
    ImVec2 GetItemRectMin();
    ImVec2 GetItemRectMax();
    ImVec2 GetItemRectSize();





    ImGuiViewport* GetMainViewport();


    ImDrawList* GetBackgroundDrawList();
    ImDrawList* GetForegroundDrawList();


    bool IsRectVisible(const ImVec2& size);
    bool IsRectVisible(const ImVec2& rect_min, const ImVec2& rect_max);
    double GetTime();
    int GetFrameCount();
    ImDrawListSharedData* GetDrawListSharedData();
    const char* GetStyleColorName(ImGuiCol idx);
    void SetStateStorage(ImGuiStorage* storage);
    ImGuiStorage* GetStateStorage();


    ImVec2 CalcTextSize(const char* text, const char* text_end = __null, bool hide_text_after_double_hash = false, float wrap_width = -1.0f);


    ImVec4 ColorConvertU32ToFloat4(ImU32 in);
    ImU32 ColorConvertFloat4ToU32(const ImVec4& in);
    void ColorConvertRGBtoHSV(float r, float g, float b, float& out_h, float& out_s, float& out_v);
    void ColorConvertHSVtoRGB(float h, float s, float v, float& out_r, float& out_g, float& out_b);






    bool IsKeyDown(ImGuiKey key);
    bool IsKeyPressed(ImGuiKey key, bool repeat = true);
    bool IsKeyReleased(ImGuiKey key);
    bool IsKeyChordPressed(ImGuiKeyChord key_chord);
    int GetKeyPressedAmount(ImGuiKey key, float repeat_delay, float rate);
    const char* GetKeyName(ImGuiKey key);
    void SetNextFrameWantCaptureKeyboard(bool want_capture_keyboard);
# 990 "/usr/include/imgui.h" 3 4
    bool Shortcut(ImGuiKeyChord key_chord, ImGuiInputFlags flags = 0);
    void SetNextItemShortcut(ImGuiKeyChord key_chord, ImGuiInputFlags flags = 0);







    void SetItemKeyOwner(ImGuiKey key);





    bool IsMouseDown(ImGuiMouseButton button);
    bool IsMouseClicked(ImGuiMouseButton button, bool repeat = false);
    bool IsMouseReleased(ImGuiMouseButton button);
    bool IsMouseDoubleClicked(ImGuiMouseButton button);
    int GetMouseClickedCount(ImGuiMouseButton button);
    bool IsMouseHoveringRect(const ImVec2& r_min, const ImVec2& r_max, bool clip = true);
    bool IsMousePosValid(const ImVec2* mouse_pos = __null);
    bool IsAnyMouseDown();
    ImVec2 GetMousePos();
    ImVec2 GetMousePosOnOpeningCurrentPopup();
    bool IsMouseDragging(ImGuiMouseButton button, float lock_threshold = -1.0f);
    ImVec2 GetMouseDragDelta(ImGuiMouseButton button = 0, float lock_threshold = -1.0f);
    void ResetMouseDragDelta(ImGuiMouseButton button = 0);
    ImGuiMouseCursor GetMouseCursor();
    void SetMouseCursor(ImGuiMouseCursor cursor_type);
    void SetNextFrameWantCaptureMouse(bool want_capture_mouse);



    const char* GetClipboardText();
    void SetClipboardText(const char* text);





    void LoadIniSettingsFromDisk(const char* ini_filename);
    void LoadIniSettingsFromMemory(const char* ini_data, size_t ini_size=0);
    void SaveIniSettingsToDisk(const char* ini_filename);
    const char* SaveIniSettingsToMemory(size_t* out_ini_size = __null);



    void DebugTextEncoding(const char* text);
    void DebugFlashStyleColor(ImGuiCol idx);
    void DebugStartItemPicker();
    bool DebugCheckVersionAndDataLayout(const char* version_str, size_t sz_io, size_t sz_style, size_t sz_vec2, size_t sz_vec4, size_t sz_drawvert, size_t sz_drawidx);

    void DebugLog(const char* fmt, ...) __attribute__((format(printf, 1, 1 +1)));
    void DebugLogV(const char* fmt, va_list args) __attribute__((format(printf, 1, 0)));






    void SetAllocatorFunctions(ImGuiMemAllocFunc alloc_func, ImGuiMemFreeFunc free_func, void* user_data = __null);
    void GetAllocatorFunctions(ImGuiMemAllocFunc* p_alloc_func, ImGuiMemFreeFunc* p_free_func, void** p_user_data);
    void* MemAlloc(size_t size);
    void MemFree(void* ptr);

}







enum ImGuiWindowFlags_
{
    ImGuiWindowFlags_None = 0,
    ImGuiWindowFlags_NoTitleBar = 1 << 0,
    ImGuiWindowFlags_NoResize = 1 << 1,
    ImGuiWindowFlags_NoMove = 1 << 2,
    ImGuiWindowFlags_NoScrollbar = 1 << 3,
    ImGuiWindowFlags_NoScrollWithMouse = 1 << 4,
    ImGuiWindowFlags_NoCollapse = 1 << 5,
    ImGuiWindowFlags_AlwaysAutoResize = 1 << 6,
    ImGuiWindowFlags_NoBackground = 1 << 7,
    ImGuiWindowFlags_NoSavedSettings = 1 << 8,
    ImGuiWindowFlags_NoMouseInputs = 1 << 9,
    ImGuiWindowFlags_MenuBar = 1 << 10,
    ImGuiWindowFlags_HorizontalScrollbar = 1 << 11,
    ImGuiWindowFlags_NoFocusOnAppearing = 1 << 12,
    ImGuiWindowFlags_NoBringToFrontOnFocus = 1 << 13,
    ImGuiWindowFlags_AlwaysVerticalScrollbar= 1 << 14,
    ImGuiWindowFlags_AlwaysHorizontalScrollbar=1<< 15,
    ImGuiWindowFlags_NoNavInputs = 1 << 16,
    ImGuiWindowFlags_NoNavFocus = 1 << 17,
    ImGuiWindowFlags_UnsavedDocument = 1 << 18,
    ImGuiWindowFlags_NoNav = ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoNavFocus,
    ImGuiWindowFlags_NoDecoration = ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoCollapse,
    ImGuiWindowFlags_NoInputs = ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoNavFocus,


    ImGuiWindowFlags_ChildWindow = 1 << 24,
    ImGuiWindowFlags_Tooltip = 1 << 25,
    ImGuiWindowFlags_Popup = 1 << 26,
    ImGuiWindowFlags_Modal = 1 << 27,
    ImGuiWindowFlags_ChildMenu = 1 << 28,



    ImGuiWindowFlags_AlwaysUseWindowPadding = 1 << 30,
    ImGuiWindowFlags_NavFlattened = 1 << 31,

};
# 1113 "/usr/include/imgui.h" 3 4
enum ImGuiChildFlags_
{
    ImGuiChildFlags_None = 0,
    ImGuiChildFlags_Borders = 1 << 0,
    ImGuiChildFlags_AlwaysUseWindowPadding = 1 << 1,
    ImGuiChildFlags_ResizeX = 1 << 2,
    ImGuiChildFlags_ResizeY = 1 << 3,
    ImGuiChildFlags_AutoResizeX = 1 << 4,
    ImGuiChildFlags_AutoResizeY = 1 << 5,
    ImGuiChildFlags_AlwaysAutoResize = 1 << 6,
    ImGuiChildFlags_FrameStyle = 1 << 7,
    ImGuiChildFlags_NavFlattened = 1 << 8,



    ImGuiChildFlags_Border = ImGuiChildFlags_Borders,

};



enum ImGuiItemFlags_
{
    ImGuiItemFlags_None = 0,
    ImGuiItemFlags_NoTabStop = 1 << 0,
    ImGuiItemFlags_NoNav = 1 << 1,
    ImGuiItemFlags_NoNavDefaultFocus = 1 << 2,
    ImGuiItemFlags_ButtonRepeat = 1 << 3,
    ImGuiItemFlags_AutoClosePopups = 1 << 4,
    ImGuiItemFlags_AllowDuplicateId = 1 << 5,
};



enum ImGuiInputTextFlags_
{

    ImGuiInputTextFlags_None = 0,
    ImGuiInputTextFlags_CharsDecimal = 1 << 0,
    ImGuiInputTextFlags_CharsHexadecimal = 1 << 1,
    ImGuiInputTextFlags_CharsScientific = 1 << 2,
    ImGuiInputTextFlags_CharsUppercase = 1 << 3,
    ImGuiInputTextFlags_CharsNoBlank = 1 << 4,


    ImGuiInputTextFlags_AllowTabInput = 1 << 5,
    ImGuiInputTextFlags_EnterReturnsTrue = 1 << 6,
    ImGuiInputTextFlags_EscapeClearsAll = 1 << 7,
    ImGuiInputTextFlags_CtrlEnterForNewLine = 1 << 8,


    ImGuiInputTextFlags_ReadOnly = 1 << 9,
    ImGuiInputTextFlags_Password = 1 << 10,
    ImGuiInputTextFlags_AlwaysOverwrite = 1 << 11,
    ImGuiInputTextFlags_AutoSelectAll = 1 << 12,
    ImGuiInputTextFlags_ParseEmptyRefVal = 1 << 13,
    ImGuiInputTextFlags_DisplayEmptyRefVal = 1 << 14,
    ImGuiInputTextFlags_NoHorizontalScroll = 1 << 15,
    ImGuiInputTextFlags_NoUndoRedo = 1 << 16,


    ImGuiInputTextFlags_CallbackCompletion = 1 << 17,
    ImGuiInputTextFlags_CallbackHistory = 1 << 18,
    ImGuiInputTextFlags_CallbackAlways = 1 << 19,
    ImGuiInputTextFlags_CallbackCharFilter = 1 << 20,
    ImGuiInputTextFlags_CallbackResize = 1 << 21,
    ImGuiInputTextFlags_CallbackEdit = 1 << 22,



};


enum ImGuiTreeNodeFlags_
{
    ImGuiTreeNodeFlags_None = 0,
    ImGuiTreeNodeFlags_Selected = 1 << 0,
    ImGuiTreeNodeFlags_Framed = 1 << 1,
    ImGuiTreeNodeFlags_AllowOverlap = 1 << 2,
    ImGuiTreeNodeFlags_NoTreePushOnOpen = 1 << 3,
    ImGuiTreeNodeFlags_NoAutoOpenOnLog = 1 << 4,
    ImGuiTreeNodeFlags_DefaultOpen = 1 << 5,
    ImGuiTreeNodeFlags_OpenOnDoubleClick = 1 << 6,
    ImGuiTreeNodeFlags_OpenOnArrow = 1 << 7,
    ImGuiTreeNodeFlags_Leaf = 1 << 8,
    ImGuiTreeNodeFlags_Bullet = 1 << 9,
    ImGuiTreeNodeFlags_FramePadding = 1 << 10,
    ImGuiTreeNodeFlags_SpanAvailWidth = 1 << 11,
    ImGuiTreeNodeFlags_SpanFullWidth = 1 << 12,
    ImGuiTreeNodeFlags_SpanTextWidth = 1 << 13,
    ImGuiTreeNodeFlags_SpanAllColumns = 1 << 14,
    ImGuiTreeNodeFlags_NavLeftJumpsBackHere = 1 << 15,

    ImGuiTreeNodeFlags_CollapsingHeader = ImGuiTreeNodeFlags_Framed | ImGuiTreeNodeFlags_NoTreePushOnOpen | ImGuiTreeNodeFlags_NoAutoOpenOnLog,


    ImGuiTreeNodeFlags_AllowItemOverlap = ImGuiTreeNodeFlags_AllowOverlap,

};
# 1221 "/usr/include/imgui.h" 3 4
enum ImGuiPopupFlags_
{
    ImGuiPopupFlags_None = 0,
    ImGuiPopupFlags_MouseButtonLeft = 0,
    ImGuiPopupFlags_MouseButtonRight = 1,
    ImGuiPopupFlags_MouseButtonMiddle = 2,
    ImGuiPopupFlags_MouseButtonMask_ = 0x1F,
    ImGuiPopupFlags_MouseButtonDefault_ = 1,
    ImGuiPopupFlags_NoReopen = 1 << 5,

    ImGuiPopupFlags_NoOpenOverExistingPopup = 1 << 7,
    ImGuiPopupFlags_NoOpenOverItems = 1 << 8,
    ImGuiPopupFlags_AnyPopupId = 1 << 10,
    ImGuiPopupFlags_AnyPopupLevel = 1 << 11,
    ImGuiPopupFlags_AnyPopup = ImGuiPopupFlags_AnyPopupId | ImGuiPopupFlags_AnyPopupLevel,
};


enum ImGuiSelectableFlags_
{
    ImGuiSelectableFlags_None = 0,
    ImGuiSelectableFlags_NoAutoClosePopups = 1 << 0,
    ImGuiSelectableFlags_SpanAllColumns = 1 << 1,
    ImGuiSelectableFlags_AllowDoubleClick = 1 << 2,
    ImGuiSelectableFlags_Disabled = 1 << 3,
    ImGuiSelectableFlags_AllowOverlap = 1 << 4,
    ImGuiSelectableFlags_Highlight = 1 << 5,


    ImGuiSelectableFlags_DontClosePopups = ImGuiSelectableFlags_NoAutoClosePopups,
    ImGuiSelectableFlags_AllowItemOverlap = ImGuiSelectableFlags_AllowOverlap,

};


enum ImGuiComboFlags_
{
    ImGuiComboFlags_None = 0,
    ImGuiComboFlags_PopupAlignLeft = 1 << 0,
    ImGuiComboFlags_HeightSmall = 1 << 1,
    ImGuiComboFlags_HeightRegular = 1 << 2,
    ImGuiComboFlags_HeightLarge = 1 << 3,
    ImGuiComboFlags_HeightLargest = 1 << 4,
    ImGuiComboFlags_NoArrowButton = 1 << 5,
    ImGuiComboFlags_NoPreview = 1 << 6,
    ImGuiComboFlags_WidthFitPreview = 1 << 7,
    ImGuiComboFlags_HeightMask_ = ImGuiComboFlags_HeightSmall | ImGuiComboFlags_HeightRegular | ImGuiComboFlags_HeightLarge | ImGuiComboFlags_HeightLargest,
};


enum ImGuiTabBarFlags_
{
    ImGuiTabBarFlags_None = 0,
    ImGuiTabBarFlags_Reorderable = 1 << 0,
    ImGuiTabBarFlags_AutoSelectNewTabs = 1 << 1,
    ImGuiTabBarFlags_TabListPopupButton = 1 << 2,
    ImGuiTabBarFlags_NoCloseWithMiddleMouseButton = 1 << 3,
    ImGuiTabBarFlags_NoTabListScrollingButtons = 1 << 4,
    ImGuiTabBarFlags_NoTooltip = 1 << 5,
    ImGuiTabBarFlags_DrawSelectedOverline = 1 << 6,
    ImGuiTabBarFlags_FittingPolicyResizeDown = 1 << 7,
    ImGuiTabBarFlags_FittingPolicyScroll = 1 << 8,
    ImGuiTabBarFlags_FittingPolicyMask_ = ImGuiTabBarFlags_FittingPolicyResizeDown | ImGuiTabBarFlags_FittingPolicyScroll,
    ImGuiTabBarFlags_FittingPolicyDefault_ = ImGuiTabBarFlags_FittingPolicyResizeDown,
};


enum ImGuiTabItemFlags_
{
    ImGuiTabItemFlags_None = 0,
    ImGuiTabItemFlags_UnsavedDocument = 1 << 0,
    ImGuiTabItemFlags_SetSelected = 1 << 1,
    ImGuiTabItemFlags_NoCloseWithMiddleMouseButton = 1 << 2,
    ImGuiTabItemFlags_NoPushId = 1 << 3,
    ImGuiTabItemFlags_NoTooltip = 1 << 4,
    ImGuiTabItemFlags_NoReorder = 1 << 5,
    ImGuiTabItemFlags_Leading = 1 << 6,
    ImGuiTabItemFlags_Trailing = 1 << 7,
    ImGuiTabItemFlags_NoAssumedClosure = 1 << 8,
};


enum ImGuiFocusedFlags_
{
    ImGuiFocusedFlags_None = 0,
    ImGuiFocusedFlags_ChildWindows = 1 << 0,
    ImGuiFocusedFlags_RootWindow = 1 << 1,
    ImGuiFocusedFlags_AnyWindow = 1 << 2,
    ImGuiFocusedFlags_NoPopupHierarchy = 1 << 3,

    ImGuiFocusedFlags_RootAndChildWindows = ImGuiFocusedFlags_RootWindow | ImGuiFocusedFlags_ChildWindows,
};




enum ImGuiHoveredFlags_
{
    ImGuiHoveredFlags_None = 0,
    ImGuiHoveredFlags_ChildWindows = 1 << 0,
    ImGuiHoveredFlags_RootWindow = 1 << 1,
    ImGuiHoveredFlags_AnyWindow = 1 << 2,
    ImGuiHoveredFlags_NoPopupHierarchy = 1 << 3,

    ImGuiHoveredFlags_AllowWhenBlockedByPopup = 1 << 5,

    ImGuiHoveredFlags_AllowWhenBlockedByActiveItem = 1 << 7,
    ImGuiHoveredFlags_AllowWhenOverlappedByItem = 1 << 8,
    ImGuiHoveredFlags_AllowWhenOverlappedByWindow = 1 << 9,
    ImGuiHoveredFlags_AllowWhenDisabled = 1 << 10,
    ImGuiHoveredFlags_NoNavOverride = 1 << 11,
    ImGuiHoveredFlags_AllowWhenOverlapped = ImGuiHoveredFlags_AllowWhenOverlappedByItem | ImGuiHoveredFlags_AllowWhenOverlappedByWindow,
    ImGuiHoveredFlags_RectOnly = ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_AllowWhenBlockedByActiveItem | ImGuiHoveredFlags_AllowWhenOverlapped,
    ImGuiHoveredFlags_RootAndChildWindows = ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows,







    ImGuiHoveredFlags_ForTooltip = 1 << 12,




    ImGuiHoveredFlags_Stationary = 1 << 13,
    ImGuiHoveredFlags_DelayNone = 1 << 14,
    ImGuiHoveredFlags_DelayShort = 1 << 15,
    ImGuiHoveredFlags_DelayNormal = 1 << 16,
    ImGuiHoveredFlags_NoSharedDelay = 1 << 17,
};


enum ImGuiDragDropFlags_
{
    ImGuiDragDropFlags_None = 0,

    ImGuiDragDropFlags_SourceNoPreviewTooltip = 1 << 0,
    ImGuiDragDropFlags_SourceNoDisableHover = 1 << 1,
    ImGuiDragDropFlags_SourceNoHoldToOpenOthers = 1 << 2,
    ImGuiDragDropFlags_SourceAllowNullID = 1 << 3,
    ImGuiDragDropFlags_SourceExtern = 1 << 4,
    ImGuiDragDropFlags_PayloadAutoExpire = 1 << 5,
    ImGuiDragDropFlags_PayloadNoCrossContext = 1 << 6,
    ImGuiDragDropFlags_PayloadNoCrossProcess = 1 << 7,

    ImGuiDragDropFlags_AcceptBeforeDelivery = 1 << 10,
    ImGuiDragDropFlags_AcceptNoDrawDefaultRect = 1 << 11,
    ImGuiDragDropFlags_AcceptNoPreviewTooltip = 1 << 12,
    ImGuiDragDropFlags_AcceptPeekOnly = ImGuiDragDropFlags_AcceptBeforeDelivery | ImGuiDragDropFlags_AcceptNoDrawDefaultRect,


    ImGuiDragDropFlags_SourceAutoExpirePayload = ImGuiDragDropFlags_PayloadAutoExpire,

};






enum ImGuiDataType_
{
    ImGuiDataType_S8,
    ImGuiDataType_U8,
    ImGuiDataType_S16,
    ImGuiDataType_U16,
    ImGuiDataType_S32,
    ImGuiDataType_U32,
    ImGuiDataType_S64,
    ImGuiDataType_U64,
    ImGuiDataType_Float,
    ImGuiDataType_Double,
    ImGuiDataType_Bool,
    ImGuiDataType_COUNT
};


enum ImGuiDir : int
{
    ImGuiDir_None = -1,
    ImGuiDir_Left = 0,
    ImGuiDir_Right = 1,
    ImGuiDir_Up = 2,
    ImGuiDir_Down = 3,
    ImGuiDir_COUNT
};


enum ImGuiSortDirection : ImU8
{
    ImGuiSortDirection_None = 0,
    ImGuiSortDirection_Ascending = 1,
    ImGuiSortDirection_Descending = 2
};
# 1429 "/usr/include/imgui.h" 3 4
enum ImGuiKey : int
{

    ImGuiKey_None = 0,
    ImGuiKey_Tab = 512,
    ImGuiKey_LeftArrow,
    ImGuiKey_RightArrow,
    ImGuiKey_UpArrow,
    ImGuiKey_DownArrow,
    ImGuiKey_PageUp,
    ImGuiKey_PageDown,
    ImGuiKey_Home,
    ImGuiKey_End,
    ImGuiKey_Insert,
    ImGuiKey_Delete,
    ImGuiKey_Backspace,
    ImGuiKey_Space,
    ImGuiKey_Enter,
    ImGuiKey_Escape,
    ImGuiKey_LeftCtrl, ImGuiKey_LeftShift, ImGuiKey_LeftAlt, ImGuiKey_LeftSuper,
    ImGuiKey_RightCtrl, ImGuiKey_RightShift, ImGuiKey_RightAlt, ImGuiKey_RightSuper,
    ImGuiKey_Menu,
    ImGuiKey_0, ImGuiKey_1, ImGuiKey_2, ImGuiKey_3, ImGuiKey_4, ImGuiKey_5, ImGuiKey_6, ImGuiKey_7, ImGuiKey_8, ImGuiKey_9,
    ImGuiKey_A, ImGuiKey_B, ImGuiKey_C, ImGuiKey_D, ImGuiKey_E, ImGuiKey_F, ImGuiKey_G, ImGuiKey_H, ImGuiKey_I, ImGuiKey_J,
    ImGuiKey_K, ImGuiKey_L, ImGuiKey_M, ImGuiKey_N, ImGuiKey_O, ImGuiKey_P, ImGuiKey_Q, ImGuiKey_R, ImGuiKey_S, ImGuiKey_T,
    ImGuiKey_U, ImGuiKey_V, ImGuiKey_W, ImGuiKey_X, ImGuiKey_Y, ImGuiKey_Z,
    ImGuiKey_F1, ImGuiKey_F2, ImGuiKey_F3, ImGuiKey_F4, ImGuiKey_F5, ImGuiKey_F6,
    ImGuiKey_F7, ImGuiKey_F8, ImGuiKey_F9, ImGuiKey_F10, ImGuiKey_F11, ImGuiKey_F12,
    ImGuiKey_F13, ImGuiKey_F14, ImGuiKey_F15, ImGuiKey_F16, ImGuiKey_F17, ImGuiKey_F18,
    ImGuiKey_F19, ImGuiKey_F20, ImGuiKey_F21, ImGuiKey_F22, ImGuiKey_F23, ImGuiKey_F24,
    ImGuiKey_Apostrophe,
    ImGuiKey_Comma,
    ImGuiKey_Minus,
    ImGuiKey_Period,
    ImGuiKey_Slash,
    ImGuiKey_Semicolon,
    ImGuiKey_Equal,
    ImGuiKey_LeftBracket,
    ImGuiKey_Backslash,
    ImGuiKey_RightBracket,
    ImGuiKey_GraveAccent,
    ImGuiKey_CapsLock,
    ImGuiKey_ScrollLock,
    ImGuiKey_NumLock,
    ImGuiKey_PrintScreen,
    ImGuiKey_Pause,
    ImGuiKey_Keypad0, ImGuiKey_Keypad1, ImGuiKey_Keypad2, ImGuiKey_Keypad3, ImGuiKey_Keypad4,
    ImGuiKey_Keypad5, ImGuiKey_Keypad6, ImGuiKey_Keypad7, ImGuiKey_Keypad8, ImGuiKey_Keypad9,
    ImGuiKey_KeypadDecimal,
    ImGuiKey_KeypadDivide,
    ImGuiKey_KeypadMultiply,
    ImGuiKey_KeypadSubtract,
    ImGuiKey_KeypadAdd,
    ImGuiKey_KeypadEnter,
    ImGuiKey_KeypadEqual,
    ImGuiKey_AppBack,
    ImGuiKey_AppForward,



    ImGuiKey_GamepadStart,
    ImGuiKey_GamepadBack,
    ImGuiKey_GamepadFaceLeft,
    ImGuiKey_GamepadFaceRight,
    ImGuiKey_GamepadFaceUp,
    ImGuiKey_GamepadFaceDown,
    ImGuiKey_GamepadDpadLeft,
    ImGuiKey_GamepadDpadRight,
    ImGuiKey_GamepadDpadUp,
    ImGuiKey_GamepadDpadDown,
    ImGuiKey_GamepadL1,
    ImGuiKey_GamepadR1,
    ImGuiKey_GamepadL2,
    ImGuiKey_GamepadR2,
    ImGuiKey_GamepadL3,
    ImGuiKey_GamepadR3,
    ImGuiKey_GamepadLStickLeft,
    ImGuiKey_GamepadLStickRight,
    ImGuiKey_GamepadLStickUp,
    ImGuiKey_GamepadLStickDown,
    ImGuiKey_GamepadRStickLeft,
    ImGuiKey_GamepadRStickRight,
    ImGuiKey_GamepadRStickUp,
    ImGuiKey_GamepadRStickDown,



    ImGuiKey_MouseLeft, ImGuiKey_MouseRight, ImGuiKey_MouseMiddle, ImGuiKey_MouseX1, ImGuiKey_MouseX2, ImGuiKey_MouseWheelX, ImGuiKey_MouseWheelY,


    ImGuiKey_ReservedForModCtrl, ImGuiKey_ReservedForModShift, ImGuiKey_ReservedForModAlt, ImGuiKey_ReservedForModSuper,
    ImGuiKey_COUNT,
# 1531 "/usr/include/imgui.h" 3 4
    ImGuiMod_None = 0,
    ImGuiMod_Ctrl = 1 << 12,
    ImGuiMod_Shift = 1 << 13,
    ImGuiMod_Alt = 1 << 14,
    ImGuiMod_Super = 1 << 15,
    ImGuiMod_Mask_ = 0xF000,




    ImGuiKey_NamedKey_BEGIN = 512,
    ImGuiKey_NamedKey_END = ImGuiKey_COUNT,
    ImGuiKey_NamedKey_COUNT = ImGuiKey_NamedKey_END - ImGuiKey_NamedKey_BEGIN,




    ImGuiKey_KeysData_SIZE = ImGuiKey_COUNT,
    ImGuiKey_KeysData_OFFSET = 0,



    ImGuiMod_Shortcut = ImGuiMod_Ctrl,
    ImGuiKey_ModCtrl = ImGuiMod_Ctrl, ImGuiKey_ModShift = ImGuiMod_Shift, ImGuiKey_ModAlt = ImGuiMod_Alt, ImGuiKey_ModSuper = ImGuiMod_Super,


};




enum ImGuiInputFlags_
{
    ImGuiInputFlags_None = 0,
    ImGuiInputFlags_Repeat = 1 << 0,




    ImGuiInputFlags_RouteActive = 1 << 10,
    ImGuiInputFlags_RouteFocused = 1 << 11,
    ImGuiInputFlags_RouteGlobal = 1 << 12,
    ImGuiInputFlags_RouteAlways = 1 << 13,

    ImGuiInputFlags_RouteOverFocused = 1 << 14,
    ImGuiInputFlags_RouteOverActive = 1 << 15,
    ImGuiInputFlags_RouteUnlessBgFocused = 1 << 16,
    ImGuiInputFlags_RouteFromRootWindow = 1 << 17,


    ImGuiInputFlags_Tooltip = 1 << 18,
};





enum ImGuiNavInput
{
    ImGuiNavInput_Activate, ImGuiNavInput_Cancel, ImGuiNavInput_Input, ImGuiNavInput_Menu, ImGuiNavInput_DpadLeft, ImGuiNavInput_DpadRight, ImGuiNavInput_DpadUp, ImGuiNavInput_DpadDown,
    ImGuiNavInput_LStickLeft, ImGuiNavInput_LStickRight, ImGuiNavInput_LStickUp, ImGuiNavInput_LStickDown, ImGuiNavInput_FocusPrev, ImGuiNavInput_FocusNext, ImGuiNavInput_TweakSlow, ImGuiNavInput_TweakFast,
    ImGuiNavInput_COUNT,
};



enum ImGuiConfigFlags_
{
    ImGuiConfigFlags_None = 0,
    ImGuiConfigFlags_NavEnableKeyboard = 1 << 0,
    ImGuiConfigFlags_NavEnableGamepad = 1 << 1,
    ImGuiConfigFlags_NoMouse = 1 << 4,
    ImGuiConfigFlags_NoMouseCursorChange = 1 << 5,
    ImGuiConfigFlags_NoKeyboard = 1 << 6,


    ImGuiConfigFlags_IsSRGB = 1 << 20,
    ImGuiConfigFlags_IsTouchScreen = 1 << 21,


    ImGuiConfigFlags_NavEnableSetMousePos = 1 << 2,
    ImGuiConfigFlags_NavNoCaptureKeyboard = 1 << 3,

};


enum ImGuiBackendFlags_
{
    ImGuiBackendFlags_None = 0,
    ImGuiBackendFlags_HasGamepad = 1 << 0,
    ImGuiBackendFlags_HasMouseCursors = 1 << 1,
    ImGuiBackendFlags_HasSetMousePos = 1 << 2,
    ImGuiBackendFlags_RendererHasVtxOffset = 1 << 3,
};


enum ImGuiCol_
{
    ImGuiCol_Text,
    ImGuiCol_TextDisabled,
    ImGuiCol_WindowBg,
    ImGuiCol_ChildBg,
    ImGuiCol_PopupBg,
    ImGuiCol_Border,
    ImGuiCol_BorderShadow,
    ImGuiCol_FrameBg,
    ImGuiCol_FrameBgHovered,
    ImGuiCol_FrameBgActive,
    ImGuiCol_TitleBg,
    ImGuiCol_TitleBgActive,
    ImGuiCol_TitleBgCollapsed,
    ImGuiCol_MenuBarBg,
    ImGuiCol_ScrollbarBg,
    ImGuiCol_ScrollbarGrab,
    ImGuiCol_ScrollbarGrabHovered,
    ImGuiCol_ScrollbarGrabActive,
    ImGuiCol_CheckMark,
    ImGuiCol_SliderGrab,
    ImGuiCol_SliderGrabActive,
    ImGuiCol_Button,
    ImGuiCol_ButtonHovered,
    ImGuiCol_ButtonActive,
    ImGuiCol_Header,
    ImGuiCol_HeaderHovered,
    ImGuiCol_HeaderActive,
    ImGuiCol_Separator,
    ImGuiCol_SeparatorHovered,
    ImGuiCol_SeparatorActive,
    ImGuiCol_ResizeGrip,
    ImGuiCol_ResizeGripHovered,
    ImGuiCol_ResizeGripActive,
    ImGuiCol_TabHovered,
    ImGuiCol_Tab,
    ImGuiCol_TabSelected,
    ImGuiCol_TabSelectedOverline,
    ImGuiCol_TabDimmed,
    ImGuiCol_TabDimmedSelected,
    ImGuiCol_TabDimmedSelectedOverline,
    ImGuiCol_PlotLines,
    ImGuiCol_PlotLinesHovered,
    ImGuiCol_PlotHistogram,
    ImGuiCol_PlotHistogramHovered,
    ImGuiCol_TableHeaderBg,
    ImGuiCol_TableBorderStrong,
    ImGuiCol_TableBorderLight,
    ImGuiCol_TableRowBg,
    ImGuiCol_TableRowBgAlt,
    ImGuiCol_TextLink,
    ImGuiCol_TextSelectedBg,
    ImGuiCol_DragDropTarget,
    ImGuiCol_NavCursor,
    ImGuiCol_NavWindowingHighlight,
    ImGuiCol_NavWindowingDimBg,
    ImGuiCol_ModalWindowDimBg,
    ImGuiCol_COUNT,


    ImGuiCol_TabActive = ImGuiCol_TabSelected,
    ImGuiCol_TabUnfocused = ImGuiCol_TabDimmed,
    ImGuiCol_TabUnfocusedActive = ImGuiCol_TabDimmedSelected,
    ImGuiCol_NavHighlight = ImGuiCol_NavCursor,

};
# 1703 "/usr/include/imgui.h" 3 4
enum ImGuiStyleVar_
{

    ImGuiStyleVar_Alpha,
    ImGuiStyleVar_DisabledAlpha,
    ImGuiStyleVar_WindowPadding,
    ImGuiStyleVar_WindowRounding,
    ImGuiStyleVar_WindowBorderSize,
    ImGuiStyleVar_WindowMinSize,
    ImGuiStyleVar_WindowTitleAlign,
    ImGuiStyleVar_ChildRounding,
    ImGuiStyleVar_ChildBorderSize,
    ImGuiStyleVar_PopupRounding,
    ImGuiStyleVar_PopupBorderSize,
    ImGuiStyleVar_FramePadding,
    ImGuiStyleVar_FrameRounding,
    ImGuiStyleVar_FrameBorderSize,
    ImGuiStyleVar_ItemSpacing,
    ImGuiStyleVar_ItemInnerSpacing,
    ImGuiStyleVar_IndentSpacing,
    ImGuiStyleVar_CellPadding,
    ImGuiStyleVar_ScrollbarSize,
    ImGuiStyleVar_ScrollbarRounding,
    ImGuiStyleVar_GrabMinSize,
    ImGuiStyleVar_GrabRounding,
    ImGuiStyleVar_TabRounding,
    ImGuiStyleVar_TabBorderSize,
    ImGuiStyleVar_TabBarBorderSize,
    ImGuiStyleVar_TabBarOverlineSize,
    ImGuiStyleVar_TableAngledHeadersAngle,
    ImGuiStyleVar_TableAngledHeadersTextAlign,
    ImGuiStyleVar_ButtonTextAlign,
    ImGuiStyleVar_SelectableTextAlign,
    ImGuiStyleVar_SeparatorTextBorderSize,
    ImGuiStyleVar_SeparatorTextAlign,
    ImGuiStyleVar_SeparatorTextPadding,
    ImGuiStyleVar_COUNT
};


enum ImGuiButtonFlags_
{
    ImGuiButtonFlags_None = 0,
    ImGuiButtonFlags_MouseButtonLeft = 1 << 0,
    ImGuiButtonFlags_MouseButtonRight = 1 << 1,
    ImGuiButtonFlags_MouseButtonMiddle = 1 << 2,
    ImGuiButtonFlags_MouseButtonMask_ = ImGuiButtonFlags_MouseButtonLeft | ImGuiButtonFlags_MouseButtonRight | ImGuiButtonFlags_MouseButtonMiddle,
    ImGuiButtonFlags_EnableNav = 1 << 3,
};


enum ImGuiColorEditFlags_
{
    ImGuiColorEditFlags_None = 0,
    ImGuiColorEditFlags_NoAlpha = 1 << 1,
    ImGuiColorEditFlags_NoPicker = 1 << 2,
    ImGuiColorEditFlags_NoOptions = 1 << 3,
    ImGuiColorEditFlags_NoSmallPreview = 1 << 4,
    ImGuiColorEditFlags_NoInputs = 1 << 5,
    ImGuiColorEditFlags_NoTooltip = 1 << 6,
    ImGuiColorEditFlags_NoLabel = 1 << 7,
    ImGuiColorEditFlags_NoSidePreview = 1 << 8,
    ImGuiColorEditFlags_NoDragDrop = 1 << 9,
    ImGuiColorEditFlags_NoBorder = 1 << 10,


    ImGuiColorEditFlags_AlphaBar = 1 << 16,
    ImGuiColorEditFlags_AlphaPreview = 1 << 17,
    ImGuiColorEditFlags_AlphaPreviewHalf= 1 << 18,
    ImGuiColorEditFlags_HDR = 1 << 19,
    ImGuiColorEditFlags_DisplayRGB = 1 << 20,
    ImGuiColorEditFlags_DisplayHSV = 1 << 21,
    ImGuiColorEditFlags_DisplayHex = 1 << 22,
    ImGuiColorEditFlags_Uint8 = 1 << 23,
    ImGuiColorEditFlags_Float = 1 << 24,
    ImGuiColorEditFlags_PickerHueBar = 1 << 25,
    ImGuiColorEditFlags_PickerHueWheel = 1 << 26,
    ImGuiColorEditFlags_InputRGB = 1 << 27,
    ImGuiColorEditFlags_InputHSV = 1 << 28,



    ImGuiColorEditFlags_DefaultOptions_ = ImGuiColorEditFlags_Uint8 | ImGuiColorEditFlags_DisplayRGB | ImGuiColorEditFlags_InputRGB | ImGuiColorEditFlags_PickerHueBar,


    ImGuiColorEditFlags_DisplayMask_ = ImGuiColorEditFlags_DisplayRGB | ImGuiColorEditFlags_DisplayHSV | ImGuiColorEditFlags_DisplayHex,
    ImGuiColorEditFlags_DataTypeMask_ = ImGuiColorEditFlags_Uint8 | ImGuiColorEditFlags_Float,
    ImGuiColorEditFlags_PickerMask_ = ImGuiColorEditFlags_PickerHueWheel | ImGuiColorEditFlags_PickerHueBar,
    ImGuiColorEditFlags_InputMask_ = ImGuiColorEditFlags_InputRGB | ImGuiColorEditFlags_InputHSV,



};




enum ImGuiSliderFlags_
{
    ImGuiSliderFlags_None = 0,
    ImGuiSliderFlags_Logarithmic = 1 << 5,
    ImGuiSliderFlags_NoRoundToFormat = 1 << 6,
    ImGuiSliderFlags_NoInput = 1 << 7,
    ImGuiSliderFlags_WrapAround = 1 << 8,
    ImGuiSliderFlags_ClampOnInput = 1 << 9,
    ImGuiSliderFlags_ClampZeroRange = 1 << 10,
    ImGuiSliderFlags_AlwaysClamp = ImGuiSliderFlags_ClampOnInput | ImGuiSliderFlags_ClampZeroRange,
    ImGuiSliderFlags_InvalidMask_ = 0x7000000F,
};



enum ImGuiMouseButton_
{
    ImGuiMouseButton_Left = 0,
    ImGuiMouseButton_Right = 1,
    ImGuiMouseButton_Middle = 2,
    ImGuiMouseButton_COUNT = 5
};



enum ImGuiMouseCursor_
{
    ImGuiMouseCursor_None = -1,
    ImGuiMouseCursor_Arrow = 0,
    ImGuiMouseCursor_TextInput,
    ImGuiMouseCursor_ResizeAll,
    ImGuiMouseCursor_ResizeNS,
    ImGuiMouseCursor_ResizeEW,
    ImGuiMouseCursor_ResizeNESW,
    ImGuiMouseCursor_ResizeNWSE,
    ImGuiMouseCursor_Hand,
    ImGuiMouseCursor_NotAllowed,
    ImGuiMouseCursor_COUNT
};





enum ImGuiMouseSource : int
{
    ImGuiMouseSource_Mouse = 0,
    ImGuiMouseSource_TouchScreen,
    ImGuiMouseSource_Pen,
    ImGuiMouseSource_COUNT
};




enum ImGuiCond_
{
    ImGuiCond_None = 0,
    ImGuiCond_Always = 1 << 0,
    ImGuiCond_Once = 1 << 1,
    ImGuiCond_FirstUseEver = 1 << 2,
    ImGuiCond_Appearing = 1 << 3,
};
# 1890 "/usr/include/imgui.h" 3 4
enum ImGuiTableFlags_
{

    ImGuiTableFlags_None = 0,
    ImGuiTableFlags_Resizable = 1 << 0,
    ImGuiTableFlags_Reorderable = 1 << 1,
    ImGuiTableFlags_Hideable = 1 << 2,
    ImGuiTableFlags_Sortable = 1 << 3,
    ImGuiTableFlags_NoSavedSettings = 1 << 4,
    ImGuiTableFlags_ContextMenuInBody = 1 << 5,

    ImGuiTableFlags_RowBg = 1 << 6,
    ImGuiTableFlags_BordersInnerH = 1 << 7,
    ImGuiTableFlags_BordersOuterH = 1 << 8,
    ImGuiTableFlags_BordersInnerV = 1 << 9,
    ImGuiTableFlags_BordersOuterV = 1 << 10,
    ImGuiTableFlags_BordersH = ImGuiTableFlags_BordersInnerH | ImGuiTableFlags_BordersOuterH,
    ImGuiTableFlags_BordersV = ImGuiTableFlags_BordersInnerV | ImGuiTableFlags_BordersOuterV,
    ImGuiTableFlags_BordersInner = ImGuiTableFlags_BordersInnerV | ImGuiTableFlags_BordersInnerH,
    ImGuiTableFlags_BordersOuter = ImGuiTableFlags_BordersOuterV | ImGuiTableFlags_BordersOuterH,
    ImGuiTableFlags_Borders = ImGuiTableFlags_BordersInner | ImGuiTableFlags_BordersOuter,
    ImGuiTableFlags_NoBordersInBody = 1 << 11,
    ImGuiTableFlags_NoBordersInBodyUntilResize = 1 << 12,

    ImGuiTableFlags_SizingFixedFit = 1 << 13,
    ImGuiTableFlags_SizingFixedSame = 2 << 13,
    ImGuiTableFlags_SizingStretchProp = 3 << 13,
    ImGuiTableFlags_SizingStretchSame = 4 << 13,

    ImGuiTableFlags_NoHostExtendX = 1 << 16,
    ImGuiTableFlags_NoHostExtendY = 1 << 17,
    ImGuiTableFlags_NoKeepColumnsVisible = 1 << 18,
    ImGuiTableFlags_PreciseWidths = 1 << 19,

    ImGuiTableFlags_NoClip = 1 << 20,

    ImGuiTableFlags_PadOuterX = 1 << 21,
    ImGuiTableFlags_NoPadOuterX = 1 << 22,
    ImGuiTableFlags_NoPadInnerX = 1 << 23,

    ImGuiTableFlags_ScrollX = 1 << 24,
    ImGuiTableFlags_ScrollY = 1 << 25,

    ImGuiTableFlags_SortMulti = 1 << 26,
    ImGuiTableFlags_SortTristate = 1 << 27,

    ImGuiTableFlags_HighlightHoveredColumn = 1 << 28,


    ImGuiTableFlags_SizingMask_ = ImGuiTableFlags_SizingFixedFit | ImGuiTableFlags_SizingFixedSame | ImGuiTableFlags_SizingStretchProp | ImGuiTableFlags_SizingStretchSame,
};


enum ImGuiTableColumnFlags_
{

    ImGuiTableColumnFlags_None = 0,
    ImGuiTableColumnFlags_Disabled = 1 << 0,
    ImGuiTableColumnFlags_DefaultHide = 1 << 1,
    ImGuiTableColumnFlags_DefaultSort = 1 << 2,
    ImGuiTableColumnFlags_WidthStretch = 1 << 3,
    ImGuiTableColumnFlags_WidthFixed = 1 << 4,
    ImGuiTableColumnFlags_NoResize = 1 << 5,
    ImGuiTableColumnFlags_NoReorder = 1 << 6,
    ImGuiTableColumnFlags_NoHide = 1 << 7,
    ImGuiTableColumnFlags_NoClip = 1 << 8,
    ImGuiTableColumnFlags_NoSort = 1 << 9,
    ImGuiTableColumnFlags_NoSortAscending = 1 << 10,
    ImGuiTableColumnFlags_NoSortDescending = 1 << 11,
    ImGuiTableColumnFlags_NoHeaderLabel = 1 << 12,
    ImGuiTableColumnFlags_NoHeaderWidth = 1 << 13,
    ImGuiTableColumnFlags_PreferSortAscending = 1 << 14,
    ImGuiTableColumnFlags_PreferSortDescending = 1 << 15,
    ImGuiTableColumnFlags_IndentEnable = 1 << 16,
    ImGuiTableColumnFlags_IndentDisable = 1 << 17,
    ImGuiTableColumnFlags_AngledHeader = 1 << 18,


    ImGuiTableColumnFlags_IsEnabled = 1 << 24,
    ImGuiTableColumnFlags_IsVisible = 1 << 25,
    ImGuiTableColumnFlags_IsSorted = 1 << 26,
    ImGuiTableColumnFlags_IsHovered = 1 << 27,


    ImGuiTableColumnFlags_WidthMask_ = ImGuiTableColumnFlags_WidthStretch | ImGuiTableColumnFlags_WidthFixed,
    ImGuiTableColumnFlags_IndentMask_ = ImGuiTableColumnFlags_IndentEnable | ImGuiTableColumnFlags_IndentDisable,
    ImGuiTableColumnFlags_StatusMask_ = ImGuiTableColumnFlags_IsEnabled | ImGuiTableColumnFlags_IsVisible | ImGuiTableColumnFlags_IsSorted | ImGuiTableColumnFlags_IsHovered,
    ImGuiTableColumnFlags_NoDirectResize_ = 1 << 30,
};


enum ImGuiTableRowFlags_
{
    ImGuiTableRowFlags_None = 0,
    ImGuiTableRowFlags_Headers = 1 << 0,
};
# 1996 "/usr/include/imgui.h" 3 4
enum ImGuiTableBgTarget_
{
    ImGuiTableBgTarget_None = 0,
    ImGuiTableBgTarget_RowBg0 = 1,
    ImGuiTableBgTarget_RowBg1 = 2,
    ImGuiTableBgTarget_CellBg = 3,
};





struct ImGuiTableSortSpecs
{
    const ImGuiTableColumnSortSpecs* Specs;
    int SpecsCount;
    bool SpecsDirty;

    ImGuiTableSortSpecs() { memset(this, 0, sizeof(*this)); }
};


struct ImGuiTableColumnSortSpecs
{
    ImGuiID ColumnUserID;
    ImS16 ColumnIndex;
    ImS16 SortOrder;
    ImGuiSortDirection SortDirection;

    ImGuiTableColumnSortSpecs() { memset(this, 0, sizeof(*this)); }
};
# 2048 "/usr/include/imgui.h" 3 4
struct ImNewWrapper {};
inline void* operator new(size_t, ImNewWrapper, void* ptr) { return ptr; }
inline void operator delete(void*, ImNewWrapper, void*) {}




template<typename T> void IM_DELETE(T* p) { if (p) { p->~T(); ImGui::MemFree(p); } }
# 2068 "/usr/include/imgui.h" 3 4

template<typename T>
struct ImVector
{
    int Size;
    int Capacity;
    T* Data;


    typedef T value_type;
    typedef value_type* iterator;
    typedef const value_type* const_iterator;


    inline ImVector() { Size = Capacity = 0; Data = __null; }
    inline ImVector(const ImVector<T>& src) { Size = Capacity = 0; Data = __null; operator=(src); }
    inline ImVector<T>& operator=(const ImVector<T>& src) { clear(); resize(src.Size); if (src.Data) memcpy(Data, src.Data, (size_t)Size * sizeof(T)); return *this; }
    inline ~ImVector() { if (Data) ImGui::MemFree(Data); }

    inline void clear() { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = __null; } }
    inline void clear_delete() { for (int n = 0; n < Size; n++) IM_DELETE(Data[n]); clear(); }
    inline void clear_destruct() { for (int n = 0; n < Size; n++) Data[n].~T(); clear(); }

    inline bool empty() const { return Size == 0; }
    inline int size() const { return Size; }
    inline int size_in_bytes() const { return Size * (int)sizeof(T); }
    inline int max_size() const { return 0x7FFFFFFF / (int)sizeof(T); }
    inline int capacity() const { return Capacity; }
    inline T& operator[](int i) { (static_cast <bool> (i >= 0 && i < Size) ? void (0) : __assert_fail ("i >= 0 && i < Size", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)); return Data[i]; }
    inline const T& operator[](int i) const { (static_cast <bool> (i >= 0 && i < Size) ? void (0) : __assert_fail ("i >= 0 && i < Size", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)); return Data[i]; }

    inline T* begin() { return Data; }
    inline const T* begin() const { return Data; }
    inline T* end() { return Data + Size; }
    inline const T* end() const { return Data + Size; }
    inline T& front() { (static_cast <bool> (Size > 0) ? void (0) : __assert_fail ("Size > 0", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)); return Data[0]; }
    inline const T& front() const { (static_cast <bool> (Size > 0) ? void (0) : __assert_fail ("Size > 0", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)); return Data[0]; }
    inline T& back() { (static_cast <bool> (Size > 0) ? void (0) : __assert_fail ("Size > 0", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)); return Data[Size - 1]; }
    inline const T& back() const { (static_cast <bool> (Size > 0) ? void (0) : __assert_fail ("Size > 0", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)); return Data[Size - 1]; }
    inline void swap(ImVector<T>& rhs) { int rhs_size = rhs.Size; rhs.Size = Size; Size = rhs_size; int rhs_cap = rhs.Capacity; rhs.Capacity = Capacity; Capacity = rhs_cap; T* rhs_data = rhs.Data; rhs.Data = Data; Data = rhs_data; }

    inline int _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
    inline void resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
    inline void resize(int new_size, const T& v) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }
    inline void shrink(int new_size) { (static_cast <bool> (new_size <= Size) ? void (0) : __assert_fail ("new_size <= Size", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)); Size = new_size; }
    inline void reserve(int new_capacity) { if (new_capacity <= Capacity) return; T* new_data = (T*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); ImGui::MemFree(Data); } Data = new_data; Capacity = new_capacity; }
    inline void reserve_discard(int new_capacity) { if (new_capacity <= Capacity) return; if (Data) ImGui::MemFree(Data); Data = (T*)ImGui::MemAlloc((size_t)new_capacity * sizeof(T)); Capacity = new_capacity; }


    inline void push_back(const T& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
    inline void pop_back() { (static_cast <bool> (Size > 0) ? void (0) : __assert_fail ("Size > 0", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)); Size--; }
    inline void push_front(const T& v) { if (Size == 0) push_back(v); else insert(Data, v); }
    inline T* erase(const T* it) { (static_cast <bool> (it >= Data && it < Data + Size) ? void (0) : __assert_fail ("it >= Data && it < Data + Size", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)); const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + 1, ((size_t)Size - (size_t)off - 1) * sizeof(T)); Size--; return Data + off; }
    inline T* erase(const T* it, const T* it_last){ (static_cast <bool> (it >= Data && it < Data + Size && it_last >= it && it_last <= Data + Size) ? void (0) : __assert_fail ("it >= Data && it < Data + Size && it_last >= it && it_last <= Data + Size", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)); const ptrdiff_t count = it_last - it; const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + count, ((size_t)Size - (size_t)off - (size_t)count) * sizeof(T)); Size -= (int)count; return Data + off; }
    inline T* erase_unsorted(const T* it) { (static_cast <bool> (it >= Data && it < Data + Size) ? void (0) : __assert_fail ("it >= Data && it < Data + Size", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)); const ptrdiff_t off = it - Data; if (it < Data + Size - 1) memcpy(Data + off, Data + Size - 1, sizeof(T)); Size--; return Data + off; }
    inline T* insert(const T* it, const T& v) { (static_cast <bool> (it >= Data && it <= Data + Size) ? void (0) : __assert_fail ("it >= Data && it <= Data + Size", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)); const ptrdiff_t off = it - Data; if (Size == Capacity) reserve(_grow_capacity(Size + 1)); if (off < (int)Size) memmove(Data + off + 1, Data + off, ((size_t)Size - (size_t)off) * sizeof(T)); memcpy(&Data[off], &v, sizeof(v)); Size++; return Data + off; }
    inline bool contains(const T& v) const { const T* data = Data; const T* data_end = Data + Size; while (data < data_end) if (*data++ == v) return true; return false; }
    inline T* find(const T& v) { T* data = Data; const T* data_end = Data + Size; while (data < data_end) if (*data == v) break; else ++data; return data; }
    inline const T* find(const T& v) const { const T* data = Data; const T* data_end = Data + Size; while (data < data_end) if (*data == v) break; else ++data; return data; }
    inline int find_index(const T& v) const { const T* data_end = Data + Size; const T* it = find(v); if (it == data_end) return -1; const ptrdiff_t off = it - Data; return (int)off; }
    inline bool find_erase(const T& v) { const T* it = find(v); if (it < Data + Size) { erase(it); return true; } return false; }
    inline bool find_erase_unsorted(const T& v) { const T* it = find(v); if (it < Data + Size) { erase_unsorted(it); return true; } return false; }
    inline int index_from_ptr(const T* it) const { (static_cast <bool> (it >= Data && it < Data + Size) ? void (0) : __assert_fail ("it >= Data && it < Data + Size", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)); const ptrdiff_t off = it - Data; return (int)off; }
};

# 2142 "/usr/include/imgui.h" 3 4
struct ImGuiStyle
{
    float Alpha;
    float DisabledAlpha;
    ImVec2 WindowPadding;
    float WindowRounding;
    float WindowBorderSize;
    ImVec2 WindowMinSize;
    ImVec2 WindowTitleAlign;
    ImGuiDir WindowMenuButtonPosition;
    float ChildRounding;
    float ChildBorderSize;
    float PopupRounding;
    float PopupBorderSize;
    ImVec2 FramePadding;
    float FrameRounding;
    float FrameBorderSize;
    ImVec2 ItemSpacing;
    ImVec2 ItemInnerSpacing;
    ImVec2 CellPadding;
    ImVec2 TouchExtraPadding;
    float IndentSpacing;
    float ColumnsMinSpacing;
    float ScrollbarSize;
    float ScrollbarRounding;
    float GrabMinSize;
    float GrabRounding;
    float LogSliderDeadzone;
    float TabRounding;
    float TabBorderSize;
    float TabMinWidthForCloseButton;
    float TabBarBorderSize;
    float TabBarOverlineSize;
    float TableAngledHeadersAngle;
    ImVec2 TableAngledHeadersTextAlign;
    ImGuiDir ColorButtonPosition;
    ImVec2 ButtonTextAlign;
    ImVec2 SelectableTextAlign;
    float SeparatorTextBorderSize;
    ImVec2 SeparatorTextAlign;
    ImVec2 SeparatorTextPadding;
    ImVec2 DisplayWindowPadding;
    ImVec2 DisplaySafeAreaPadding;
    float MouseCursorScale;
    bool AntiAliasedLines;
    bool AntiAliasedLinesUseTex;
    bool AntiAliasedFill;
    float CurveTessellationTol;
    float CircleTessellationMaxError;
    ImVec4 Colors[ImGuiCol_COUNT];



    float HoverStationaryDelay;
    float HoverDelayShort;
    float HoverDelayNormal;
    ImGuiHoveredFlags HoverFlagsForTooltipMouse;
    ImGuiHoveredFlags HoverFlagsForTooltipNav;

    ImGuiStyle();
    void ScaleAllSizes(float scale_factor);
};
# 2219 "/usr/include/imgui.h" 3 4
struct ImGuiKeyData
{
    bool Down;
    float DownDuration;
    float DownDurationPrev;
    float AnalogValue;
};

struct ImGuiIO
{




    ImGuiConfigFlags ConfigFlags;
    ImGuiBackendFlags BackendFlags;
    ImVec2 DisplaySize;
    float DeltaTime;
    float IniSavingRate;
    const char* IniFilename;
    const char* LogFilename;
    void* UserData;


    ImFontAtlas*Fonts;
    float FontGlobalScale;
    bool FontAllowUserScaling;
    ImFont* FontDefault;
    ImVec2 DisplayFramebufferScale;


    bool ConfigNavSwapGamepadButtons;
    bool ConfigNavMoveSetMousePos;
    bool ConfigNavCaptureKeyboard;
    bool ConfigNavEscapeClearFocusItem;
    bool ConfigNavEscapeClearFocusWindow;
    bool ConfigNavCursorVisibleAuto;
    bool ConfigNavCursorVisibleAlways;



    bool MouseDrawCursor;
    bool ConfigMacOSXBehaviors;
    bool ConfigInputTrickleEventQueue;
    bool ConfigInputTextCursorBlink;
    bool ConfigInputTextEnterKeepActive;
    bool ConfigDragClickToInputText;
    bool ConfigWindowsResizeFromEdges;
    bool ConfigWindowsMoveFromTitleBarOnly;
    bool ConfigScrollbarScrollByPage;
    float ConfigMemoryCompactTimer;



    float MouseDoubleClickTime;
    float MouseDoubleClickMaxDist;
    float MouseDragThreshold;
    float KeyRepeatDelay;
    float KeyRepeatRate;
# 2297 "/usr/include/imgui.h" 3 4
    bool ConfigErrorRecovery;
    bool ConfigErrorRecoveryEnableAssert;
    bool ConfigErrorRecoveryEnableDebugLog;
    bool ConfigErrorRecoveryEnableTooltip;





    bool ConfigDebugIsDebuggerPresent;





    bool ConfigDebugHighlightIdConflicts;





    bool ConfigDebugBeginReturnValueOnce;
    bool ConfigDebugBeginReturnValueLoop;




    bool ConfigDebugIgnoreFocusLoss;


    bool ConfigDebugIniSettings;







    const char* BackendPlatformName;
    const char* BackendRendererName;
    void* BackendPlatformUserData;
    void* BackendRendererUserData;
    void* BackendLanguageUserData;






    void AddKeyEvent(ImGuiKey key, bool down);
    void AddKeyAnalogEvent(ImGuiKey key, bool down, float v);
    void AddMousePosEvent(float x, float y);
    void AddMouseButtonEvent(int button, bool down);
    void AddMouseWheelEvent(float wheel_x, float wheel_y);
    void AddMouseSourceEvent(ImGuiMouseSource source);
    void AddFocusEvent(bool focused);
    void AddInputCharacter(unsigned int c);
    void AddInputCharacterUTF16(ImWchar16 c);
    void AddInputCharactersUTF8(const char* str);

    void SetKeyEventNativeData(ImGuiKey key, int native_keycode, int native_scancode, int native_legacy_index = -1);
    void SetAppAcceptingEvents(bool accepting_events);
    void ClearEventsQueue();
    void ClearInputKeys();
    void ClearInputMouse();

    void ClearInputCharacters();
# 2372 "/usr/include/imgui.h" 3 4
    bool WantCaptureMouse;
    bool WantCaptureKeyboard;
    bool WantTextInput;
    bool WantSetMousePos;
    bool WantSaveIniSettings;
    bool NavActive;
    bool NavVisible;
    float Framerate;
    int MetricsRenderVertices;
    int MetricsRenderIndices;
    int MetricsRenderWindows;
    int MetricsActiveWindows;
    ImVec2 MouseDelta;





    ImGuiContext* Ctx;




    ImVec2 MousePos;
    bool MouseDown[5];
    float MouseWheel;
    float MouseWheelH;
    ImGuiMouseSource MouseSource;
    bool KeyCtrl;
    bool KeyShift;
    bool KeyAlt;
    bool KeySuper;


    ImGuiKeyChord KeyMods;
    ImGuiKeyData KeysData[ImGuiKey_KeysData_SIZE];
    bool WantCaptureMouseUnlessPopupClose;
    ImVec2 MousePosPrev;
    ImVec2 MouseClickedPos[5];
    double MouseClickedTime[5];
    bool MouseClicked[5];
    bool MouseDoubleClicked[5];
    ImU16 MouseClickedCount[5];
    ImU16 MouseClickedLastCount[5];
    bool MouseReleased[5];
    bool MouseDownOwned[5];
    bool MouseDownOwnedUnlessPopupClose[5];
    bool MouseWheelRequestAxisSwap;
    bool MouseCtrlLeftAsRightClick;
    float MouseDownDuration[5];
    float MouseDownDurationPrev[5];
    float MouseDragMaxDistanceSqr[5];
    float PenPressure;
    bool AppFocusLost;
    bool AppAcceptingEvents;
    ImS8 BackendUsingLegacyKeyArrays;
    bool BackendUsingLegacyNavInputArray;
    ImWchar16 InputQueueSurrogate;
    ImVector<ImWchar> InputQueueCharacters;





    int KeyMap[ImGuiKey_COUNT];
    bool KeysDown[ImGuiKey_COUNT];
    float NavInputs[ImGuiNavInput_COUNT];






    const char* (*GetClipboardTextFn)(void* user_data);
    void (*SetClipboardTextFn)(void* user_data, const char* text);
    void* ClipboardUserData;


    ImGuiIO();
};
# 2466 "/usr/include/imgui.h" 3 4
struct ImGuiInputTextCallbackData
{
    ImGuiContext* Ctx;
    ImGuiInputTextFlags EventFlag;
    ImGuiInputTextFlags Flags;
    void* UserData;






    ImWchar EventChar;
    ImGuiKey EventKey;
    char* Buf;
    int BufTextLen;
    int BufSize;
    bool BufDirty;
    int CursorPos;
    int SelectionStart;
    int SelectionEnd;



    ImGuiInputTextCallbackData();
    void DeleteChars(int pos, int bytes_count);
    void InsertChars(int pos, const char* text, const char* text_end = __null);
    void SelectAll() { SelectionStart = 0; SelectionEnd = BufTextLen; }
    void ClearSelection() { SelectionStart = SelectionEnd = BufTextLen; }
    bool HasSelection() const { return SelectionStart != SelectionEnd; }
};



struct ImGuiSizeCallbackData
{
    void* UserData;
    ImVec2 Pos;
    ImVec2 CurrentSize;
    ImVec2 DesiredSize;
};


struct ImGuiPayload
{

    void* Data;
    int DataSize;


    ImGuiID SourceId;
    ImGuiID SourceParentId;
    int DataFrameCount;
    char DataType[32 + 1];
    bool Preview;
    bool Delivery;

    ImGuiPayload() { Clear(); }
    void Clear() { SourceId = SourceParentId = 0; Data = __null; DataSize = 0; memset(DataType, 0, sizeof(DataType)); DataFrameCount = -1; Preview = Delivery = false; }
    bool IsDataType(const char* type) const { return DataFrameCount != -1 && strcmp(type, DataType) == 0; }
    bool IsPreview() const { return Preview; }
    bool IsDelivery() const { return Delivery; }
};
# 2544 "/usr/include/imgui.h" 3 4
struct ImGuiOnceUponAFrame
{
    ImGuiOnceUponAFrame() { RefFrame = -1; }
    mutable int RefFrame;
    operator bool() const { int current_frame = ImGui::GetFrameCount(); if (RefFrame == current_frame) return false; RefFrame = current_frame; return true; }
};


struct ImGuiTextFilter
{
    ImGuiTextFilter(const char* default_filter = "");
    bool Draw(const char* label = "Filter (inc,-exc)", float width = 0.0f);
    bool PassFilter(const char* text, const char* text_end = __null) const;
    void Build();
    void Clear() { InputBuf[0] = 0; Build(); }
    bool IsActive() const { return !Filters.empty(); }


    struct ImGuiTextRange
    {
        const char* b;
        const char* e;

        ImGuiTextRange() { b = e = __null; }
        ImGuiTextRange(const char* _b, const char* _e) { b = _b; e = _e; }
        bool empty() const { return b == e; }
        void split(char separator, ImVector<ImGuiTextRange>* out) const;
    };
    char InputBuf[256];
    ImVector<ImGuiTextRange>Filters;
    int CountGrep;
};



struct ImGuiTextBuffer
{
    ImVector<char> Buf;
    static char EmptyString[1];

    ImGuiTextBuffer() { }
    inline char operator[](int i) const { (static_cast <bool> (Buf.Data != __null) ? void (0) : __assert_fail ("Buf.Data != __null", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)); return Buf.Data[i]; }
    const char* begin() const { return Buf.Data ? &Buf.front() : EmptyString; }
    const char* end() const { return Buf.Data ? &Buf.back() : EmptyString; }
    int size() const { return Buf.Size ? Buf.Size - 1 : 0; }
    bool empty() const { return Buf.Size <= 1; }
    void clear() { Buf.clear(); }
    void reserve(int capacity) { Buf.reserve(capacity); }
    const char* c_str() const { return Buf.Data ? Buf.Data : EmptyString; }
    void append(const char* str, const char* str_end = __null);
    void appendf(const char* fmt, ...) __attribute__((format(printf, 2, 2 +1)));
    void appendfv(const char* fmt, va_list args) __attribute__((format(printf, 2, 0)));
};


struct ImGuiStoragePair
{
    ImGuiID key;
    union { int val_i; float val_f; void* val_p; };
    ImGuiStoragePair(ImGuiID _key, int _val) { key = _key; val_i = _val; }
    ImGuiStoragePair(ImGuiID _key, float _val) { key = _key; val_f = _val; }
    ImGuiStoragePair(ImGuiID _key, void* _val) { key = _key; val_p = _val; }
};
# 2616 "/usr/include/imgui.h" 3 4
struct ImGuiStorage
{

    ImVector<ImGuiStoragePair> Data;




    void Clear() { Data.clear(); }
    int GetInt(ImGuiID key, int default_val = 0) const;
    void SetInt(ImGuiID key, int val);
    bool GetBool(ImGuiID key, bool default_val = false) const;
    void SetBool(ImGuiID key, bool val);
    float GetFloat(ImGuiID key, float default_val = 0.0f) const;
    void SetFloat(ImGuiID key, float val);
    void* GetVoidPtr(ImGuiID key) const;
    void SetVoidPtr(ImGuiID key, void* val);





    int* GetIntRef(ImGuiID key, int default_val = 0);
    bool* GetBoolRef(ImGuiID key, bool default_val = false);
    float* GetFloatRef(ImGuiID key, float default_val = 0.0f);
    void** GetVoidPtrRef(ImGuiID key, void* default_val = __null);


    void BuildSortByKey();

    void SetAllInt(int val);




};
# 2673 "/usr/include/imgui.h" 3 4
struct ImGuiListClipper
{
    ImGuiContext* Ctx;
    int DisplayStart;
    int DisplayEnd;
    int ItemsCount;
    float ItemsHeight;
    float StartPosY;
    double StartSeekOffsetY;
    void* TempData;



    ImGuiListClipper();
    ~ImGuiListClipper();
    void Begin(int items_count, float items_height = -1.0f);
    void End();
    bool Step();



    inline void IncludeItemByIndex(int item_index) { IncludeItemsByIndex(item_index, item_index + 1); }
    void IncludeItemsByIndex(int item_begin, int item_end);




    void SeekCursorForItem(int item_index);


    inline void IncludeRangeByIndices(int item_begin, int item_end) { IncludeItemsByIndex(item_begin, item_end); }
    inline void ForceDisplayRangeByIndices(int item_begin, int item_end) { IncludeItemsByIndex(item_begin, item_end); }


};
# 2765 "/usr/include/imgui.h" 3 4
struct ImColor
{
    ImVec4 Value;

    constexpr ImColor() { }
    constexpr ImColor(float r, float g, float b, float a = 1.0f) : Value(r, g, b, a) { }
    constexpr ImColor(const ImVec4& col) : Value(col) {}
    constexpr ImColor(int r, int g, int b, int a = 255) : Value((float)r * (1.0f / 255.0f), (float)g * (1.0f / 255.0f), (float)b * (1.0f / 255.0f), (float)a* (1.0f / 255.0f)) {}
    constexpr ImColor(ImU32 rgba) : Value((float)((rgba >> 0) & 0xFF) * (1.0f / 255.0f), (float)((rgba >> 8) & 0xFF) * (1.0f / 255.0f), (float)((rgba >> 16) & 0xFF) * (1.0f / 255.0f), (float)((rgba >> 24) & 0xFF) * (1.0f / 255.0f)) {}
    inline operator ImU32() const { return ImGui::ColorConvertFloat4ToU32(Value); }
    inline operator ImVec4() const { return Value; }


    inline void SetHSV(float h, float s, float v, float a = 1.0f){ ImGui::ColorConvertHSVtoRGB(h, s, v, Value.x, Value.y, Value.z); Value.w = a; }
    static ImColor HSV(float h, float s, float v, float a = 1.0f) { float r, g, b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r, g, b, a); }
};
# 2823 "/usr/include/imgui.h" 3 4
enum ImGuiMultiSelectFlags_
{
    ImGuiMultiSelectFlags_None = 0,
    ImGuiMultiSelectFlags_SingleSelect = 1 << 0,
    ImGuiMultiSelectFlags_NoSelectAll = 1 << 1,
    ImGuiMultiSelectFlags_NoRangeSelect = 1 << 2,
    ImGuiMultiSelectFlags_NoAutoSelect = 1 << 3,
    ImGuiMultiSelectFlags_NoAutoClear = 1 << 4,
    ImGuiMultiSelectFlags_NoAutoClearOnReselect = 1 << 5,
    ImGuiMultiSelectFlags_BoxSelect1d = 1 << 6,
    ImGuiMultiSelectFlags_BoxSelect2d = 1 << 7,
    ImGuiMultiSelectFlags_BoxSelectNoScroll = 1 << 8,
    ImGuiMultiSelectFlags_ClearOnEscape = 1 << 9,
    ImGuiMultiSelectFlags_ClearOnClickVoid = 1 << 10,
    ImGuiMultiSelectFlags_ScopeWindow = 1 << 11,
    ImGuiMultiSelectFlags_ScopeRect = 1 << 12,
    ImGuiMultiSelectFlags_SelectOnClick = 1 << 13,
    ImGuiMultiSelectFlags_SelectOnClickRelease = 1 << 14,

    ImGuiMultiSelectFlags_NavWrapX = 1 << 16,
};






struct ImGuiMultiSelectIO
{

    ImVector<ImGuiSelectionRequest> Requests;
    ImGuiSelectionUserData RangeSrcItem;
    ImGuiSelectionUserData NavIdItem;
    bool NavIdSelected;
    bool RangeSrcReset;
    int ItemsCount;
};


enum ImGuiSelectionRequestType
{
    ImGuiSelectionRequestType_None = 0,
    ImGuiSelectionRequestType_SetAll,
    ImGuiSelectionRequestType_SetRange,
};


struct ImGuiSelectionRequest
{

    ImGuiSelectionRequestType Type;
    bool Selected;
    ImS8 RangeDirection;
    ImGuiSelectionUserData RangeFirstItem;
    ImGuiSelectionUserData RangeLastItem;
};
# 2896 "/usr/include/imgui.h" 3 4
struct ImGuiSelectionBasicStorage
{

    int Size;
    bool PreserveOrder;
    void* UserData;
    ImGuiID (*AdapterIndexToStorageId)(ImGuiSelectionBasicStorage* self, int idx);
    int _SelectionOrder;
    ImGuiStorage _Storage;


    ImGuiSelectionBasicStorage();
    void ApplyRequests(ImGuiMultiSelectIO* ms_io);
    bool Contains(ImGuiID id) const;
    void Clear();
    void Swap(ImGuiSelectionBasicStorage& r);
    void SetItemSelected(ImGuiID id, bool selected);
    bool GetNextSelectedItem(void** opaque_it, ImGuiID* out_id);
    inline ImGuiID GetStorageIdFromIndex(int idx) { return AdapterIndexToStorageId(this, idx); }
};



struct ImGuiSelectionExternalStorage
{

    void* UserData;
    void (*AdapterSetItemSelected)(ImGuiSelectionExternalStorage* self, int idx, bool selected);


    ImGuiSelectionExternalStorage();
    void ApplyRequests(ImGuiMultiSelectIO* ms_io);
};
# 2948 "/usr/include/imgui.h" 3 4
typedef void (*ImDrawCallback)(const ImDrawList* parent_list, const ImDrawCmd* cmd);
# 2962 "/usr/include/imgui.h" 3 4
struct ImDrawCmd
{
    ImVec4 ClipRect;
    ImTextureID TextureId;
    unsigned int VtxOffset;
    unsigned int IdxOffset;
    unsigned int ElemCount;
    ImDrawCallback UserCallback;
    void* UserCallbackData;
    int UserCallbackDataSize;
    int UserCallbackDataOffset;

    ImDrawCmd() { memset(this, 0, sizeof(*this)); }


    inline ImTextureID GetTexID() const { return TextureId; }
};



struct ImDrawVert
{
    ImVec2 pos;
    ImVec2 uv;
    ImU32 col;
};
# 2997 "/usr/include/imgui.h" 3 4
struct ImDrawCmdHeader
{
    ImVec4 ClipRect;
    ImTextureID TextureId;
    unsigned int VtxOffset;
};


struct ImDrawChannel
{
    ImVector<ImDrawCmd> _CmdBuffer;
    ImVector<ImDrawIdx> _IdxBuffer;
};




struct ImDrawListSplitter
{
    int _Current;
    int _Count;
    ImVector<ImDrawChannel> _Channels;

    inline ImDrawListSplitter() { memset(this, 0, sizeof(*this)); }
    inline ~ImDrawListSplitter() { ClearFreeMemory(); }
    inline void Clear() { _Current = 0; _Count = 1; }
    void ClearFreeMemory();
    void Split(ImDrawList* draw_list, int count);
    void Merge(ImDrawList* draw_list);
    void SetCurrentChannel(ImDrawList* draw_list, int channel_idx);
};



enum ImDrawFlags_
{
    ImDrawFlags_None = 0,
    ImDrawFlags_Closed = 1 << 0,
    ImDrawFlags_RoundCornersTopLeft = 1 << 4,
    ImDrawFlags_RoundCornersTopRight = 1 << 5,
    ImDrawFlags_RoundCornersBottomLeft = 1 << 6,
    ImDrawFlags_RoundCornersBottomRight = 1 << 7,
    ImDrawFlags_RoundCornersNone = 1 << 8,
    ImDrawFlags_RoundCornersTop = ImDrawFlags_RoundCornersTopLeft | ImDrawFlags_RoundCornersTopRight,
    ImDrawFlags_RoundCornersBottom = ImDrawFlags_RoundCornersBottomLeft | ImDrawFlags_RoundCornersBottomRight,
    ImDrawFlags_RoundCornersLeft = ImDrawFlags_RoundCornersBottomLeft | ImDrawFlags_RoundCornersTopLeft,
    ImDrawFlags_RoundCornersRight = ImDrawFlags_RoundCornersBottomRight | ImDrawFlags_RoundCornersTopRight,
    ImDrawFlags_RoundCornersAll = ImDrawFlags_RoundCornersTopLeft | ImDrawFlags_RoundCornersTopRight | ImDrawFlags_RoundCornersBottomLeft | ImDrawFlags_RoundCornersBottomRight,
    ImDrawFlags_RoundCornersDefault_ = ImDrawFlags_RoundCornersAll,
    ImDrawFlags_RoundCornersMask_ = ImDrawFlags_RoundCornersAll | ImDrawFlags_RoundCornersNone,
};



enum ImDrawListFlags_
{
    ImDrawListFlags_None = 0,
    ImDrawListFlags_AntiAliasedLines = 1 << 0,
    ImDrawListFlags_AntiAliasedLinesUseTex = 1 << 1,
    ImDrawListFlags_AntiAliasedFill = 1 << 2,
    ImDrawListFlags_AllowVtxOffset = 1 << 3,
};
# 3069 "/usr/include/imgui.h" 3 4
struct ImDrawList
{

    ImVector<ImDrawCmd> CmdBuffer;
    ImVector<ImDrawIdx> IdxBuffer;
    ImVector<ImDrawVert> VtxBuffer;
    ImDrawListFlags Flags;


    unsigned int _VtxCurrentIdx;
    ImDrawListSharedData* _Data;
    ImDrawVert* _VtxWritePtr;
    ImDrawIdx* _IdxWritePtr;
    ImVector<ImVec2> _Path;
    ImDrawCmdHeader _CmdHeader;
    ImDrawListSplitter _Splitter;
    ImVector<ImVec4> _ClipRectStack;
    ImVector<ImTextureID> _TextureIdStack;
    ImVector<ImU8> _CallbacksDataBuf;
    float _FringeScale;
    const char* _OwnerName;


    ImDrawList(ImDrawListSharedData* shared_data) { memset(this, 0, sizeof(*this)); _Data = shared_data; }

    ~ImDrawList() { _ClearFreeMemory(); }
    void PushClipRect(const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_current_clip_rect = false);
    void PushClipRectFullScreen();
    void PopClipRect();
    void PushTextureID(ImTextureID texture_id);
    void PopTextureID();
    inline ImVec2 GetClipRectMin() const { const ImVec4& cr = _ClipRectStack.back(); return ImVec2(cr.x, cr.y); }
    inline ImVec2 GetClipRectMax() const { const ImVec4& cr = _ClipRectStack.back(); return ImVec2(cr.z, cr.w); }
# 3110 "/usr/include/imgui.h" 3 4
    void AddLine(const ImVec2& p1, const ImVec2& p2, ImU32 col, float thickness = 1.0f);
    void AddRect(const ImVec2& p_min, const ImVec2& p_max, ImU32 col, float rounding = 0.0f, ImDrawFlags flags = 0, float thickness = 1.0f);
    void AddRectFilled(const ImVec2& p_min, const ImVec2& p_max, ImU32 col, float rounding = 0.0f, ImDrawFlags flags = 0);
    void AddRectFilledMultiColor(const ImVec2& p_min, const ImVec2& p_max, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left);
    void AddQuad(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, ImU32 col, float thickness = 1.0f);
    void AddQuadFilled(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, ImU32 col);
    void AddTriangle(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, ImU32 col, float thickness = 1.0f);
    void AddTriangleFilled(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, ImU32 col);
    void AddCircle(const ImVec2& center, float radius, ImU32 col, int num_segments = 0, float thickness = 1.0f);
    void AddCircleFilled(const ImVec2& center, float radius, ImU32 col, int num_segments = 0);
    void AddNgon(const ImVec2& center, float radius, ImU32 col, int num_segments, float thickness = 1.0f);
    void AddNgonFilled(const ImVec2& center, float radius, ImU32 col, int num_segments);
    void AddEllipse(const ImVec2& center, const ImVec2& radius, ImU32 col, float rot = 0.0f, int num_segments = 0, float thickness = 1.0f);
    void AddEllipseFilled(const ImVec2& center, const ImVec2& radius, ImU32 col, float rot = 0.0f, int num_segments = 0);
    void AddText(const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = __null);
    void AddText(const ImFont* font, float font_size, const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = __null, float wrap_width = 0.0f, const ImVec4* cpu_fine_clip_rect = __null);
    void AddBezierCubic(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, ImU32 col, float thickness, int num_segments = 0);
    void AddBezierQuadratic(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, ImU32 col, float thickness, int num_segments = 0);




    void AddPolyline(const ImVec2* points, int num_points, ImU32 col, ImDrawFlags flags, float thickness);
    void AddConvexPolyFilled(const ImVec2* points, int num_points, ImU32 col);
    void AddConcavePolyFilled(const ImVec2* points, int num_points, ImU32 col);





    void AddImage(ImTextureID user_texture_id, const ImVec2& p_min, const ImVec2& p_max, const ImVec2& uv_min = ImVec2(0, 0), const ImVec2& uv_max = ImVec2(1, 1), ImU32 col = (((ImU32)(255)<<24) | ((ImU32)(255)<<16) | ((ImU32)(255)<<8) | ((ImU32)(255)<<0)));
    void AddImageQuad(ImTextureID user_texture_id, const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, const ImVec2& uv1 = ImVec2(0, 0), const ImVec2& uv2 = ImVec2(1, 0), const ImVec2& uv3 = ImVec2(1, 1), const ImVec2& uv4 = ImVec2(0, 1), ImU32 col = (((ImU32)(255)<<24) | ((ImU32)(255)<<16) | ((ImU32)(255)<<8) | ((ImU32)(255)<<0)));
    void AddImageRounded(ImTextureID user_texture_id, const ImVec2& p_min, const ImVec2& p_max, const ImVec2& uv_min, const ImVec2& uv_max, ImU32 col, float rounding, ImDrawFlags flags = 0);




    inline void PathClear() { _Path.Size = 0; }
    inline void PathLineTo(const ImVec2& pos) { _Path.push_back(pos); }
    inline void PathLineToMergeDuplicate(const ImVec2& pos) { if (_Path.Size == 0 || memcmp(&_Path.Data[_Path.Size - 1], &pos, 8) != 0) _Path.push_back(pos); }
    inline void PathFillConvex(ImU32 col) { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }
    inline void PathFillConcave(ImU32 col) { AddConcavePolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }
    inline void PathStroke(ImU32 col, ImDrawFlags flags = 0, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, flags, thickness); _Path.Size = 0; }
    void PathArcTo(const ImVec2& center, float radius, float a_min, float a_max, int num_segments = 0);
    void PathArcToFast(const ImVec2& center, float radius, int a_min_of_12, int a_max_of_12);
    void PathEllipticalArcTo(const ImVec2& center, const ImVec2& radius, float rot, float a_min, float a_max, int num_segments = 0);
    void PathBezierCubicCurveTo(const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, int num_segments = 0);
    void PathBezierQuadraticCurveTo(const ImVec2& p2, const ImVec2& p3, int num_segments = 0);
    void PathRect(const ImVec2& rect_min, const ImVec2& rect_max, float rounding = 0.0f, ImDrawFlags flags = 0);
# 3169 "/usr/include/imgui.h" 3 4
    void AddCallback(ImDrawCallback callback, void* userdata, size_t userdata_size = 0);


    void AddDrawCmd();
    ImDrawList* CloneOutput() const;







    inline void ChannelsSplit(int count) { _Splitter.Split(this, count); }
    inline void ChannelsMerge() { _Splitter.Merge(this); }
    inline void ChannelsSetCurrent(int n) { _Splitter.SetCurrentChannel(this, n); }




    void PrimReserve(int idx_count, int vtx_count);
    void PrimUnreserve(int idx_count, int vtx_count);
    void PrimRect(const ImVec2& a, const ImVec2& b, ImU32 col);
    void PrimRectUV(const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col);
    void PrimQuadUV(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col);
    inline void PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col) { _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }
    inline void PrimWriteIdx(ImDrawIdx idx) { *_IdxWritePtr = idx; _IdxWritePtr++; }
    inline void PrimVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col) { PrimWriteIdx((ImDrawIdx)_VtxCurrentIdx); PrimWriteVtx(pos, uv, col); }
# 3205 "/usr/include/imgui.h" 3 4
    void _ResetForNewFrame();
    void _ClearFreeMemory();
    void _PopUnusedDrawCmd();
    void _TryMergeDrawCmds();
    void _OnChangedClipRect();
    void _OnChangedTextureID();
    void _OnChangedVtxOffset();
    void _SetTextureID(ImTextureID texture_id);
    int _CalcCircleAutoSegmentCount(float radius) const;
    void _PathArcToFastEx(const ImVec2& center, float radius, int a_min_sample, int a_max_sample, int a_step);
    void _PathArcToN(const ImVec2& center, float radius, float a_min, float a_max, int num_segments);
};




struct ImDrawData
{
    bool Valid;
    int CmdListsCount;
    int TotalIdxCount;
    int TotalVtxCount;
    ImVector<ImDrawList*> CmdLists;
    ImVec2 DisplayPos;
    ImVec2 DisplaySize;
    ImVec2 FramebufferScale;
    ImGuiViewport* OwnerViewport;


    ImDrawData() { Clear(); }
    void Clear();
    void AddDrawList(ImDrawList* draw_list);
    void DeIndexAllBuffers();
    void ScaleClipRects(const ImVec2& fb_scale);
};





struct ImFontConfig
{
    void* FontData;
    int FontDataSize;
    bool FontDataOwnedByAtlas;
    int FontNo;
    float SizePixels;
    int OversampleH;
    int OversampleV;
    bool PixelSnapH;
    ImVec2 GlyphExtraSpacing;
    ImVec2 GlyphOffset;
    const ImWchar* GlyphRanges;
    float GlyphMinAdvanceX;
    float GlyphMaxAdvanceX;
    bool MergeMode;
    unsigned int FontBuilderFlags;
    float RasterizerMultiply;
    float RasterizerDensity;
    ImWchar EllipsisChar;


    char Name[40];
    ImFont* DstFont;

    ImFontConfig();
};



struct ImFontGlyph
{
    unsigned int Colored : 1;
    unsigned int Visible : 1;
    unsigned int Codepoint : 30;
    float AdvanceX;
    float X0, Y0, X1, Y1;
    float U0, V0, U1, V1;
};



struct ImFontGlyphRangesBuilder
{
    ImVector<ImU32> UsedChars;

    ImFontGlyphRangesBuilder() { Clear(); }
    inline void Clear() { int size_in_bytes = (0xFFFF + 1) / 8; UsedChars.resize(size_in_bytes / (int)sizeof(ImU32)); memset(UsedChars.Data, 0, (size_t)size_in_bytes); }
    inline bool GetBit(size_t n) const { int off = (int)(n >> 5); ImU32 mask = 1u << (n & 31); return (UsedChars[off] & mask) != 0; }
    inline void SetBit(size_t n) { int off = (int)(n >> 5); ImU32 mask = 1u << (n & 31); UsedChars[off] |= mask; }
    inline void AddChar(ImWchar c) { SetBit(c); }
    void AddText(const char* text, const char* text_end = __null);
    void AddRanges(const ImWchar* ranges);
    void BuildRanges(ImVector<ImWchar>* out_ranges);
};


struct ImFontAtlasCustomRect
{
    unsigned short Width, Height;
    unsigned short X, Y;
    unsigned int GlyphID;
    float GlyphAdvanceX;
    ImVec2 GlyphOffset;
    ImFont* Font;
    ImFontAtlasCustomRect() { Width = Height = 0; X = Y = 0xFFFF; GlyphID = 0; GlyphAdvanceX = 0.0f; GlyphOffset = ImVec2(0, 0); Font = __null; }
    bool IsPacked() const { return X != 0xFFFF; }
};


enum ImFontAtlasFlags_
{
    ImFontAtlasFlags_None = 0,
    ImFontAtlasFlags_NoPowerOfTwoHeight = 1 << 0,
    ImFontAtlasFlags_NoMouseCursors = 1 << 1,
    ImFontAtlasFlags_NoBakedLines = 1 << 2,
};
# 3340 "/usr/include/imgui.h" 3 4
struct ImFontAtlas
{
    ImFontAtlas();
    ~ImFontAtlas();
    ImFont* AddFont(const ImFontConfig* font_cfg);
    ImFont* AddFontDefault(const ImFontConfig* font_cfg = __null);
    ImFont* AddFontFromFileTTF(const char* filename, float size_pixels, const ImFontConfig* font_cfg = __null, const ImWchar* glyph_ranges = __null);
    ImFont* AddFontFromMemoryTTF(void* font_data, int font_data_size, float size_pixels, const ImFontConfig* font_cfg = __null, const ImWchar* glyph_ranges = __null);
    ImFont* AddFontFromMemoryCompressedTTF(const void* compressed_font_data, int compressed_font_data_size, float size_pixels, const ImFontConfig* font_cfg = __null, const ImWchar* glyph_ranges = __null);
    ImFont* AddFontFromMemoryCompressedBase85TTF(const char* compressed_font_data_base85, float size_pixels, const ImFontConfig* font_cfg = __null, const ImWchar* glyph_ranges = __null);
    void ClearInputData();
    void ClearTexData();
    void ClearFonts();
    void Clear();






    bool Build();
    void GetTexDataAsAlpha8(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = __null);
    void GetTexDataAsRGBA32(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = __null);
    bool IsBuilt() const { return Fonts.Size > 0 && TexReady; }
    void SetTexID(ImTextureID id) { TexID = id; }
# 3374 "/usr/include/imgui.h" 3 4
    const ImWchar* GetGlyphRangesDefault();
    const ImWchar* GetGlyphRangesGreek();
    const ImWchar* GetGlyphRangesKorean();
    const ImWchar* GetGlyphRangesJapanese();
    const ImWchar* GetGlyphRangesChineseFull();
    const ImWchar* GetGlyphRangesChineseSimplifiedCommon();
    const ImWchar* GetGlyphRangesCyrillic();
    const ImWchar* GetGlyphRangesThai();
    const ImWchar* GetGlyphRangesVietnamese();
# 3395 "/usr/include/imgui.h" 3 4
    int AddCustomRectRegular(int width, int height);
    int AddCustomRectFontGlyph(ImFont* font, ImWchar id, int width, int height, float advance_x, const ImVec2& offset = ImVec2(0, 0));
    ImFontAtlasCustomRect* GetCustomRectByIndex(int index) { (static_cast <bool> (index >= 0) ? void (0) : __assert_fail ("index >= 0", __builtin_FILE (), __builtin_LINE (), __extension__ __PRETTY_FUNCTION__)); return &CustomRects[index]; }


    void CalcCustomRectUV(const ImFontAtlasCustomRect* rect, ImVec2* out_uv_min, ImVec2* out_uv_max) const;
    bool GetMouseCursorTexData(ImGuiMouseCursor cursor, ImVec2* out_offset, ImVec2* out_size, ImVec2 out_uv_border[2], ImVec2 out_uv_fill[2]);





    ImFontAtlasFlags Flags;
    ImTextureID TexID;
    int TexDesiredWidth;
    int TexGlyphPadding;
    bool Locked;
    void* UserData;



    bool TexReady;
    bool TexPixelsUseColors;
    unsigned char* TexPixelsAlpha8;
    unsigned int* TexPixelsRGBA32;
    int TexWidth;
    int TexHeight;
    ImVec2 TexUvScale;
    ImVec2 TexUvWhitePixel;
    ImVector<ImFont*> Fonts;
    ImVector<ImFontAtlasCustomRect> CustomRects;
    ImVector<ImFontConfig> ConfigData;
    ImVec4 TexUvLines[(63) + 1];


    const ImFontBuilderIO* FontBuilderIO;
    unsigned int FontBuilderFlags;


    int PackIdMouseCursors;
    int PackIdLines;




};



struct ImFont
{

    ImVector<float> IndexAdvanceX;
    float FallbackAdvanceX;
    float FontSize;


    ImVector<ImWchar> IndexLookup;
    ImVector<ImFontGlyph> Glyphs;
    const ImFontGlyph* FallbackGlyph;


    ImFontAtlas* ContainerAtlas;
    const ImFontConfig* ConfigData;
    short ConfigDataCount;
    ImWchar FallbackChar;
    ImWchar EllipsisChar;
    short EllipsisCharCount;
    float EllipsisWidth;
    float EllipsisCharStep;
    bool DirtyLookupTables;
    float Scale;
    float Ascent, Descent;
    int MetricsTotalSurface;
    ImU8 Used4kPagesMap[(0xFFFF +1)/4096/8];


    ImFont();
    ~ImFont();
    const ImFontGlyph*FindGlyph(ImWchar c) const;
    const ImFontGlyph*FindGlyphNoFallback(ImWchar c) const;
    float GetCharAdvance(ImWchar c) const { return ((int)c < IndexAdvanceX.Size) ? IndexAdvanceX[(int)c] : FallbackAdvanceX; }
    bool IsLoaded() const { return ContainerAtlas != __null; }
    const char* GetDebugName() const { return ConfigData ? ConfigData->Name : "<unknown>"; }



    ImVec2 CalcTextSizeA(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end = __null, const char** remaining = __null) const;
    const char* CalcWordWrapPositionA(float scale, const char* text, const char* text_end, float wrap_width) const;
    void RenderChar(ImDrawList* draw_list, float size, const ImVec2& pos, ImU32 col, ImWchar c) const;
    void RenderText(ImDrawList* draw_list, float size, const ImVec2& pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, float wrap_width = 0.0f, bool cpu_fine_clip = false) const;


    void BuildLookupTable();
    void ClearOutputData();
    void GrowIndex(int new_size);
    void AddGlyph(const ImFontConfig* src_cfg, ImWchar c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advance_x);
    void AddRemapChar(ImWchar dst, ImWchar src, bool overwrite_dst = true);
    void SetGlyphVisible(ImWchar c, bool visible);
    bool IsGlyphRangeUnused(unsigned int c_begin, unsigned int c_last);
};






enum ImGuiViewportFlags_
{
    ImGuiViewportFlags_None = 0,
    ImGuiViewportFlags_IsPlatformWindow = 1 << 0,
    ImGuiViewportFlags_IsPlatformMonitor = 1 << 1,
    ImGuiViewportFlags_OwnedByApp = 1 << 2,
};
# 3517 "/usr/include/imgui.h" 3 4
struct ImGuiViewport
{
    ImGuiID ID;
    ImGuiViewportFlags Flags;
    ImVec2 Pos;
    ImVec2 Size;
    ImVec2 WorkPos;
    ImVec2 WorkSize;


    void* PlatformHandle;
    void* PlatformHandleRaw;

    ImGuiViewport() { memset(this, 0, sizeof(*this)); }


    ImVec2 GetCenter() const { return ImVec2(Pos.x + Size.x * 0.5f, Pos.y + Size.y * 0.5f); }
    ImVec2 GetWorkCenter() const { return ImVec2(WorkPos.x + WorkSize.x * 0.5f, WorkPos.y + WorkSize.y * 0.5f); }
};






struct ImGuiPlatformIO
{
    ImGuiPlatformIO();







    const char* (*Platform_GetClipboardTextFn)(ImGuiContext* ctx);
    void (*Platform_SetClipboardTextFn)(ImGuiContext* ctx, const char* text);
    void* Platform_ClipboardUserData;



    bool (*Platform_OpenInShellFn)(ImGuiContext* ctx, const char* path);
    void* Platform_OpenInShellUserData;



    void (*Platform_SetImeDataFn)(ImGuiContext* ctx, ImGuiViewport* viewport, ImGuiPlatformImeData* data);
    void* Platform_ImeUserData;




    ImWchar Platform_LocaleDecimalPoint;






    void* Renderer_RenderState;
};


struct ImGuiPlatformImeData
{
    bool WantVisible;
    ImVec2 InputPos;
    float InputLineHeight;

    ImGuiPlatformImeData() { memset(this, 0, sizeof(*this)); }
};
# 3596 "/usr/include/imgui.h" 3 4
namespace ImGui
{

    static inline void PushButtonRepeat(bool repeat) { PushItemFlag(ImGuiItemFlags_ButtonRepeat, repeat); }
    static inline void PopButtonRepeat() { PopItemFlag(); }
    static inline void PushTabStop(bool tab_stop) { PushItemFlag(ImGuiItemFlags_NoTabStop, !tab_stop); }
    static inline void PopTabStop() { PopItemFlag(); }
    ImVec2 GetContentRegionMax();
    ImVec2 GetWindowContentRegionMin();
    ImVec2 GetWindowContentRegionMax();

    static inline bool BeginChildFrame(ImGuiID id, const ImVec2& size, ImGuiWindowFlags window_flags = 0) { return BeginChild(id, size, ImGuiChildFlags_FrameStyle, window_flags); }
    static inline void EndChildFrame() { EndChild(); }


    static inline void ShowStackToolWindow(bool* p_open = __null) { ShowIDStackToolWindow(p_open); }
    bool Combo(const char* label, int* current_item, bool (*old_callback)(void* user_data, int idx, const char** out_text), void* user_data, int items_count, int popup_max_height_in_items = -1);
    bool ListBox(const char* label, int* current_item, bool (*old_callback)(void* user_data, int idx, const char** out_text), void* user_data, int items_count, int height_in_items = -1);

    void SetItemAllowOverlap();

    static inline void PushAllowKeyboardFocus(bool tab_stop) { PushItemFlag(ImGuiItemFlags_NoTabStop, !tab_stop); }
    static inline void PopAllowKeyboardFocus() { PopItemFlag(); }

    ImGuiKey GetKeyIndex(ImGuiKey key);
# 3681 "/usr/include/imgui.h" 3 4
}
# 3720 "/usr/include/imgui.h" 3 4
#pragma GCC diagnostic pop
# 12 "/home/devkon/CLionProjects/VertexLab/main.cpp" 2
# 1 "/home/devkon/CLionProjects/VertexLab/imgui_manager.h" 1




# 1 "/home/devkon/CLionProjects/VertexLab/imgui_manager.h" 1
# 6 "/home/devkon/CLionProjects/VertexLab/imgui_manager.h" 2



# 8 "/home/devkon/CLionProjects/VertexLab/imgui_manager.h"
class ImGuiManager {
public:
    static void Init(GLFWwindow* window);
    static void BeginFrame();
    static void Render();
    static void Cleanup();
};
# 13 "/home/devkon/CLionProjects/VertexLab/main.cpp" 2
# 1 "/home/devkon/CLionProjects/VertexLab/imgui_widgets.h" 1



void RenderImGuiWidgets(float fps, float frameTime);
# 14 "/home/devkon/CLionProjects/VertexLab/main.cpp" 2


Camera camera;

int main() {

    InitializeGLFW();
    GLFWwindow* window = CreateWindow();
    if (!window) return -1;


    InitializeGLEW();
    SetupOpenGLSettings();


    SetupCallbacks(window);
    ImGuiManager::Init(window);


    GridData grid = CreateGrid();


    float lastFrame = 0.0f, fpsTimer = 0.0f;
    int frameCount = 0;
    float fps = 0.0f, frameTime = 0.0f;

    while (!glfwWindowShouldClose(window)) {

        float currentFrame = glfwGetTime();
        float deltaTime = currentFrame - lastFrame;
        lastFrame = currentFrame;


        frameCount++;
        fpsTimer += deltaTime;
        if (fpsTimer >= 1.0f) {
            fps = frameCount / fpsTimer;
            frameTime = (fpsTimer / frameCount) * 1000.0f;
            frameCount = 0;
            fpsTimer = 0.0f;
        }


        camera.processKeyboard(window, deltaTime);
        ImGuiManager::BeginFrame();
        RenderImGuiWidgets(fps, frameTime);
        ImGui::Render();


        glClear(
# 63 "/home/devkon/CLionProjects/VertexLab/main.cpp" 3 4
               0x00004000 
# 63 "/home/devkon/CLionProjects/VertexLab/main.cpp"
                                   | 
# 63 "/home/devkon/CLionProjects/VertexLab/main.cpp" 3 4
                                     0x00000100
# 63 "/home/devkon/CLionProjects/VertexLab/main.cpp"
                                                        );


        glm::mat4 view = camera.getViewMatrix();
        glm::mat4 projection = glm::perspective(glm::radians(45.0f), 1280.0f / 960.0f, 0.1f, 100.0f);


        DrawGrid(grid, view, projection);


        ImGuiManager::Render();
        glfwSwapBuffers(window);
        glfwPollEvents();
    }


    ImGuiManager::Cleanup();
    
# 80 "/home/devkon/CLionProjects/VertexLab/main.cpp" 3 4
   __glewDeleteVertexArrays
# 80 "/home/devkon/CLionProjects/VertexLab/main.cpp"
                       (1, &grid.vao);
    
# 81 "/home/devkon/CLionProjects/VertexLab/main.cpp" 3 4
   __glewDeleteBuffers
# 81 "/home/devkon/CLionProjects/VertexLab/main.cpp"
                  (1, &grid.vbo);
    
# 82 "/home/devkon/CLionProjects/VertexLab/main.cpp" 3 4
   __glewDeleteProgram
# 82 "/home/devkon/CLionProjects/VertexLab/main.cpp"
                  (grid.shaderProgram);
    glfwTerminate();

    return 0;
}
